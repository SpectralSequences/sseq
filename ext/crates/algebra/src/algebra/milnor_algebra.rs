use std::cell::Cell;

use fp::{
    prime::{factor_pk, iter::BitflagIterator, Binomial, Prime, ValidPrime},
    vector::{FpSlice, FpSliceMut, FpVector},
};
use itertools::Itertools;
use once::OnceVec;
use rustc_hash::FxHashMap as HashMap;
use serde::{Deserialize, Serialize};

use crate::algebra::{combinatorics, Algebra, Bialgebra, GeneratedAlgebra, UnstableAlgebra};

// This is here so that the Python bindings can use modules defined for AdemAlgebraT with their own algebra enum.
// In order for things to work AdemAlgebraT cannot implement Algebra.
// Otherwise, the algebra enum for our bindings will see an implementation clash.
pub trait MilnorAlgebraT: Send + Sync + Algebra {
    fn milnor_algebra(&self) -> &MilnorAlgebra;
}

impl MilnorAlgebraT for MilnorAlgebra {
    fn milnor_algebra(&self) -> &MilnorAlgebra {
        self
    }
}

fn q_part_default() -> u32 {
    !0
}

#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct MilnorProfile {
    /// If `true`, unspecified p_part entries will be 0. Otherwise they will be infinity.
    pub truncated: bool,
    /// A bitmask indicating which of the Q_k we want to include (1 = include). Defaults to `!0`.
    /// This is only relevant at odd primes.
    #[serde(default = "q_part_default")]
    pub q_part: u32,
    /// The profile function for the Q part.
    #[serde(default)]
    pub p_part: PPart,
}

impl MilnorProfile {
    pub fn is_trivial(&self) -> bool {
        !self.truncated && self.q_part == !0 && self.p_part.is_empty()
    }

    pub fn get_p_part(&self, i: usize) -> PPartEntry {
        self.p_part
            .get(i)
            .copied()
            .unwrap_or(if self.truncated { 0 } else { PPartEntry::MAX })
    }

    /// Checks whether the profile function is valid
    pub fn is_valid(&self) -> bool {
        for (i, &hi) in self.p_part.iter().enumerate() {
            for (j, &hj) in self.p_part.iter().enumerate().skip(i + 1) {
                if hi > (j - i) as PPartEntry + hj && self.p_part[j - i] > hj {
                    return false;
                }
            }
        }
        if self.truncated {
            let len = self.p_part.len();
            for (i, &hi) in self.p_part.iter().enumerate() {
                if hi > (len - i) as PPartEntry {
                    return false;
                }
            }
        }
        if self.q_part != !0 {
            for i in BitflagIterator::set_bit_iterator(!self.q_part as u64) {
                for j in 0..i {
                    if (self.q_part >> j) & 1 == 1 && self.get_p_part(i - j - 1) > j as PPartEntry {
                        return false;
                    }
                }
            }
        }
        true
    }

    /// Whether the profile is that of A(n). This is relevant since A(n) is generated by P(p^n) and
    /// β but a general subalgebra is not.
    pub fn is_an(&self, generic: bool) -> bool {
        if *self == Self::default() {
            return true;
        }
        if !self.truncated {
            return false;
        }
        if self.p_part.len() != self.p_part[0] as usize {
            return false;
        }
        if generic && self.q_part != (1 << (self.p_part.len() + 1)) - 1 {
            return false;
        }
        true
    }
}

impl Default for MilnorProfile {
    fn default() -> Self {
        Self {
            truncated: false,
            q_part: !0,
            p_part: Vec::new(),
        }
    }
}

pub type PPartEntry = u32;
pub type PPart = Vec<PPartEntry>;

#[derive(Debug, Clone, Default)]
pub struct MilnorBasisElement {
    pub q_part: u32,
    pub p_part: PPart,
    pub degree: i32,
}

impl MilnorBasisElement {
    fn from_p(p_part: PPart, degree: i32) -> Self {
        Self {
            q_part: 0,
            p_part,
            degree,
        }
    }

    fn excess(&self, p: ValidPrime) -> u32 {
        if p == 2 {
            self.p_part.iter().sum::<PPartEntry>()
        } else {
            self.q_part.count_ones() + 2 * self.p_part.iter().sum::<PPartEntry>()
        }
    }

    pub fn clone_into(&self, other: &mut Self) {
        other.q_part = self.q_part;
        other.degree = self.degree;
        other.p_part.clear();
        other.p_part.extend_from_slice(&self.p_part);
    }

    /// Update the degree component to the correct degree
    pub fn compute_degree(&mut self, p: ValidPrime) {
        let q = if p == 2 { 1 } else { 2 * (p.as_i32() - 1) };
        let xi_degrees = combinatorics::xi_degrees(p);
        let tau_degrees = combinatorics::tau_degrees(p);

        self.degree = q * std::iter::zip(xi_degrees, &self.p_part)
            .map(|(&a, &b)| a * b as i32)
            .sum::<i32>()
            + BitflagIterator::set_bit_iterator(self.q_part as u64)
                .map(|k| tau_degrees[k])
                .sum::<i32>();
    }
}

impl std::cmp::PartialEq for MilnorBasisElement {
    fn eq(&self, other: &Self) -> bool {
        #[cfg(feature = "odd-primes")]
        return self.p_part == other.p_part && self.q_part == other.q_part;

        #[cfg(not(feature = "odd-primes"))]
        return self.p_part == other.p_part;
    }
}

impl std::cmp::Eq for MilnorBasisElement {}

impl std::hash::Hash for MilnorBasisElement {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.p_part.hash(state);
        #[cfg(feature = "odd-primes")]
        self.q_part.hash(state);
    }
}

impl std::fmt::Display for MilnorBasisElement {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if self.degree == 0 {
            write!(f, "1")?;
            return Ok(());
        }
        if self.q_part != 0 {
            let q_part = BitflagIterator::set_bit_iterator(self.q_part as u64)
                .map(|idx| format!("Q_{idx}"))
                .format(" ");
            write!(f, "{q_part}")?;
        }
        if !self.p_part.is_empty() {
            if self.q_part != 0 {
                write!(f, " ")?;
            }
            write!(f, "P({})", self.p_part.iter().format(", "))?;
        }
        Ok(())
    }
}

/// A version of `HashMap<MilnorBasisElement, T>` that is more efficient at the prime 2.
#[cfg(feature = "odd-primes")]
type MilnorHashMap<V> = HashMap<MilnorBasisElement, V>;

#[cfg(not(feature = "odd-primes"))]
struct MilnorHashMap<V> {
    degree: i32,
    inner: HashMap<u64, V>,
}

#[cfg(not(feature = "odd-primes"))]
impl<V> Default for MilnorHashMap<V> {
    fn default() -> Self {
        Self {
            degree: -1,
            inner: HashMap::default(),
        }
    }
}

#[cfg(not(feature = "odd-primes"))]
impl<V> MilnorHashMap<V> {
    /// Encode a [`MilnorBasisElement`] of a known degree into a `u64`. This is achieved by packing
    /// the PPart into a single `u64`, where we omit the first entry since it can be derived from
    /// the degree. This currently supports elements up to degree 2^9 * 3 = 1536.
    fn code(x: &MilnorBasisElement) -> u64 {
        let mut counter = 0;
        let mut shift = 0;
        for (idx, &entry) in x.p_part.iter().skip(1).enumerate() {
            counter += (entry as u64) << shift;
            shift += 9 - idx;
        }
        counter
    }

    fn reserve(&mut self, additional: usize) {
        self.inner.reserve(additional);
    }

    fn insert(&mut self, k: MilnorBasisElement, v: V) {
        if self.degree == -1 {
            self.degree = k.degree;
        }
        assert_eq!(k.degree, self.degree);
        assert!(
            self.inner.insert(Self::code(&k), v).is_none(),
            "Duplicate entry for {k}"
        );
    }

    fn get(&self, k: &MilnorBasisElement) -> Option<&V> {
        assert_eq!(k.degree, self.degree);
        self.inner.get(&Self::code(k))
    }
}

pub struct MilnorAlgebra {
    profile: MilnorProfile,
    p: ValidPrime,
    #[cfg(feature = "odd-primes")]
    generic: bool,

    unstable_enabled: bool,

    /// This is a list of possible P(R) of each degree, where `ppart_table[i]` contains elements of
    /// degree `q * i`.
    ppart_table: OnceVec<Vec<PPart>>,

    /// A list of all basis elements of each degree, constructed from [`Self::ppart_table`]
    basis_table: OnceVec<Vec<MilnorBasisElement>>,

    excess_table: OnceVec<Vec<usize>>,

    /// degree -> MilnorBasisElement -> index
    basis_element_to_index_map: OnceVec<MilnorHashMap<usize>>,

    #[cfg(feature = "cache-multiplication")]
    /// source_deg -> target_deg -> source_op -> target_op
    multiplication_table: OnceVec<OnceVec<Vec<Vec<FpVector>>>>,
}

impl std::fmt::Display for MilnorAlgebra {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "MilnorAlgebra(p={})", self.prime())
    }
}

impl MilnorAlgebra {
    pub fn new(p: ValidPrime, unstable_enabled: bool) -> Self {
        Self::new_with_profile(p, MilnorProfile::default(), unstable_enabled)
    }

    pub fn new_with_profile(p: ValidPrime, profile: MilnorProfile, unstable_enabled: bool) -> Self {
        assert!(profile.is_valid());
        Self {
            p,
            #[cfg(feature = "odd-primes")]
            generic: p != 2,
            unstable_enabled,
            profile,
            ppart_table: OnceVec::new(),
            basis_table: OnceVec::new(),
            excess_table: OnceVec::new(),
            basis_element_to_index_map: OnceVec::new(),
            #[cfg(feature = "cache-multiplication")]
            multiplication_table: OnceVec::new(),
        }
    }

    #[inline]
    pub fn generic(&self) -> bool {
        #[cfg(feature = "odd-primes")]
        {
            self.generic
        }

        #[cfg(not(feature = "odd-primes"))]
        {
            false
        }
    }

    pub fn q(&self) -> i32 {
        if self.generic() {
            2 * (self.prime().as_i32() - 1)
        } else {
            1
        }
    }

    pub fn profile(&self) -> &MilnorProfile {
        &self.profile
    }

    pub fn basis_element_from_index(&self, degree: i32, idx: usize) -> &MilnorBasisElement {
        &self.basis_table[degree as usize][idx]
    }

    pub fn try_basis_element_to_index(&self, elt: &MilnorBasisElement) -> Option<usize> {
        self.basis_element_to_index_map[elt.degree as usize]
            .get(elt)
            .copied()
    }

    pub fn basis_element_to_index(&self, elt: &MilnorBasisElement) -> usize {
        self.try_basis_element_to_index(elt)
            .unwrap_or_else(|| panic!("Didn't find element: {elt:?}"))
    }

    /// Gives a list of PPart's in degree `t`.
    pub fn ppart_table(&self, t: i32) -> &[PPart] {
        &self.ppart_table[t as usize]
    }
}

impl Algebra for MilnorAlgebra {
    fn prefix(&self) -> &str {
        "milnor"
    }

    fn magic(&self) -> u32 {
        (self.p << 16)
            + if self.profile.is_trivial() {
                0x8000
            } else {
                0x8001
            }
    }

    fn prime(&self) -> ValidPrime {
        self.p
    }

    fn default_filtration_one_products(&self) -> Vec<(String, i32, usize)> {
        let mut products = Vec::with_capacity(4);
        let max_degree;
        if self.generic() {
            if self.profile.q_part & 1 != 0 {
                products.push((
                    "a_0".to_string(),
                    MilnorBasisElement {
                        degree: 1,
                        q_part: 1,
                        p_part: vec![],
                    },
                ));
            }
            if (self.profile.p_part.is_empty() && !self.profile.truncated)
                || (!self.profile.p_part.is_empty() && self.profile.p_part[0] > 0)
            {
                products.push((
                    "h_0".to_string(),
                    MilnorBasisElement {
                        degree: (2 * self.prime() - 2) as i32,
                        q_part: 0,
                        p_part: vec![1],
                    },
                ));
            }
            max_degree = (2 * self.prime() - 2) as i32;
        } else {
            let mut max = 4;
            if !self.profile.p_part.is_empty() {
                max = std::cmp::min(4, self.profile.p_part[0]);
            } else if self.profile.truncated {
                max = 0;
            }
            for i in 0..max {
                let degree = 1 << i; // degree is 2^hi
                products.push((
                    format!("h_{i}"),
                    MilnorBasisElement {
                        degree,
                        q_part: 0,
                        p_part: vec![1 << i],
                    },
                ));
            }
            max_degree = 1 << 3;
        }
        self.compute_basis(max_degree + 1);

        products
            .into_iter()
            .map(|(name, b)| (name, b.degree, self.basis_element_to_index(&b)))
            .collect()
    }

    fn compute_basis(&self, max_degree: i32) {
        self.compute_ppart(max_degree);

        if self.generic() {
            self.generate_basis_generic(max_degree);
        } else {
            self.generate_basis_2(max_degree);
        }

        // Populate hash map
        self.basis_element_to_index_map
            .extend(max_degree as usize, |d| {
                let basis = &self.basis_table[d];
                let mut map = MilnorHashMap::default();
                map.reserve(basis.len());
                for (i, b) in basis.iter().enumerate() {
                    map.insert(b.clone(), i);
                }
                map
            });

        #[cfg(feature = "cache-multiplication")]
        {
            self.multiplication_table
                .extend(max_degree as usize, |_| OnceVec::new());

            for d in 0..=max_degree as usize {
                self.multiplication_table[d].extend(max_degree as usize - d, |e| {
                    (0..self.dimension(d as i32))
                        .map(|i| {
                            (0..self.dimension(e as i32))
                                .map(|j| {
                                    let mut res =
                                        FpVector::new(self.prime(), self.dimension((d + e) as i32));
                                    self.multiply(
                                        res.as_slice_mut(),
                                        1,
                                        &self.basis_table[d][i],
                                        &self.basis_table[e][j],
                                    );
                                    res
                                })
                                .collect::<Vec<_>>()
                        })
                        .collect::<Vec<_>>()
                });
            }
        }

        if self.unstable_enabled {
            self.generate_excess_table(max_degree);
        }
    }

    fn dimension(&self, degree: i32) -> usize {
        if degree < 0 {
            return 0;
        }
        self.basis_table[degree as usize].len()
    }

    #[cfg(not(feature = "cache-multiplication"))]
    fn multiply_basis_elements(
        &self,
        result: FpSliceMut,
        coef: u32,
        r_degree: i32,
        r_idx: usize,
        s_degree: i32,
        s_idx: usize,
    ) {
        self.multiply(
            result,
            coef,
            self.basis_element_from_index(r_degree, r_idx),
            self.basis_element_from_index(s_degree, s_idx),
        );
    }

    #[cfg(feature = "cache-multiplication")]
    fn multiply_basis_elements(
        &self,
        mut result: FpSliceMut,
        coef: u32,
        r_degree: i32,
        r_idx: usize,
        s_degree: i32,
        s_idx: usize,
    ) {
        result.add(
            self.multiplication_table[r_degree as usize][s_degree as usize][r_idx][s_idx]
                .as_slice(),
            coef,
        );
    }

    fn multiply_basis_element_by_element(
        &self,
        mut result: FpSliceMut,
        coeff: u32,
        r_degree: i32,
        r_idx: usize,
        s_degree: i32,
        s: FpSlice,
    ) {
        let p = self.prime();
        let r = self.basis_element_from_index(r_degree, r_idx);
        PPartAllocation::with_local(|mut allocation| {
            for (i, v) in s.iter_nonzero() {
                allocation = self.multiply_with_allocation(
                    result.copy(),
                    (coeff * v) % p,
                    r,
                    self.basis_element_from_index(s_degree, i),
                    i32::MAX,
                    allocation,
                );
            }
            allocation
        });
    }

    fn multiply_element_by_element(
        &self,
        mut res: FpSliceMut,
        coef: u32,
        r_deg: i32,
        r: FpSlice,
        s_deg: i32,
        s: FpSlice,
    ) {
        PPartAllocation::with_local(|mut allocation| {
            for (i, c) in r.iter_nonzero() {
                allocation = self.multiply_basis_by_element_with_allocation(
                    res.copy(),
                    coef * c,
                    self.basis_element_from_index(r_deg, i),
                    s_deg,
                    s,
                    allocation,
                );
            }
            allocation
        })
    }

    fn basis_element_to_string(&self, degree: i32, idx: usize) -> String {
        format!("{}", self.basis_element_from_index(degree, idx))
    }

    fn basis_element_from_string(&self, elt: &str) -> Option<(i32, usize)> {
        use nom::{
            branch::alt,
            bytes::complete::tag,
            character::complete::char,
            combinator::{map, opt},
            multi::{many0, separated_list1},
            sequence::{preceded, tuple},
        };

        use crate::steenrod_parser::{brackets, digits, p_or_sq};

        let p = self.prime();

        let mut parser = alt((
            map(char('1'), |_| (0, 0)),
            map(char('b'), |_| (1, 0)),
            map(preceded(p_or_sq, digits), |i| self.beps_pn(0, i)),
            map(
                tuple((tag("P^"), digits, char('_'), digits)),
                |(_, s, _, t)| {
                    let entry = p.pow(s);
                    let degree = entry as i32 * self.q() * combinatorics::xi_degrees(p)[t];
                    let mut elt = MilnorBasisElement {
                        degree,
                        q_part: 0,
                        p_part: vec![0; t],
                    };
                    elt.p_part[t - 1] = entry as PPartEntry;
                    self.compute_basis(degree);
                    (degree, self.basis_element_to_index(&elt))
                },
            ),
            map(
                tuple((
                    many0(preceded(tag("Q_"), digits::<u32>)),
                    opt(preceded(
                        char('P'),
                        brackets(separated_list1(char(','), digits)),
                    )),
                )),
                |(q_list, p_list)| {
                    let q_part = q_list.into_iter().fold(0, |acc, q| acc + (1 << q));
                    let mut elt = MilnorBasisElement {
                        degree: 0,
                        q_part,
                        p_part: p_list.unwrap_or_default(),
                    };
                    elt.compute_degree(p);
                    self.compute_basis(elt.degree);

                    (elt.degree, self.basis_element_to_index(&elt))
                },
            ),
        ));

        if let Ok(("", res)) = parser(elt) {
            Some(res)
        } else {
            None
        }
    }
}

impl UnstableAlgebra for MilnorAlgebra {
    fn dimension_unstable(&self, degree: i32, excess: i32) -> usize {
        if degree < 0 || excess < 0 {
            0
        } else if excess < degree {
            self.excess_table[degree as usize][excess as usize]
        } else {
            self.basis_table[degree as usize].len()
        }
    }

    fn multiply_basis_elements_unstable(
        &self,
        result: FpSliceMut,
        coeff: u32,
        r_degree: i32,
        r_index: usize,
        s_degree: i32,
        s_index: usize,
        excess: i32,
    ) {
        let m1 = self.basis_element_from_index(r_degree, r_index);
        let m2 = self.basis_element_from_index(s_degree, s_index);
        PPartAllocation::with_local(|allocation| {
            self.multiply_with_allocation(result, coeff, m1, m2, excess, allocation)
        });
    }
}

impl GeneratedAlgebra for MilnorAlgebra {
    fn generator_to_string(&self, degree: i32, idx: usize) -> String {
        if self.generic() {
            if degree == 1 {
                return "b".to_string();
            }
            let elt = self.basis_element_from_index(degree, idx);
            let len = elt.p_part.len();
            if elt.q_part != 0 {
                elt.to_string()
            } else if len == 1 {
                format!("P{}", degree / self.q())
            } else {
                format!(
                    "P^{}_{}",
                    degree / (self.q() * combinatorics::xi_degrees(self.prime())[len - 1]),
                    len
                )
            }
        } else {
            let elt = self.basis_element_from_index(degree, idx);
            let len = elt.p_part.len();
            if len == 1 {
                format!("Sq{degree}")
            } else {
                format!(
                    "P^{}_{}",
                    degree / (combinatorics::xi_degrees(self.prime())[len - 1]),
                    len
                )
            }
        }
    }

    fn generators(&self, degree: i32) -> Vec<usize> {
        if degree == 0 {
            return vec![];
        } else if degree == 1 {
            return vec![0]; // Q_0
        }

        let p = self.prime();

        // Check for the Q_k
        if self.generic() && degree % 2 == 1 {
            if self.profile.is_an(true) {
                return vec![];
            }

            // If this is 2p^k - 1, then return Q_k
            if let (k, 2) = factor_pk(p, degree as u32 + 1) {
                let q_part = 1 << k;
                if self.profile.q_part & q_part != 0 {
                    return vec![self.basis_element_to_index(&MilnorBasisElement {
                        degree,
                        q_part,
                        p_part: vec![],
                    })];
                }
            }
            return vec![];
        }

        if self.profile.is_an(self.generic()) {
            // Look for P(p^k), which has degree p^k q.
            let q = self.q() as u32;
            if degree as u32 % q != 0 {
                return vec![];
            }
            if let (k, 1) = factor_pk(p, degree as u32 / q) {
                if (k as PPartEntry) < self.profile.get_p_part(0) {
                    return vec![self.basis_element_to_index(&MilnorBasisElement {
                        degree,
                        q_part: 0,
                        p_part: vec![(degree as u32 / q) as PPartEntry],
                    })];
                }
            }
            vec![]
        } else {
            // Look for P(0, ..., 0, p^k), which has degree (2p^j - 2) p^k.
            let (k, rem) = factor_pk(p, degree as u32);

            let reduced = if self.generic() {
                // rem must be even because degree is even
                (rem + 2) / 2
            } else {
                rem + 1
            };

            if let (j, 1) = factor_pk(p, reduced) {
                if self.profile.get_p_part(j as usize - 1) <= k as PPartEntry {
                    return vec![];
                }
                let mut p_part = vec![0; j as usize];
                p_part[j as usize - 1] = p.pow(k) as PPartEntry;
                return vec![self.basis_element_to_index(&MilnorBasisElement {
                    degree,
                    q_part: 0,
                    p_part,
                })];
            }
            vec![]
        }
    }

    fn decompose_basis_element(
        &self,
        degree: i32,
        idx: usize,
    ) -> Vec<(u32, (i32, usize), (i32, usize))> {
        let basis = self.basis_element_from_index(degree, idx);
        // If qpart = 0, return self
        if basis.q_part == 0 {
            self.decompose_basis_element_ppart(degree, idx)
        } else {
            self.decompose_basis_element_qpart(degree, idx)
        }
    }

    fn generating_relations(&self, degree: i32) -> Vec<Vec<(u32, (i32, usize), (i32, usize))>> {
        if self.generic() && degree == 2 {
            // beta^2 = 0 is an edge case
            return vec![vec![(1, (1, 0), (1, 0))]];
        }
        let p = self.prime();
        let inadmissible_pairs = combinatorics::inadmissible_pairs(p, self.generic(), degree);
        let mut result = Vec::new();
        for (x, b, y) in inadmissible_pairs {
            let mut relation = Vec::new();
            // Adem relation. Sometimes these don't exist because of profiles. Then just ignore it.
            (|| {
                let (first_degree, first_index) = self.try_beps_pn(0, x as PPartEntry)?;
                let (second_degree, second_index) = self.try_beps_pn(b, y as PPartEntry)?;
                relation.push((
                    p - 1,
                    (first_degree, first_index),
                    (second_degree, second_index),
                ));
                for e1 in 0..=b {
                    let e2 = b - e1;
                    // e1 and e2 determine where a bockstein shows up.
                    // e1 determines whether a bockstein shows up in front
                    // e2 determines whether a bockstein shows up in middle
                    // So our output term looks like b^{e1} P^{x+y-j} b^{e2} P^{j}
                    for j in 0..=x / p {
                        let c = combinatorics::adem_relation_coefficient(p, x, y, j, e1, e2);
                        if c == 0 {
                            continue;
                        }
                        if j == 0 {
                            relation.push((
                                c,
                                self.try_beps_pn(e1, (x + y) as PPartEntry)?,
                                (e2 as i32, 0),
                            ));
                            continue;
                        }
                        let first_sq = self.try_beps_pn(e1, (x + y - j) as PPartEntry)?;
                        let second_sq = self.try_beps_pn(e2, j as PPartEntry)?;
                        relation.push((c, first_sq, second_sq));
                    }
                }
                result.push(relation);
                Some(())
            })();
        }
        result
    }
}

// Compute basis functions
impl MilnorAlgebra {
    fn compute_ppart(&self, max_degree: i32) {
        self.ppart_table.extend(0, |_| vec![Vec::new()]);

        let p = self.prime().as_i32();
        let q = if p == 2 { 1 } else { 2 * p - 2 };
        let new_deg = max_degree / q;

        let xi_degrees = combinatorics::xi_degrees(self.prime());
        let mut profile_list = Vec::with_capacity(xi_degrees.len());
        for i in 0..xi_degrees.len() {
            if i < self.profile.p_part.len() {
                profile_list.push((self.prime().pow(self.profile.p_part[i]) - 1) as PPartEntry);
            } else if self.profile.truncated {
                profile_list.push(0);
            } else {
                profile_list.push(PPartEntry::MAX);
            }
        }

        self.ppart_table.extend(new_deg as usize, |d| {
            let d = d as i32;
            let mut new_row = Vec::new(); // Improve this
            for i in 0..xi_degrees.len() {
                if xi_degrees[i] > d {
                    break;
                }
                if profile_list[i] == 0 {
                    continue;
                }

                let rem = (d - xi_degrees[i]) as usize;
                for old in &self.ppart_table[rem] {
                    // ppart_table[rem] is arranged in increasing order of highest
                    // xi_i. If we get something too large, we may abort;
                    if old.len() > i + 1 {
                        break;
                    }
                    if old.len() == i + 1 && old[i] == profile_list[i] {
                        continue;
                    }
                    let mut new = old.clone();
                    if new.len() < i + 1 {
                        new.resize(i + 1, 0);
                    }
                    new[i] += 1;
                    new_row.push(new);
                }
            }
            new_row
        });
    }

    fn generate_basis_generic(&self, max_degree: i32) {
        let q = 2 * self.prime() - 2;
        let tau_degrees = combinatorics::tau_degrees(self.prime());

        self.basis_table.extend(max_degree as usize, |d| {
            let mut table = Vec::new();
            let residue = d as u32 % q;

            for q_part in 0u32.. {
                if q_part.count_ones() % q != residue {
                    continue;
                }

                let mut q_degree = 0;
                let mut bs = q_part;
                for &entry in tau_degrees {
                    q_degree += entry * (bs & 1) as i32;
                    bs >>= 1;
                    if bs == 0 {
                        break;
                    }
                }

                if q_degree > d as i32 {
                    break;
                }

                if q_part & !self.profile.q_part != 0 {
                    continue;
                }

                table.extend(
                    self.ppart_table[(d - q_degree as usize) / q as usize]
                        .iter()
                        .map(|p_part| MilnorBasisElement {
                            p_part: p_part.clone(),
                            q_part,
                            degree: d as i32,
                        }),
                );
            }
            if self.unstable_enabled {
                table.sort_by_cached_key(|e| e.excess(self.p));
            }
            table
        });
    }

    fn generate_basis_2(&self, max_degree: i32) {
        self.basis_table.extend(max_degree as usize, |d| {
            let mut table: Vec<_> = self.ppart_table[d]
                .iter()
                .map(|p| MilnorBasisElement::from_p(p.clone(), d as i32))
                .collect();
            if self.unstable_enabled {
                table.sort_by_cached_key(|e| e.excess(fp::prime::TWO));
            }
            table
        });
    }

    fn generate_excess_table(&self, max_degree: i32) {
        let p = self.prime();
        self.excess_table.extend(max_degree as usize, |n| {
            let mut new_entry = Vec::with_capacity(n);
            let mut cur_excess = 0;
            for (i, elt) in self.basis_table[n].iter().enumerate() {
                let excess = elt.excess(p);
                for _ in cur_excess..excess {
                    new_entry.push(i);
                }
                cur_excess = excess;
            }
            let dim = self.dimension(n as i32);
            for _ in cur_excess..n as u32 {
                new_entry.push(dim);
            }
            new_entry
        });
    }
}

// Multiplication logic
impl MilnorAlgebra {
    fn try_beps_pn(&self, e: u32, x: PPartEntry) -> Option<(i32, usize)> {
        let q = self.q() as u32;
        let degree = (q * x + e) as i32;
        self.compute_basis(degree);
        self.try_basis_element_to_index(&MilnorBasisElement {
            degree,
            q_part: e,
            p_part: vec![x as PPartEntry],
        })
        .map(|index| (degree, index))
    }

    /// Return the degree and index of $Q_1^e P(x)$.
    pub fn beps_pn(&self, e: u32, x: PPartEntry) -> (i32, usize) {
        self.try_beps_pn(e, x).unwrap()
    }

    fn multiply_qpart(&self, m1: &MilnorBasisElement, f: u32) -> Vec<(u32, MilnorBasisElement)> {
        let mut new_result: Vec<(u32, MilnorBasisElement)> = vec![(1, m1.clone())];
        let mut old_result: Vec<(u32, MilnorBasisElement)> = Vec::new();

        for k in BitflagIterator::set_bit_iterator(f as u64) {
            let k = k as u32;
            let pk = self.p.pow(k) as PPartEntry;
            std::mem::swap(&mut new_result, &mut old_result);
            new_result.clear();

            // We implement the formula
            // P(R) Q_k = Q_k P^R + Q_{k+1} P(R - p^k e_1) + Q_{k+2} P(R - p^k e_2) +
            // ... + Q_{k + i} P(R - p^k e_i) + ...
            // where e_i is the vector with value 1 in entry i and 0 otherwise (in the above
            // formula, the first xi is xi_1, hence the offset below). If R - p^k e_i has a
            // negative entry, the term is 0.
            //
            // We also use the fact that Q_k Q_j = -Q_j Q_k
            for (coef, term) in &old_result {
                for i in 0..=term.p_part.len() {
                    // If there is already Q_{k+i} on the other side, the result is 0
                    if term.q_part & (1 << (k + i as u32)) != 0 {
                        continue;
                    }
                    // Check if R - p^k e_i < 0. Only do this from the first term onwards.
                    if i > 0 && term.p_part[i - 1] < pk {
                        continue;
                    }

                    let mut new_p = term.p_part.clone();
                    if i > 0 {
                        new_p[i - 1] -= pk;
                    }

                    // Now calculate the number of Q's we are moving past
                    let larger_q = (term.q_part >> (k + i as u32 + 1)).count_ones();

                    // If new_p ends with 0, drop them
                    while let Some(0) = new_p.last() {
                        new_p.pop();
                    }
                    // Now put everything together
                    let m = MilnorBasisElement {
                        p_part: new_p,
                        q_part: term.q_part | 1 << (k + i as u32),
                        degree: 0, // we don't really care about the degree here. The final degree of the whole calculation is known a priori
                    };
                    let c = if larger_q % 2 == 0 {
                        *coef
                    } else {
                        *coef * (self.prime() - 1)
                    };

                    new_result.push((c, m));
                }
            }
        }
        new_result
    }

    pub fn multiply(
        &self,
        res: FpSliceMut,
        coef: u32,
        m1: &MilnorBasisElement,
        m2: &MilnorBasisElement,
    ) {
        PPartAllocation::with_local(|allocation| {
            self.multiply_with_allocation(res, coef, m1, m2, i32::MAX, allocation)
        });
    }

    pub fn multiply_with_allocation(
        &self,
        mut res: FpSliceMut,
        coef: u32,
        m1: &MilnorBasisElement,
        m2: &MilnorBasisElement,
        excess: i32,
        mut allocation: PPartAllocation,
    ) -> PPartAllocation {
        let target_deg = m1.degree + m2.degree;
        if self.generic() {
            let m1f = self.multiply_qpart(m1, m2.q_part);
            for (cc, basis) in m1f {
                let mut multiplier = PPartMultiplier::<false>::new_from_allocation(
                    self.prime(),
                    &basis.p_part,
                    &m2.p_part,
                    allocation,
                    basis.q_part,
                    target_deg,
                );

                while let Some(c) = multiplier.next() {
                    let idx = self.basis_element_to_index(&multiplier.ans);
                    if idx < self.dimension_unstable(target_deg, excess) {
                        res.add_basis_element(idx, c * cc * coef);
                    }
                }
                allocation = multiplier.into_allocation()
            }
        } else {
            let mut multiplier = PPartMultiplier::<false>::new_from_allocation(
                self.prime(),
                &m1.p_part,
                &m2.p_part,
                allocation,
                0,
                target_deg,
            );

            while let Some(c) = multiplier.next() {
                let idx = self.basis_element_to_index(&multiplier.ans);
                if idx < self.dimension_unstable(target_deg, excess) {
                    res.add_basis_element(idx, c * coef);
                }
            }
            allocation = multiplier.into_allocation()
        }
        allocation
    }

    pub fn multiply_basis_by_element(
        &self,
        res: FpSliceMut,
        coef: u32,
        m1: &MilnorBasisElement,
        s_deg: i32,
        s: FpSlice,
    ) {
        PPartAllocation::with_local(|allocation| {
            self.multiply_basis_by_element_with_allocation(res, coef, m1, s_deg, s, allocation)
        });
    }

    fn multiply_basis_by_element_with_allocation(
        &self,
        mut res: FpSliceMut,
        coef: u32,
        m1: &MilnorBasisElement,
        s_deg: i32,
        s: FpSlice,
        mut allocation: PPartAllocation,
    ) -> PPartAllocation {
        for (i, c) in s.iter_nonzero() {
            allocation = self.multiply_with_allocation(
                res.copy(),
                coef * c,
                m1,
                self.basis_element_from_index(s_deg, i),
                i32::MAX,
                allocation,
            );
        }
        allocation
    }
}

#[derive(Debug, Default)]
struct Matrix2D {
    cols: usize,
    inner: PPart,
}

impl std::fmt::Display for Matrix2D {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        for i in 0..self.inner.len() / self.cols {
            writeln!(f, "{:?}", &self[i][0..self.cols])?;
        }
        Ok(())
    }
}

impl Matrix2D {
    fn reset(&mut self, rows: usize, cols: usize) {
        self.cols = cols;
        self.inner.clear();
        self.inner.resize(rows * cols, 0);
    }
}

impl Matrix2D {
    fn with_capacity(rows: usize, cols: usize) -> Self {
        Self {
            cols: 0,
            inner: Vec::with_capacity(rows * cols),
        }
    }
}

impl std::ops::Index<usize> for Matrix2D {
    type Output = [PPartEntry];

    fn index(&self, row: usize) -> &Self::Output {
        // Computing the end point is fairly expensive and only serves as a safety check...
        &self.inner[row * self.cols..]
    }
}

impl std::ops::IndexMut<usize> for Matrix2D {
    fn index_mut(&mut self, row: usize) -> &mut Self::Output {
        &mut self.inner[row * self.cols..]
    }
}

/// The parts of a PPartMultiplier that involve heap allocation.
///
/// This lets us reuse the allocation across multiple different multipliers. Reusing the whole
/// PPartMultiplier is finicky but doable due to lifetime issues. However, it appears to be less
/// performant.
#[derive(Default)]
pub struct PPartAllocation {
    m: Matrix2D,
    #[cfg(feature = "odd-primes")]
    diagonal: PPart,
    p_part: PPart,
}

thread_local! {
    static ALLOCATION: Cell<PPartAllocation> = Cell::new(PPartAllocation::with_capacity(9));
}

impl PPartAllocation {
    /// This creates a PPartAllocation with enough capacity to handle mulitiply elements with
    /// of total degree < 2^n - ε at p = 2.
    pub fn with_capacity(n: usize) -> Self {
        Self {
            m: Matrix2D::with_capacity(n + 1, n),
            #[cfg(feature = "odd-primes")]
            diagonal: Vec::with_capacity(n),
            // This size should be the number of diagonals. Even though the answer cannot be that
            // long, we still insert zeros then pop them out later.
            p_part: Vec::with_capacity(2 * n),
        }
    }

    pub fn with_local(f: impl FnOnce(Self) -> Self) {
        ALLOCATION.with(|alloc| {
            alloc.set(f(alloc.take()));
        });
    }
}

#[allow(non_snake_case)]
pub struct PPartMultiplier<'a, const MOD4: bool> {
    p: ValidPrime,
    M: Matrix2D,
    r: &'a PPart,
    rows: usize,
    cols: usize,
    diag_num: usize,
    init: bool,
    pub ans: MilnorBasisElement,
    #[cfg(feature = "odd-primes")]
    diagonal: PPart,
}

#[allow(non_snake_case)]
impl<'a, const MOD4: bool> PPartMultiplier<'a, MOD4> {
    fn prime(&self) -> ValidPrime {
        self.p
    }

    #[allow(unused_mut)] // Mut is only used with odd primes
    pub fn new_from_allocation(
        p: ValidPrime,
        r: &'a PPart,
        s: &'a PPart,
        mut allocation: PPartAllocation,
        q_part: u32,
        degree: i32,
    ) -> Self {
        if MOD4 {
            assert_eq!(p, 2);
        }
        let rows = r.len() + 1;
        let cols = s.len() + 1;
        let diag_num = r.len() + s.len();
        #[cfg(feature = "odd-primes")]
        {
            allocation.diagonal.clear();
            allocation.diagonal.reserve_exact(std::cmp::max(rows, cols));
        }

        let mut M = allocation.m;
        M.reset(rows, cols);

        for i in 1..rows {
            M[i][0] = r[i - 1];
        }
        // This is somehow quite significantly faster than copy_from_slice
        #[allow(clippy::manual_memcpy)]
        for k in 1..cols {
            M[0][k] = s[k - 1];
        }

        let ans = MilnorBasisElement {
            q_part,
            p_part: allocation.p_part,
            degree,
        };
        PPartMultiplier {
            #[cfg(feature = "odd-primes")]
            diagonal: allocation.diagonal,
            p,
            M,
            r,
            rows,
            cols,
            diag_num,
            ans,
            init: true,
        }
    }

    pub fn into_allocation(self) -> PPartAllocation {
        PPartAllocation {
            m: self.M,
            #[cfg(feature = "odd-primes")]
            diagonal: self.diagonal,
            p_part: self.ans.p_part,
        }
    }

    /// This compute the first l > k such that (sum + l) choose l != 0 mod p, stopping if we reach
    /// max + 1. This is useful for incrementing the matrix.
    ///
    /// TODO: Improve odd prime performance
    fn next_val(&self, sum: PPartEntry, k: PPartEntry, max: PPartEntry) -> PPartEntry {
        match self.prime().as_u32() {
            2 => {
                if MOD4 {
                    // x.count_ones() + y.count_ones() - (x + y).count_ones() is the number of
                    // carries when adding x to y.
                    //
                    // The p-adic valuation of (n + r) choose r is the number of carries when
                    // adding r to n in base p.
                    (k + 1..max + 1)
                        .find(|&l| {
                            sum & l == 0
                                || (sum.count_ones() + l.count_ones()) - (sum + l).count_ones() == 1
                        })
                        .unwrap_or(max + 1)
                } else {
                    ((k | sum) + 1) & !sum
                }
            }
            _ => (k + 1..max + 1)
                .find(|&l| !PPartEntry::binomial_odd_is_zero(self.prime(), sum + l, l))
                .unwrap_or(max + 1),
        }
    }

    /// We have a matrix of the form
    ///    | s₁  s₂  s₃ ...
    /// --------------------
    /// r₁ |
    /// r₂ |     x_{ij}
    /// r₃ |
    ///
    /// We think of ourselves as modifiying the center pieces x_{ij}, while the r_i's and s_j's are
    /// only there to ensure the x_{ij}'s don't get too big. The idea is to sweep through the
    /// matrix row by row, from top-to-bottom, and left-to-right. In each pass, we find the first
    /// entry that can be incremented. We then increment it and zero out all the entries that
    /// appear before it. This will give us all valid entries.
    fn update(&mut self) -> bool {
        for i in 1..self.rows {
            // total is sum x_{ij} p^j up to the jth column
            let mut total = self.M[i][0];
            let mut p_to_the_j = 1;
            for j in 1..self.cols {
                p_to_the_j *= self.prime().as_u32() as PPartEntry;
                if total < p_to_the_j {
                    // We don't have enough weight left in the entries above this one in the column to increment this cell.
                    // Add the weight from this cell to the total, we can use it to increment a cell lower down.
                    total += self.M[i][j] * p_to_the_j;
                    continue;
                }
                let col_sum: PPartEntry = (0..i).map(|k| self.M[k][j]).sum();
                if col_sum == 0 {
                    total += self.M[i][j] * p_to_the_j;
                    continue;
                }

                let max_inc = std::cmp::min(col_sum, total / p_to_the_j);

                // Compute the sum of entries along the diagonal to the bottom-left
                let mut sum = 0;
                for c in (i + j + 1).saturating_sub(self.rows)..j {
                    sum += self.M[i + j - c][c];
                }

                // Find the next possible value we can increment M[i][j] to without setting the
                // coefficient to 0. The coefficient is the multinomial coefficient of the
                // diagonal, and if the multinomial coefficient of any subset is zero, so is the
                // coefficient of the whole diagonal.
                let next_val = self.next_val(sum, self.M[i][j], max_inc + self.M[i][j]);
                let inc = next_val - self.M[i][j];

                // The remaining obstacle to incrementing this entry is the column sum condition.
                // For this, we only need a non-zero entry in the column j above row i.
                if inc <= max_inc {
                    // If so, we found our next matrix.
                    for row in 1..i {
                        self.M[row][0] = self.r[row - 1];
                        for col in 1..self.cols {
                            self.M[0][col] += self.M[row][col];
                            self.M[row][col] = 0;
                        }
                    }
                    for col in 1..j {
                        self.M[0][col] += self.M[i][col];
                        self.M[i][col] = 0;
                    }
                    self.M[0][j] -= inc;
                    self.M[i][j] += inc;
                    self.M[i][0] = total - p_to_the_j * inc;
                    return true;
                }
                // All the cells above this one are zero so we didn't find our next matrix.
                // Add the weight from this cell to the total, we can use it to increment a cell lower down.
                total += self.M[i][j] * p_to_the_j;
            }
        }
        false
    }
}

impl<const MOD4: bool> Iterator for PPartMultiplier<'_, MOD4> {
    type Item = u32;

    fn next(&mut self) -> Option<u32> {
        let p = self.prime().as_u32() as PPartEntry;
        'outer: loop {
            self.ans.p_part.clear();
            let mut coef = 1;

            if self.init {
                self.init = false;
                for i in 1..std::cmp::min(self.cols, self.rows) {
                    if MOD4 {
                        coef *= PPartEntry::binomial4(self.M[i][0] + self.M[0][i], self.M[0][i]);
                        coef %= 4;
                    } else {
                        coef *= PPartEntry::binomial(
                            self.prime(),
                            self.M[i][0] + self.M[0][i],
                            self.M[0][i],
                        );
                        coef %= p;
                    }
                    if coef == 0 {
                        continue 'outer;
                    }
                }
                self.ans
                    .p_part
                    .reserve(std::cmp::max(self.cols, self.rows) - 1);
                self.ans.p_part.extend(&self.M[0][1..self.cols]);

                if self.rows > self.cols {
                    self.ans.p_part.resize(self.r.len(), 0);
                }
                self.ans
                    .p_part
                    .iter_mut()
                    .zip(self.r.iter())
                    .for_each(|(l, r)| *l += r);

                // If new_p ends with 0, drop them
                while let Some(0) = self.ans.p_part.last() {
                    self.ans.p_part.pop();
                }
                return Some(coef);
            } else if self.update() {
                self.ans.p_part.reserve(self.diag_num);
                for diag_idx in 1..=self.diag_num {
                    let i_min = if diag_idx + 1 > self.cols {
                        diag_idx + 1 - self.cols
                    } else {
                        0
                    };
                    let i_max = std::cmp::min(1 + diag_idx, self.rows);
                    let mut sum = 0;

                    if self.prime() == 2 {
                        if MOD4 {
                            for i in i_min..i_max {
                                let entry = self.M[i][diag_idx - i];
                                sum += entry;
                                if coef % 2 == 0 {
                                    coef *= PPartEntry::binomial2(sum, entry);
                                } else {
                                    coef *= PPartEntry::binomial4(sum, entry);
                                }
                                coef %= 4;
                                if coef == 0 {
                                    continue 'outer;
                                }
                            }
                        } else {
                            let mut or = 0;
                            for i in i_min..i_max {
                                sum += self.M[i][diag_idx - i];
                                or |= self.M[i][diag_idx - i];
                            }
                            if sum != or {
                                continue 'outer;
                            }
                        }
                    } else {
                        #[cfg(feature = "odd-primes")]
                        {
                            self.diagonal.clear();
                            for i in i_min..i_max {
                                self.diagonal.push(self.M[i][diag_idx - i]);
                                sum += self.M[i][diag_idx - i];
                            }

                            coef *= PPartEntry::multinomial_odd(self.prime(), &mut self.diagonal);
                            coef %= p;
                            if coef == 0 {
                                continue 'outer;
                            }
                        }
                    }
                    self.ans.p_part.push(sum);
                }
                // If new_p ends with 0, drop them
                while let Some(0) = self.ans.p_part.last() {
                    self.ans.p_part.pop();
                }

                return Some(coef);
            } else {
                return None;
            }
        }
    }
}

impl MilnorAlgebra {
    fn decompose_basis_element_qpart(
        &self,
        degree: i32,
        idx: usize,
    ) -> Vec<(u32, (i32, usize), (i32, usize))> {
        let basis = self.basis_element_from_index(degree, idx);
        // Look for left-most non-zero qpart
        let i = basis.q_part.trailing_zeros();
        // If the basis element is just Q_{k+1}, we decompose Q_{k+1} = P(p^k) Q_k - Q_k P(p^k).
        if basis.q_part == 1 << i && basis.p_part.is_empty() {
            let ppow = self.prime().pow(i - 1);

            let q_degree = (2 * ppow - 1) as i32;
            let p_degree = (ppow * (2 * self.prime() - 2)) as i32;

            let p_idx = self
                .basis_element_to_index(&MilnorBasisElement::from_p(
                    vec![ppow as PPartEntry],
                    p_degree,
                ))
                .to_owned();

            let q_idx = self
                .basis_element_to_index(&MilnorBasisElement {
                    q_part: 1 << (i - 1),
                    p_part: Vec::new(),
                    degree: q_degree,
                })
                .to_owned();

            vec![
                (1, (p_degree, p_idx), (q_degree, q_idx)),
                (self.prime() - 1, (q_degree, q_idx), (p_degree, p_idx)),
            ]
        } else {
            // Otherwise, separate out the first Q_k.
            let first_degree = combinatorics::tau_degrees(self.prime())[i as usize];
            let second_degree = degree - first_degree;

            let first_idx = self.basis_element_to_index(&MilnorBasisElement {
                q_part: 1 << i,
                p_part: Vec::new(),
                degree: first_degree,
            });

            let second_idx = self.basis_element_to_index(&MilnorBasisElement {
                q_part: basis.q_part ^ 1 << i,
                p_part: basis.p_part.clone(),
                degree: second_degree,
            });

            vec![(1, (first_degree, first_idx), (second_degree, second_idx))]
        }
    }

    fn decompose_basis_element_ppart(
        &self,
        degree: i32,
        idx: usize,
    ) -> Vec<(u32, (i32, usize), (i32, usize))> {
        let p = self.prime();

        // We define an ordering on the p parts as follows: we order each entry in reverse, and
        // then impose the reverse lexicographic ordering. Then for each non-generator P(R), `init`
        // is a partial decomposition such that the non-zero terms in the `init` product are all
        // greater than or equal to P(R) (and P(R) has non-zero coefficient in `init`). We can then
        // apply this algorithm recursively to decompose an element.

        // result is the products we have added so far
        let mut result = Vec::new();
        // buffer is the products we are adding in the current iteration
        let mut buffer = Vec::new();

        // out_vec is the remaining items we have to kill. We are done when this hits zero.
        let mut out_vec = FpVector::new(p, self.dimension(degree));
        out_vec.set_entry(idx, p - 1);

        while let Some((idx, c)) = out_vec.iter_nonzero().next() {
            let b = self.basis_element_from_index(degree, idx);
            let len = b.p_part.len();

            if b.p_part[0..len - 1].iter().all(|&x| x == 0) {
                // There is only one entry
                let entry = b.p_part[len - 1];
                let (k, m) = factor_pk(p, entry);

                // This is a power of p
                if m == 1 {
                    if len == 1 || !self.profile.is_an(self.generic()) {
                        buffer.extend([(p - c, (degree, idx), (0, 0))]);
                    } else {
                        // Write this as [P(p^(len + k - 1)), P(0, .., 0, P^k)] plus higher order
                        // terms.
                        let l_entry = p.pow(len as u32 + k - 1) as PPartEntry;
                        let r_entry = p.pow(k) as PPartEntry;

                        let l_degree = l_entry as i32 * self.q();
                        let l_index = self.basis_element_to_index(&MilnorBasisElement {
                            q_part: 0,
                            p_part: vec![l_entry],
                            degree: l_degree,
                        });

                        let mut r_p_part = vec![0; len - 1];
                        r_p_part[len - 2] = r_entry;
                        let r_degree =
                            r_entry as i32 * combinatorics::xi_degrees(p)[len - 2] * self.q();

                        let r_index = self.basis_element_to_index(&MilnorBasisElement {
                            q_part: 0,
                            p_part: r_p_part,
                            degree: r_degree,
                        });
                        buffer.extend(vec![
                            (p - c, (l_degree, l_index), (r_degree, r_index)),
                            (c, (r_degree, r_index), (l_degree, l_index)),
                        ])
                    }
                } else {
                    // This is not a power of p. Just subtract the lowest power of p.
                    let pk = p.pow(k) as PPartEntry;
                    let rem_entry = entry - pk;

                    let entry_deg = combinatorics::xi_degrees(p)[len - 1] * self.q();

                    let mut elt = MilnorBasisElement {
                        q_part: 0,
                        degree: 0,
                        p_part: vec![0; len],
                    };

                    elt.p_part[len - 1] = pk;
                    elt.degree = entry_deg * elt.p_part[len - 1] as i32;
                    let first = (elt.degree, self.basis_element_to_index(&elt));

                    elt.p_part[len - 1] = rem_entry;
                    elt.degree = entry_deg * elt.p_part[len - 1] as i32;
                    let second = (elt.degree, self.basis_element_to_index(&elt));

                    let coef =
                        p - fp::prime::inverse(p, PPartEntry::binomial(p, pk + rem_entry, pk));
                    buffer.extend([(coef, first, second)])
                }
            } else {
                // There is more than one entry. Just separate out the last entry.
                let last_entry = b.p_part[len - 1];
                let last_deg = combinatorics::xi_degrees(p)[len - 1] * self.q() * last_entry as i32;
                let mut elt = MilnorBasisElement {
                    q_part: 0,
                    p_part: vec![0; len],
                    degree: last_deg,
                };
                elt.p_part[len - 1] = last_entry;
                let first = (elt.degree, self.basis_element_to_index(&elt));

                elt.degree = degree - last_deg;
                elt.p_part.clear();
                elt.p_part.extend_from_slice(&b.p_part[0..len - 1]);
                while let Some(0) = elt.p_part.last() {
                    elt.p_part.pop();
                }
                let second = (elt.degree, self.basis_element_to_index(&elt));
                buffer.extend([(p - c, first, second)]);
            };
            for (c, first, second) in &buffer {
                self.multiply_basis_elements(
                    out_vec.as_slice_mut(),
                    *c,
                    first.0,
                    first.1,
                    second.0,
                    second.1,
                );
            }
            result.extend(&buffer);
            buffer.clear();
        }
        result
    }
}

impl MilnorAlgebra {
    /// Returns `true` if the new element is not within the bounds
    fn increment_p_part(element: &mut PPart, max: &[PPartEntry]) -> bool {
        element[0] += 1;
        for i in 0..element.len() - 1 {
            if element[i] > max[i] {
                element[i] = 0;
                element[i + 1] += 1;
            }
        }
        element.last().unwrap() > max.last().unwrap()
    }
}

impl Bialgebra for MilnorAlgebra {
    fn coproduct(&self, op_deg: i32, op_idx: usize) -> Vec<(i32, usize, i32, usize)> {
        assert_eq!(self.prime(), 2, "Coproduct at odd primes not supported");
        if op_deg == 0 {
            return vec![(0, 0, 0, 0)];
        }
        let xi_degrees = combinatorics::xi_degrees(self.prime());

        let mut len = 1;
        let p_part = &self.basis_element_from_index(op_deg, op_idx).p_part;

        for i in p_part.iter() {
            len *= i + 1;
        }
        let len = len as usize;
        let mut result = Vec::with_capacity(len);

        let mut cur_ppart: PPart = vec![0; p_part.len()];
        loop {
            let mut left_degree: i32 = 0;
            for i in 0..cur_ppart.len() {
                left_degree += cur_ppart[i] as i32 * xi_degrees[i];
            }
            let right_degree: i32 = op_deg - left_degree;

            let mut left_ppart = cur_ppart.clone();
            while let Some(0) = left_ppart.last() {
                left_ppart.pop();
            }

            let mut right_ppart = cur_ppart
                .iter()
                .enumerate()
                .map(|(i, v)| p_part[i] - *v)
                .collect::<Vec<_>>();
            while let Some(0) = right_ppart.last() {
                right_ppart.pop();
            }

            let left_idx = self.basis_element_to_index(&MilnorBasisElement {
                degree: left_degree,
                q_part: 0,
                p_part: left_ppart,
            });
            let right_idx = self.basis_element_to_index(&MilnorBasisElement {
                degree: right_degree,
                q_part: 0,
                p_part: right_ppart,
            });

            result.push((left_degree, left_idx, right_degree, right_idx));
            if Self::increment_p_part(&mut cur_ppart, p_part) {
                break;
            }
        }
        result
    }

    fn decompose(&self, op_deg: i32, op_idx: usize) -> Vec<(i32, usize)> {
        vec![(op_deg, op_idx)]
    }
}

#[cfg(test)]
mod tests {
    use std::fmt::Write as _; // Needed for write! macro for String

    use expect_test::expect;
    use rstest::rstest;

    use super::*;

    #[rstest]
    #[trace]
    #[case(2, 32, None)]
    #[case(2, 32, Some(MilnorProfile { q_part: !0, p_part: vec!(3, 2, 1), truncated: true }))]
    #[case(2, 32, Some(MilnorProfile { q_part: !0, p_part: vec!(2, 2, 1), truncated: true }))]
    #[case(2, 32, Some(MilnorProfile { q_part: !0, p_part: vec!(0), truncated: false }))]
    #[case(3, 106, None)]
    #[case(3, 106, Some(MilnorProfile { q_part: 0b1111, p_part: vec!(3, 2, 1), truncated: true }))]
    #[case(3, 106, Some(MilnorProfile { q_part: 0b1111, p_part: vec!(2, 2, 1), truncated: true }))]
    fn test_milnor_decompose(
        #[case] p: u32,
        #[case] max_degree: i32,
        #[case] profile: Option<MilnorProfile>,
    ) {
        let p = ValidPrime::new(p);
        let algebra = MilnorAlgebra::new_with_profile(p, profile.unwrap_or_default(), false);
        algebra.compute_basis(max_degree);
        for i in 1..max_degree {
            let dim = algebra.dimension(i);
            let gens = algebra.generators(i);
            // println!("i : {}, gens : {:?}", i, gens);
            let mut out_vec = FpVector::new(p, dim);
            for j in 0..dim {
                if gens.contains(&j) {
                    continue;
                }
                for (coeff, (first_degree, first_idx), (second_degree, second_idx)) in
                    algebra.decompose_basis_element(i, j)
                {
                    // print!("{} * {} * {}  +  ", coeff, algebra.basis_element_to_string(first_degree,first_idx), algebra.basis_element_to_string(second_degree, second_idx));
                    algebra.multiply_basis_elements(
                        out_vec.as_slice_mut(),
                        coeff,
                        first_degree,
                        first_idx,
                        second_degree,
                        second_idx,
                    );
                }
                assert!(
                    out_vec.entry(j) == 1,
                    "{} != {}",
                    algebra.basis_element_to_string(i, j),
                    algebra.element_to_string(i, out_vec.as_slice())
                );
                out_vec.set_entry(j, 0);
                assert!(
                    out_vec.is_zero(),
                    "\n{} != {}",
                    algebra.basis_element_to_string(i, j),
                    algebra.element_to_string(i, out_vec.as_slice())
                );
            }
        }
    }

    #[rstest]
    #[trace]
    #[case(2, 32)]
    #[case(3, 106)]
    fn test_milnor_string(#[case] p: u32, #[case] max_degree: i32) {
        let p = ValidPrime::new(p);
        let algebra = MilnorAlgebra::new(p, false);
        algebra.compute_basis(max_degree);
        for t in 0..max_degree {
            for i in 0..algebra.dimension(t) {
                let elt = algebra.basis_element_to_string(t, i);
                assert_eq!(
                    Some((t, i)),
                    algebra.basis_element_from_string(&elt),
                    "Error parsing {elt}"
                );
            }
            for i in algebra.generators(t) {
                let elt = algebra.generator_to_string(t, i);
                assert_eq!(
                    Some((t, i)),
                    algebra.basis_element_from_string(&elt),
                    "Error parsing {elt}"
                );
            }
        }
    }

    use crate::module::ModuleFailedRelationError;
    #[rstest(p, max_degree, case(2, 32), case(3, 106))]
    #[trace]
    fn test_adem_relations(p: u32, max_degree: i32) {
        let p = ValidPrime::new(p);
        let algebra = MilnorAlgebra::new(p, false);
        algebra.compute_basis(max_degree + 2);
        let mut output_vec = FpVector::new(p, 0);
        for i in 1..max_degree {
            let output_dim = algebra.dimension(i);
            output_vec.set_scratch_vector_size(output_dim);
            let relations = algebra.generating_relations(i);
            println!("{relations:?}");
            for relation in relations {
                for (coeff, (deg_1, idx_1), (deg_2, idx_2)) in &relation {
                    algebra.multiply_basis_elements(
                        output_vec.as_slice_mut(),
                        *coeff,
                        *deg_1,
                        *idx_1,
                        *deg_2,
                        *idx_2,
                    );
                }
                if !output_vec.is_zero() {
                    let mut relation_string = String::new();
                    for (coeff, (deg_1, idx_1), (deg_2, idx_2)) in &relation {
                        let _ = write!(
                            relation_string,
                            "{} * {} * {}  +  ",
                            *coeff,
                            &algebra.basis_element_to_string(*deg_1, *idx_1),
                            &algebra.basis_element_to_string(*deg_2, *idx_2)
                        );
                    }
                    relation_string.pop();
                    relation_string.pop();
                    relation_string.pop();
                    relation_string.pop();
                    relation_string.pop();
                    let value_string = algebra.element_to_string(i, output_vec.as_slice());
                    panic!(
                        "{}",
                        ModuleFailedRelationError {
                            relation: relation_string,
                            value: value_string
                        }
                    );
                }
            }
        }
    }

    #[test]
    fn test_clone_into() {
        let mut other = MilnorBasisElement::default();

        let mut check = |a: &MilnorBasisElement| {
            a.clone_into(&mut other);
            assert_eq!(a, &other);
        };

        check(&MilnorBasisElement {
            q_part: 3,
            p_part: vec![3, 2],
            degree: 12,
        });
        check(&MilnorBasisElement {
            q_part: 1,
            p_part: vec![3],
            degree: 11,
        });
        check(&MilnorBasisElement {
            q_part: 5,
            p_part: vec![1, 3, 5, 2],
            degree: 7,
        });
        check(&MilnorBasisElement {
            q_part: 0,
            p_part: vec![],
            degree: 2,
        });
    }

    #[test]
    fn test_ppart_multiplier_2() {
        let r = vec![1, 4];
        let s = vec![2, 4];
        let mut m = PPartMultiplier::<false>::new_from_allocation(
            fp::prime::TWO,
            &r,
            &s,
            PPartAllocation::default(),
            0,
            0,
        );

        expect![[r#"
            [0, 2, 4]
            [1, 0, 0]
            [4, 0, 0]
        "#]]
        .assert_eq(&m.M.to_string());

        assert_eq!(m.next(), Some(1));

        expect![[r#"
            [0, 0, 4]
            [1, 0, 0]
            [0, 2, 0]
        "#]]
        .assert_eq(&m.M.to_string());

        assert_eq!(m.next(), Some(1));

        expect![[r#"
            [0, 2, 3]
            [1, 0, 0]
            [0, 0, 1]
        "#]]
        .assert_eq(&m.M.to_string());

        assert_eq!(m.next(), None);
    }

    #[test]
    fn test_ppart_multiplier_3() {
        let r = vec![3, 4];
        let s = vec![1, 4];
        let mut m = PPartMultiplier::<false>::new_from_allocation(
            ValidPrime::new(3),
            &r,
            &s,
            PPartAllocation::default(),
            0,
            0,
        );

        expect![[r#"
            [0, 1, 4]
            [3, 0, 0]
            [4, 0, 0]
        "#]]
        .assert_eq(&m.M.to_string());

        assert_eq!(m.next(), Some(1));

        expect![[r#"
            [0, 1, 4]
            [3, 0, 0]
            [4, 0, 0]
        "#]]
        .assert_eq(&m.M.to_string());

        assert_eq!(m.next(), Some(2));

        expect![[r#"
            [0, 0, 4]
            [3, 0, 0]
            [1, 1, 0]
        "#]]
        .assert_eq(&m.M.to_string());

        assert_eq!(m.next(), None);
    }

    #[test]
    fn test_valid_profile() {
        assert!((MilnorProfile {
            p_part: vec![3, 2, 1],
            q_part: !0,
            truncated: true
        })
        .is_valid());

        assert!(!(MilnorProfile {
            p_part: vec![3, 2],
            q_part: !0,
            truncated: true
        })
        .is_valid());

        assert!((MilnorProfile {
            p_part: vec![3, 2, 1],
            q_part: 0b1111,
            truncated: true
        })
        .is_valid());

        assert!(!(MilnorProfile {
            p_part: vec![3, 2, 1],
            q_part: 0b111,
            truncated: true
        })
        .is_valid());
    }
}

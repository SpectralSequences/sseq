use self::limb::LimbMethods;
use crate::prime::Prime;

pub(crate) mod limb;

pub mod fp;
pub mod smallfq;

pub use fp::Fp;
pub use smallfq::SmallFq;

pub trait FieldElement: Clone {
    fn is_zero(&self) -> bool;
}

pub trait Field: LimbMethods + Sized {
    #[cfg(feature = "odd-primes")]
    type Characteristic: Prime;

    #[cfg(feature = "odd-primes")]
    fn characteristic(self) -> Self::Characteristic;
    #[cfg(not(feature = "odd-primes"))]
    fn characteristic(self) -> super::prime::P2 {
        super::prime::P2
    }

    fn degree(self) -> u32;

    fn q(self) -> u32 {
        self.characteristic().pow(self.degree())
    }

    fn zero(self) -> Self::Element;
    fn one(self) -> Self::Element;

    fn add(self, a: Self::Element, b: Self::Element) -> Self::Element;
    fn mul(self, a: Self::Element, b: Self::Element) -> Self::Element;

    fn sub(self, a: Self::Element, b: Self::Element) -> Self::Element {
        self.add(a, self.neg(b))
    }

    fn div(self, a: Self::Element, b: Self::Element) -> Option<Self::Element> {
        Some(self.mul(a, self.inv(b)?))
    }

    fn neg(self, a: Self::Element) -> Self::Element;
    fn inv(self, a: Self::Element) -> Option<Self::Element>;

    fn frobenius(self, a: Self::Element) -> Self::Element;
}

// TODO: Figure out better tests
#[cfg(test)]
mod test {
    use super::{Field, SmallFq};
    use crate::prime::{P2, P3};

    #[test]
    fn test_f_4() {
        // Multiplication table generated by Sage.
        let f4 = SmallFq::new(P2, 2);

        let mut a = vec![f4.one()];
        for _ in 1..f4.q() {
            let prev = a.last().unwrap();
            a.push(f4.mul(*prev, f4.a()));
        }

        let expansions = vec![a[0], a[1], f4.add(a[1], a[0]), a[0]];

        assert_eq!(a, expansions);
    }

    #[test]
    fn test_f_8() {
        // Multiplication table generated by Sage.
        let f8 = SmallFq::new(P2, 3);

        let mut a = vec![f8.one()];
        for _ in 1..f8.q() {
            let prev = a.last().unwrap();
            a.push(f8.mul(*prev, f8.a()));
        }

        let expansions = vec![
            a[0],
            a[1],
            a[2],
            f8.add(a[1], a[0]),
            f8.add(a[2], a[1]),
            f8.add(a[2], f8.add(a[1], a[0])),
            f8.add(a[2], a[0]),
            a[0],
        ];

        assert_eq!(a, expansions);
    }

    #[test]
    fn test_f_16() {
        // Multiplication table generated by Sage.
        let f16 = SmallFq::new(P2, 4);

        let mut a = vec![f16.one()];
        for _ in 1..f16.q() {
            let prev = a.last().unwrap();
            a.push(f16.mul(*prev, f16.a()));
        }

        let expansions = vec![
            a[0],
            a[1],
            a[2],
            a[3],
            f16.add(a[1], a[0]),
            f16.add(a[2], a[1]),
            f16.add(a[3], a[2]),
            f16.add(a[3], f16.add(a[1], a[0])),
            f16.add(a[2], a[0]),
            f16.add(a[3], a[1]),
            f16.add(a[2], f16.add(a[1], a[0])),
            f16.add(a[3], f16.add(a[2], a[1])),
            f16.add(a[3], f16.add(a[2], f16.add(a[1], a[0]))),
            f16.add(a[3], f16.add(a[2], a[0])),
            f16.add(a[3], a[0]),
            a[0],
        ];

        assert_eq!(a, expansions);
    }

    #[test]
    fn test_f_9() {
        // Multiplication table generated by Sage.
        let f9 = SmallFq::new(P3, 2);

        let two = f9.add(f9.one(), f9.one());

        let mut a = vec![f9.one()];
        for _ in 1..f9.q() {
            let prev = a.last().unwrap();
            a.push(f9.mul(*prev, f9.a()));
        }

        let expansions = vec![
            a[0],
            a[1],
            f9.add(a[1], a[0]),
            f9.add(f9.mul(two, a[1]), a[0]),
            two,
            f9.mul(two, a[1]),
            f9.add(f9.mul(two, a[1]), two),
            f9.add(a[1], two),
            a[0],
        ];

        assert_eq!(a, expansions);
    }
}

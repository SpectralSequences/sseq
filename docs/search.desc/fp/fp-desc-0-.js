searchState.loadedDescShard("fp", 0, "The number of primes that will be prepared at …\nAn array containing the first <code>NUM_PRIMES</code> prime numbers.\nFor any integer <code>i</code> less than or equal to <code>MAX_PRIME</code>, …\nThe number of bits each <code>Limb</code> occupies.\nThe number of bytes each <code>Limb</code> occupies.\nThe <code>NUM_PRIMES</code>th prime number.\nA sentinel value. <code>PRIME_TO_INDEX_MAP[i] == NOT_A_PRIME</code> if …\nThe number of primes that will be prepared at …\nAn array containing the first <code>NUM_PRIMES</code> prime numbers.\nFor any integer <code>i</code> less than or equal to <code>MAX_PRIME</code>, …\nA struct containing the information required to access a …\nReturn the <code>Limb</code> whose <code>i</code>th entry is …\nReturn the number of bits an element of $\\mathbb{F}_P$ …\nIf <code>l</code> is a limb of elements of $\\mathbb{F}_p$, then …\nThe number of elements of $\\mathbb{F}_p$ that fit in a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck whether or not a limb is reduced, i.e. whether every …\nReturn the number of limbs required to hold <code>dim</code> entries.\nGiven an interator of <code>u32</code>’s, pack all of them into a …\nReturn the <code>Range&lt;usize&gt;</code> starting at the index of the limb …\nReturn the <code>Limb</code> whose entries are the entries of <code>limb</code> …\nReturn either <code>Some(sum)</code> if no carries happen in the limb, …\nGive an iterator over the entries of <code>limb</code>. We return <code>u64</code> …\nThis models an augmented matrix.\nA matrix! In particular, a matrix with values in F_p. The …\nGiven a matrix M, a quasi-inverse Q is a map from the …\nA subspace of a vector space.\nThe pivot columns of the matrix. <code>pivots[n]</code> is <code>k</code> if column <code>n</code>…\nExample\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nM4RI works as follows — first row reduce k rows using …\nAdd a row to the table.\nClear the contents of the table\nThe list of pivot columns of the rows\nThe 2^k linear combinations of the k rows, apart from the …\nReturns the argument unchanged.\nGenerates the table from the known data <code>num</code> is the number …\nCalls <code>U::from(self)</code>.\nWhether the table has no rows\nNumber of rows in the M4riTable\nThe smallest non-zero limb in this table. We use this when …\nCreate a table with space for <code>k</code> vectors, each with <code>cols</code> …\nGet the list of pivot rows\nThe indices of new rows in the table\nThis models an augmented matrix.\nA matrix! In particular, a matrix with values in F_p. The …\nFor each row, add the <code>v[i]</code>th entry of <code>other</code> to <code>self</code>.\nApplies a matrix to a vector.\nProduces a padded augmented matrix from an <code>&amp;[Vec&lt;u32&gt;]</code> …\nGets the number of columns in the matrix.\nComputes the quasi-inverse of a matrix given a rref of […\nComputes the kernel from an augmented matrix in rref. To …\nComputes the quasi-inverse of a matrix given a rref of […\nThis function computes quasi-inverses for matrices A, B …\nGiven a matrix in rref, say [A|B|C], where B lies between …\nGiven a matrix M in rref, add rows to make the matrix …\nGiven a row reduced matrix, find the first row whose pivot …\nThis is very similar to row_reduce, except we only need to …\nExample\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nProduces a Matrix from an <code>&amp;[Vec&lt;u32&gt;]</code> object. If the …\nReturns the ith row of the matrix\nReturns the ith row of the matrix\nSet the pivots to -1 in every entry. This is called by …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProduces a new matrix over F_p with the specified number …\nThe pivot columns of the matrix. <code>pivots[n]</code> is <code>k</code> if column <code>n</code>…\nRead a vector of <code>isize</code> of length <code>dim</code>.\nPerforms a row operation using <code>pivot_column</code> as the pivot …\nA version of <code>Matrix::row_op</code> without the zero assumption.\nPerform row reduction to reduce it to reduced row echelon …\nGets the number of rows in the matrix.\nA no-nonsense, safe, row operation. Adds <code>c * self[source]</code> …\nMutably borrows <code>x[i]</code> and <code>x[j]</code>.\nRead a vector of <code>isize</code>\nGiven a matrix M, a quasi-inverse Q is a map from the …\nApply the quasi-inverse to an input vector and add a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGiven a data file containing a quasi-inverse, apply it to …\nThe pivot columns of the complement to the subspace\nReturns the argument unchanged.\nGiven a chain of subspaces <code>subspace</code> &lt; <code>space</code> &lt; k^…\nCalls <code>U::from(self)</code>.\nCreate a new subquotient of an ambient space of dimension …\nCreate a new subquotient of an ambient space of dimension …\nGiven a vector <code>elt</code>, project <code>elt</code> to the complement and …\nProject the vector onto the complement of the quotient …\nSet the subquotient to be the full ambient space …\nThe dimension of the subspace part of the subquotient.\nThe generators of the subspace part of the subquotient.\nA subspace of a vector space.\nThis adds a vector to the subspace. This function assumes …\nThis adds some rows to the subspace\nReturns a basis of the subspace.\nExample\nReturns the argument unchanged.\nCreate a new subspace from a matrix. The matrix does not …\nCalls <code>U::from(self)</code>.\nWhether the subspace is empty. This assumes the subspace …\nIterate over all vectors in the subspace.\nProjects a vector to a complement of the subspace. The …\nSets the subspace to be the entire subspace.\nSets the subspace to be the zero subspace.\nRun a closure on the matrix and then ensure it is …\nA trait that represents a prime number. There are …\nFactor $n$ as $p^k m$. Returns $(k, m)$.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCompute the base 2 log of a number, rounded down to the …\nDiscrete log base p of n.\nCompute b^e mod p. This is a const version of …\nComputes the product mod p. This takes care of overflow.\nA number satisfying the Binomial trait supports computing …\nBinomial coefficient n choose k.\nmod 2 binomial coefficient n choose k\nBinomial coefficients mod 4. We pre-compute the …\nCompute binomial coefficients mod 4 using the recursion …\nCompute odd binomial coefficients mod p, where p is odd. …\nChecks whether n choose k is zero mod p. Since we don’t …\nThis uses a lookup table for n choose k when n and k are …\nMultinomial coefficient of the list l\nmod 2 multinomial coefficient\nComputes the multinomial coefficient mod p using Lucas’ …\nIterates through all numbers with the same number of bits. …\nIterates through all combinations of numbers from 0 to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis module is provides wrappers around the contents of …\nAn <code>FpVectorP</code> is a vector over $\\mathbb{F}_p$ for a fixed …\nA <code>SliceMutP</code> is a mutable slice of an <code>FpVectorP</code>. This …\nA SliceP is a slice of an FpVectorP. This immutably …\nGiven a mask v, add the <code>v[i]</code>th entry of <code>other</code> to the <code>i</code>th …\nAdd <code>other</code> to <code>self</code> on the assumption that the first <code>offset</code> …\nAdd <code>other</code> to <code>self</code> on the assumption that the first <code>offset</code> …\nAdds <code>c</code> * <code>other</code> to <code>self</code>. <code>other</code> must have the same length, …\n<code>coeff</code> need not be reduced mod p. Adds v otimes w to self.\nGiven a mask v, add the <code>i</code>th entry of <code>other</code> to the <code>v[i]</code>th …\nTODO: improve efficiency\nA version of <code>FpVectorP::assign</code> that allows <code>other</code> to be …\nGenerates a version of itself with a shorter lifetime\nThis replaces the contents of the vector with the contents …\nThis function ensures the length of the vector is at least …\nFind the index and value of the first non-zero entry of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTODO: implement prime 2 version\nThis function underflows if <code>self.end == 0</code>, which happens …\nThis clears the vector and sets the length to <code>len</code>. This is …\nConverts a slice to an owned FpVectorP. This is vastly …\nPermanently remove the first <code>n</code> elements in the vector. <code>n</code> …\nIterator over non-zero entries of an FpVector. This is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExample\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")
searchState.loadedDescShard("fp", 0, "The number of primes that will be prepared at …\nAn array containing the first <code>NUM_PRIMES</code> prime numbers.\nFor any integer <code>i</code> less than or equal to <code>MAX_PRIME</code>, …\nThe number of bits each <code>Limb</code> occupies.\nThe number of bytes each <code>Limb</code> occupies.\nThe <code>NUM_PRIMES</code>th prime number.\nA sentinel value. <code>PRIME_TO_INDEX_MAP[i] == NOT_A_PRIME</code> if …\nThe number of primes that will be prepared at …\nAn array containing the first <code>NUM_PRIMES</code> prime numbers.\nFor any integer <code>i</code> less than or equal to <code>MAX_PRIME</code>, …\nAn element of a field.\nThis just ensures that the containers are “nice enough”…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new field element. This is only visible to the …\nThe internal representation of a field element.\nInternal methods required for fields.\nReturn the number of bits a <code>Self::Element</code> occupies in a …\nIf <code>l</code> is a limb of <code>Self::Element</code>s, then <code>l &amp; F.bitmask()</code> is …\nDecode a <code>Limb</code> into a field element. The argument will …\nCreate a new field element. This is the method responsible …\nEncode a field element into a <code>Limb</code>. The limbs of an …\nThe number of <code>Self::Element</code>s that fit in a single limb.\nFused multiply-add. Return the <code>Limb</code> whose <code>i</code>th entry is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck whether or not a limb is reduced. This may …\nReturn the number of limbs required to hold <code>dim</code> entries.\nGiven an interator of <code>FieldElement&lt;Self&gt;</code>s, pack all of …\nReturn the <code>Range&lt;usize&gt;</code> starting at the index of the limb …\nReduce a limb, i.e. make it “canonical”. For example, …\nReturn either <code>Some(sum)</code> if no carries happen in the limb, …\nGive an iterator over the entries of <code>limb</code>.\nA prime field. This is just a wrapper around a prime.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContributed by Robert Burklund.\nA field of order <code>q = p^d</code>, where <code>q &lt; 2^16</code> and <code>d &gt; 1</code>. Fields …\nA field element, stored as the exponent of a distinguished …\nA table of lazily initialized Zech logarithms.\nThe distinguished primitive element that generates the …\nThis is 2n + 1 if <code>element</code> is a^n, and 0 otherwise.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the element <code>-1</code>. If <code>p = 2</code>, this is <code>a^0 = 1</code>. …\nReturn the Zech logarithm table for the given field. If it …\nA struct containing the information required to access a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis models an augmented matrix.\nA matrix! In particular, a matrix with values in F_p.\nGiven a matrix M, a quasi-inverse Q is a map from the …\nA subspace of a vector space.\nThe pivot columns of the matrix. <code>pivots[n]</code> is <code>k</code> if column <code>n</code>…\nExample\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nM4RI works as follows — first row reduce k rows using …\nAdd a row to the table.\nClear the contents of the table\nThe list of pivot columns of the rows\nThe 2^k linear combinations of the k rows, apart from the …\nReturns the argument unchanged.\nGenerates the table from the known data <code>num</code> is the number …\nCalls <code>U::from(self)</code>.\nWhether the table has no rows\nNumber of rows in the M4riTable\nThe smallest non-zero limb in this table. We use this when …\nCreate a table with space for <code>k</code> vectors, each with <code>cols</code> …\nGet the list of pivot rows\nThe indices of new rows in the table\nThis models an augmented matrix.\nA matrix! In particular, a matrix with values in F_p.\nFor each row, add the <code>v[i]</code>th entry of <code>other</code> to <code>self</code>.\nApplies a matrix to a vector.\nGenerate an arbitrary row-reduced matrix.\nProduces a padded augmented matrix from an <code>&amp;[Vec&lt;u32&gt;]</code> …\nGets the number of columns in the matrix.\nComputes the quasi-inverse of a matrix given a rref of […\nComputes the kernel from an augmented matrix in rref. To …\nComputes the quasi-inverse of a matrix given a rref of […\nThis function computes quasi-inverses for matrices A, B …\nGiven a matrix in rref, say [A|B|C], where B lies between …\nGiven a matrix M in rref, add rows to make the matrix …\nGiven a row reduced matrix, find the first row whose pivot …\nThis is very similar to row_reduce, except we only need to …\nExample\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nProduces a <code>1 x n</code> matrix from a single FpVector. This is a …\nProduces a Matrix from a vector of FpVectors. We pass in …\nProduces a Matrix from an <code>&amp;[Vec&lt;u32&gt;]</code> object. If the …\nReturns the ith row of the matrix\nReturns the ith row of the matrix\nSet the pivots to -1 in every entry. This is called by …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProduces a new matrix over F_p with the specified number …\nThe pivot columns of the matrix. <code>pivots[n]</code> is <code>k</code> if column <code>n</code>…\nRead a vector of <code>isize</code> of length <code>dim</code>.\nPerforms a row operation using <code>pivot_column</code> as the pivot …\nA version of <code>Matrix::row_op</code> without the zero assumption.\nPerform row reduction to reduce it to reduced row echelon …\nGets the number of rows in the matrix.\nA no-nonsense, safe, row operation. Adds <code>c * self[source]</code> …\nMutably borrows <code>x[i]</code> and <code>x[j]</code>.\nRead a vector of <code>isize</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGiven a matrix M, a quasi-inverse Q is a map from the …\nApply the quasi-inverse to an input vector and add a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGiven a data file containing a quasi-inverse, apply it to …\nThe pivot columns of the complement to the subspace\nReturns the argument unchanged.\nGiven a chain of subspaces <code>quotient</code> &lt; <code>sub</code> in some ambient …\nCalls <code>U::from(self)</code>.\nCreate a new subquotient of an ambient space of dimension …\nCreate a new subquotient of an ambient space of dimension …\nGiven a vector <code>elt</code>, project <code>elt</code> to the complement and …\nProject the vector onto the complement of the quotient …\nSet the subquotient to be the full ambient space …\nThe dimension of the subspace part of the subquotient.\nThe generators of the subspace part of the subquotient.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA subspace of a vector space.\nThis adds a vector to the subspace. This function assumes …\nThis adds some rows to the subspace\nReturns a basis of the subspace.\nExample\nReturns the argument unchanged.\nCreate a new subspace from a matrix. The matrix does not …\nCalls <code>U::from(self)</code>.\nWhether the subspace is empty. This assumes the subspace …\nIterate over all vectors in the subspace.\nProjects a vector to a complement of the subspace. The …\nSets the subspace to be the entire subspace.\nSets the subspace to be the zero subspace.\nRun a closure on the matrix and then ensure it is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA trait that represents a prime number. There are …\nFactor $n$ as $p^k m$. Returns $(k, m)$.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCompute the base 2 log of a number, rounded down to the …\nDiscrete log base p of n.\nCompute b^e mod p. This is a const version of …\nComputes the product mod p. This takes care of overflow.\nComputes the sum mod p. This takes care of overflow.\nA number satisfying the Binomial trait supports computing …\nBinomial coefficient n choose k.\nmod 2 binomial coefficient n choose k\nBinomial coefficients mod 4. We pre-compute the …\nCompute binomial coefficients mod 4 using the recursion …\nCompute odd binomial coefficients mod p, where p is odd. …\nChecks whether n choose k is zero mod p. Since we don’t …\nThis uses a lookup table for n choose k when n and k are …\nMultinomial coefficient of the list l\nmod 2 multinomial coefficient\nComputes the multinomial coefficient mod p using Lucas’ …\nIterates through all numbers with the same number of bits. …\nIterates through all combinations of numbers from 0 to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn arbitrary <code>ValidPrime</code> in the range <code>2..(1 &lt;&lt; 24)</code>, plus …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis module provides convenience wrappers around the …\nExample\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis module defines methods that assist in plumbing …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDefine a struct that wraps some field-dependent type in an …\nUse all primes. It isn’t possible to have this import …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA slice of an <code>FqVector</code>.\nA mutable slice of an <code>FqVector</code>.\nA vector over a finite field.\nGiven a mask v, add the <code>v[i]</code>th entry of <code>other</code> to the <code>i</code>th …\nAdd <code>other</code> to <code>self</code> on the assumption that the first <code>offset</code> …\nAdds <code>c</code> * <code>other</code> to <code>self</code>. <code>other</code> must have the same length, …\nAdds v otimes w to self.\nGiven a mask v, add the <code>i</code>th entry of <code>other</code> to the <code>v[i]</code>th …\nTODO: improve efficiency\nA version of <code>FqVector::assign</code> that allows <code>other</code> to be …\nGenerates a version of itself with a shorter lifetime\nThis replaces the contents of the vector with the contents …\nThis function ensures the length of the vector is at least …\nFind the index and value of the first non-zero entry of …\nExample\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTODO: implement prime 2 version\nThis function underflows if <code>self.end == 0</code>, which happens …\nThis clears the vector and sets the length to <code>len</code>. This is …\nConverts a slice to an owned FqVector. This is vastly more …\nPermanently remove the first <code>n</code> elements in the vector. <code>n</code> …\nIterator over non-zero entries of an FpVector. This is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")
searchState.loadedDescShard("algebra", 0, "Types and traits for working with various algebras and …\nAn <code>Algebra</code> implementing the Steenrod algebra, using the …\nAn algebra that can be viewed as an Adem algebra.\nA graded algebra over $\\mathbb{F}_p$.\nAn <code>Algebra</code> equipped with a coproduct operation that makes …\n$\\mathbb{F}_p$, viewed as an <code>Algebra</code> over itself.\nAn <code>Algebra</code> equipped with a distinguished presentation.\nAn algebra that is maybe unstable. Every Algebra …\nThe Steenrod algebra using the Adem basis.\nTraits describing algebras, and implementations thereof …\nConverts a string to a basis element. This must be a …\ndegree -&gt; AdemBasisElement -&gt; index\ndegree -&gt; MilnorBasisElement -&gt; index\nConverts a basis element into a string for display.\ndegree -&gt; index -&gt; AdemBasisElement\nA list of all basis elements of each degree, constructed …\nComputes basis elements up to and including <code>degree</code>.\nComputes a coproduct $\\Delta(x)$, expressed as\nDecomposes an element of the algebra into a product of …\nDecomposes an element into generators.\nReturns the dimension of the algebra in degree <code>degree</code>.\nFinite fields over a prime.\nReturns relations that the algebra wants checked to ensure …\nReturn generators in <code>degree</code>.\ndegree -&gt; first square -&gt; admissible sequence idx -&gt; result\nsource_deg -&gt; target_deg -&gt; source_op -&gt; target_op\nComputes the product <code>r * s</code> of two basis elements, and adds …\nComputes the product <code>r * s</code> of a general element <code>r</code> and a …\nComputes the product <code>r * s</code> of two general elements, and …\nThis implements the notion of a split pair algebra in the …\nThis is a list of possible P(R) of each degree, where …\nReturns the prime the algebra is over.\nThis module includes code for parsing an expression in the …\nAn <code>Algebra</code> implementing the Steenrod algebra, using the …\nAn algebra that can be viewed as an Adem algebra.\nAn Adem basis element for the Steenrod algebra.\nA Steenrod power $P^i$, or a Bockstein $\\beta^\\varepsilon$.\ndegree -&gt; AdemBasisElement -&gt; index\ndegree -&gt; index -&gt; AdemBasisElement\nA bitset of which $\\beta$ Bocksteins are in the element’…\nThe degree of the element.\ndegree -&gt; first square -&gt; admissible sequence idx -&gt; result\nWhether to denote the generators as powers $P^i$ or …\nA list of which Steenrod powers are in the element’s …\nThe Steenrod algebra using the Adem basis.\nFinite fields over a prime.\nThis implements the notion of a split pair algebra in the …\nAn <code>Algebra</code> implementing the Steenrod algebra, using the …\nAn algebra that can be viewed as an Adem algebra.\nAn Adem basis element for the Steenrod algebra.\nA Steenrod power $P^i$, or a Bockstein $\\beta^\\varepsilon$.\ndegree -&gt; AdemBasisElement -&gt; index\ndegree -&gt; index -&gt; AdemBasisElement\nA bitset of which $\\beta$ Bocksteins are in the element’…\nThe degree of the element.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis function expresses $Sq^x$ (current) in terms of the …\nWe return Adem relations $b^2 = 0$, $P^i P^j = \\cdots$ for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator over the element’s decomposition.\nReduce a Steenrod monomial at the prime 2.\ndegree -&gt; first square -&gt; admissible sequence idx -&gt; result\nConstructs a new <code>AdemAlgebra</code>.\nWhether to denote the generators as powers $P^i$ or …\nA list of which Steenrod powers are in the element’s …\nShifts a <code>Vec</code>’s elements back by <code>offset</code>.\nA graded algebra over $\\mathbb{F}_p$.\nAn <code>Algebra</code> equipped with a distinguished presentation.\nAn algebra that is maybe unstable. Every Algebra …\nConverts a string to a basis element. This must be a …\nConverts a basis element into a string for display.\nComputes basis elements up to and including <code>degree</code>.\nDecomposes an element into generators.\nReturns a list of filtration-one elements in $Ext(k, k)$.\nReturns a list of filtration-one elements in $Ext(k, k)$.\nReturns the dimension of the algebra in degree <code>degree</code>.\nConverts a general element into a string for display.\nConverts a general element into a string for display.\nReturns relations that the algebra wants checked to ensure …\nReturns the name of a generator.\nReturns the name of a generator.\nReturn generators in <code>degree</code>.\nA magic constant used to identify the algebra in save …\nA magic constant used to identify the algebra in save …\nComputes the product <code>r * s</code> of a basis element <code>r</code> and a …\nComputes the product <code>r * s</code> of a basis element <code>r</code> and a …\nComputes the product <code>r * s</code> of a basis element <code>r</code> and a …\nComputes the product <code>r * s</code> of a basis element <code>r</code> and a …\nComputes the product <code>r * s</code> of two basis elements, and adds …\nComputes the product <code>r * s</code> of a general element <code>r</code> and a …\nComputes the product <code>r * s</code> of a general element <code>r</code> and a …\nComputes the product <code>r * s</code> of a general element <code>r</code> and a …\nComputes the product <code>r * s</code> of a general element <code>r</code> and a …\nComputes the product <code>r * s</code> of a general element <code>r</code> and a …\nComputes the product <code>r * s</code> of two general elements, and …\nComputes the product <code>r * s</code> of two general elements, and …\nComputes the product <code>r * s</code> of two general elements, and …\nComputes the product <code>r * s</code> of two general elements, and …\nComputes the product <code>r * s</code> of two general elements, and …\nA name for the algebra to use in serialization operations. …\nA name for the algebra to use in serialization operations. …\nReturns the prime the algebra is over.\nAn <code>Algebra</code> equipped with a coproduct operation that makes …\nComputes a coproduct $\\Delta(x)$, expressed as\nDecomposes an element of the algebra into a product of …\nIf p is the nth prime, then <code>TAU_DEGREES[n][i]</code> is the …\nIf p is the nth prime, then <code>XI_DEGREES[n][i - 1]</code> is the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nindex ==&gt; degree\ndegree =&gt; (first_index, number_of_gens)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ndegree =&gt; max_part =&gt; list of partitions with maximum part …\n$\\mathbb{F}_p$, viewed as an <code>Algebra</code> over itself.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns a new <code>Field</code> over the given prime <code>p</code>.\nA version of <code>HashMap&lt;MilnorBasisElement, T&gt;</code> that is more …\nThe parts of a PPartMultiplier that involve heap …\ndegree -&gt; MilnorBasisElement -&gt; index\nA list of all basis elements of each degree, constructed …\nReturn the degree and index of $Q_1^e P(x)$.\nUpdate the degree component to the correct degree\nAssert that <code>elt</code> is in the image of the differential. Drop …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if the new element is not within the bounds\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether the profile is that of A(n). This is relevant …\nChecks whether the profile function is valid\nsource_deg -&gt; target_deg -&gt; source_op -&gt; target_op\nThis compute the first l &gt; k such that (sum + l) choose l …\nThe profile function for the Q part.\nGives a list of PPart’s in degree <code>t</code>.\nThis is a list of possible P(R) of each degree, where …\nA bitmask indicating which of the Q_k we want to include …\nIf <code>true</code>, unspecified p_part entries will be 0. Otherwise …\nWe have a matrix of the form | s₁  s₂  s₃ …\nThis creates a PPartAllocation with enough capacity to …\nAn element in the cohomological degree zero part of the …\nA lift of an algebra to a split pair algebra. See module …\nCompute $A(r, s)$ and write the result to <code>result</code>.\nCompute $A(Sq(R), Y_{k, l})$ where $a = Sq(R)$. This …\nActually computes $A(a, Y_{k, l})$ and returns the result.\nAssert that <code>elt</code> is in the image of the differential. Drop …\nAssert that <code>elt</code> is in the image of the differential. Drop …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new zero element in the given degree.\nThe element p is classified by a filtration on element in …\nSame as <code>PairAlgebra::sigma_multiply_basis</code> but with …\nSame as <code>PairAlgebra::sigma_multiply_basis</code> but with …\nGiven $r, s \\in \\pi_0(A)$, compute $\\sigma(r) \\sigma(s)$ …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nindex ==&gt; degree\ndegree =&gt; (first_index, number_of_gens)\ndegree =&gt; max_part =&gt; list of partitions with maximum part …\n$\\mathbb{F}_p$, viewed as an <code>Algebra</code> over itself.\nThe parts of a PPartMultiplier that involve heap …\ndegree -&gt; MilnorBasisElement -&gt; index\nA list of all basis elements of each degree, constructed …\nsource_deg -&gt; target_deg -&gt; source_op -&gt; target_op\nThe profile function for the Q part.\nThis is a list of possible P(R) of each degree, where …\nA bitmask indicating which of the Q_k we want to include …\nIf <code>true</code>, unspecified p_part entries will be 0. Otherwise …\nGiven a module N and a free module M, this is the module …\nA bounded below module over an algebra. To accommodate for …\nA free module.\nA quotient of a module truncated below a fix degree.\nThis is $\\mathbb{RP}_{\\mathrm{min}}^{\\mathrm{max}}$. The …\nThe algebra the module is over.\nThe name of a basis element. This is useful for debugging …\nFor each degree <code>d</code>, <code>basis_list[d]</code> is a list of basis …\nThe dimension of a module at the given degree\ndegree -&gt; internal index of first generator in degree\ndegree -&gt; internal index of first generator in degree\ndegree -&gt; internal index of first generator in degree\ndegree -&gt; internal_gen_idx -&gt; the offset of the generator …\ndegree -&gt; internal_gen_idx -&gt; the offset of the generator …\ndegree -&gt; internal_gen_idx -&gt; the offset of the generator …\nThe maximum <code>t</code> for which the module is fully defined at <code>t</code>. …\nThe minimum degree of the module, which is required to be …\nThe underlying module\nThe subspaces that we quotient out by\nEverything above this degree is quotiented out.\nA block structure is a structure that makes it efficient …\nAdd source vector “source” to the block indicated by …\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert (generator, basis element) to basis element of the …\nFind the block corresponding to a given generator.\nFind the (generator, basis element) pair corresponding to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis function will panic if you call it with input such …\nThis function will panic if you call it with input such …\nThis should really by try_from but orphan rules prohibit …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA free module.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ndegree -&gt; internal index of first generator in degree\ndegree -&gt; internal index of first generator in degree\ndegree -&gt; internal index of first generator in degree\nGiven a generator <code>(gen_deg, gen_idx)</code>, find the first index …\ndegree -&gt; internal_gen_idx -&gt; the offset of the generator …\ndegree -&gt; internal_gen_idx -&gt; the offset of the generator …\ndegree -&gt; internal_gen_idx -&gt; the offset of the generator …\nGiven a generator <code>(gen_deg, gen_idx)</code>, find the first index …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate the degrees and offsets of each generator up to …\nIterate the degrees and indices of each generator up to …\nGiven an element in a degree, iterate through the slices …\nGiven a vector that represents an element in degree <code>degree</code>…\nGiven a module N and a free module M, this is the module …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA ModuleHomomorphism that simply records the matrix of the …\nGiven a map $\\mathtt{map}: A \\to B$ and hom modules …\nEach <code>ModuleHomomorphism</code> may come with auxiliary data, …\nAttempt to apply quasi inverse to the input. Returns …\nCalling this function when …\nCompute the auxiliary data associated to the homomorphism …\ndegree shift, such that ouptut_degree = input_degree - …\ndegree shift, such that ouptut_degree = input_degree - …\ndegree shift, such that ouptut_degree = input_degree - …\nWrite the matrix of the homomorphism at input degree <code>degree</code>…\nGet the values of the homomorphism on the specified inputs …\nThe matrices of the module homomorphism. Unspecified …\nA MatrixFpSlice will do but there is no applicaiton of …\nAdd the image of a bidegree out of order. See …\ndegree shift, such that ouptut_degree = input_degree - …\ndegree shift, such that ouptut_degree = input_degree - …\ndegree shift, such that ouptut_degree = input_degree - …\nReturns the argument unchanged.\nGiven f: M -&gt; N, compute the dual f*: Hom(N, k) -&gt; Hom(M, …\nCalls <code>U::from(self)</code>.\nList of outputs that have been added out of order\nA ModuleHomomorphism that simply records the matrix of the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe matrices of the module homomorphism. Unspecified …\nThis function replaces the source of the …\nSee <code>replace_source</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGiven a map $\\mathtt{map}: A \\to B$ and hom modules …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA bounded below module over an algebra. To accommodate for …\nThe length of <code>input</code> need not be equal to the dimension of …\nThe length of <code>input</code> need not be equal to the dimension of …\nThe algebra the module is over.\nThe name of a basis element. This is useful for debugging …\nCompute internal data of the module so that we can query …\nCompute internal data of the module so that we can query …\nThe dimension of a module at the given degree\nGives the name of an element. The default implementation …\nGives the name of an element. The default implementation …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether this is the unit module.\nWhether this is the unit module.\nThe maximum <code>t</code> for which the module is fully defined at <code>t</code>. …\n<code>max_degree</code> is the a degree such that if t &gt; <code>max_degree</code>, …\n<code>max_degree</code> is the a degree such that if t &gt; <code>max_degree</code>, …\nMaximum degree of a generator under the Steenrod action. …\nMaximum degree of a generator under the Steenrod action. …\nThe minimum degree of the module, which is required to be …\nThe prime the module is over, which should be equal to the …\nThe prime the module is over, which should be equal to the …\nA quotient of a module truncated below a fix degree.\nFor each degree <code>d</code>, <code>basis_list[d]</code> is a list of basis …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe underlying module\nArguments\nThe subspaces that we quotient out by\nEverything above this degree is quotiented out.\nThis is $\\mathbb{RP}_{\\mathrm{min}}^{\\mathrm{max}}$. The …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn element in the cohomological degree zero part of the …\nA lift of an algebra to a split pair algebra. See module …\nCompute $A(r, s)$ and write the result to <code>result</code>.\nCreate a new zero element in the given degree.\nThe element p is classified by a filtration on element in …\nGiven $r, s \\in \\pi_0(A)$, compute $\\sigma(r) \\sigma(s)$ …\nExpress $Q_{qi}$ in the adem basis.\nTranslate from the adem basis to the milnor basis, adding …\nReturns\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nSurround with brackets\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPad both ends with whitespace")
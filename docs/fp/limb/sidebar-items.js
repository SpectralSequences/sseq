initSidebarItems({"fn":[["add","Return the `Limb` whose `i`th entry is `limb_a[i] + coeff * limb_b[i]` mod P. Both `limb_a` and `limb_b` are assumed to be reduced."],["bit_length","Return the number of bits an element of $\\mathbb{F}_P$ occupies in a limb."],["bit_length_const","Return the number of bits an element of $\\mathbb{F}_P$ occupies in a limb."],["bitmask","If `l` is a limb of elements of $\\mathbb{F}_p$, then `l & bitmask::<P>()` is the value of the first entry of `l`."],["entries_per_limb","The number of elements of $\\mathbb{F}_p$ that fit in a single limb."],["entries_per_limb_const","The number of elements of $\\mathbb{F}_p$ that fit in a single limb."],["is_reduced","Check whether or not a limb is reduced, i.e. whether every entry is a value in the range `0..P`. This is currently not faster than calling [`reduce`] directly."],["limb_bit_index_pair",""],["number","Return the number of limbs required to hold `dim` entries."],["pack","Given an interator of `u32`â€™s, pack all of them into a single limb in order. It is assumed that"],["range","Return the pair of usizes `(min, max)` such that `min..max` is the range starting at the index of the limb containing the `start`th entry, and ending at the index of the limb containing the `end`th entry (including the latter)."],["reduce","Return the `Limb` whose entries are the entries of `limb` reduced modulo `P`."],["sign_rule",""],["truncate","Return either `Some(sum)` if no carries happen in the limb, or `None` if some carry does happen."],["unpack","Give an iterator over the entries of `limb`."]],"struct":[["LimbBitIndexPair","A struct containing the information required to access a specific entry in an array of `Limb`s."]]});
initSidebarItems({"constant":[["BITMASKS",""],["BITS_PER_LIMB",""],["BIT_LENGTHS",""],["BYTES_PER_LIMB",""],["ENTRIES_PER_LIMB",""],["MAX_LEN",""]],"fn":[["bit_length",""],["bitmask","TODO: Would it be simpler to just compute this at “runtime”? It’s going to be inlined anyway."],["entries_per_limb",""],["initialize_limb_bit_index_table",""],["limb_bit_index_pair",""]],"mod":[["limb",""]],"static":[["LIMB_BIT_INDEX_ONCE_TABLE",""],["LIMB_BIT_INDEX_TABLE","This table tells us which limb and which bitfield of that limb to look for a given index of the vector in."]],"struct":[["AddShiftLeftData",""],["AddShiftRightData",""],["FpVectorIterator",""],["FpVectorNonZeroIteratorP","Iterator over non-zero entries of an FpVector. This is monomorphized over P for significant performance gains."],["FpVectorP","An `FpVectorP` is a vector over $\\mathbb{F}_p$ for a fixed prime, implemented using const generics. Due to limitations with const generics, we cannot constrain P to actually be a prime, so we allow it to be any u32. However, most functions will panic if P is not a prime."],["LimbBitIndexPair",""],["SliceMutP","A `SliceMutP` is a mutable slice of an `FpVectorP`. This mutably borrows the vector. Since it is a mutable borrow, it cannot implement `Copy`. However, it has a [`SliceMutP::copy`] function that imitates the reborrowing, that mutably borrows `SliceMutP` and returns a `SliceMutP` with a shorter lifetime."],["SliceP","A SliceP is a slice of an FpVectorP. This immutably borrows the vector and implements Copy"]],"type":[["Limb",""]]});
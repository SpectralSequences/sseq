rd_("CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6CkContiguously store the active double-precision (64-bit) \xe2\x80\xa6CkContiguously store the active single-precision (32-bit) \xe2\x80\xa6ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000002222ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa6CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa6CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmCopy a to tmp, then insert 128 bits (composed of 4 packed \xe2\x80\xa6CmCopy a to tmp, then insert 128 bits (composed of 2 packed \xe2\x80\xa610CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa6CiCounts the number of leading zero bits in each packed \xe2\x80\xa60CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa6CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa6CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa6ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa6CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa6CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa6EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa6CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa6210CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa6210CiStore packed 32-bit integers from a into memory using \xe2\x80\xa6CiStore packed 64-bit integers from a into memory using \xe2\x80\xa6ChStore packed 8-bit integers from a into memory using \xe2\x80\xa6CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa6CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa610CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa6ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa6CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CfNormalize the mantissas of packed double-precision \xe2\x80\xa6CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa6CfNormalize the mantissas of packed single-precision \xe2\x80\xa6CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa6CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa6CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa6CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa6CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa676ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa6CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa6543210CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa6CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa6CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa6CgReduce the packed 16-bit integers in a by addition. \xe2\x80\xa6CjReduce the packed 16-bit integers in a by bitwise AND. \xe2\x80\xa6CnReduce the packed 16-bit integers in a by maximum. Returns \xe2\x80\xa6CfReduce the packed unsigned 16-bit integers in a by \xe2\x80\xa6CnReduce the packed 16-bit integers in a by minimum. Returns \xe2\x80\xa61CmReduce the packed 16-bit integers in a by multiplication. \xe2\x80\xa6CnThis intrinsic is one of the two SHA512 message scheduling \xe2\x80\xa60CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa6CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa6CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa6CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa6ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa6CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa6CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa6CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa65ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa6ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa6432710432710432710432CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa6CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CfNormalize the mantissas of packed double-precision \xe2\x80\xa6CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa6CfNormalize the mantissas of packed single-precision \xe2\x80\xa6CkScatter 32-bit integers from a into memory using 32-bit \xe2\x80\xa6CkScatter 64-bit integers from a into memory using 32-bit \xe2\x80\xa6CkScatter 32-bit integers from a into memory using 64-bit \xe2\x80\xa6CkScatter 64-bit integers from a into memory using 64-bit \xe2\x80\xa67CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa6CkBlend packed 16-bit integers from a and b using control \xe2\x80\xa6CkBlend packed 32-bit integers from a and b using control \xe2\x80\xa6CkBlend packed 64-bit integers from a and b using control \xe2\x80\xa6?CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6?CkContiguously store the active double-precision (64-bit) \xe2\x80\xa6CkContiguously store the active single-precision (32-bit) \xe2\x80\xa6ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000002222ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa6CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa6CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmCopy a to tmp, then insert 128 bits (composed of 4 packed \xe2\x80\xa6CmCopy a to tmp, then insert 256 bits (composed of 8 packed \xe2\x80\xa6CmCopy a to tmp, then insert 128 bits (composed of 2 packed \xe2\x80\xa6CmCopy a to tmp, then insert 256 bits (composed of 4 packed \xe2\x80\xa63210CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa6CiCounts the number of leading zero bits in each packed \xe2\x80\xa60CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa6CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa6CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa6ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa6CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa6CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa6EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa6CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa6210CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa6210CiStore packed 32-bit integers from a into memory using \xe2\x80\xa6CiStore packed 64-bit integers from a into memory using \xe2\x80\xa6ChStore packed 8-bit integers from a into memory using \xe2\x80\xa6CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa6CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa610CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa6ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa6CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CfNormalize the mantissas of packed double-precision \xe2\x80\xa6CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa6CfNormalize the mantissas of packed single-precision \xe2\x80\xa6CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa6CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa6CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa6CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa6CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa676ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa6CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa6543210CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa6CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa6CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa6CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa6CgReduce the packed 32-bit integers in a by addition. \xe2\x80\xa6CgReduce the packed 64-bit integers in a by addition. \xe2\x80\xa6CjReduce the packed 32-bit integers in a by bitwise AND. \xe2\x80\xa6CjReduce the packed 64-bit integers in a by bitwise AND. \xe2\x80\xa6CmReduce the packed signed 32-bit integers in a by maximum. \xe2\x80\xa6CmReduce the packed signed 64-bit integers in a by maximum. \xe2\x80\xa6CfReduce the packed unsigned 32-bit integers in a by \xe2\x80\xa6CfReduce the packed unsigned 64-bit integers in a by \xe2\x80\xa6CmReduce the packed signed 32-bit integers in a by minimum. \xe2\x80\xa6CmReduce the packed signed 64-bit integers in a by minimum. \xe2\x80\xa632CmReduce the packed 32-bit integers in a by multiplication. \xe2\x80\xa6CmReduce the packed 64-bit integers in a by multiplication. \xe2\x80\xa6CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa6CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa6CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa6CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa6CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa6ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa6ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa6ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa6CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa6CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa6CmTest each 32-bit element of a for equality with all other \xe2\x80\xa6CmTest each 64-bit element of a for equality with all other \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa6ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa6ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa6CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa6ClZero extend packed unsigned 16-bit integers in the low 4 \xe2\x80\xa6CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa6CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6210ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa6CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa60CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60CmReduce the packed 8-bit integers in a by bitwise OR using \xe2\x80\xa6CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa6ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa6CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa6ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa6CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa6CmSign extend packed 8-bit integers in the low 2 bytes of a \xe2\x80\xa6CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa6CkZero extend packed unsigned 8-bit integers in th elow 4 \xe2\x80\xa6CkZero extend packed unsigned 8-bit integers in the low 2 \xe2\x80\xa6CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa6CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa6ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa6CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa6CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa6ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa6CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa6ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa6CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa6CiCompute the square root of the lower double-precision \xe2\x80\xa6CgCompute the square root of the lower half-precision \xe2\x80\xa6CiCompute the square root of the lower single-precision \xe2\x80\xa6CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa6CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa6876CiTests whether the specified bits in a 128-bit integer \xe2\x80\xa6CmTranslate from the adem basis to the milnor basis, adding \xe2\x80\xa6CcConverts a basis element into a string for display.CmThe name of a basis element. This is useful for debugging \xe2\x80\xa601CjCheck if the pre-condition <code>cond</code> has been met.BfDecomposes an element into generators.0CnGiven a row reduced matrix, find the first row whose pivot \xe2\x80\xa6CnThis is very similar to row_reduce, except we only need to \xe2\x80\xa6CgConverts a slice of bytes to a string slice without \xe2\x80\xa6DhReads from indices in <code>slice</code> to construct a SIMD vector. \xe2\x80\xa6BhReturns the current <code>0</code> flag.DfAn iterator of differentials in the form <code>(source, target)</code>CmInserts a new key-value pair into the map in the gap that \xe2\x80\xa60CjInserts a new element into the set in the gap that the \xe2\x80\xa60DdConsumes the <code>Arc</code>, returning the wrapped pointer and \xe2\x80\xa6DnConsumes the <code>Weak&lt;T&gt;</code>, returning the wrapped pointer and \xe2\x80\xa6DjConsumes the <code>Box</code>, returning a wrapped raw pointer and the \xe2\x80\xa6DcConsumes the <code>Rc</code>, returning the wrapped pointer and \xe2\x80\xa62BnChecks if <code>arm</code> feature is enabled.CnReturns whether the argument\xe2\x80\x99s value is statically known \xe2\x80\xa6D`A macro to test at <em>runtime</em> whether a CPU feature is \xe2\x80\xa60DkComputes the product <code>r * s</code> of two basis elements, and adds \xe2\x80\xa60DaThe first s such that <code>self.module(s)</code> is not defined.DiThis module defines <code>MuResolutionHomomorphism</code>, which is a \xe2\x80\xa6DkThis clears the vector and sets the length to <code>len</code>. This is \xe2\x80\xa6CaAdds elements within a vector from left to right.CgMultiplies elements within a vector from left to right.ClConstructs a new boxed slice with uninitialized contents \xe2\x80\xa60DjPerforms a volatile load from the <code>src</code> pointer The pointer \xe2\x80\xa6CjConverts an address back to a pointer, picking up some \xe2\x80\xa6CmConverts an address back to a mutable pointer, picking up \xe2\x80\xa6CgConverts an address back to a pointer, picking up a \xe2\x80\xa6000fU+001CDkA chain complex homomorphims from a <code>FreeChainComplex</code>. This \xe2\x80\xa6CeZero-sized type used to mark a lifetime as covariant.CeZero-sized type used to mark a lifetime as invariant.Cluse MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code>CmPerforms the last round of an AES decryption flow on each \xe2\x80\xa6CmPerforms the last round of an AES encryption flow on each \xe2\x80\xa6ClBroadcast the low 8-bits from input mask k to all 64-bit \xe2\x80\xa6CmBroadcast the low 16-bits from input mask k to all 32-bit \xe2\x80\xa6CfPerforms a carry-less multiplication of two 64-bit \xe2\x80\xa6ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa6ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa6ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa6CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6DeExtracts 128 bits (composed of integer data) from <code>a</code>, \xe2\x80\xa6DiExtracts 128 bits (of integer data) from <code>a</code> selected with \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa61ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa612CnConcatenate a and b into a 64-byte immediate result, shift \xe2\x80\xa60CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60000022CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa63=<CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa6CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa6CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa6DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa6000CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa6CnShuffle 8-bit integers in a within 128-bit lanes using the \xe2\x80\xa6CiStore packed 16-bit integers from a into memory using \xe2\x80\xa6CiStore packed 32-bit integers from a into memory using \xe2\x80\xa6CiStore packed 64-bit integers from a into memory using \xe2\x80\xa6CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa6CkContiguously store the active double-precision (64-bit) \xe2\x80\xa6CkContiguously store the active single-precision (32-bit) \xe2\x80\xa6ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000002222ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa6CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa6CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmCopy a to tmp, then insert 128 bits (composed of 4 packed \xe2\x80\xa6CmCopy a to tmp, then insert 128 bits (composed of 2 packed \xe2\x80\xa610CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa6CiCounts the number of leading zero bits in each packed \xe2\x80\xa60CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa6CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa6CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa6ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa6CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa6CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa6EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa6CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa6210CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa6210CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa6CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa610EbPermutes 64-bit integers from <code>a</code> using control mask <code>imm8</code>.DjShuffles eight 32-bit floating-point elements in <code>a</code> across \xe2\x80\xa6ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa6CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa6CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa6CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa6CjThis intrinsic performs two rounds of SHA512 operation \xe2\x80\xa6CnLoad 256-bits of integer data from memory into dst using a \xe2\x80\xa6CmPerforms the last round of an AES decryption flow on each \xe2\x80\xa6CmPerforms the last round of an AES encryption flow on each \xe2\x80\xa6ClBroadcast the low 8-bits from input mask k to all 64-bit \xe2\x80\xa6CmBroadcast the low 16-bits from input mask k to all 32-bit \xe2\x80\xa6CfPerforms a carry-less multiplication of two 64-bit \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa6ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa6ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa6ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6000CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa6CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CkLoads 8 64-bit integer elements from memory starting at \xe2\x80\xa6121321CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa6CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa6CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa6CiConcatenate a and b into a 128-byte immediate result, \xe2\x80\xa60CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa6<>>>>======<<CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa6=CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa6ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa6CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa6CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa6CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa6CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa6ClGather double-precision (64-bit) floating-point elements \xe2\x80\xa6ClGather single-precision (32-bit) floating-point elements \xe2\x80\xa610CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6210ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CnMultiplies elements in packed 64-bit integer vectors a and \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa6CnShuffle 8-bit integers in a within 128-bit lanes using the \xe2\x80\xa6CiStore packed 16-bit integers from a into memory using \xe2\x80\xa6CiStore packed 32-bit integers from a into memory using \xe2\x80\xa6CiStore packed 64-bit integers from a into memory using \xe2\x80\xa6ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa6CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa6ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa6CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa6CkContiguously store the active double-precision (64-bit) \xe2\x80\xa6CkContiguously store the active single-precision (32-bit) \xe2\x80\xa6ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000002222ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa6CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa6CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmCopy a to tmp, then insert 128 bits (composed of 4 packed \xe2\x80\xa6CmCopy a to tmp, then insert 256 bits (composed of 8 packed \xe2\x80\xa6CmCopy a to tmp, then insert 128 bits (composed of 2 packed \xe2\x80\xa6CmCopy a to tmp, then insert 256 bits (composed of 4 packed \xe2\x80\xa63210CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa6CiCounts the number of leading zero bits in each packed \xe2\x80\xa60CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa6CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa6CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa6ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa6CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa6CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa6EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa6CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa6210CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa6210CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa6CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa610ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa6CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa6CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa6CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa6CnLoad 512-bits of integer data from memory into dst using a \xe2\x80\xa6CmBroadcasts 128 bits of integer data from a to all 128-bit \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6210CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa6ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa6CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa6CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa610101010ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa6CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa6=<;=<;ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa6CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa6ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa6CkTest the lower double-precision (64-bit) floating-point \xe2\x80\xa6CiTest the lower half-precision (16-bit) floating-point \xe2\x80\xa6CkTest the lower single-precision (32-bit) floating-point \xe2\x80\xa6CfConvert the exponent of the lower double-precision \xe2\x80\xa6CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa6CfConvert the exponent of the lower single-precision \xe2\x80\xa6DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa6000CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CkReduce the packed 8-bit integers in a by addition using \xe2\x80\xa6CnReduce the packed 8-bit integers in a by bitwise AND using \xe2\x80\xa6CjReduce the packed 8-bit integers in a by maximum using \xe2\x80\xa6CmReduce the packed unsigned 8-bit integers in a by maximum \xe2\x80\xa6CjReduce the packed 8-bit integers in a by minimum using \xe2\x80\xa6CmReduce the packed unsigned 8-bit integers in a by minimum \xe2\x80\xa6CkReduce the packed 8-bit integers in a by multiplication \xe2\x80\xa6CnReduce the packed 16-bit integers in a by bitwise OR using \xe2\x80\xa6CnExtract the reduced argument of the lower double-precision \xe2\x80\xa6ClExtract the reduced argument of the lower half-precision \xe2\x80\xa6CnExtract the reduced argument of the lower single-precision \xe2\x80\xa6CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa6CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa6CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa6CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa6CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa6CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa6CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa6CmTest each 32-bit element of a for equality with all other \xe2\x80\xa6CmTest each 64-bit element of a for equality with all other \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa6ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa6ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa6CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa6ClZero extend packed unsigned 16-bit integers in the low 4 \xe2\x80\xa6CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa6CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6210ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa6CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa60CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa6CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa6CkAn atomic fence for synchronization within a single thread.CjEnsure all bidegrees less than or equal to (s, t) have \xe2\x80\xa6FjCopies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>self</code>. The \xe2\x80\xa6CcConstruct a chain map that lifts a given module \xe2\x80\xa6BoChecks if <code>mips</code> feature is enabled.E`See documentation of <code>&lt;*const T&gt;::offset_from_unsigned</code> for \xe2\x80\xa6CmAppends an element and returns a reference to it if there \xe2\x80\xa6ClWrites values from a SIMD vector to multiple potentially \xe2\x80\xa6CfSet the permissions of a file, unless it is a symlink.CfForms a raw mutable slice from a pointer and a length.DjPerforms a volatile store to the <code>dst</code> pointer. The pointer \xe2\x80\xa6DeCreates an empty <code>HashMap</code> with at least the specified \xe2\x80\xa6DeCreates an empty <code>HashSet</code> with at least the specified \xe2\x80\xa6fU+001DA`round to nearestCkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa6ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa6CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa60ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa6CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa6ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa6CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa6CmSign extend packed 8-bit integers in the low 4 bytes of a \xe2\x80\xa6CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa6CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa6CkZero extend packed unsigned 8-bit integers in the low 4 \xe2\x80\xa6CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa6CnStores 4 double-precision (64-bit) floating-point elements \xe2\x80\xa6CnStores 8 single-precision (32-bit) floating-point elements \xe2\x80\xa61CnStores 4 single-precision (32-bit) floating-point elements \xe2\x80\xa6CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa6CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa6CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa6CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa6CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa6CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa6CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa6CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa6CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa6CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa6CnConcatenate a and b into a 64-byte immediate result, shift \xe2\x80\xa60CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60000022CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa63CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa6CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa6CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa6CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa6CkShuffle packed 8-bit integers in a according to shuffle \xe2\x80\xa6CmLoads 4 double-precision (64-bit) floating-point elements \xe2\x80\xa6CmLoads 8 single-precision (32-bit) floating-point elements \xe2\x80\xa61CmLoads 4 single-precision (32-bit) floating-point elements \xe2\x80\xa6ClShuffles 128-bits (composed of integer data) selected by \xe2\x80\xa6EgShuffles 128-bits of integer data selected by <code>imm8</code> from <code>a</code> \xe2\x80\xa6CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa6CiBitwise ternary logic that provides the capability to \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6000CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa6ClExtracts 256 bits (composed of 8 packed 32-bit integers) \xe2\x80\xa6ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa6CkExtract 256 bits (composed of 4 packed 64-bit integers) \xe2\x80\xa6CnStores 8 64-bit integer elements from a to memory starting \xe2\x80\xa6ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa6CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa61010ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa6CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa6ClPerforms element-by-element conversion of the lower half \xe2\x80\xa6CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa6CmSign extend packed 8-bit integers in the low 8 bytes of a \xe2\x80\xa64CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa60CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa6CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa6CmScatter double-precision (64-bit) floating-point elements \xe2\x80\xa6CmScatter single-precision (32-bit) floating-point elements \xe2\x80\xa610CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa6CmMultiply the packed complex numbers in a and b, and store \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CnReduce the packed double-precision (64-bit) floating-point \xe2\x80\xa6CnReduce the packed single-precision (32-bit) floating-point \xe2\x80\xa6101010CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa6CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa6CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa6CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa6CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa6CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa6CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa6CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa6CfCompute the square root of packed double-precision \xe2\x80\xa6CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa6CfCompute the square root of packed single-precision \xe2\x80\xa6CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa6CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa6CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa6CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa6CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa6CiConcatenate a and b into a 128-byte immediate result, \xe2\x80\xa60CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60000022CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa63CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa6ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa6CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa6CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa6CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa6CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6210ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa61CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa6CkShuffle packed 8-bit integers in a according to shuffle \xe2\x80\xa6ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa6CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa6ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa6CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa6CiBitwise ternary logic that provides the capability to \xe2\x80\xa60BgAssist in expanding the AES cipher key.EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6210CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa6ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa6CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa6CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa6CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa65ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa6ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa6432710432710432710432CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa6CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa6CiMultiply the lower complex number in a by the complex \xe2\x80\xa6CiNormalize the mantissas of the lower double-precision \xe2\x80\xa6CgNormalize the mantissas of the lower half-precision \xe2\x80\xa6CiNormalize the mantissas of the lower single-precision \xe2\x80\xa6CnStores 4 32-bit integer elements from a to memory starting \xe2\x80\xa6CnStores 2 64-bit integer elements from a to memory starting \xe2\x80\xa6CnStores 2 32-bit integer elements from a to memory starting \xe2\x80\xa61CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa6ClReduce the packed 16-bit integers in a by addition using \xe2\x80\xa6CiReduce the packed 16-bit integers in a by bitwise AND \xe2\x80\xa6CkReduce the packed 16-bit integers in a by maximum using \xe2\x80\xa6CnReduce the packed unsigned 16-bit integers in a by maximum \xe2\x80\xa6CkReduce the packed 16-bit integers in a by minimum using \xe2\x80\xa6CnReduce the packed unsigned 16-bit integers in a by minimum \xe2\x80\xa6ClReduce the packed 16-bit integers in a by multiplication \xe2\x80\xa6CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa6CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa6CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa6CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa6ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa6CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6210CfConvert the exponent of the lower double-precision \xe2\x80\xa6CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa6CfConvert the exponent of the lower single-precision \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CnExtract the reduced argument of the lower double-precision \xe2\x80\xa6ClExtract the reduced argument of the lower half-precision \xe2\x80\xa6CnExtract the reduced argument of the lower single-precision \xe2\x80\xa6CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa6CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa6CkLoads 4 32-bit integer elements from memory starting at \xe2\x80\xa6CkLoads 2 64-bit integer elements from memory starting at \xe2\x80\xa6CkLoads 2 32-bit integer elements from memory starting at \xe2\x80\xa61CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa6ChConverts a string to a basis element. This must be a \xe2\x80\xa60CkCalculates the distance between two pointers within the \xe2\x80\xa6CnReturns the smallest power of two greater than or equal to \xe2\x80\xa600000DjDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> \xe2\x80\xa6DiDecrements the strong reference count on the <code>Rc&lt;T&gt;</code> \xe2\x80\xa6CkConverts a boxed slice of bytes to a boxed string slice \xe2\x80\xa6BgCreates a layout, bypassing all checks.DjIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> \xe2\x80\xa6DiIncrements the strong reference count on the <code>Rc&lt;T&gt;</code> \xe2\x80\xa6DkGiven a generator <code>(gen_deg, gen_idx)</code>, find the first index \xe2\x80\xa6DcDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: \xe2\x80\xa6DdA macro to test at <em>runtime</em> whether instruction sets are \xe2\x80\xa6C`Checks if <code>s390x</code> feature is enabled.DjThe <code>prefetch</code> intrinsic is a hint to the code generator to \xe2\x80\xa6CnReturns the amount of time elapsed from another instant to \xe2\x80\xa6CnAdds elements within a vector in arbitrary order. May also \xe2\x80\xa6CkMultiplies elements within a vector in arbitrary order. \xe2\x80\xa6CfNon-overlapping <em>typed</em> swap of a single value.Cg<code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code>CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa6CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa6CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa6ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa6ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa6ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa6CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa6CmTest each 32-bit element of a for equality with all other \xe2\x80\xa6CmTest each 64-bit element of a for equality with all other \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa6ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa6ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa6CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa6ClZero extend packed unsigned 16-bit integers in the low 8 \xe2\x80\xa6CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa6CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa6CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa60CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CmReduce the packed 8-bit integers in a by bitwise OR using \xe2\x80\xa6CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa6ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa6CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa6ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa6CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa6CmSign extend packed 8-bit integers in the low 4 bytes of a \xe2\x80\xa6CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa6CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa6CkZero extend packed unsigned 8-bit integers in the low 4 \xe2\x80\xa6CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa6CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa6CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa6CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa6CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa6CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa6CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa6CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa6CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa6CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa6CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa6CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa6CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa6CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa6ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa6ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa6ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6101010CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa6CmTest each 32-bit element of a for equality with all other \xe2\x80\xa6CmTest each 64-bit element of a for equality with all other \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa6ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa6ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa6CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa6CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6CmLoads 8 double-precision (64-bit) floating-point elements \xe2\x80\xa6CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa60CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa6ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa6CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa6ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa6CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa6CmSign extend packed 8-bit integers in the low 8 bytes of a \xe2\x80\xa6CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa60CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa6CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa6CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa6CmMultiply the packed complex numbers in a and b, and store \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa6CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa6CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa6CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa6CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa6CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa6CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa6CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa6CfCompute the square root of packed double-precision \xe2\x80\xa6CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa6CfCompute the square root of packed single-precision \xe2\x80\xa6CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa6CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa6<;:CkPerforms an affine transformation on the packed bytes in x.CiMultiply the lower complex number in a by the complex \xe2\x80\xa6CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa6ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa6ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa6ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa6ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa6CkContiguously store the active double-precision (64-bit) \xe2\x80\xa6CkContiguously store the active single-precision (32-bit) \xe2\x80\xa6CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa6CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa6CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa6CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa6CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa6ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa6CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa6CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa6CiMultiply the lower complex number in a by the complex \xe2\x80\xa6CiNormalize the mantissas of the lower double-precision \xe2\x80\xa6CgNormalize the mantissas of the lower half-precision \xe2\x80\xa6CiNormalize the mantissas of the lower single-precision \xe2\x80\xa6CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa6Bidegree -&gt; AdemBasisElement -&gt; indexBkdegree -&gt; MilnorBasisElement -&gt; index1010DjAttempts to get mutable references to <code>N</code> values in the map \xe2\x80\xa6CaChecks if <code>mips64</code> feature is enabled.DjThe <code>prefetch</code> intrinsic is a hint to the code generator to \xe2\x80\xa6CmBroadcasts 128 bits of integer data from a to all 128-bit \xe2\x80\xa6CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa6CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa6CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa6CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa6ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa6CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa6ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa6CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa6CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa610101010ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa6ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa6ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa6CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa6ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa6DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa6000CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CkReduce the packed 8-bit integers in a by addition using \xe2\x80\xa6CnReduce the packed 8-bit integers in a by bitwise AND using \xe2\x80\xa6CjReduce the packed 8-bit integers in a by maximum using \xe2\x80\xa6CmReduce the packed unsigned 8-bit integers in a by maximum \xe2\x80\xa6CjReduce the packed 8-bit integers in a by minimum using \xe2\x80\xa6CmReduce the packed unsigned 8-bit integers in a by minimum \xe2\x80\xa6CkReduce the packed 8-bit integers in a by multiplication \xe2\x80\xa6CnReduce the packed 16-bit integers in a by bitwise OR using \xe2\x80\xa6CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa6CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa6CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa6CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa6CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa6CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa6CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa6CmTest each 32-bit element of a for equality with all other \xe2\x80\xa6CmTest each 64-bit element of a for equality with all other \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa6ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa6ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa6CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa6ClZero extend packed unsigned 16-bit integers in the low 8 \xe2\x80\xa6CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa6CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa6CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa60CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa6CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa6DhPermutes packed 32-bit integers from <code>a</code> according to the \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa6CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa6CeBroadcasts the 8 packed single-precision (32-bit) \xe2\x80\xa6CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa6CdBroadcast the 4 packed double-precision (64-bit) \xe2\x80\xa6CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa6ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa6CiBroadcasts the 8 packed 32-bit integers from a to all \xe2\x80\xa6CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa6ChBroadcast the 4 packed 64-bit integers from a to all \xe2\x80\xa6ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa6CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa6CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa610101010ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa6ClExtracts 256 bits (composed of 8 packed single-precision \xe2\x80\xa6ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa6CkExtract 256 bits (composed of 4 packed double-precision \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa6CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa6ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa6ChConvert the exponent of each packed double-precision \xe2\x80\xa6CfConvert the exponent of each packed half-precision \xe2\x80\xa6ChConvert the exponent of each packed single-precision \xe2\x80\xa6ClGather 32-bit integers from memory using 32-bit indices. \xe2\x80\xa6ClGather 64-bit integers from memory using 32-bit indices. \xe2\x80\xa6CnStores 8 double-precision (64-bit) floating-point elements \xe2\x80\xa6ClGather 32-bit integers from memory using 64-bit indices. \xe2\x80\xa6ClGather 64-bit integers from memory using 64-bit indices. \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CnReduce the packed 32-bit integers in a by bitwise OR using \xe2\x80\xa6CnReduce the packed 64-bit integers in a by bitwise OR using \xe2\x80\xa6CkExtract the reduced argument of packed double-precision \xe2\x80\xa6CiExtract the reduced argument of packed half-precision \xe2\x80\xa6CkExtract the reduced argument of packed single-precision \xe2\x80\xa6CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa6CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa6CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa6CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa6CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa6CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa6CmTest each 32-bit element of a for equality with all other \xe2\x80\xa6CmTest each 64-bit element of a for equality with all other \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa6ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa6ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa6CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa6CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa60CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa6CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa6ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa6CiBitwise ternary logic that provides the capability to \xe2\x80\xa60CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa6CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa6CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa6CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa6CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa69CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa6DkConverts a Vec&lt;u8&gt; to a <code>CString</code> without checking the \xe2\x80\xa6Chdegree -&gt; internal index of first generator in degree00000DiThis macro tests, at runtime, whether an <code>aarch64</code> feature \xe2\x80\xa6CbChecks if <code>powerpc</code> feature is enabled.DhComputes the product <code>r * s</code> of two general elements, and \xe2\x80\xa60CmConverts an address back to a mutable pointer, picking up \xe2\x80\xa6CiZero-sized type used to mark a lifetime as contravariant.EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa6ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa6CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa6CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa6CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa65ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa6ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa6432710432710432710432CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa6CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa6CnStores 8 32-bit integer elements from a to memory starting \xe2\x80\xa6CnStores 4 64-bit integer elements from a to memory starting \xe2\x80\xa6CnStores 4 32-bit integer elements from a to memory starting \xe2\x80\xa61CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa6ClReduce the packed 16-bit integers in a by addition using \xe2\x80\xa6CiReduce the packed 16-bit integers in a by bitwise AND \xe2\x80\xa6CkReduce the packed 16-bit integers in a by maximum using \xe2\x80\xa6CnReduce the packed unsigned 16-bit integers in a by maximum \xe2\x80\xa6CkReduce the packed 16-bit integers in a by minimum using \xe2\x80\xa6CnReduce the packed unsigned 16-bit integers in a by minimum \xe2\x80\xa6ClReduce the packed 16-bit integers in a by multiplication \xe2\x80\xa6CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa6CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa6CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa6CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa6CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa6CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa6CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa6ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa6CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa6ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa6ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa6CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa6CkLoads 8 32-bit integer elements from memory starting at \xe2\x80\xa6CkLoads 4 64-bit integer elements from memory starting at \xe2\x80\xa6CkLoads 4 32-bit integer elements from memory starting at \xe2\x80\xa61CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa6EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa687CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa6ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa6CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa6CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa6CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa65ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa6ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa6432710432710432710432CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa6CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CfNormalize the mantissas of packed double-precision \xe2\x80\xa6CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa6CfNormalize the mantissas of packed single-precision \xe2\x80\xa6CkScatter 32-bit integers from a into memory using 32-bit \xe2\x80\xa6CkScatter 64-bit integers from a into memory using 32-bit \xe2\x80\xa6CkScatter 32-bit integers from a into memory using 64-bit \xe2\x80\xa6CkScatter 64-bit integers from a into memory using 64-bit \xe2\x80\xa6CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa6CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa6ClReduce the packed 32-bit integers in a by addition using \xe2\x80\xa6ClReduce the packed 64-bit integers in a by addition using \xe2\x80\xa6CiReduce the packed 32-bit integers in a by bitwise AND \xe2\x80\xa61ClReduce the packed signed 32-bit integers in a by maximum \xe2\x80\xa6ClReduce the packed signed 64-bit integers in a by maximum \xe2\x80\xa6CnReduce the packed unsigned 32-bit integers in a by maximum \xe2\x80\xa6CnReduce the packed unsigned 64-bit integers in a by maximum \xe2\x80\xa63212ClReduce the packed 32-bit integers in a by multiplication \xe2\x80\xa6ClReduce the packed 64-bit integers in a by multiplication \xe2\x80\xa6CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa6CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa6CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa6CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa6CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa6CeBroadcasts the 8 packed single-precision (32-bit) \xe2\x80\xa6CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa6CdBroadcast the 4 packed double-precision (64-bit) \xe2\x80\xa6CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa6ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa6CiBroadcasts the 8 packed 32-bit integers from a to all \xe2\x80\xa6CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa6ChBroadcast the 4 packed 64-bit integers from a to all \xe2\x80\xa6ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa6ClExtracts 256 bits (composed of 8 packed single-precision \xe2\x80\xa6ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa6CkExtract 256 bits (composed of 4 packed double-precision \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChConvert the exponent of each packed double-precision \xe2\x80\xa6CfConvert the exponent of each packed half-precision \xe2\x80\xa6ChConvert the exponent of each packed single-precision \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CkExtract the reduced argument of packed double-precision \xe2\x80\xa6CiExtract the reduced argument of packed half-precision \xe2\x80\xa6CkExtract the reduced argument of packed single-precision \xe2\x80\xa6CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa6CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa6CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa6CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa6ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa6ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa6CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa6ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa6654CiBitwise ternary logic that provides the capability to \xe2\x80\xa60CaAdd the image of a bidegree out of order. See \xe2\x80\xa6DhConverts bytes to an <code>OsString</code> without checking that the \xe2\x80\xa6CkConverts a slice of bytes to an OS string slice without \xe2\x80\xa6CnConvert (generator, basis element) to basis element of the \xe2\x80\xa6CmFind the (generator, basis element) pair corresponding to \xe2\x80\xa6EgConsumes the <code>Box</code>, returning a wrapped <code>NonNull</code> pointer and \xe2\x80\xa6BmReceives data and ancillary data from socket.0BlSends data and ancillary data on the socket.0ChCreates a vector of pointers from a vector of addresses.DhChecks if the <code>Request</code> would be satisfied if provided with aCkPerforms an affine transformation on the packed bytes in x.ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa6ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa6ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa6CkContiguously store the active double-precision (64-bit) \xe2\x80\xa6CkContiguously store the active single-precision (32-bit) \xe2\x80\xa6CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa6CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa6CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa6ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa6CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa6CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa6CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa6CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa6CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa6CkPerforms an affine transformation on the packed bytes in x.CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa6ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa6ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa6CkContiguously store the active double-precision (64-bit) \xe2\x80\xa6CkContiguously store the active single-precision (32-bit) \xe2\x80\xa6ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6000CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa6CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa6CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa6CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa6CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CkLoads 8 64-bit integer elements from memory starting at \xe2\x80\xa6ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa6CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa6CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa6CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa6CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa6CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CfNormalize the mantissas of packed double-precision \xe2\x80\xa6CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa6CfNormalize the mantissas of packed single-precision \xe2\x80\xa6CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa6ClPerforms an affine transformation on the inverted packed \xe2\x80\xa6CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa6CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa6ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa6CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa6ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa6CfUnsafely creates a C string wrapper from a byte slice.DbChecks if <code>loongarch</code> feature is enabled. Supported \xe2\x80\xa6CbChecks if <code>powerpc</code> feature is enabled.CaNegates results only before the end of the stringCbDo not negate results before the end of the stringClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa6CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa6ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa6CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa6CiBitwise ternary logic that provides the capability to \xe2\x80\xa60CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa6CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa6CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa69CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa6CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa6CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa6<ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa61ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa612CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6000CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa6ClExtracts 256 bits (composed of 8 packed 32-bit integers) \xe2\x80\xa6ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa6CkExtract 256 bits (composed of 4 packed 64-bit integers) \xe2\x80\xa6CnStores 8 64-bit integer elements from a to memory starting \xe2\x80\xa6CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa6CiBitwise ternary logic that provides the capability to \xe2\x80\xa60ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6000CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa6CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa6CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa6CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa6CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa6CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa6CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa6CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa6EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa6ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa6CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa6DjA guard for <code>std::mem::uninitialized</code>. This will statically \xe2\x80\xa6DhChecks if the <code>Request</code> would be satisfied if provided with aCmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa6ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa6CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa6ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa6543CiBitwise ternary logic that provides the capability to \xe2\x80\xa606543CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa6CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa6CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60000022228ClExtracts 256 bits (composed of 8 packed 32-bit integers) \xe2\x80\xa68CkExtract 256 bits (composed of 4 packed 64-bit integers) \xe2\x80\xa6>=<88ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6CkPerforms an affine transformation on the packed bytes in x.CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa6CmA MatrixSlice will do but there is no application of this \xe2\x80\xa6CiReturns a list of filtration-one elements in $Ext(k, k)$.0CfSends data and ancillary data on the socket to the \xe2\x80\xa6ClPerforms an affine transformation on the inverted packed \xe2\x80\xa6CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa6CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa6CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa66543210CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa6CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa6CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CkPerforms an affine transformation on the packed bytes in x.EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa6ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa6CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa676543210EcComputes the product <code>r * s</code> of a basis element <code>r</code> and a \xe2\x80\xa60EeComputes the product <code>r * s</code> of a general element <code>r</code> and a \xe2\x80\xa60BmReceives data and ancillary data from socket.ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6CkPerforms an affine transformation on the packed bytes in x.954432109ClPerforms an affine transformation on the inverted packed \xe2\x80\xa6322132210DeEquivalent to the appropriate <code>llvm.memcpy.p0i8.0i8.*</code> \xe2\x80\xa6DhComputes the product <code>r * s</code> of two general elements, and \xe2\x80\xa60002222ClThis function expresses $Sq^x$ (current) in terms of the \xe2\x80\xa6<<;;;;")
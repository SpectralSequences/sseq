rd_("CfComputes the absolute value of packed 8-bit signed \xe2\x80\xa6D`Adds packed 8-bit integers in <code>a</code> and <code>b</code>.DmAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.CiBlend packed double-precision (64-bit) floating-point \xe2\x80\xa6CiBlend packed single-precision (32-bit) floating-point \xe2\x80\xa6EbCompares corresponding elements in <code>a</code> and <code>b</code> for equality.DkCompares each of the four floats in <code>a</code> to the corresponding \xe2\x80\xa6DkReturns a new vector with the low element of <code>a</code> replaced by \xe2\x80\xa6DiCompares the lowest <code>f32</code> of both inputs for equality. The \xe2\x80\xa6GaCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> \xe2\x80\xa60FnCompares packed strings <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> \xe2\x80\xa61111DlCompares corresponding elements in <code>a</code> and <code>b</code> for \xe2\x80\xa654DkCompares the lowest <code>f32</code> of both inputs for greater than or \xe2\x80\xa6165DiCompares the lowest <code>f32</code> of both inputs for greater than. \xe2\x80\xa6EfCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> \xe2\x80\xa6000000387DhCompares the lowest <code>f32</code> of both inputs for less than or \xe2\x80\xa6EcCompares corresponding elements in <code>a</code> and <code>b</code> for less-than.:9DjCompares the lowest <code>f32</code> of both inputs for less than. The \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa6CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa6DcStarting with the initial value in <code>crc</code>, return the \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6ClConverts packed double-precision (64-bit) floating-point \xe2\x80\xa6CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CnConverts the 4 x 16-bit half-precision float values in the \xe2\x80\xa6ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa6CnConverts the 4 x 32-bit float values in the 128-bit vector \xe2\x80\xa6CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa6C`Converts the lower double-precision (64-bit) \xe2\x80\xa6ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Converts the lower single-precision (32-bit) \xe2\x80\xa6CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa6CmRound the packed double-precision (64-bit) floating-point \xe2\x80\xa6CmRound the packed single-precision (32-bit) floating-point \xe2\x80\xa6ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa6ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa6CnMultiplies packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6CnMultiplies packed single-precision (32-bit) floating-point \xe2\x80\xa6CbMultiplies the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6CbMultiplies the lower single-precision (32-bit) \xe2\x80\xa6543210CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa6ClLoads a double-precision (64-bit) floating-point element \xe2\x80\xa6EeConstruct a <code>__m128</code> by duplicating the value read from <code>p</code> \xe2\x80\xa61BcAlias for <code>_mm_load1_ps</code>CnLoads a double-precision value into the high-order bits of \xe2\x80\xa6CmLoads a double-precision value into the low-order bits of \xe2\x80\xa6CmLoads 2 double-precision (64-bit) floating-point elements \xe2\x80\xa6EhLoads four <code>f32</code> values from aligned memory into a <code>__m128</code> in \xe2\x80\xa6CiLoads 128-bits (composed of 2 packed double-precision \xe2\x80\xa6CfLoad 128-bits (composed of 8 packed half-precision \xe2\x80\xa6EhLoads four <code>f32</code> values from memory into a <code>__m128</code>. There are \xe2\x80\xa6EcCompares packed 8-bit integers in <code>a</code> and <code>b</code> and returns \xe2\x80\xa6EeCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and \xe2\x80\xa610CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa6CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa6CmComputes the bitwise OR of 128 bits (representing integer \xe2\x80\xa6DgFetch the cache line that contains address <code>p</code> using the \xe2\x80\xa6CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60C`Compute the approximate reciprocal of packed \xe2\x80\xa60CcCompute the approximate reciprocal of the lower \xe2\x80\xa60CmRound the packed double-precision (64-bit) floating-point \xe2\x80\xa6CmRound the packed single-precision (32-bit) floating-point \xe2\x80\xa6ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa6ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa6ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6ClReturns the approximate reciprocal square root of packed \xe2\x80\xa6CiCompute the approximate reciprocal square root of the \xe2\x80\xa6CiReturns the approximate reciprocal square root of the \xe2\x80\xa6CiSum the absolute differences of packed unsigned 8-bit \xe2\x80\xa6CdSets packed 8-bit integers with the supplied values.CjStores 128-bits (composed of 2 packed double-precision \xe2\x80\xa6CgStore 128-bits (composed of 8 packed half-precision \xe2\x80\xa6CgStores four 32-bit floats into <em>aligned</em> memory.CcStores the lower 64 bits of a 128-bit vector of \xe2\x80\xa6CjStore the lower half-precision (16-bit) floating-point \xe2\x80\xa6CmStores the lowest 32 bit float of <code>a</code> into memory.DgSubtracts packed 8-bit integers in <code>b</code> from packed 8-bit \xe2\x80\xa6CfComputes the bitwise AND of 128 bits (representing \xe2\x80\xa6000CjCounts the number of trailing least significant zero bits.0AjStore 8-bit mask to memoryC`Compute dot-product of bytes in tiles with a \xe2\x80\xa6000CkStore the tile specified by src to memory specifieid by \xe2\x80\xa6EhRetrieves the parameter passed to <code>_xabort</code> when <code>_xbegin</code>\xe2\x80\x99s \xe2\x80\xa6CcInvokes a closure, aborting if the closure unwinds.FcGiven a mask v, add the <code>i</code>th entry of <code>other</code> to the <code>v[i]</code>th \xe2\x80\xa6BjThe Steenrod algebra using the Adem basis.0BoThe required alignment of the referenced value.CmReturns the ABI-required minimum alignment of the type of \xe2\x80\xa600000CgComputes the offset that needs to be applied to the \xe2\x80\xa6CeAllocates zero-initialized memory with the global \xe2\x80\xa6DkBehaves like <code>alloc</code>, but also ensures that the contents are \xe2\x80\xa6CnMakes all future panics abort directly without running the \xe2\x80\xa6CkCalculates the offset from a pointer, potentially wrapping.DiReturns an iterator over <code>N</code> elements of the iterator at a \xe2\x80\xa600000DfReturns the contents of this <code>MaybeUninit</code> as a mutable \xe2\x80\xa6ElConverts from <code>Option&lt;T&gt;</code> (or <code>&amp;mut Option&lt;T&gt;</code>) to \xe2\x80\xa6EdGets <code>Pin&lt;&amp;mut T&gt;</code> to the underlying pinned value from this \xe2\x80\xa6FbConverts from <code>Result&lt;T, E&gt;</code> (or <code>&amp;mut Result&lt;T, E&gt;</code>) to \xe2\x80\xa6CkReturns a mutable array reference containing the entire \xe2\x80\xa6CnReturns a mutable slice of all elements that have not been \xe2\x80\xa6CnReturns a mutable slice of the contained value, if any. If \xe2\x80\xa6CjViews the underlying data as a mutable subslice of the \xe2\x80\xa6CmReturns the remaining items of this iterator as a mutable \xe2\x80\xa6BnExtracts a mutable slice of the entire vector.CcExtracts the raw pthread_t without taking ownership0DkStores a value if the current value is the same as the <code>old</code> \xe2\x80\xa6A`An atomic fence.DjStores the value at the specified memory location. <code>T</code> must \xe2\x80\xa6ClCompute odd binomial coefficients mod p, where p is odd. \xe2\x80\xa6BgPerforms the <code>|=</code> operation.AeCreates a new hasher.CmReturns the canonical, absolute form of the path with all \xe2\x80\xa6CkReturns the canonical, absolute form of a path with all \xe2\x80\xa6CmRust\xe2\x80\x99s \xe2\x80\x9ctry catch\xe2\x80\x9d construct for unwinding. Invokes \xe2\x80\xa6CjInvokes a closure, capturing the cause of an unwinding \xe2\x80\xa6BfClear the poisoned state from a mutex.BeClear the poisoned state from a lock.CaReports the exit code, if applicable, from an \xe2\x80\xa6CjCollects all the items from an iterator into a collection.00000CjIterates through all combinations of numbers from 0 to \xe2\x80\xa6BhConcatenates literals into a byte slice.00000BbConnects the socket to an address.CiConnects to the socket specified by <code>address</code>.DkReturns <code>true</code> if the map contains a value for the specified \xe2\x80\xa60EcCopies the sign from <code>y</code> to <code>x</code> for <code>f128</code> values.EbSets whether a <code>PidFd</code> should be created for the <code>Child</code> \xe2\x80\xa6EhLike <code>ctlz</code>, but extra-unsafe as it returns <code>undef</code> when given \xe2\x80\xa6EhLike <code>cttz</code>, but extra-unsafe as it returns <code>undef</code> when given \xe2\x80\xa6BgProvides a cursor at the front element.DjPass custom flags to the <code>flags</code> argument of <code>open</code>.0ClCreates a new pointer that is dangling, but non-null and \xe2\x80\xa6CmSpecifies whether the <code>Debug</code> trait should use \xe2\x80\xa6DbAsserts that a boolean expression is <code>true</code> at runtime.DfCreates a <code>DebugStruct</code> builder designed to assist with \xe2\x80\xa6CnCreates an iterator over the UTF-16 encoded code points in \xe2\x80\xa6ClRemoves all but the first of consecutive elements in the \xe2\x80\xa6Cjdegree shift, such that ouptut_degree = input_degree - \xe2\x80\xa600000AgDeinterleave two masks.AiDeinterleave two vectors.CcAttribute macro used to apply derive macros for \xe2\x80\xa60000CkThis returns the differential starting from the sth module.DhReturns a value uniquely identifying the enum variant in <code>v</code>.D`Forwards to the method defined on the type <code>dyn Any</code>.CnReturns some mutable reference to the inner value if it is \xe2\x80\xa6ClForwards to the method defined on the type <code>Any</code>.DbForwards to the method defined on the type <code>dyn Error</code>.021CnReturns some reference to the inner value if it is of type \xe2\x80\xa64110CjClears the binary heap, returning an iterator over the \xe2\x80\xa6ClEnsures that a child node exists at the specified index, \xe2\x80\xa6CmReturns an iterator that produces an escaped version of a \xe2\x80\xa6CnExit the current process with the given <code>ExitCode</code>.CmGiven a matrix in rref, say [A|B|C], where B lies between \xe2\x80\xa6ChFetches the value, and applies a function to it that \xe2\x80\xa600000000000ClApplies the given predicate to the items in the parallel \xe2\x80\xa6DhAn adaptor that flattens serial-iterable <code>Item</code>s into one \xe2\x80\xa6DcApplies a function to each value in the <code>TwoEndedGrove</code>.AnCreates a mask from a bitmask.EjBuild a <em>pinned mutable</em> reference to an <code>Exclusive&lt;T&gt;</code> from a \xe2\x80\xa6EaDecode a UTF-16BE\xe2\x80\x93encoded vector <code>v</code> into a <code>String</code>, \xe2\x80\xa6EaDecode a UTF-16LE\xe2\x80\x93encoded vector <code>v</code> into a <code>String</code>, \xe2\x80\xa6CmWhether the current set of differentials is inconsistent. \xe2\x80\xa6CkWhether there is an inconsistent differential involving \xe2\x80\xa6CmInserts a new key-value pair into the map in the gap that \xe2\x80\xa60CjInserts a new element into the set in the gap that the \xe2\x80\xa60DdInserts a new element into the <code>LinkedList</code> after the \xe2\x80\xa6DgSets the value of the entry, and returns an <code>OccupiedEntry</code>.DjSets the value of the entry with the <code>VacantEntry</code>\xe2\x80\x99s key, \xe2\x80\xa610CnVisits the values representing the intersection, i.e., the \xe2\x80\xa6ClVisits the elements representing the intersection, i.e., \xe2\x80\xa6DfConsumes this error, returning original <code>CString</code> which \xe2\x80\xa6CmReturns <code>true</code> if this is a broadcast address (\xe2\x80\xa6EaReturns <code>true</code> if some <code>call_once()</code> call has completed \xe2\x80\xa6CnChecks if the value is a lowercase character: 0x61 \xe2\x80\x98a\xe2\x80\x99 \xe2\x80\xa6CiReturns <code>true</code> if this is a multicast address.EdReturns <code>true</code> if this is a multicast address (<code>224.0.0.0/4</code>).EaReturns <code>true</code> if this is a multicast address (<code>ff00::/8</code>).CjChecks whether the pattern matches at the front of the \xe2\x80\xa6ClDetermines whether the character is one of the permitted \xe2\x80\xa6ClChecks if the elements of this iterator are sorted using \xe2\x80\xa600000ChReturns true for each element if its value is subnormal.0CiChecks whether the pattern matches at the back of the \xe2\x80\xa6CnChecks if the value is an uppercase character: 0x41 \xe2\x80\x98A\xe2\x80\x99\xe2\x80\xa6CdReturns the number of leading ones in the binary \xe2\x80\xa6000FcMaps <code>ControlFlow&lt;B, C&gt;</code> to <code>ControlFlow&lt;B, T&gt;</code> by applying a \xe2\x80\xa6CkReturns the ABI-required minimum alignment of a type in \xe2\x80\xa6Ammod 2 multinomial coefficientElReturn the element <code>-1</code>. If <code>p = 2</code>, this is <code>a^0 = 1</code>. \xe2\x80\xa6CjReturns the position of the nul byte in the slice that \xe2\x80\xa6CbReturns a list of out-of-order elements remaining.CiPerforms the correct padding for an integer which has \xe2\x80\xa6CnCreates a layout by rounding the size of this layout up to \xe2\x80\xa6CmThis implements the notion of a split pair algebra in the \xe2\x80\xa60CjBlocks unless or until the current thread\xe2\x80\x99s token is \xe2\x80\xa6Dddegree =&gt; max_part =&gt; list of partitions with maximum part \xe2\x80\xa60AgCreates a pattern type.CkRemoves and returns the first element from the deque if \xe2\x80\xa6DiSearches for <strong>some</strong> item in the parallel iterator that \xe2\x80\xa6EbLowers in MIR to <code>Rvalue::UnaryOp</code> with <code>UnOp::PtrMetadata</code>.CiPush an element into the vector and check that it was \xe2\x80\xa6ClQuery the user for a module and a bidegree, and return a \xe2\x80\xa6CiReturns the OS error that this error represents (if any).BhReturns the read timeout of this socket.000ClAttempts to wait for a value on this receiver, returning \xe2\x80\xa60ClRemoves a key from the map, returning the stored key and \xe2\x80\xa60CeTake the ownership of the key and value from the map.CaTake ownership of the key and value from the map.CgReplaces the rightmost occurrence of a pattern with \xe2\x80\xa6DkReplaces the wrapped value with a new one computed from <code>f</code>, \xe2\x80\xa6CjReverses the order of bits in each elemnent. The least \xe2\x80\xa6000ChReverses the order of bits in the integer. The least \xe2\x80\xa600000000000BhReverses the bit pattern of the integer.00000000000000000000000AfPerforms rotate right.DgShifts the bits to the right by a specified amount, <code>n</code>, \xe2\x80\xa600000000000000000000000000000000000DbRotates the double-ended queue <code>n</code> places to the right.DeA version of <code>Matrix::row_op</code> without the zero assumption.D`Returns <code>true</code> if senders belong to the same channel.DbReturns <code>true</code> if receivers belong to the same channel.CmWaits for a message to be sent into the channel, but only \xe2\x80\xa6CeSends data on the socket to the specified SocketAddr.BcSet the last access time of a file.ClChanges the flow information associated with this socket \xe2\x80\xa6CeChanges the modification time of the underlying file.BeSet the last modified time of a file.CiEnable or disable socket option <code>SO_PASSCRED</code>.BaSets the position of this cursor.BlEnable or disable <code>TCP_QUICKACK</code>.CnModifies the readonly flag for this set of permissions. If \xe2\x80\xa6CiChanges the scope ID associated with this socket address.BiTruncates an integer vector to a bitmask.BbExtracts an element from a vector.AoWrites to a vector of pointers.BfShuffles two vectors by const indices.CiConstructs a new SIMD vector by copying elements from \xe2\x80\xa60CaGets a pointer to the first element of the array.DjGiven a vector that represents an element in degree <code>degree</code>\xe2\x80\xa6CmSpawns a new scoped thread using the settings set through \xe2\x80\xa6DiInserts the elements from the given <code>LinkedList</code> after the \xe2\x80\xa6CmSplits the list into two before the current element. This \xe2\x80\xa6ChMutably borrows <code>x[i]</code> and <code>x[j]</code>.DfConditionally write contiguous elements to <code>slice</code>. The \xe2\x80\xa6EbReturns a path that, when joined onto <code>base</code>, yields <code>self</code>.DaGets the number of strong (<code>Arc</code>) pointers to this \xe2\x80\xa6DjGets the number of strong (<code>Arc</code>) pointers pointing to this \xe2\x80\xa6DhGets the number of strong (<code>Rc</code>) pointers to this allocation.DiGets the number of strong (<code>Rc</code>) pointers pointing to this \xe2\x80\xa6DaReturns the fractional part of this <code>Duration</code>, in \xe2\x80\xa6CjCreates a new mask from the elements of <code>mask</code>.BkCreates a new synchronous, bounded channel.0CbDeclare a new thread local storage key of type \xe2\x80\xa6DcConverts this address to an <code>IpAddr::V4</code> if it is an \xe2\x80\xa60CgMakes a copy of the value in its lower case equivalent.CeCopies the slice into an owned <code>OsString</code>.CmDecompose a (possibly wide) pointer into its data pointer \xe2\x80\xa6CgMakes a copy of the value in its upper case equivalent.CfEnables or disables tracing functionality used for \xe2\x80\xa600000DdExecutes a fallible <code>OP</code> on each item produced by the \xe2\x80\xa6CjAn iterator method that applies a fallible function to \xe2\x80\xa600000CiReturns difference as a bidegree if the difference in \xe2\x80\xa6BiUnstable placeholder for type ascription.0000ClComputes the absolute value of self without any wrapping \xe2\x80\xa600000CjThe intrinsic will return the alignment stored in that \xe2\x80\xa6ChWaits on this condition variable for a notification, \xe2\x80\xa60CnSets the maximum length of iterators desired to process in \xe2\x80\xa6CnSets the minimum length of iterators desired to process in \xe2\x80\xa6ChCreates a new formatter based on this one with given \xe2\x80\xa6CnWrapping absolute value, see <code>isize::wrapping_abs</code>.CmWrapping absolute value, see <code>i128::wrapping_abs</code>.CkWrapping absolute value, see <code>i8::wrapping_abs</code>.ClWrapping absolute value, see <code>i64::wrapping_abs</code>.ClWrapping absolute value, see <code>i32::wrapping_abs</code>.ClWrapping absolute value, see <code>i16::wrapping_abs</code>.CjReturns (a + b) mod 2N, where N is the width of T in bits.CgCalculates the offset from a pointer using wrapping \xe2\x80\xa6000CjReturns (a * b) mod 2N, where N is the width of T in bits.AbWrapping negation.0DfWrapping (modular) negation. Computes <code>-self</code>, wrapping \xe2\x80\xa600000CjReturns (a - b) mod 2N, where N is the width of T in bits.4444ClAttempts to write an entire buffer starting from a given \xe2\x80\xa60CjThe algebra with trivial profile, corresponding to the \xe2\x80\xa6BgAn entity already exists, often a file.CiThis enum represent one control message of variable type.C`A trait for dealing with asynchronous iterators.CcThe number of bits each <code>Limb</code> occupies.DkA range of bidegrees, corresponding to all <code>s</code> up to a given \xe2\x80\xa6DbFuture returned by <code>AsyncFnMut::async_call_mut</code> and \xe2\x80\xa600000BnEmits a <code>CastKind::Transmute</code> cast.A`A chain homotopyCoTypes for which cloning <code>Cell&lt;Self&gt;</code> is sound.DeA generalization of <code>Clone</code> to dynamically-sized types \xe2\x80\xa6CmDerive macro that makes a smart pointer usable with trait \xe2\x80\xa6ClTrait that indicates that this is a pointer or a wrapper \xe2\x80\xa6DgA marker for types which can be used as types of <code>const</code> \xe2\x80\xa6CiSpecifies the file extension, if any, used for shared \xe2\x80\xa6DaThe default <code>Hasher</code> used by <code>RandomState</code>.0ChUnix-specific extensions to <code>fs::DirBuilder</code>.CmSpecifies the file extension, if any, used for executable \xe2\x80\xa6DgAn iterator that yields the literal escape code of a <code>char</code>.CdThe return type of <code>str::escape_default</code>.BoAn iterator over the escaped version of a byte.CkReturns an iterator that yields the hexadecimal Unicode \xe2\x80\xa6CdThe return type of <code>str::escape_unicode</code>.DdUnix-specific extensions to <code>process::ExitStatus</code> and \xe2\x80\xa60i1/sqrt(2)000i1/sqrt(3)000BeInternal methods required for fields.ChAn iterator over the values yielded by an underlying \xe2\x80\xa6DgA possible error value when converting a <code>String</code> from a \xe2\x80\xa6DeAn iterator that always continues to yield <code>None</code> when \xe2\x80\xa6CnWhether the composite can hit generators. This is true for \xe2\x80\xa6BbThe type of the resulting iteratorBiBy-value <code>RangeFrom</code> iterator.CdUnix-specific extensions to <code>JoinHandle</code>.0CmThe maximum number of two-byte units required to encode a \xe2\x80\xa6DoA version of <code>HashMap&lt;MilnorBasisElement, T&gt;</code> that is more \xe2\x80\xa6CfA filesystem object is, unexpectedly, not a directory.DjA view into an occupied entry in a <code>HashMap</code>. It is part of \xe2\x80\xa6DjA view into an occupied entry in a <code>HashSet</code>. It is part of \xe2\x80\xa6DkA view into an occupied entry in a <code>BTreeMap</code>. It is part of \xe2\x80\xa6DkA view into an occupied entry in a <code>BTreeSet</code>. It is part of \xe2\x80\xa6DfThe error returned by <code>try_insert</code> when the key already \xe2\x80\xa60Dk<code>OneSidedRange</code> is implemented for built-in range types that \xe2\x80\xa60BmA struct providing information about a panic.CgAn error which can be returned when parsing an integer.CjA marker type which does not implement <code>Unpin</code>.CjFilesystem quota or some other kind of quota was exceeded.fU+0022CdCreated with the method <code>rmatch_indices</code>.BbA re-entrant mutual exclusion lockCnA marker trait representing types where a shared reference \xe2\x80\xa6BlLogic that is common to all secondary lifts.B`Parallel <code>PartialEq</code>.0ChPlatform-specific extensions to <code>SocketAddr</code>.BfType returned by String and str types.CmA trait for objects which can be converted or resolved to \xe2\x80\xa6DcMarks that <code>Src</code> is transmutable into <code>Self</code>.ChA type alias for the result of a nonblocking locking \xe2\x80\xa600CmA bidirectional sparse vector that supports both positive \xe2\x80\xa6CnAn error returned when an operation could not be completed \xe2\x80\xa6DaLinux-specific functionality for <code>AF_UNIX</code> sockets \xe2\x80\xa6CnAn unwind action that continues execution in a given basic \xe2\x80\xa6AnFalse (ordered, non-signaling)AjFalse (ordered, signaling)eEqualAbLess-than-or-equaliLess-thaniNot-equalBgSee <code>_MM_GET_EXCEPTION_MASK</code>DiThe <code>MM_PERM_ENUM</code> type used to specify shuffle operations \xe2\x80\xa6BfTransaction abort due to a debug trap.AnTransaction retry is possible.DhReturns the result of the <code>cpuid</code> instruction for a given \xe2\x80\xa6EgAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit \xe2\x80\xa6EgAdds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit \xe2\x80\xa6ClConvert 8-bit mask a to a 32-bit integer value and store \xe2\x80\xa6CmConvert 32-bit integer value a to an 8-bit mask and store \xe2\x80\xa6CjCompute the bitwise NOT of 16-bit masks a and then AND \xe2\x80\xa6CjCompute the bitwise NOT of 32-bit masks a and then AND \xe2\x80\xa6CjCompute the bitwise NOT of 64-bit masks a and then AND \xe2\x80\xa6CiCompute the bitwise XNOR of 16-bit masks a and b, and \xe2\x80\xa6CiCompute the bitwise XNOR of 32-bit masks a and b, and \xe2\x80\xa6CiCompute the bitwise XNOR of 64-bit masks a and b, and \xe2\x80\xa6CjFinds the absolute value of each packed half-precision \xe2\x80\xa6ChAdds packed double-precision (64-bit) floating-point \xe2\x80\xa6CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa6ChAdds packed single-precision (32-bit) floating-point \xe2\x80\xa6CiComputes the bitwise AND of a packed double-precision \xe2\x80\xa6CgComputes the bitwise AND of packed single-precision \xe2\x80\xa6ClCompares packed double-precision (64-bit) floating-point \xe2\x80\xa6ClCompares packed single-precision (32-bit) floating-point \xe2\x80\xa6ChComputes the division of each of the 4 packed 64-bit \xe2\x80\xa6ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa6ChComputes the division of each of the 8 packed 32-bit \xe2\x80\xa64CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa64504CnMultiplies packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6CnMultiplies packed single-precision (32-bit) floating-point \xe2\x80\xa6CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa6CaComputes the approximate reciprocal of packed \xe2\x80\xa6ChSets packed double-precision (64-bit) floating-point \xe2\x80\xa6CnSet packed half-precision (16-bit) floating-point elements \xe2\x80\xa6ChSets packed single-precision (32-bit) floating-point \xe2\x80\xa6CmSubtracts packed double-precision (64-bit) floating-point \xe2\x80\xa6CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa6CmSubtracts packed single-precision (32-bit) floating-point \xe2\x80\xa6CgComputes the bitwise XOR of packed double-precision \xe2\x80\xa6CgComputes the bitwise XOR of packed single-precision \xe2\x80\xa6ClFinds the absolute value of each packed double-precision \xe2\x80\xa6CjFinds the absolute value of each packed half-precision \xe2\x80\xa6ClFinds the absolute value of each packed single-precision \xe2\x80\xa6CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa6CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa6CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa6CfCompute the bitwise AND of packed double-precision \xe2\x80\xa6CfCompute the bitwise AND of packed single-precision \xe2\x80\xa6CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa6ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa6CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6210ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa6CgSet packed double-precision (64-bit) floating-point \xe2\x80\xa6CnSet packed half-precision (16-bit) floating-point elements \xe2\x80\xa6DeSets packed 32-bit integers in <code>dst</code> with the supplied \xe2\x80\xa6ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa6CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa6ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa6CfCompute the bitwise XOR of packed double-precision \xe2\x80\xa6CfCompute the bitwise XOR of packed single-precision \xe2\x80\xa6ClComputes the absolute value of each of the packed 16-bit \xe2\x80\xa6ClComputes the absolute value of each of the packed 32-bit \xe2\x80\xa6CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa6DaAdds packed 16-bit integers in <code>a</code> and <code>b</code>.DaAdds packed 32-bit integers in <code>a</code> and <code>b</code>.DaAdds packed 64-bit integers in <code>a</code> and <code>b</code>.EaAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.EbAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using \xe2\x80\xa6CjAlternatively add and subtract packed double-precision \xe2\x80\xa6CjAlternatively add and subtract packed single-precision \xe2\x80\xa6CnComputes the bitwise AND of 128 bits (representing integer \xe2\x80\xa6DlComputes the bitwise NOT of <code>a</code> and then AND with <code>b</code>.CgBitwise AND-NOT of packed single-precision (32-bit) \xe2\x80\xa6DnAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.CiBlend packed double-precision (64-bit) floating-point \xe2\x80\xa6CiBlend packed single-precision (32-bit) floating-point \xe2\x80\xa6DoCast vector of type <code>__m128d</code> to type <code>__m128h</code>. This \xe2\x80\xa6DkCasts a 128-bit floating-point vector of <code>[2 x double]</code> into \xe2\x80\xa6DoCast vector of type <code>__m128h</code> to type <code>__m128d</code>. This \xe2\x80\xa6EhCast vector of type <code>__m128h</code> to type <code>__m128</code>. This intrinsic \xe2\x80\xa6DjCasts a 128-bit floating-point vector of <code>[4 x float]</code> into \xe2\x80\xa6EhCast vector of type <code>__m128</code> to type <code>__m128h</code>. This intrinsic \xe2\x80\xa6EcCompares corresponding elements in <code>a</code> and <code>b</code> for not-equal.DkCompares each of the four floats in <code>a</code> to the corresponding \xe2\x80\xa6DkReturns a new vector with the low element of <code>a</code> replaced by \xe2\x80\xa6DkCompares the lowest <code>f32</code> of both inputs for inequality. The \xe2\x80\xa6DlCompares corresponding elements in <code>a</code> and <code>b</code> for \xe2\x80\xa632CkCompares the lowest <code>f32</code> of both inputs for \xe2\x80\xa614301430143DjCompares the lowest <code>f32</code> of both inputs for not-less-than. \xe2\x80\xa6EbCompares corresponding elements in <code>a</code> and <code>b</code> to see if \xe2\x80\xa665DiChecks if the lowest <code>f32</code> of both inputs are ordered. The \xe2\x80\xa6DmCompares the lower element of <code>a</code> and <code>b</code> for equality.ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6DhCompares two 32-bit floats from the low-order bits of <code>a</code> \xe2\x80\xa6DgCompares the lower element of <code>a</code> and <code>b</code> for \xe2\x80\xa621EaCompares the lower element of <code>a</code> and <code>b</code> for greater-than.32132DnCompares the lower element of <code>a</code> and <code>b</code> for less-than.43DcStarting with the initial value in <code>crc</code>, return the \xe2\x80\xa600BfAlias for <code>_mm_cvtsi32_ss</code>.BfAlias for <code>_mm_cvtss_si32</code>.CmConvert the signed 32-bit integer b to a double-precision \xe2\x80\xa6CkConvert the signed 32-bit integer b to a half-precision \xe2\x80\xa6CmConvert the signed 32-bit integer b to a single-precision \xe2\x80\xa6CmConvert the signed 64-bit integer b to a double-precision \xe2\x80\xa6CkConvert the signed 64-bit integer b to a half-precision \xe2\x80\xa6CmConvert the signed 64-bit integer b to a single-precision \xe2\x80\xa6CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa6CmConverts a single BF16 (16-bit) floating-point element in \xe2\x80\xa6CnReturns the lower double-precision (64-bit) floating-point \xe2\x80\xa6CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa6000ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa6000CgExtracts the lowest 32 bit float from the input vector.CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa6000BnConvert the unsigned 32-bit integer b to a \xe2\x80\xa6CmConvert the unsigned 32-bit integer b to a half-precision \xe2\x80\xa61BnConvert the unsigned 64-bit integer b to a \xe2\x80\xa6CmConvert the unsigned 64-bit integer b to a half-precision \xe2\x80\xa61CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa6CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa6CnMultiplies packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6CnMultiplies packed single-precision (32-bit) floating-point \xe2\x80\xa6CbMultiplies the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6CbMultiplies the lower single-precision (32-bit) \xe2\x80\xa6543210ChConvert the exponent of each packed double-precision \xe2\x80\xa6CfConvert the exponent of each packed half-precision \xe2\x80\xa6ChConvert the exponent of each packed single-precision \xe2\x80\xa6CfConvert the exponent of the lower double-precision \xe2\x80\xa6CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa6CfConvert the exponent of the lower single-precision \xe2\x80\xa6EhSelect a single value in <code>b</code> to store at some position in <code>a</code>, \xe2\x80\xa6CkLoad internal wrapping key (IWKey). The 32-bit unsigned \xe2\x80\xa6EeCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns \xe2\x80\xa6EeCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns \xe2\x80\xa6CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa6EfCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and \xe2\x80\xa6EfCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and \xe2\x80\xa6CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa6543210EoCombine higher half of <code>a</code> and <code>b</code>. The higher half of <code>b</code> \xe2\x80\xa6EmCombine lower half of <code>a</code> and <code>b</code>. The lower half of <code>b</code> \xe2\x80\xa6CkSet each packed 8-bit integer in dst to all ones or all \xe2\x80\xa6CnMultiplies the low 32-bit integers from each packed 64-bit \xe2\x80\xa6CiMultiplies the low unsigned 32-bit integers from each \xe2\x80\xa6CkExtract the reduced argument of packed double-precision \xe2\x80\xa6CiExtract the reduced argument of packed half-precision \xe2\x80\xa6CkExtract the reduced argument of packed single-precision \xe2\x80\xa6CnExtract the reduced argument of the lower double-precision \xe2\x80\xa6ClExtract the reduced argument of the lower half-precision \xe2\x80\xa6CnExtract the reduced argument of the lower single-precision \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6200ChBroadcasts 8-bit integer <code>a</code> to all elements.CeSets packed 16-bit integers with the supplied values.CeSets packed 32-bit integers with the supplied values.CjSets packed 8-bit integers with the supplied values in \xe2\x80\xa6DjNegates packed 8-bit integers in <code>a</code> when the corresponding \xe2\x80\xa6EdShifts packed 16-bit integers in <code>a</code> left by <code>count</code> while \xe2\x80\xa6EdShifts packed 32-bit integers in <code>a</code> left by <code>count</code> while \xe2\x80\xa6EdShifts packed 64-bit integers in <code>a</code> left by <code>count</code> while \xe2\x80\xa6EeShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while \xe2\x80\xa6EeShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while \xe2\x80\xa6CjShift packed 64-bit integers in a right by count while \xe2\x80\xa621EeShifts packed 64-bit integers in <code>a</code> right by <code>count</code> while \xe2\x80\xa6CmStores the lower double-precision (64-bit) floating-point \xe2\x80\xa6DhStores the lowest 32 bit float of <code>a</code> repeated four times \xe2\x80\xa61BdAlias for <code>_mm_store1_ps</code>CcStores the upper 64 bits of a 128-bit vector of \xe2\x80\xa6CcStores the lower 64 bits of a 128-bit vector of \xe2\x80\xa6CnStores 2 double-precision (64-bit) floating-point elements \xe2\x80\xa6DeStores four 32-bit floats into <em>aligned</em> memory in reverse \xe2\x80\xa6CjStores 128-bits (composed of 2 packed double-precision \xe2\x80\xa6CgStore 128-bits (composed of 8 packed half-precision \xe2\x80\xa6CgStores four 32-bit floats into memory. There are no \xe2\x80\xa6DjStores a 128-bit floating point vector of <code>[2 x double]</code> to \xe2\x80\xa6EgStores <code>a</code> into the memory at <code>mem_addr</code> using a non-temporal \xe2\x80\xa6CkNon-temporal store of <code>a.0</code> into <code>p</code>.0DiSubtracts packed 16-bit integers in <code>b</code> from packed 16-bit \xe2\x80\xa6DhSubtract packed 32-bit integers in <code>b</code> from packed 32-bit \xe2\x80\xa6DhSubtract packed 64-bit integers in <code>b</code> from packed 64-bit \xe2\x80\xa6DfSubtract packed 8-bit integers in <code>b</code> from packed 8-bit \xe2\x80\xa6DiSubtract packed unsigned 8-bit integers in <code>b</code> from packed \xe2\x80\xa6CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa6CnComputes the bitwise XOR of 128 bits (representing integer \xe2\x80\xa6AkStore 16-bit mask to memoryBeStore 32-bit mask from a into memory.BeStore 64-bit mask from a into memory.ChRelease the tile configuration to return to the init \xe2\x80\xa6CgAdd composites up to and including the specified degreeCoAppend <code>self.extension</code> with <code>extension</code>.ChReturns the number of milliseconds contained by this \xe2\x80\xa60DfYields a mutable reference to the underlying <code>OsStr</code> slice.CiReturns a pair of slices which contain, in order, the \xe2\x80\xa6CkViews the underlying data as a pair of subslices of the \xe2\x80\xa6ClReturns a unique references to the value. In contrast to \xe2\x80\xa6ClReturns a shared references to the value. In contrast to \xe2\x80\xa6DjBinary searches this <code>VecDeque</code> for a given element. If the \xe2\x80\xa6CkCompute binomial coefficients mod 4 using the recursion \xe2\x80\xa6BkPerforms the <code>&amp;=</code> operation.BgPerforms the <code>^=</code> operation.CiReturns the number of 64 x 64 block columns in this tile.DdReturns the bit pattern of <code>self</code> reinterpreted as an \xe2\x80\xa600000DcLexicographically compare <code>[left, left + bytes)</code> and \xe2\x80\xa6CkCauses compilation to fail with the given error message \xe2\x80\xa600000D`Computes basis elements up to and including <code>degree</code>.0ClCompute internal data of the module so that we can query \xe2\x80\xa601CkComputes the quasi-inverse of a matrix given a rref of [\xe2\x80\xa6DeWrites a SIMD vector to the first <code>N</code> elements of a slice.BlProvide a list of type aliases and other \xe2\x80\xa60000CdThis prints all the differentials in the resolution.Bdx -&gt; y -&gt; r -&gt; differential0CiExecutes the destructor (if any) of the pointed-to value.0DhCreates a layout describing the record for <code>self</code> followed byDkOffsets the pointer\xe2\x80\x99s address by adding <code>val</code> (in units of \xe2\x80\xa6DgOffsets the pointer\xe2\x80\x99s address by subtracting <code>val</code> (in \xe2\x80\xa6CkReturns the name of the source file as a nul-terminated \xe2\x80\xa6DiReturns a reference to the underlying <code>OsStr</code> of this entry\xe2\x80\xa6ClApplies the given predicate to the items in the parallel \xe2\x80\xa6CkFind the index and value of the first non-zero entry of \xe2\x80\xa6DkApplies <code>map_op</code> to each item of this iterator to get nested \xe2\x80\xa6EdExecutes <code>OP</code> on a value returned by <code>init</code> with each item \xe2\x80\xa6E`Executes <code>OP</code> on the given <code>init</code> value with each item \xe2\x80\xa6CmProduces layout describing a record that could be used to \xe2\x80\xa6CeForcibly captures a full backtrace, regardless of \xe2\x80\xa6CnCreates an integer value from its representation as a byte \xe2\x80\xa60CiCreates a native endian integer value from its memory \xe2\x80\xa6CeConstructs a box from a <code>NonNull</code> pointer.EjCreates a <code>Vec&lt;T, A&gt;</code> directly from a <code>NonNull</code> pointer, a \xe2\x80\xa6EcConstructs a <code>SockAddr</code> with the family <code>AF_UNIX</code> and the \xe2\x80\xa6DaConstructs the type from a compatible <code>Residual</code> type.DdCreates a new <code>Duration</code> from the specified number of \xe2\x80\xa60DdCreates an <code>Ipv6Addr</code> from an eight element 16-bit array.CiConverts a mutable slice of bytes to a mutable string \xe2\x80\xa6DhReads from indices in <code>slice</code> to construct a SIMD vector. \xe2\x80\xa6BhReturns the current <code>#</code> flag.CdThe dimension in a bidegree, None if not yet definedClReturns the key-value pair corresponding to the supplied \xe2\x80\xa60DeGets non-atomic access to a <code>&amp;mut [AtomicBool]</code> slice.DdGets non-atomic access to a <code>&amp;mut [AtomicPtr]</code> slice.DaGet non-atomic access to a <code>&amp;mut [AtomicI8]</code> sliceDaGet non-atomic access to a <code>&amp;mut [AtomicU8]</code> sliceDbGet non-atomic access to a <code>&amp;mut [AtomicI16]</code> sliceDbGet non-atomic access to a <code>&amp;mut [AtomicU16]</code> sliceDbGet non-atomic access to a <code>&amp;mut [AtomicI32]</code> sliceDbGet non-atomic access to a <code>&amp;mut [AtomicU32]</code> sliceDbGet non-atomic access to a <code>&amp;mut [AtomicI64]</code> sliceDbGet non-atomic access to a <code>&amp;mut [AtomicU64]</code> sliceDdGet non-atomic access to a <code>&amp;mut [AtomicIsize]</code> sliceDdGet non-atomic access to a <code>&amp;mut [AtomicUsize]</code> sliceEgInserts <code>value</code> into the option if it is <code>None</code>, then returns \xe2\x80\xa6DkInserts the given <code>value</code> into the set if it is not present, \xe2\x80\xa60AnReturns the current precision.BcThis panics if there is no save dirCmRetrieves a reference to the value at the specified index \xe2\x80\xa6fSafetyCmReturns a pointer to the output at this location, without \xe2\x80\xa6CiChecks if there is any data left to be <code>read</code>.0BdComputes the signature of an elementBoIncludes a file as a reference to a byte array.00000CmInserts a new key-value pair into the map in the gap that \xe2\x80\xa60CjInserts a new element into the set in the gap that the \xe2\x80\xa60DeInserts a new element into the <code>LinkedList</code> before the \xe2\x80\xa6DmConverts a Box&lt;CStr&gt; into a <code>CString</code> without copying or \xe2\x80\xa6CiTurn this into an iterator over the connections being \xe2\x80\xa6E`Consumes the <code>Box</code>, returning a wrapped <code>NonNull</code> pointer.EjConverts a <code>Box&lt;Path&gt;</code> into a <code>PathBuf</code> without copying or \xe2\x80\xa6DeConstructs the associated searcher from <code>self</code> and the \xe2\x80\xa6CmReturns whether the pointer is aligned to <code>align</code>.BoChecks if the value is an alphabetic character:EeReturns <code>true</code> if the address is link-local (<code>169.254.0.0/16</code>).CnChecks if the value is a whitespace character: 0x20 SPACE, \xe2\x80\xa6CgReturns an iterator over the element\xe2\x80\x99s decomposition.CiReturns an error representing the last OS error which \xe2\x80\xa6CeReturns the number of leading zeros in the binary \xe2\x80\xa6000000000000000000000000000000000000000CcConstructs a new pin by mapping the interior value.CjReturns minimum and maximum values with respect to the \xe2\x80\xa6DnConstructs a new <code>Arc&lt;T, A&gt;</code> in the given allocator while \xe2\x80\xa6DmConstructs a new <code>Rc&lt;T, A&gt;</code> in the given allocator while \xe2\x80\xa6BnCreates an iterator over the elements in a \xe2\x80\xa6E`Constructs a new <code>Pin&lt;Ptr&gt;</code> around a reference to some data \xe2\x80\xa6BcCreates a new <code>NonNull</code>.DiCreates an <code>Alignment</code> from a power-of-two <code>usize</code>.ClCreates a non-zero without checking whether the value is \xe2\x80\xa6DhConstructs a new <code>Arc</code> with uninitialized contents in the \xe2\x80\xa6CkConstructs a new box with uninitialized contents in the \xe2\x80\xa6DgConstructs a new <code>Rc</code> with uninitialized contents in the \xe2\x80\xa6DeCreates a <code>SipHasher</code> that is keyed off the provided keys.DkConstructs a new <code>Arc</code> with uninitialized contents, with the \xe2\x80\xa6DkConstructs a new <code>Box</code> with uninitialized contents, with the \xe2\x80\xa6DjConstructs a new <code>Rc</code> with uninitialized contents, with the \xe2\x80\xa6CiAttempts to open a file in read-only mode with buffering.CmPartitions and maps the items of a parallel iterator into \xe2\x80\xa6ChGets the physical number of rows allocated (for BLAS \xe2\x80\xa6DlSearches for the sequentially <strong>last</strong> item in the parallel \xe2\x80\xa6CjSets the process group ID (PGID) of the child process. \xe2\x80\xa60CjProvides a value or other type with only static lifetimes.ChAdds an element to the back of the list, returning a \xe2\x80\xa6ClAppends an element to the back of the deque, returning a \xe2\x80\xa6DeFind the differential that hits <code>value</code>, and write the \xe2\x80\xa6DjReads the exact number of bytes required to fill <code>buf</code> from \xe2\x80\xa60DeLike <code>read</code>, except that it reads into a slice of buffers.00DiThis is an implementation detail of <code>crate::ptr::read</code> and \xe2\x80\xa6DgPerforms a volatile read of the value from <code>src</code> without \xe2\x80\xa6DhPerforms a volatile read of the value from <code>self</code> without \xe2\x80\xa6ClAttempts to wait for a value on this receiver, returning \xe2\x80\xa60ClGiven a subspace of the target space, project the target \xe2\x80\xa6DjCreates a layout describing the record for <code>n</code> instances of \xe2\x80\xa6CnReplaces the leftmost occurrence of a pattern with another \xe2\x80\xa6CnRemoves the specified range in the string, and replaces it \xe2\x80\xa6DoRequests a value of type <code>T</code> from the given <code>impl Error</code>.DkReserves the minimum capacity for at least <code>additional</code> more \xe2\x80\xa6DdInvokes <code>reserve_exact</code> on the underlying instance of \xe2\x80\xa61DfReserves the minimum capacity for at least <code>additional</code> \xe2\x80\xa620CaTriggers a panic without invoking the panic hook.CdThe value of the SECONDARY_JOB environment variable.BgSeeks relative to the current position.CfSeeks relative to the current position. If the new \xe2\x80\xa611CmWaits for a message to be sent into the channel, but only \xe2\x80\xa6DgSets the value of the <code>SO_BROADCAST</code> option for this socket.CnThis can only be set when bidegrees to the left and bottom \xe2\x80\xa6FbUpdates <code>self.extension</code> to <code>Some(extension)</code> or to <code>None</code> if \xe2\x80\xa6CnUpdates <code>self.file_name</code> to <code>file_name</code>.BlSets the subspace to be the entire subspace.BhSets the value of the specified element.DfShrinks the capacity of the <code>OsString</code> to match its length.DdInvokes <code>shrink_to_fit</code> on the underlying instance of \xe2\x80\xa6CgShrinks the capacity of the vector as much as possible.CkShrinks the capacity of the map as much as possible. It \xe2\x80\xa6CaDiscards as much additional capacity as possible.CkShrinks the capacity of the set as much as possible. It \xe2\x80\xa6CfShrinks the capacity of the deque as much as possible.DeShrinks the capacity of this <code>String</code> to match its length.AkCasts a vector of pointers.DjInserts the elements from the given <code>LinkedList</code> before the \xe2\x80\xa6ClReturns the last access time of the file, in nanoseconds \xe2\x80\xa6CgReturns the last status change time of the file, in \xe2\x80\xa6CfReturns the last modification time of the file, in \xe2\x80\xa6D`Returns the bounds on the number of <em>successor</em> steps \xe2\x80\xa60DgReturns the fractional part of this <code>Duration</code>, in whole \xe2\x80\xa60CgThe generators of the subspace part of the subquotient.CeReturns the number of trailing ones in the binary \xe2\x80\xa6000DhPerforms a fallible parallel fold with a cloneable <code>init</code> \xe2\x80\xa6CaAttempts to set the value at the specified index.CmReturns the result of an unchecked addition, resulting in \xe2\x80\xa6CjAdds an unsigned integer to a non-zero value, assuming \xe2\x80\xa600000CjPerforms an unchecked division, resulting in undefined \xe2\x80\xa6CfReturns the result of an unchecked multiplication, \xe2\x80\xa6CgMultiplies two non-zero integers together, assuming \xe2\x80\xa600000000000CmReturns the remainder of an unchecked division, resulting \xe2\x80\xa6ClPerforms an unchecked left shift, resulting in undefined \xe2\x80\xa6CmPerforms an unchecked right shift, resulting in undefined \xe2\x80\xa6CmReturns the result of an unchecked subtraction, resulting \xe2\x80\xa6ClIndicates unimplemented code by panicking with a message \xe2\x80\xa6ClBypasses Rust\xe2\x80\x99s normal memory-initialization checks by \xe2\x80\xa6CjOperators used to turn types into unsafe binders and back.CaUnwrap an unsafe binder into its underlying type.DgReturns the number of variants of the type <code>T</code> cast to a \xe2\x80\xa6CoReturns the number of variants in the enum type <code>T</code>.CkPerforms a volatile load from the <code>src</code> pointer.CjThis creates a PPartAllocation with enough capacity to \xe2\x80\xa6DeCreates a new <code>OsString</code> with at least the given capacity.DkCreates a new <code>PathBuf</code> with a given capacity used to create \xe2\x80\xa6EaConstructs a new, empty <code>Vec&lt;T&gt;</code> with at least the specified \xe2\x80\xa6DeCreates an empty <code>HashMap</code> with at least the specified \xe2\x80\xa6DhCreates an empty <code>BinaryHeap</code> with at least the specified \xe2\x80\xa6DeCreates an empty <code>HashSet</code> with at least the specified \xe2\x80\xa6DhCreates an empty deque with space for at least <code>capacity</code> \xe2\x80\xa6DkCreates a new <code>BufReader&lt;R&gt;</code> with the specified buffer \xe2\x80\xa6DmCreates a new <code>BufWriter&lt;W&gt;</code> with at least the specified \xe2\x80\xa6DeCreates a new <code>LineWriter</code> with at least the specified \xe2\x80\xa6DgCreates a new empty <code>String</code> with at least the specified \xe2\x80\xa6CgInternal method used to define the behavior of this \xe2\x80\xa6BiReturns the write timeout of this socket.000CmAn error which can be returned when parsing an IP address \xe2\x80\xa6ClThe error type which is returned from parsing the type a \xe2\x80\xa6CnA type for atomic ordering parameters for intrinsics. This \xe2\x80\xa6BiThe quasi-inverse of the augmentation mapCdThe number of bytes each <code>Limb</code> occupies.AnA single frame of a backtrace.CkThe configuration for whether and how the default panic \xe2\x80\xa6CmA structure that makes it efficient to convert between an \xe2\x80\xa6CjAn error returned by <code>RefCell::try_borrow_mut</code>.DgA writeable view of the unfilled portion of a <code>BorrowedBuf</code>.CmFuture returned by <code>AsyncFnOnce::async_call_once</code>.00000fU+000DClIn addition to checking the checksum, we also keep track \xe2\x80\xa6CiAn iterator over a slice in (non-overlapping) mutable \xe2\x80\xa6DdA Builder used to construct a <code>Context</code> instance with \xe2\x80\xa6BeThe result of a coroutine resumption.CgCross-device or cross-filesystem (hard) link or rename.fU+0010j1/sqrt(\xcf\x80)000j2/sqrt(\xcf\x80)000CkLoop in the filesystem or IO subsystem; often, too many \xe2\x80\xa6DgA possible error value when converting a <code>String</code> from a \xe2\x80\xa6AfInterface-Local scope.DjAn error returned by <code>BufWriter::into_inner</code> which combines \xe2\x80\xa6DdThe error type for operations on the <code>PATH</code> variable. \xe2\x80\xa6fU+000BClThe primary separator of path components for the current \xe2\x80\xa6EfAn error returned from <code>Path::normalize_lexically</code> if a <code>..</code> \xe2\x80\xa6CiUnix-specific extensions to <code>fs::OpenOptions</code>.0EdAn error returned when parsing a <code>bool</code> using <code>from_str</code> failsCcAn error which can be returned when parsing a char.CiUnix-specific extensions to <code>fs::Permissions</code>.0CdA quotient of a module truncated below a fix degree.0DgA range bounded inclusively below and above (<code>start..=end</code>).0DhA range bounded inclusively below and above (<code>start..=last</code>).ClA virtual function pointer table (vtable) that specifies \xe2\x80\xa6fU+005CBoThis control message contains unix credentials.BaParallel <code>PartialOrd</code>.0CnA field element, stored as the exponent of a distinguished \xe2\x80\xa6CiAn iterator over subslices separated by elements that \xe2\x80\xa6CnAn iterator over the substrings of a string, terminated by \xe2\x80\xa6CfThe range is bounded inclusively from below and is \xe2\x80\xa6fU+0001Bo<code>UnsafeCell</code>, but <code>Sync</code>.BjAn unwind action that continues unwinding.C`The possible states of a <code>WriteOnce</code>.BmError returned for the buffered data from \xe2\x80\xa6AfNot less-than-or-equalmNot less-thanAkSee <code>_mm_setcsr</code>BfSee <code>_MM_GET_ROUNDING_MODE</code>Bo<strong>Mask only</strong>: return the bit maskC`Transaction abort in a inner nested transaction.EgAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit \xe2\x80\xa6EgAdds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit \xe2\x80\xa6EgReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>\xe2\x80\xa6CnConvert 16-bit mask a into an integer value, and store the \xe2\x80\xa6CnConvert 32-bit mask a into an integer value, and store the \xe2\x80\xa6CnConvert 64-bit mask a into an integer value, and store the \xe2\x80\xa6CnConvert 32-bit integer value a to an 16-bit mask and store \xe2\x80\xa6CnConvert integer value a into an 32-bit mask, and store the \xe2\x80\xa6CnConvert integer value a into an 64-bit mask, and store the \xe2\x80\xa6CjRounds packed double-precision (64-bit) floating point \xe2\x80\xa6CjRounds packed single-precision (32-bit) floating point \xe2\x80\xa6CiCopy the lower half-precision (16-bit) floating-point \xe2\x80\xa6CkHorizontal addition of adjacent pairs in the two packed \xe2\x80\xa60CnHorizontal subtraction of adjacent pairs in the two packed \xe2\x80\xa60CiLoads 256-bits (composed of 4 packed double-precision \xe2\x80\xa6CgLoad 256-bits (composed of 16 packed half-precision \xe2\x80\xa6CiLoads 256-bits (composed of 8 packed single-precision \xe2\x80\xa6CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6DkBroadcasts double-precision (64-bit) floating-point value <code>a</code>\xe2\x80\xa6CnBroadcast the half-precision (16-bit) floating-point value \xe2\x80\xa6DkBroadcasts single-precision (32-bit) floating-point value <code>a</code>\xe2\x80\xa6ChSets packed double-precision (64-bit) floating-point \xe2\x80\xa6CnSet packed half-precision (16-bit) floating-point elements \xe2\x80\xa6ChSets packed single-precision (32-bit) floating-point \xe2\x80\xa6CfReturns the square root of packed double-precision \xe2\x80\xa6CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa6CfReturns the square root of packed single-precision \xe2\x80\xa6C`Zeroes the contents of all XMM or YMM registers.CiCopy the lower half-precision (16-bit) floating-point \xe2\x80\xa6ChLoad 512-bits (composed of 8 packed double-precision \xe2\x80\xa6CgLoad 512-bits (composed of 32 packed half-precision \xe2\x80\xa6CiLoad 512-bits (composed of 16 packed single-precision \xe2\x80\xa6>DjBroadcast 64-bit float <code>a</code> to all elements of <code>dst</code>.=DjBroadcast 32-bit float <code>a</code> to all elements of <code>dst</code>.CgSet packed double-precision (64-bit) floating-point \xe2\x80\xa6CgSet packed single-precision (32-bit) floating-point \xe2\x80\xa61=DeSets packed 32-bit integers in <code>dst</code> with the supplied \xe2\x80\xa6DhReturn vector of type <code>__m512</code> with all elements set to zero.CfCompute the square root of packed double-precision \xe2\x80\xa6=CfCompute the square root of packed single-precision \xe2\x80\xa6EbAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.EcAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using \xe2\x80\xa6EaCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.EeCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.EbCompares packed 8-bit integers in <code>a</code> and <code>b</code> for less-than.DnCompares the lower element of <code>a</code> and <code>b</code> for not-equal.ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6DhCompares two 32-bit floats from the low-order bits of <code>a</code> \xe2\x80\xa6C`Converts the lower double-precision (64-bit) \xe2\x80\xa60EbReturns <code>a</code> with its lower element replaced by <code>b</code> after \xe2\x80\xa6CkConverts a 32 bit integer to a 32 bit float. The result \xe2\x80\xa61CkConverts a 64 bit integer to a 32 bit float. The result \xe2\x80\xa6CmConverts the lowest 32 bit float in the input vector to a \xe2\x80\xa60BgAlias for <code>_mm_cvttss_si32</code>.CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa6000ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa6000CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa6000CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa6CgExtracts a single-precision (32-bit) floating-point \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CiMultiply the lower complex number in a by the complex \xe2\x80\xa6CfNormalize the mantissas of packed double-precision \xe2\x80\xa6CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa6CfNormalize the mantissas of packed single-precision \xe2\x80\xa6CiNormalize the mantissas of the lower double-precision \xe2\x80\xa6CgNormalize the mantissas of the lower half-precision \xe2\x80\xa6CiNormalize the mantissas of the lower single-precision \xe2\x80\xa6ClHorizontally adds the adjacent pairs of values contained \xe2\x80\xa60CfHorizontally subtract the adjacent pairs of values \xe2\x80\xa60CmLoad 128-bits (composed of 4 packed 32-bit integers) from \xe2\x80\xa6CmLoad 128-bits (composed of 2 packed 64-bit integers) from \xe2\x80\xa6CiLoads 128-bits of integer data from memory into a new \xe2\x80\xa6ClLoads a double-precision (64-bit) floating-point element \xe2\x80\xa6CmLoad 128-bits (composed of 16 packed 8-bit integers) from \xe2\x80\xa6ClLoads unaligned 16-bits of integer data from memory into \xe2\x80\xa6ClLoads unaligned 32-bits of integer data from memory into \xe2\x80\xa6ClLoads unaligned 64-bits of integer data from memory into \xe2\x80\xa6CfMultiplies and then horizontally add signed 16 bit \xe2\x80\xa6CnCompute the bitwise OR of packed double-precision (64-bit) \xe2\x80\xa6CnCompute the bitwise OR of packed single-precision (32-bit) \xe2\x80\xa6DkReturns a vector where the low element is extracted from <code>a</code> \xe2\x80\xa6CnDuplicate the low double-precision (64-bit) floating-point \xe2\x80\xa6ClSet each packed 16-bit integer in dst to all ones or all \xe2\x80\xa6ClSet each packed 32-bit integer in dst to all ones or all \xe2\x80\xa6ClSet each packed 64-bit integer in dst to all ones or all \xe2\x80\xa6CnShuffles double-precision (64-bit) floating-point elements \xe2\x80\xa6CnShuffles single-precision (32-bit) floating-point elements \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CiCompute the approximate reciprocal square root of the \xe2\x80\xa60CiBroadcasts 16-bit integer <code>a</code> to all elements.CiBroadcasts 32-bit integer <code>a</code> to all elements.CnSets packed 64-bit integers with the supplied values, from \xe2\x80\xa6CkSets packed 16-bit integers with the supplied values in \xe2\x80\xa6CkSets packed 32-bit integers with the supplied values in \xe2\x80\xa6CkReturns packed double-precision (64-bit) floating-point \xe2\x80\xa6CjReturn vector of type __m128h with all elements set to \xe2\x80\xa6DfConstruct a <code>__m128</code> with all elements initialized to zero.DkConstructs a 128-bit floating-point vector of <code>[2 x double]</code> \xe2\x80\xa6ClShuffles packed single-precision (32-bit) floating-point \xe2\x80\xa6DkNegates packed 16-bit integers in <code>a</code> when the corresponding \xe2\x80\xa6DkNegates packed 32-bit integers in <code>a</code> when the corresponding \xe2\x80\xa6EcShifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while \xe2\x80\xa6EcShifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while \xe2\x80\xa6EcShifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while \xe2\x80\xa6DnShifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa6DfShifts packed 32-bit integers in <code>a</code> left by the amount \xe2\x80\xa6DfShifts packed 64-bit integers in <code>a</code> left by the amount \xe2\x80\xa6EdShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while \xe2\x80\xa6EdShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while \xe2\x80\xa6CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa6DgShifts packed 32-bit integers in <code>a</code> right by the amount \xe2\x80\xa6CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa654EdShifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while \xe2\x80\xa6DoShifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.43DgShifts packed 64-bit integers in <code>a</code> right by the amount \xe2\x80\xa6DhSubtract packed 16-bit integers in <code>b</code> from packed 16-bit \xe2\x80\xa6DjSubtract packed unsigned 16-bit integers in <code>b</code> from packed \xe2\x80\xa6CfComputes the bitwise AND of 128 bits (representing \xe2\x80\xa60DmCompares the lower element of <code>a</code> and <code>b</code> for equality.ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6DhCompares two 32-bit floats from the low-order bits of <code>a</code> \xe2\x80\xa6DgCompares the lower element of <code>a</code> and <code>b</code> for \xe2\x80\xa621EaCompares the lower element of <code>a</code> and <code>b</code> for greater-than.32132DnCompares the lower element of <code>a</code> and <code>b</code> for less-than.43CkRead a hardware generated 16-bit random value and store \xe2\x80\xa6CkRead a hardware generated 32-bit random value and store \xe2\x80\xa6CkRead a hardware generated 64-bit random value and store \xe2\x80\xa6ChRead a 16-bit NIST SP800-90B and SP800-90C compliant \xe2\x80\xa6ChRead a 32-bit NIST SP800-90B and SP800-90C compliant \xe2\x80\xa6ChRead a 64-bit NIST SP800-90B and SP800-90C compliant \xe2\x80\xa6EgAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit \xe2\x80\xa6EgAdds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit \xe2\x80\xa6CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa6CmCompute dot-product of FP16 (16-bit) floating-point pairs \xe2\x80\xa6G`Adds <code>c</code> * <code>other</code> to <code>self</code>. <code>other</code> must have the same length, \xe2\x80\xa6CkRegisters a function to run for every newly thread spawned.AjAdvance a slice of slices.0EkAn arbitrary <code>ValidPrime</code> in the range <code>2..(1 &lt;&lt; 24)</code>, plus \xe2\x80\xa6DgUnstable module containing the unstable <code>assert_matches</code> \xe2\x80\xa6ChAsserts that an expression matches the provided pattern.EcA version of <code>FqVector::assign</code> that allows <code>other</code> to be \xe2\x80\xa6DiCall the <code>AsyncFnMut</code>, returning a future which may borrow \xe2\x80\xa600000CmCompute the auxiliary data associated to the homomorphism \xe2\x80\xa6CjKeeps the item it\xe2\x80\x99s applied to if the passed path is \xe2\x80\xa60000BcA \xe2\x80\x9ccompiler-only\xe2\x80\x9d atomic fence.CaUpdate the degree component to the correct degreeClComputes the kernel from an augmented matrix in rref. To \xe2\x80\xa6EeCreates a new vector from the elements of <code>first</code> and <code>second</code>.ClAllocates a block of memory at compile time. At runtime, \xe2\x80\xa6FcConverts the <code>ControlFlow</code> into an <code>Option</code> which is <code>Some</code> if \xe2\x80\xa6ChRecursively create a directory and all of its parent \xe2\x80\xa6C`Combine two values which have no bits in common.DbSee <code>super::disjoint_bitor</code>; we just need the trait \xe2\x80\xa6CnReturns the amount of time elapsed from another instant to \xe2\x80\xa6ClReturns the amount of time elapsed from an earlier point \xe2\x80\xa6CdChecks that two values are a case-insensitive match.CmReturns an iterator that produces an escaped version of a \xe2\x80\xa6ClExtends the resolution homomorphism up to a given range. \xe2\x80\xa6CmReserves capacity in a collection for the given number of \xe2\x80\xa600000CeFloat addition that allows optimizations based on \xe2\x80\xa6CeFloat division that allows optimizations based on \xe2\x80\xa6DnOffsets the pointer\xe2\x80\x99s address by adding <code>val</code> <em>bytes</em>, \xe2\x80\xa6EcOffsets the pointer\xe2\x80\x99s address by subtracting <code>val</code> <em>bytes</em>, \xe2\x80\xa6CmThis computes all available filtration one products for a \xe2\x80\xa6ClApplies the given predicate to the items in the parallel \xe2\x80\xa6CkFloat multiplication that allows optimizations based on \xe2\x80\xa6CjLike <code>forget</code>, but also accepts unsized values.CfFloat remainder that allows optimizations based on \xe2\x80\xa6CiCreates a new iterator where each iteration calls the \xe2\x80\xa6CkGets atomic access to a <code>&amp;mut [bool]</code> slice.BjGets atomic access to a slice of pointers.ChGet atomic access to a <code>&amp;mut [i8]</code> slice.ChGet atomic access to a <code>&amp;mut [u8]</code> slice.CiGet atomic access to a <code>&amp;mut [i16]</code> slice.CiGet atomic access to a <code>&amp;mut [u16]</code> slice.CiGet atomic access to a <code>&amp;mut [i32]</code> slice.CiGet atomic access to a <code>&amp;mut [u32]</code> slice.CiGet atomic access to a <code>&amp;mut [i64]</code> slice.CiGet atomic access to a <code>&amp;mut [u64]</code> slice.CkGet atomic access to a <code>&amp;mut [isize]</code> slice.CkGet atomic access to a <code>&amp;mut [usize]</code> slice.BcForms a slice from a pointer range.CkForms a (possibly-wide) raw pointer from a data pointer \xe2\x80\xa6DkPerforms the same functionality as <code>std::ptr::from_raw_parts</code>\xe2\x80\xa6BjForms a slice from a pointer and a length.ClCreates a <code>&amp;str</code> from a pointer and a length.E`Creates a <code>Vec&lt;T&gt;</code> directly from a pointer, a length, and a \xe2\x80\xa6DdCreates a new <code>String</code> from a pointer, a length and a \xe2\x80\xa6ChFloat subtraction that allows optimizations based on \xe2\x80\xa6CeGet read-write access to the contents of a pinned \xe2\x80\xa6ChConverts this <code>String</code> into a Box&lt;str&gt;.EhTakes a <code>Vec&lt;[T; N]&gt;</code> and flattens it into a <code>Vec&lt;T&gt;</code>.E`Converts a Box&lt;OsStr&gt; into an <code>OsString</code> without copying or \xe2\x80\xa6EbConsumes the <code>PathBuf</code>, yielding its internal <code>OsString</code> \xe2\x80\xa6C`Consumes the thread, returning the raw pthread_t0DcDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: \xe2\x80\xa6CmDecomposes a <code>String</code> into its raw components: \xe2\x80\xa6CjReturns an iterator over the remaining elements of the \xe2\x80\xa6CkReturns the remainder of the original slice that is not \xe2\x80\xa60CmReturns <code>true</code> if this file type is a char device.0DgReturns <code>true</code> if the address is an IPv4-mapped address (\xe2\x80\xa6CkChecks if the elements of this iterator are partitioned \xe2\x80\xa600000BoChecks if the value is a punctuation character:DdReturns <code>true</code> for the special \xe2\x80\x98unspecified\xe2\x80\x99 address.DhReturns <code>true</code> for the special \xe2\x80\x98unspecified\xe2\x80\x99 address (\xe2\x80\xa6EgReturns <code>true</code> for the special \xe2\x80\x98unspecified\xe2\x80\x99 address (<code>::</code>\xe2\x80\xa6CjReturns the last key-value pair in the map. The key in \xe2\x80\xa6CjConverts this value to its lower case equivalent in-place.CjConverts this value to its upper case equivalent in-place.FgMaps an <code>Option&lt;T&gt;</code> to a <code>U</code> by applying function <code>f</code> to the \xe2\x80\xa6FiMaps a <code>Result&lt;T, E&gt;</code> to a <code>U</code> by applying function <code>f</code> to the \xe2\x80\xa6CnEnsures a value is in the entry by inserting the result of \xe2\x80\xa60DiLexicographically compares the elements of this <code>Iterator</code> \xe2\x80\xa600000CmReturns the payload associated with the panic, if it is a \xe2\x80\xa6DmSearches for the sequentially <strong>first</strong> item in the parallel \xe2\x80\xa6CiAdds an element to the front of the list, returning a \xe2\x80\xa6CnPrepends an element to the deque, returning a reference to \xe2\x80\xa6DeReads the exact number of bytes required to fill <code>cursor</code>.0CbReads the entire contents of a file into a string.CmReads all bytes from a reader into a new <code>String</code>.DkThis function is not supported by <code>io::Repeat</code>, because there\xe2\x80\xa6ClReads all bytes until EOF in this source, appending them \xe2\x80\xa60DhReads the value from <code>src</code> without moving it. This leaves theDiReads the value from <code>self</code> without moving it. This leaves \xe2\x80\xa6CnReducing multiply.  Returns the product of the elements of \xe2\x80\xa6CkReturns the product of the elements of the vector, with \xe2\x80\xa60100CmRemoves the current element from the <code>LinkedList</code>.ClRemoves a directory at this path, after removing all its \xe2\x80\xa6DjRemove all matches of pattern <code>pat</code> in the <code>String</code>.BlThis function replaces the source of the \xe2\x80\xa6AoSee <code>replace_source</code>ClLanewise saturating absolute value, implemented in Rust. \xe2\x80\xa60D`Saturating absolute value, see <code>i64::saturating_abs</code>.D`Saturating absolute value, see <code>i32::saturating_abs</code>.DbSaturating absolute value, see <code>isize::saturating_abs</code>.DaSaturating absolute value, see <code>i128::saturating_abs</code>.D`Saturating absolute value, see <code>i16::saturating_abs</code>.CoSaturating absolute value, see <code>i8::saturating_abs</code>.CjComputes <code>a + b</code>, saturating at numeric bounds.AhLanewise saturating add.000ChAdds an unsigned integer to a non-zero value. Return \xe2\x80\xa600000EbSaturating <code>Duration</code> addition. Computes <code>self + other</code>, \xe2\x80\xa6CeMultiplies two non-zero integers together. Return \xe2\x80\xa600000000000EhSaturating <code>Duration</code> multiplication. Computes <code>self * other</code>, \xe2\x80\xa6CiLanewise saturating negation, implemented in Rust. As \xe2\x80\xa60CoSaturating negation. Computes <code>-self</code>, returning \xe2\x80\xa600000CdRaise non-zero value to an integer power. Return \xe2\x80\xa600000000000CjComputes <code>a - b</code>, saturating at numeric bounds.AmLanewise saturating subtract.000EeSaturating <code>Duration</code> subtraction. Computes <code>self - other</code>, \xe2\x80\xa6ClWrites values from a SIMD vector to multiple potentially \xe2\x80\xa6CkDisplay backtrace if available when using pretty output \xe2\x80\xa6DcSame as <code>PairAlgebra::sigma_multiply_basis</code> but with \xe2\x80\xa60DhGive a list of basis elements in degree <code>degree</code> that has \xe2\x80\xa6BhLogical \xe2\x80\x9cors\xe2\x80\x9d all elements together.DeCreates an iterator that skips elements from <em>anywhere</em> in \xe2\x80\xa6CgSignals the processor that it is inside a busy-wait \xe2\x80\xa6ChIf the process was stopped by a signal, returns that \xe2\x80\xa60DeCreates an iterator that takes elements from <em>anywhere</em> in \xe2\x80\xa6BiTests the value of the specified element.DfConverts this address to an <code>IPv4</code> address if it\xe2\x80\x99s an \xe2\x80\xa6DbConverts this address to an IPv4-mapped <code>IPv6</code> address.CfReturns the number of trailing zeros in the binary \xe2\x80\xa6000000000000000000000000000000000000000FeInterprets <code>src</code> as having type <code>&amp;Dst</code>, and then reads <code>src</code> \xe2\x80\xa6DfShortens the deque, keeping the last <code>len</code> elements and \xe2\x80\xa6ClMutably borrows the wrapped value, returning an error if \xe2\x80\xa6DbConstructs a new <code>Arc</code> with uninitialized contents, \xe2\x80\xa6CkConstructs a new box with uninitialized contents on the \xe2\x80\xa6DkConstructs a new <code>Rc</code> with uninitialized contents, returning \xe2\x80\xa6DkConstructs a new <code>Arc</code> with uninitialized contents, with the \xe2\x80\xa6DkConstructs a new <code>Box</code> with uninitialized contents, with the \xe2\x80\xa6DjConstructs a new <code>Rc</code> with uninitialized contents, with the \xe2\x80\xa6CnComputes the suspension map between different unstable Ext \xe2\x80\xa6DgReturns the contained <code>Some</code> value or computes it from a \xe2\x80\xa6DeReturns the contained <code>Ok</code> value or computes it from a \xe2\x80\xa6CjPerforms a volatile store to the <code>dst</code> pointer.EcCreates an owned <code>PathBuf</code> like <code>self</code> but with the given \xe2\x80\xa6EhCreates an owned <code>PathBuf</code> like <code>self</code> but with the given file \xe2\x80\xa6CnThis shifts the sseq horizontally so that the minimum x is \xe2\x80\xa6DgLike <code>write</code>, except that it writes into a slice of buffers.DgLike <code>write</code>, except that it writes from a slice of buffers.0DjThis is an implementation detail of <code>crate::ptr::write</code> and \xe2\x80\xa6CkPerforms a volatile write of a memory location with the \xe2\x80\xa60ClA marker trait for primitive types which can be modified \xe2\x80\xa6B`This models an augmented matrix.0ClThe current status of a backtrace, indicating whether it \xe2\x80\xa6CmAn element of a bigraded vector space. Most commonly used \xe2\x80\xa6BnThe connection was reset by the remote server.Da<code>DispatchFromDyn</code> is used in the implementation of \xe2\x80\xa6fU+0021CeDescribes the result of a process after it has failedk1/sqrt(2\xcf\x80)000fU+003EBaThe remote host is not reachable.CkAn iterator adapter that places a separator between all \xe2\x80\xa6DkAn error indicating invalid UTF-8 when converting a <code>CString</code>\xe2\x80\xa60AgA filename was invalid.fU+0028BoNumber of significant digits in base 2. Use \xe2\x80\xa60BlAn immutable view of a tile within a matrix.ClA variant of <code>Bidegree</code> that has a defined order.CdThe parts of a PPartMultiplier that involve heap \xe2\x80\xa60CdAn error which can be returned when parsing a float.CmA structure wrapping a Windows path prefix as well as its \xe2\x80\xa6CiAn iterator over a slice in (non-overlapping) mutable \xe2\x80\xa6BhA reverse searcher for a string pattern.CnRAII structure used to release the shared read access of a \xe2\x80\xa600BdA Unix socket Ancillary data struct.CfCreated with the method <code>split_terminator</code>.CkAn iterator over the non-whitespace substrings of a string,fU+0016EcAn error returned from the <code>duration_since</code> and <code>elapsed</code> \xe2\x80\xa6ChThe error type returned when a checked integral type \xe2\x80\xa6CdThe error type for <code>try_reserve</code> methods.DjThe version of Unicode that the Unicode parts of <code>char</code> and \xe2\x80\xa6BoAn unwind action that terminates the execution.DdThe <code>_MM_CMPINT_ENUM</code> type used to specify comparison \xe2\x80\xa6dTrueBhSee <code>_MM_GET_EXCEPTION_STATE</code>Bground up and do not suppress exceptionsBoround to nearest and do not suppress exceptionsCduse MXCSR.RC and do not suppress exceptions; see \xe2\x80\xa6AkSee <code>_mm_setcsr</code>BgString contains signed 8-bit charactersBjString contains unsigned 16-bit charactersClString contains unsigned 8-bit characters <em>(Default)</em>C`<strong>Mask only</strong>: return the byte mask2BaTransaction successfully started.FdReturns the highest-supported <code>leaf</code> (<code>EAX</code>) and sub-leaf (<code>ECX</code>\xe2\x80\xa6CkShift 8-bit mask a left by count bits while shifting in \xe2\x80\xa6ClShift 8-bit mask a right by count bits while shifting in \xe2\x80\xa6CnCompute the bitwise AND of 8-bit masks a and b, and if the \xe2\x80\xa6DhComputes the absolute values of packed 8-bit integers in <code>a</code>.D`Adds packed 8-bit integers in <code>a</code> and <code>b</code>.DmAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.CjBlends packed double-precision (64-bit) floating-point \xe2\x80\xa6CjBlends packed single-precision (32-bit) floating-point \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6ClConverts packed double-precision (64-bit) floating-point \xe2\x80\xa6CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CnConverts the 8 x 16-bit half-precision float values in the \xe2\x80\xa6ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa6CnConverts the 8 x 32-bit float values in the 256-bit vector \xe2\x80\xa6CjRounds packed double-precision (64-bit) floating point \xe2\x80\xa6CjRounds packed single-precision (32-bit) floating point \xe2\x80\xa6CnMultiplies packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6CnMultiplies packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6CiLoads 256-bits (composed of 4 packed double-precision \xe2\x80\xa6CgLoad 256-bits (composed of 16 packed half-precision \xe2\x80\xa6CiLoads 256-bits (composed of 8 packed single-precision \xe2\x80\xa6EhCompares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the \xe2\x80\xa6EeCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and \xe2\x80\xa610CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa6CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa6CmComputes the bitwise OR of 256 bits (representing integer \xe2\x80\xa6CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60C`Compute the approximate reciprocal of packed \xe2\x80\xa60?>ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6CmComputes the approximate reciprocal square root of packed \xe2\x80\xa6CnComputes the absolute differences of packed unsigned 8-bit \xe2\x80\xa6CjSets packed 8-bit integers in returned vector with the \xe2\x80\xa6ChSets packed __m256 returned vector with the supplied \xe2\x80\xa6CjStores 256-bits (composed of 4 packed double-precision \xe2\x80\xa6ChStore 256-bits (composed of 16 packed half-precision \xe2\x80\xa6CjStores 256-bits (composed of 8 packed single-precision \xe2\x80\xa6DfSubtract packed 8-bit integers in <code>b</code> from packed 8-bit \xe2\x80\xa6CfComputes the bitwise AND of 256 bits (representing \xe2\x80\xa6000CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa6CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa6CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6CmConverts integer mask into bitmask, storing the result in \xe2\x80\xa6CmPerforms bitwise OR between k1 and k2, storing the result \xe2\x80\xa60CnUnpack and interleave 8 bits from masks a and b, and store \xe2\x80\xa6CiUnpack and interleave 32 bits from masks a and b, and \xe2\x80\xa6CiUnpack and interleave 16 bits from masks a and b, and \xe2\x80\xa6CiLoads 512-bits (composed of 8 packed double-precision \xe2\x80\xa6CgLoad 512-bits (composed of 32 packed half-precision \xe2\x80\xa6CjLoads 512-bits (composed of 16 packed single-precision \xe2\x80\xa6CkConverts bit mask k1 into an integer value, storing the \xe2\x80\xa6CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa6CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa610CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa6CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa6ClCompute the bitwise OR of 512 bits (representing integer \xe2\x80\xa6CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60C`Compute the approximate reciprocal of packed \xe2\x80\xa60ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6CmCompute the absolute differences of packed unsigned 8-bit \xe2\x80\xa6CjSet packed 8-bit integers in dst with the supplied values.CgSet packed double-precision (64-bit) floating-point \xe2\x80\xa6CgSet packed single-precision (32-bit) floating-point \xe2\x80\xa6CiStore 512-bits (composed of 8 packed double-precision \xe2\x80\xa6ChStore 512-bits (composed of 32 packed half-precision \xe2\x80\xa6CfStore 512-bits of integer data from a into memory. \xe2\x80\xa6CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa6EbConcatenate 16-byte blocks in <code>a</code> and <code>b</code> into a 32-byte \xe2\x80\xa6CiConvert scalar half-precision (16-bit) floating-point \xe2\x80\xa6EfBlend packed 16-bit integers from <code>a</code> and <code>b</code> using the mask \xe2\x80\xa6EfBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control \xe2\x80\xa6EjBlend packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>DnShifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.DoShifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa6ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa6EbCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.EbCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.EaCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equalityDlCompares packed 16-bit integers in <code>a</code> and <code>b</code> for \xe2\x80\xa6DlCompares packed 32-bit integers in <code>a</code> and <code>b</code> for \xe2\x80\xa6DlCompares packed 64-bit integers in <code>a</code> and <code>b</code> for \xe2\x80\xa6EcCompares packed 16-bit integers in <code>a</code> and <code>b</code> for less-than.EcCompares packed 32-bit integers in <code>a</code> and <code>b</code> for less-than.EbCompares corresponding elements in <code>a</code> and <code>b</code> to see if \xe2\x80\xa6DkCompares each of the four floats in <code>a</code> to the corresponding \xe2\x80\xa6DkReturns a new vector with the low element of <code>a</code> replaced by \xe2\x80\xa6DkChecks if the lowest <code>f32</code> of both inputs are unordered. The \xe2\x80\xa6ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa6DfConverts the lower two packed 32-bit integers in <code>a</code> to \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6CoConverts packed 32-bit integers in <code>a</code> to packed \xe2\x80\xa6ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa6CgConverts a single-precision (32-bit) floating-point \xe2\x80\xa6ClConverts packed double-precision (64-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6004444443CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600BeAlias for <code>_mm_cvtsd_si64</code>EbReturns <code>a</code> with its lower element replaced by <code>b</code> after \xe2\x80\xa6C`Converts the lower double-precision (64-bit) \xe2\x80\xa60CmConverts the lowest 32 bit float in the input vector to a \xe2\x80\xa60CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa6CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa6CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa6CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa6CnMultiplies packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6CnMultiplies packed single-precision (32-bit) floating-point \xe2\x80\xa6210ClHorizontally adds the adjacent pairs of values contained \xe2\x80\xa6CfHorizontally subtract the adjacent pairs of values \xe2\x80\xa6EhReturns a copy of <code>a</code> with the 8-bit integer from <code>i</code> inserted \xe2\x80\xa6FeInserts the <code>[length:0]</code> bits of <code>y</code> into <code>x</code> at <code>index</code>.CnLoads 128-bits of integer data from unaligned memory. This \xe2\x80\xa6CjLoads 64-bit integer from memory into first element of \xe2\x80\xa6CmLoad 128-bits (composed of 8 packed 16-bit integers) from \xe2\x80\xa6CmLoad 128-bits (composed of 4 packed 32-bit integers) from \xe2\x80\xa6CmLoad 128-bits (composed of 2 packed 64-bit integers) from \xe2\x80\xa6CiLoads 128-bits of integer data from memory into a new \xe2\x80\xa6CiCounts the number of leading zero bits in each packed \xe2\x80\xa60CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa6CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa6CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa6CjAdd the lower double-precision (64-bit) floating-point \xe2\x80\xa6ChAdd the lower half-precision (16-bit) floating-point \xe2\x80\xa6CjAdd the lower single-precision (32-bit) floating-point \xe2\x80\xa6CfCompute the bitwise AND of packed double-precision \xe2\x80\xa6CfCompute the bitwise AND of packed single-precision \xe2\x80\xa6CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa6ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa6CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa6CmDivide the lower double-precision (64-bit) floating-point \xe2\x80\xa6CkDivide the lower half-precision (16-bit) floating-point \xe2\x80\xa6CmDivide the lower single-precision (32-bit) floating-point \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa6ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa6543210ChMove packed double-precision (64-bit) floating-point \xe2\x80\xa6ChMove packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa6CcCompute the approximate reciprocal of the lower \xe2\x80\xa6ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa6CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa6ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa6C`Subtract the lower double-precision (64-bit) \xe2\x80\xa6CmSubtract the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Subtract the lower single-precision (32-bit) \xe2\x80\xa6CfCompute the bitwise XOR of packed double-precision \xe2\x80\xa6CfCompute the bitwise XOR of packed single-precision \xe2\x80\xa6CiLoads packed double-precision (64-bit) floating-point \xe2\x80\xa6CiLoads packed single-precision (32-bit) floating-point \xe2\x80\xa6CnCompute the bitwise OR of packed double-precision (64-bit) \xe2\x80\xa6CnCompute the bitwise OR of packed single-precision (32-bit) \xe2\x80\xa6CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa6CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa6CnReturns a mask of the most significant bit of each element \xe2\x80\xa60DkMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.EdMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.1DoMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, \xe2\x80\xa6EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa6EdConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa6EdConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa6CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa6CiBroadcasts 64-bit integer <code>a</code> to all elements.CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa6210CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa6210CnStore 128-bits (composed of 4 packed 32-bit integers) from \xe2\x80\xa6CnStore 128-bits (composed of 2 packed 64-bit integers) from \xe2\x80\xa6D`Stores 128-bits of integer data from <code>a</code> into memory.CnStore 128-bits (composed of 16 packed 8-bit integers) from \xe2\x80\xa6CiStore 16-bit integer from the first element of a into \xe2\x80\xa6CiStore 32-bit integer from the first element of a into \xe2\x80\xa6CiStore 64-bit integer from the first element of a into \xe2\x80\xa6CiStores a 32-bit integer value in the specified memory \xe2\x80\xa6CiStores a 64-bit integer value in the specified memory \xe2\x80\xa6CiTests whether the specified bits in a 128-bit integer \xe2\x80\xa60DnCompares the lower element of <code>a</code> and <code>b</code> for not-equal.ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6DhCompares two 32-bit floats from the low-order bits of <code>a</code> \xe2\x80\xa6DkThe resulting <code>__m128d</code> element is composed by the low-order \xe2\x80\xa6CdUnpacks and interleave single-precision (32-bit) \xe2\x80\xa6DaThe resulting <code>__m128d</code> element is composed by the \xe2\x80\xa61CoAdvances the iterator from the back by <code>n</code> elements.00000DjBehaves like <code>allocate</code>, but also ensures that the returned \xe2\x80\xa6CcReturns a non-null pointer to the slice\xe2\x80\x99s buffer.CeReturns a shared reference to a slice of possibly \xe2\x80\xa6BoReturns the pattern as utf-8 bytes if possible.CiGets a mutable (unique) reference to the contained value.BoGets a shared reference to the contained value.DhCall the <code>AsyncFnOnce</code>, returning a future which may move \xe2\x80\xa600000CiGet a string representation of d(gen), where d is the \xe2\x80\xa6DiPerforms the same function as <code>call_once()</code> except ignores \xe2\x80\xa6DjGets a reference to a static <code>Location</code> indicating where it \xe2\x80\xa6DePerforms copy-assignment from <code>self</code> to <code>dest</code>.CgOpens a TCP connection to a remote host with a timeout.CnThis replaces the contents of the vector with the contents \xe2\x80\xa6BoOpens a file in write-only mode with buffering.CiProvides a cursor with editing operations at the back \xe2\x80\xa6CeAsserts that two expressions are equal to each other.CiAsserts that two expressions are not equal to each other.GgWhen passed the <em>number</em> <code>0</code>, <code>1</code>, \xe2\x80\xa6, <code>9</code>, returns the <em>character</em> \xe2\x80\xa6ClThis uses a lookup table for n choose k when n and k are \xe2\x80\xa6CnDefine a struct that wraps some field-dependent type in an \xe2\x80\xa6CgInternal method used to define the behavior of this \xe2\x80\xa6EhIf <code>min_degree &lt; self.min_degree</code>, set <code>self.min_degree</code> to \xe2\x80\xa6DeExtend the <code>MuResolutionHomomorphism</code> to be defined on \xe2\x80\xa6CkReturns the first key-value pair in the map. The key in \xe2\x80\xa6CjReturns the value that would be obtained by taking the \xe2\x80\xa60DdCreates a new <code>Duration</code> from the specified number of \xe2\x80\xa6EnConstructs a <code>Layout</code> from a given <code>size</code> and <code>align</code>, or \xe2\x80\xa6ClConverts a slice of bytes to a string, including invalid \xe2\x80\xa6CgPerforms C = A * B + C where A, B, C are 64x64 matricesCjScalar (non-SIMD) implementation of 64 x 64 block GEMM \xe2\x80\xa6ChPerforms tile-level GEMM with recursive parallelization.CdReturns the working directory for the child process.CkGets the mutable reference of the contents of the cell, \xe2\x80\xa60DiGets the contents of the cell, initializing it to <code>f()</code> if \xe2\x80\xa60CaConverts <code>self</code> into an async iteratorDbConverts this <code>PathBuf</code> into a boxed <code>Path</code>.ClReturns a mutable reference to the filled portion of the \xe2\x80\xa6DgConsumes the <code>BinaryHeap</code> and returns a vector in sorted \xe2\x80\xa6AnReturn the throughput in MiB/sDgConverts the bytes into a <code>String</code> lossily, substituting \xe2\x80\xa6CaChecks if the value is an alphanumeric character:DjReturns <code>true</code> if this address is in a range designated for \xe2\x80\xa6EdReturns <code>true</code> if this address part of the <code>198.18.0.0/15</code> \xe2\x80\xa6D`Returns <code>true</code> if this is an address reserved for \xe2\x80\xa6CnReturns <code>true</code> if this file type is a block device.0CkChecks whether the pattern matches anywhere in the haystackFeReturns <code>true</code> if and only if <code>self == (1 &lt;&lt; k)</code> for some <code>k</code>.00000EjReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.00000000000EdReturns <code>true</code> if this is a unique local address (<code>fc00::/7</code>).CgIterate through all signatures of this algebra that \xe2\x80\xa6DkReads contiguous elements from <code>slice</code>. Elements are read so \xe2\x80\xa6DkReads contiguous elements starting at <code>ptr</code>. Each element is \xe2\x80\xa6DcReturns a <code>CursorMut</code> pointing at the gap before the \xe2\x80\xa60CnRearranges the internal storage of this deque so it is one \xe2\x80\xa6CjComputes the bidegree containing the Massey product of \xe2\x80\xa6CmReturns the address\xe2\x80\x99s multicast scope if the address is \xe2\x80\xa6CmComputes the multinomial coefficient mod p using Lucas\xe2\x80\x99 \xe2\x80\xa6DgFinds the next <code>Match</code> result. See <code>next_back()</code>.CfComputes the absolute value of self, with overflow \xe2\x80\xa600000CmNegates self, overflowing if this is equal to the minimum \xe2\x80\xa600000AoUses <code>park_timeout</code>.CmReturns the index of the partition point according to the \xe2\x80\xa6DlSee documentation of <code>&lt;*const T&gt;::offset_from</code> for details.CjChanges the current working directory to the specified \xe2\x80\xa6CgA socket listener will be awakened solely when data \xe2\x80\xa6CfMoves this TCP stream into or out of nonblocking mode.0CfMoves this UDP socket into or out of nonblocking mode.CaMoves the socket into or out of nonblocking mode.00CgChanges the permissions found on a file or a directory.BoChanges the permissions on the underlying file.AnReverses bits of each element.CkFunnel Shifts vector left elementwise, with UB on overflow.CfFunnel Shifts vector right elementwise, with UB on \xe2\x80\xa6CkInserts an element into a vector, returning the updated \xe2\x80\xa6BcChecks if all mask values are true.BiLogical \xe2\x80\x9cand\xe2\x80\x9cs all elements together.BaChecks if any mask value is true.BhReturns the maximum element of a vector.BhReturns the minimum element of a vector.CbLogical \xe2\x80\x9cexclusive ors\xe2\x80\x9d all elements together.CbReturns the size of the pointed-to value in bytes.ClSpawns a new thread without any lifetime restrictions by \xe2\x80\xa6CnThis module includes code for parsing an expression in the \xe2\x80\xa6CmCall our resolution $X$, and the chain complex to resolve \xe2\x80\xa6CkReturns the current seek position from the start of the \xe2\x80\xa600CiRemoves the pattern from the front of haystack, if it \xe2\x80\xa6ChRemoves the pattern from the back of haystack, if it \xe2\x80\xa6ClGet the string representation of the element as a linear \xe2\x80\xa6DjConverts this object to an iterator of resolved <code>SocketAddr</code>\xe2\x80\xa6CcConverts an <code>OsStr</code> to a Cow&lt;str&gt;.CcConverts a <code>CStr</code> into a Cow&lt;str&gt;.CnConverts a <code>Path</code> to a <code>Cow&lt;str&gt;</code>.CiTry to acquire a shared (non-exclusive) lock on the file.CkReduces the items in the iterator into one item using a \xe2\x80\xa6DcIf we have the only reference to <code>T</code> then unwrap it. \xe2\x80\xa60CiUnzips the results of the iterator into the specified \xe2\x80\xa6CkThis returns the vec of differentials to draw on each page.DkReturns a <code>CursorMut</code> pointing at the gap after the greatest \xe2\x80\xa60ChWaits on this condition variable for a notification, \xe2\x80\xa6CdAcquires a mutable reference to the contained value.CgCalculates the offset from a pointer using wrapping \xe2\x80\xa6000CmOverwrites a memory location with the given value without \xe2\x80\xa60CmAn <code>AtomicBool</code> initialized to <code>false</code>.CjA nonexistent interface was requested or the requested \xe2\x80\xa6BoAn Adem basis element for the Steenrod algebra.0CnA simple wrapper around a type to assert that it is unwind \xe2\x80\xa6AoA trait for ordering bidegrees.CnIterates through all numbers with the same number of bits. \xe2\x80\xa6CnError due to the computed capacity exceeding the collection\xe2\x80\xa6EhThe error type returned when a conversion from <code>u32</code> to <code>char</code> \xe2\x80\xa6fU+005ECkAn error that can be returned when decoding UTF-16 code \xe2\x80\xa6fU+0011fU+0012CmCompiler-internal trait used to indicate the type of enum \xe2\x80\xa6BoThe internal representation of a field element.DcAn <code>Algebra</code> equipped with a distinguished presentation.0CbAn index provided was out-of-bounds for the slice.fU+007BClA struct containing the information required to access a \xe2\x80\xa6DkAn RAII mutex guard returned by <code>MutexGuard::map</code>, which can \xe2\x80\xa600ClA non-contiguous view of a 64 x 64 block within a larger \xe2\x80\xa6CkA Milnor subalgebra to be used in Nassau\xe2\x80\x99s algorithm. \xe2\x80\xa6BdData provided is not nul terminated.0C`Parallel version of the standard iterator trait.CjThe operation lacked the necessary privileges to complete.CkZero-sized type used to mark a type parameter as covariant.CkZero-sized type used to mark a type parameter as invariant.ClTrait that indicates that this is a pointer or a wrapper \xe2\x80\xa6CgCreated with the method <code>rsplit_terminator</code>.CmA range only bounded inclusively above (<code>..=end</code>).0CnA range only bounded inclusively above (<code>..=last</code>).CmThis enumeration is the list of possible errors that made \xe2\x80\xa60fU+0029CmRAII structure used to release the exclusive write access \xe2\x80\xa600ClAn owned permission to join on a scoped thread (block on \xe2\x80\xa6ClAn error returned from the <code>send_timeout</code> method.DhAn error returned from <code>Path::strip_prefix</code> if the prefix \xe2\x80\xa6CjThe error type returned when a checked char conversion \xe2\x80\xa6eFalseBiround down and do not suppress exceptionsBgtruncate and do not suppress exceptionsAkSee <code>_mm_setcsr</code>0CfFor each character in <code>a</code>, determine if \xe2\x80\xa6CkTransaction abort due to the transaction using too much \xe2\x80\xa6CkTransaction abort due to a memory conflict with another \xe2\x80\xa6CmTransaction explicitly aborted with xabort. The parameter \xe2\x80\xa6EgReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>\xe2\x80\xa60ClShift 16-bit mask a left by count bits while shifting in \xe2\x80\xa6CgShift the bits of 32-bit mask a left by count while \xe2\x80\xa6CgShift the bits of 64-bit mask a left by count while \xe2\x80\xa6CmShift 16-bit mask a right by count bits while shifting in \xe2\x80\xa6ChShift the bits of 32-bit mask a right by count while \xe2\x80\xa6ChShift the bits of 64-bit mask a right by count while \xe2\x80\xa6CkCompute the bitwise AND of 16-bit masks a and b, and if \xe2\x80\xa6CkCompute the bitwise AND of 32-bit masks a and b, and if \xe2\x80\xa6CkCompute the bitwise AND of 64-bit masks a and b, and if \xe2\x80\xa6CmCompute the bitwise NOT of 8-bit mask a and then AND with \xe2\x80\xa6CkCompute the bitwise AND of 8-bit masks a and  b, if the \xe2\x80\xa6DkComputes the absolute values of packed 16-bit integers in <code>a</code>\xe2\x80\xa6DkComputes the absolute values of packed 32-bit integers in <code>a</code>\xe2\x80\xa6CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa6DaAdds packed 16-bit integers in <code>a</code> and <code>b</code>.DaAdds packed 32-bit integers in <code>a</code> and <code>b</code>.DaAdds packed 64-bit integers in <code>a</code> and <code>b</code>.EaAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.EbAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using \xe2\x80\xa6ClAlternatively adds and subtracts packed double-precision \xe2\x80\xa6ClAlternatively adds and subtracts packed single-precision \xe2\x80\xa6CnComputes the bitwise AND of 256 bits (representing integer \xe2\x80\xa6CgComputes the bitwise NOT of packed double-precision \xe2\x80\xa6CgComputes the bitwise NOT of packed single-precision \xe2\x80\xa6DnAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.CjBlends packed double-precision (64-bit) floating-point \xe2\x80\xa6CjBlends packed single-precision (32-bit) floating-point \xe2\x80\xa6DoCast vector of type <code>__m256d</code> to type <code>__m256h</code>. This \xe2\x80\xa6BkCast vector of type __m256d to type __m256.DoCast vector of type <code>__m256h</code> to type <code>__m256d</code>. This \xe2\x80\xa6EhCast vector of type <code>__m256h</code> to type <code>__m256</code>. This intrinsic \xe2\x80\xa6BkCast vector of type __m256 to type __m256d.EhCast vector of type <code>__m256</code> to type <code>__m256h</code>. This intrinsic \xe2\x80\xa6CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa6CdReturns the first element of the input vector of \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6CnMultiplies packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6CnMultiplies packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChConvert the exponent of each packed double-precision \xe2\x80\xa6CfConvert the exponent of each packed half-precision \xe2\x80\xa6ChConvert the exponent of each packed single-precision \xe2\x80\xa6EeCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns \xe2\x80\xa6EeCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns \xe2\x80\xa6CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa6EfCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and \xe2\x80\xa6EfCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and \xe2\x80\xa6CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa6543210CkSet each packed 8-bit integer in dst to all ones or all \xe2\x80\xa6CnMultiplies the low 32-bit integers from each packed 64-bit \xe2\x80\xa6CiMultiplies the low unsigned 32-bit integers from each \xe2\x80\xa6CkExtract the reduced argument of packed double-precision \xe2\x80\xa6CiExtract the reduced argument of packed half-precision \xe2\x80\xa6CkExtract the reduced argument of packed single-precision \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6DgBroadcasts 8-bit integer <code>a</code> to all elements of returned \xe2\x80\xa6CkSets packed 16-bit integers in returned vector with the \xe2\x80\xa6CkSets packed 32-bit integers in returned vector with the \xe2\x80\xa6CiSets packed __m256d returned vector with the supplied \xe2\x80\xa6CiSets packed __m256i returned vector with the supplied \xe2\x80\xa6CjSets packed 8-bit integers in returned vector with the \xe2\x80\xa6ChSets packed __m256 returned vector with the supplied \xe2\x80\xa6DjNegates packed 8-bit integers in <code>a</code> when the corresponding \xe2\x80\xa6EdShifts packed 16-bit integers in <code>a</code> left by <code>count</code> while \xe2\x80\xa6EdShifts packed 32-bit integers in <code>a</code> left by <code>count</code> while \xe2\x80\xa6EdShifts packed 64-bit integers in <code>a</code> left by <code>count</code> while \xe2\x80\xa6EeShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while \xe2\x80\xa6EeShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while \xe2\x80\xa6CjShift packed 64-bit integers in a right by count while \xe2\x80\xa621EeShifts packed 64-bit integers in <code>a</code> right by <code>count</code> while \xe2\x80\xa6CjStores 256-bits (composed of 4 packed double-precision \xe2\x80\xa6ChStore 256-bits (composed of 16 packed half-precision \xe2\x80\xa6CjStores 256-bits (composed of 8 packed single-precision \xe2\x80\xa6CjMoves double-precision values from a 256-bit vector of \xe2\x80\xa6CgMoves single-precision floating point values from a \xe2\x80\xa6DhSubtract packed 16-bit integers in <code>b</code> from packed 16-bit \xe2\x80\xa6DhSubtract packed 32-bit integers in <code>b</code> from packed 32-bit \xe2\x80\xa6DhSubtract packed 64-bit integers in <code>b</code> from packed 64-bit \xe2\x80\xa6DfSubtract packed 8-bit integers in <code>b</code> from packed 8-bit \xe2\x80\xa6DiSubtract packed unsigned 8-bit integers in <code>b</code> from packed \xe2\x80\xa6CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa6CnComputes the bitwise XOR of 256 bits (representing integer \xe2\x80\xa6CmZeroes the upper 128 bits of all YMM registers; the lower \xe2\x80\xa6CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa6DkComputes the absolute values of packed 32-bit integers in <code>a</code>\xe2\x80\xa6CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa6ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa6CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa6CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa6CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa6CkCompute the bitwise AND of 512 bits (composed of packed \xe2\x80\xa6CmCompute the bitwise AND of 512 bits (representing integer \xe2\x80\xa6CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa6CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa6CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6DoCast vector of type <code>__m512d</code> to type <code>__m512h</code>. This \xe2\x80\xa6CnCast vector of type __m512d to type __m512. This intrinsic \xe2\x80\xa6DoCast vector of type <code>__m512h</code> to type <code>__m512d</code>. This \xe2\x80\xa6EhCast vector of type <code>__m512h</code> to type <code>__m512</code>. This intrinsic \xe2\x80\xa6CnCast vector of type __m512 to type __m512d. This intrinsic \xe2\x80\xa6EhCast vector of type <code>__m512</code> to type <code>__m512h</code>. This intrinsic \xe2\x80\xa6CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa6CkCopy the lower double-precision (64-bit) floating-point \xe2\x80\xa6CkCopy the lower single-precision (32-bit) floating-point \xe2\x80\xa6CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChConvert the exponent of each packed double-precision \xe2\x80\xa6CfConvert the exponent of each packed half-precision \xe2\x80\xa6ChConvert the exponent of each packed single-precision \xe2\x80\xa6CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa6543210CkSet each packed 8-bit integer in dst to all ones or all \xe2\x80\xa6ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa6CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa6CkExtract the reduced argument of packed double-precision \xe2\x80\xa6CiExtract the reduced argument of packed half-precision \xe2\x80\xa6CkExtract the reduced argument of packed single-precision \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6CaBroadcast 8-bit integer a to all elements of dst.CkSet packed 16-bit integers in dst with the supplied values.DeSets packed 32-bit integers in <code>dst</code> with the supplied \xe2\x80\xa6CkSet packed 64-bit integers in dst with the supplied values.CiShift packed 16-bit integers in a left by count while \xe2\x80\xa6CiShift packed 32-bit integers in a left by count while \xe2\x80\xa6CiShift packed 64-bit integers in a left by count while \xe2\x80\xa6CjShift packed 16-bit integers in a right by count while \xe2\x80\xa6CjShift packed 32-bit integers in a right by count while \xe2\x80\xa6CjShift packed 64-bit integers in a right by count while \xe2\x80\xa6210CjStores 512-bits (composed of 8 packed double-precision \xe2\x80\xa6ChStore 512-bits (composed of 32 packed half-precision \xe2\x80\xa6CkStores 512-bits (composed of 16 packed single-precision \xe2\x80\xa6CiStore 512-bits (composed of 8 packed double-precision \xe2\x80\xa6CjStore 512-bits (composed of 16 packed single-precision \xe2\x80\xa6CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa6CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa6CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa6CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa6ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa6CmReturn vector of type __m512 with indeterminate elements. \xe2\x80\xa6CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa6CmCompute the bitwise XOR of 512 bits (representing integer \xe2\x80\xa6CjAdd the lower double-precision (64-bit) floating-point \xe2\x80\xa6ChAdd the lower half-precision (16-bit) floating-point \xe2\x80\xa6CjAdd the lower single-precision (32-bit) floating-point \xe2\x80\xa6ChPerforms one round of an AES decryption flow on data \xe2\x80\xa6ChPerforms one round of an AES encryption flow on data \xe2\x80\xa6DiPerforms the <code>InvMixColumns</code> transformation on <code>a</code>.CnConcatenate a and b into a 32-byte immediate result, shift \xe2\x80\xa60CnComputes the bitwise NOT of 128 bits (representing integer \xe2\x80\xa6CiBroadcasts a single-precision (32-bit) floating-point \xe2\x80\xa6DkCasts a 128-bit floating-point vector of <code>[2 x double]</code> into \xe2\x80\xa6DoCast vector of type <code>__m128h</code> to type <code>__m128i</code>. This \xe2\x80\xa6DjCasts a 128-bit floating-point vector of <code>[4 x float]</code> into \xe2\x80\xa6CaCasts a 128-bit integer vector into a 128-bit \xe2\x80\xa6DoCast vector of type <code>__m128i</code> to type <code>__m128h</code>. This \xe2\x80\xa61CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6ClConverts packed double-precision (64-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa6444BfAlias for <code>_mm_cvttsd_si64</code>CmDivide the lower double-precision (64-bit) floating-point \xe2\x80\xa6CkDivide the lower half-precision (16-bit) floating-point \xe2\x80\xa6CmDivide the lower single-precision (32-bit) floating-point \xe2\x80\xa6CgMultiply groups of 4 adjacent pairs of signed 8-bit \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CjMultiply groups of 2 adjacent pairs of unsigned 16-bit \xe2\x80\xa60EcExtracts an 8-bit integer from <code>a</code>, selected with <code>IMM8</code>. \xe2\x80\xa6DhExtracts the bit range specified by <code>y</code> from the lower 64 \xe2\x80\xa6DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa6000EaReturns a new vector where the <code>imm8</code> element of <code>a</code> is \xe2\x80\xa6E`Returns a copy of <code>a</code> with the 32-bit integer from <code>i</code> \xe2\x80\xa6E`Returns a copy of <code>a</code> with the 64-bit integer from <code>i</code> \xe2\x80\xa6DiInserts the <code>len</code> least-significant bits from the lower 64 \xe2\x80\xa6ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa6ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa6CkLoad a double-precision (64-bit) floating-point element \xe2\x80\xa6CnLoad a half-precision (16-bit) floating-point element from \xe2\x80\xa6CkLoad a single-precision (32-bit) floating-point element \xe2\x80\xa6CkMove the lower double-precision (64-bit) floating-point \xe2\x80\xa6CiMove the lower half-precision (16-bit) floating-point \xe2\x80\xa6CkMove the lower single-precision (32-bit) floating-point \xe2\x80\xa6CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa6CfCompute the square root of packed double-precision \xe2\x80\xa6CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa6CfCompute the square root of packed single-precision \xe2\x80\xa6CiCompute the square root of the lower double-precision \xe2\x80\xa6CgCompute the square root of the lower half-precision \xe2\x80\xa6CiCompute the square root of the lower single-precision \xe2\x80\xa6CjStores packed double-precision (64-bit) floating-point \xe2\x80\xa6CjStores packed single-precision (32-bit) floating-point \xe2\x80\xa6CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa6CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa6CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa6CjAdd the lower double-precision (64-bit) floating-point \xe2\x80\xa6ChAdd the lower half-precision (16-bit) floating-point \xe2\x80\xa6CjAdd the lower single-precision (32-bit) floating-point \xe2\x80\xa6CfCompute the bitwise AND of packed double-precision \xe2\x80\xa6CfCompute the bitwise AND of packed single-precision \xe2\x80\xa6CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa6ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa6CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa6CmDivide the lower double-precision (64-bit) floating-point \xe2\x80\xa6CkDivide the lower half-precision (16-bit) floating-point \xe2\x80\xa6CmDivide the lower single-precision (32-bit) floating-point \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa6ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa6543210ChMove packed double-precision (64-bit) floating-point \xe2\x80\xa6ChMove packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa6CcCompute the approximate reciprocal of the lower \xe2\x80\xa6ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa6CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa6ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa6C`Subtract the lower double-precision (64-bit) \xe2\x80\xa6CmSubtract the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Subtract the lower single-precision (32-bit) \xe2\x80\xa6CfCompute the bitwise XOR of packed double-precision \xe2\x80\xa6CfCompute the bitwise XOR of packed single-precision \xe2\x80\xa6CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa6ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa6210CnFinds the minimum unsigned 16-bit element in the 128-bit __\xe2\x80\xa6CeSet each bit of mask register k based on the most \xe2\x80\xa6ClSubtracts 8-bit unsigned integer values and computes the \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6ClMultiplies packed 16-bit signed integer values, truncate \xe2\x80\xa6EdConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa6EdConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa6ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa6DnShuffles bytes from <code>a</code> according to the content of <code>b</code>.DdStores the lower 64-bit integer <code>a</code> to a memory location.CnStore 128-bits (composed of 8 packed 16-bit integers) from \xe2\x80\xa6CnStore 128-bits (composed of 4 packed 32-bit integers) from \xe2\x80\xa6CnStore 128-bits (composed of 2 packed 64-bit integers) from \xe2\x80\xa6D`Stores 128-bits of integer data from <code>a</code> into memory.ChStores a 128-bit integer vector to a 128-bit aligned \xe2\x80\xa6C`Subtract the lower double-precision (64-bit) \xe2\x80\xa6CmSubtract the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Subtract the lower single-precision (32-bit) \xe2\x80\xa6CeReturns vector of type __m128d with indeterminate \xe2\x80\xa6DcReturn vector of type <code>__m128h</code> with indetermination \xe2\x80\xa6CdReturns vector of type __m128 with indeterminate \xe2\x80\xa6CjLoad tile configuration from a 64-byte memory location \xe2\x80\xa6CmAdd a $d_r$ differential from bidegree $(x, y)$, with the \xe2\x80\xa6CmReturns the ABI-required minimum alignment of the type of \xe2\x80\xa6ChReturns the contents of this address if it is in the \xe2\x80\xa6ClConverts an OS string slice to a byte slice.  To convert \xe2\x80\xa6DfYields a mutable reference to the underlying <code>OsString</code> \xe2\x80\xa6CfGet an exclusive reference to the value within the \xe2\x80\xa6DgGet a shared reference to the value within the <code>UnsafeCell</code>.CmA guard for unsafe functions that cannot ever be executed \xe2\x80\xa6E`Makes a <em>soundness</em> promise to the compiler that <code>cond</code> holds.BcDrops the contained value in place.DmReads the value from the <code>MaybeUninit&lt;T&gt;</code> container. The \xe2\x80\xa6DkStores a value if the current value is the same as the <code>old</code> \xe2\x80\xa6CmThis macro uses forward-mode automatic differentiation to \xe2\x80\xa6CmThis macro uses reverse-mode automatic differentiation to \xe2\x80\xa6CjReturns the value that would be obtained by taking the \xe2\x80\xa60DfBinary searches this <code>VecDeque</code> with a comparator function.CkCalculates the distance between two pointers within the \xe2\x80\xa6CjPerforms full-width multiplication and addition with a \xe2\x80\xa6CkCollects the results of the iterator into the specified \xe2\x80\xa6CeCollects this iterator into a linked list of vectors.DiStores a value into the <code>bool</code> if the current value is the \xe2\x80\xa6CkStores a value into the pointer if the current value is \xe2\x80\xa6CiStores a value into the atomic integer if the current \xe2\x80\xa6000000000210000000000BkDeallocates a memory which allocated by \xe2\x80\xa6AjSee <code>construct</code>DhCreates a <code>Formatter</code> that writes its output to the given \xe2\x80\xa6CjProvides a cursor with editing operations at the front \xe2\x80\xa6EdDivides <code>Duration</code> by <code>Duration</code> and returns <code>f32</code>.EdDivides <code>Duration</code> by <code>Duration</code> and returns <code>f64</code>.DdThe number of <code>Self::Element</code>s that fit in a single limb.CnEnsure <code>self.page_data[b.x()][b.y()][r]</code> is definedDjAssert that <code>elt</code> is in the image of the differential. Drop \xe2\x80\xa600CkSplits an iterator into fixed-size chunks, performing a \xe2\x80\xa6DeConstructs a box from a <code>NonNull</code> pointer in the given \xe2\x80\xa6DgDecode a native endian UTF-16\xe2\x80\x93encoded slice <code>v</code> into a \xe2\x80\xa6DkGiven a generator <code>(gen_deg, gen_idx)</code>, find the first index \xe2\x80\xa6AnReturns the current precision.DjAttempts to get mutable references to <code>N</code> values in the map \xe2\x80\xa6CkAttribute macro applied to a static to register it as a \xe2\x80\xa60000CeChecks whether the path ends in a trailing separator.DeReturns <code>true</code> if the new element is not within the boundsClCreates a new iterator which places an item generated by \xe2\x80\xa600000DbConverts this <code>CString</code> into a boxed <code>CStr</code>.CeConverts the vector into <code>Box&lt;[T]&gt;</code>.DgConverts a <code>Box&lt;T&gt;</code> into a <code>Box&lt;[T]&gt;</code>CkReturns an iterator which retrieves elements in heap order.DjReturns <code>true</code> if this address is in a range designated for \xe2\x80\xa60D`Returns <code>true</code> if this is an address reserved for \xe2\x80\xa6DoDetermines if <code>File</code> has an efficient <code>read_vectored</code> \xe2\x80\xa6EfDetermines if this <code>Read</code>er has an efficient <code>read_vectored</code> \xe2\x80\xa60ClReturns true for each element if it has a negative sign, \xe2\x80\xa60ClReturns true for each element if it has a positive sign, \xe2\x80\xa60ClChecks if the elements of this iterator are sorted using \xe2\x80\xa600000BiIterate over all vectors in the subspace.CkIterate the degrees and offsets of each generator up to \xe2\x80\xa6DiThis function underflows if <code>self.end == 0</code>, which happens \xe2\x80\xa6BmLoad a module specification from a JSON file.EhA parallel version of <code>extend</code>. If the <code>concurrent</code> feature is \xe2\x80\xa60CmReturns the ABI-required minimum alignment of the type of \xe2\x80\xa6DgGets the value of the <code>IP_MULTICAST_TTL</code> option for this \xe2\x80\xa6BnCreate a new zero element in the given degree.0ClConstructs a new atomically reference-counted slice with \xe2\x80\xa6CiConstructs a new boxed slice with uninitialized contents.CaConstructs a new reference-counted slice with \xe2\x80\xa62CmConstructs a new boxed slice with uninitialized contents, \xe2\x80\xa61DhFinds the next <code>Reject</code> result. See <code>next_back()</code>.ChRemoves a trailing separator from the path, if possible.CnProvides a reference computed using a closure. The referee \xe2\x80\xa6iArgumentsDhLike <code>read_at</code>, except that it reads into a slice of buffers.0ClResolves an unstable module up to an $(n, s)$ and prints \xe2\x80\xa6C`Computes massey products in $\\Mod_{C\\lambda^2}$.BoSets the read timeout to the timeout specified.0BeSets the read timeout for the socket.0BoSets whether the path has a trailing separator.CeGet the matrix of a free module homomorphism when \xe2\x80\xa6BbExtracts an element from a vector.AkReads a vector of pointers.DkComputes <code>(x*y) + z</code> for each element, non-deterministically \xe2\x80\xa6CiGets a mutable pointer to the first element of the array.BiMutably borrows i and j. Panic if i != j.DkConditionally write contiguous elements starting from <code>ptr</code>. \xe2\x80\xa6CmRemoves an element from anywhere in the deque and returns \xe2\x80\xa6CgQueries the metadata about a file without following \xe2\x80\xa60CmRounds toward zero and converts to the same-width integer \xe2\x80\xa60ChTry to cast to a pointer of another type by checking \xe2\x80\xa6CmReturns the type name of the pointed-to value as a string \xe2\x80\xa6EeReturns the contained <code>Some</code> value, consuming the <code>self</code> value,EgReturns the contained <code>Ok</code> value, consuming the <code>self</code> value, \xe2\x80\xa6CnSimultaneously waits for the child to exit and collect all \xe2\x80\xa6DjConstructs a new, empty <code>Vec&lt;T, A&gt;</code> with at least the \xe2\x80\xa6DhCreates an empty <code>BinaryHeap</code> with at least the specified \xe2\x80\xa6DhCreates an empty deque with space for at least <code>capacity</code> \xe2\x80\xa6DfConverts the cursor into a <code>CursorMutKey</code>, which allows \xe2\x80\xa60CjAn <code>AtomicIsize</code> initialized to <code>0</code>.CjAn <code>AtomicUsize</code> initialized to <code>0</code>.EeA <code>BarrierWaitResult</code> is returned by <code>Barrier::wait()</code> when \xe2\x80\xa6DfA <em>basis</em> element of a bigraded vector space. Most commonly \xe2\x80\xa6EfAssociated type for <code>&lt;[char; N] as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.EhAssociated type for <code>&lt;&amp;[char] as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.CiThe connection was aborted (terminated) by the remote \xe2\x80\xa6C`The connection was refused by the remote server.fU+0014CfA non-empty directory was specified where an empty \xe2\x80\xa6fU+0004BhAn iterator that knows its exact length.00000AgOptions for formatting.BiConverts something into an async iteratorfU+005BAiOrganization-Local scope.fU+007DAdA secondary homotopyCcSee <code>MilnorSubalgebra::iter_signatures</code>.CnAn iterator over the mutable subslices of the vector which \xe2\x80\xa6CmThe error type returned when a conversion from a slice to \xe2\x80\xa6DdError type returned by <code>CursorMut::insert_before</code> and \xe2\x80\xa60CbAn unwind action that triggers undefined behavior.CiA type indicating whether a timed wait on a condition \xe2\x80\xa6CeA marker trait for primitive types which can be zero.AkSee <code>_mm_setcsr</code>0Acsuppress exceptionsointerval [1, 2)AkDEST = NaN if sign(SRC) = 1A`sign = sign(SRC)444CjTranspose the 4x4 matrix formed by 4 rows of __m128 in \xe2\x80\xa6CiCompute the bitwise OR of 8-bit masks a and b. If the \xe2\x80\xa6CnCompute the bitwise NOT of 16-bit mask a and then AND with \xe2\x80\xa6CnCompute the bitwise NOT of 32-bit mask a and then AND with \xe2\x80\xa6CnCompute the bitwise NOT of 64-bit mask a and then AND with \xe2\x80\xa6ClCompute the bitwise AND of 16-bit masks a and  b, if the \xe2\x80\xa6ClCompute the bitwise AND of 32-bit masks a and  b, if the \xe2\x80\xa6ClCompute the bitwise AND of 64-bit masks a and  b, if the \xe2\x80\xa6EbAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.EcAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using \xe2\x80\xa6EaCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.EeCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CfNormalize the mantissas of packed double-precision \xe2\x80\xa6CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa6CfNormalize the mantissas of packed single-precision \xe2\x80\xa6DiHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> \xe2\x80\xa6DiHorizontally adds adjacent pairs of 32-bit integers in <code>a</code> \xe2\x80\xa6CnHorizontally subtract adjacent pairs of 16-bit integers in \xe2\x80\xa6CnHorizontally subtract adjacent pairs of 32-bit integers in \xe2\x80\xa6CmLoad 256-bits (composed of 8 packed 32-bit integers) from \xe2\x80\xa6CmLoad 256-bits (composed of 4 packed 64-bit integers) from \xe2\x80\xa6CkLoads 256-bits of integer data from memory into result. \xe2\x80\xa6CmLoad 256-bits (composed of 32 packed 8-bit integers) from \xe2\x80\xa6EbMultiplies packed signed 16-bit integers in <code>a</code> and <code>b</code>, \xe2\x80\xa6CnCompute the bitwise OR of packed double-precision (64-bit) \xe2\x80\xa6CnCompute the bitwise OR of packed single-precision (32-bit) \xe2\x80\xa6CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa6ClSet each packed 16-bit integer in dst to all ones or all \xe2\x80\xa6ClSet each packed 32-bit integer in dst to all ones or all \xe2\x80\xa6ClSet each packed 64-bit integer in dst to all ones or all \xe2\x80\xa6CnShuffles double-precision (64-bit) floating-point elements \xe2\x80\xa6CnShuffles single-precision (32-bit) floating-point elements \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60DhBroadcasts 16-bit integer <code>a</code> to all elements of returned \xe2\x80\xa6DhBroadcasts 32-bit integer <code>a</code> to all elements of returned \xe2\x80\xa6CkSets packed 64-bit integers in returned vector with the \xe2\x80\xa6CkSets packed 16-bit integers in returned vector with the \xe2\x80\xa6CkSets packed 32-bit integers in returned vector with the \xe2\x80\xa6CiSets packed __m256d returned vector with the supplied \xe2\x80\xa6CiSets packed __m256i returned vector with the supplied \xe2\x80\xa6CkReturns vector of type __m256d with all elements set to \xe2\x80\xa6CjReturn vector of type __m256h with all elements set to \xe2\x80\xa6CjReturns vector of type __m256 with all elements set to \xe2\x80\xa6>=DkNegates packed 16-bit integers in <code>a</code> when the corresponding \xe2\x80\xa6DkNegates packed 32-bit integers in <code>a</code> when the corresponding \xe2\x80\xa6EcShifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while \xe2\x80\xa6EcShifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while \xe2\x80\xa6EcShifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while \xe2\x80\xa6E`Shifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while \xe2\x80\xa6ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa6DfShifts packed 32-bit integers in <code>a</code> left by the amount \xe2\x80\xa6DfShifts packed 64-bit integers in <code>a</code> left by the amount \xe2\x80\xa6EdShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while \xe2\x80\xa6EdShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while \xe2\x80\xa6CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa6DgShifts packed 32-bit integers in <code>a</code> right by the amount \xe2\x80\xa6CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa654EdShifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while \xe2\x80\xa6EaShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while \xe2\x80\xa643DgShifts packed 64-bit integers in <code>a</code> right by the amount \xe2\x80\xa6DhSubtract packed 16-bit integers in <code>b</code> from packed 16-bit \xe2\x80\xa6DjSubtract packed unsigned 16-bit integers in <code>b</code> from packed \xe2\x80\xa6CfComputes the bitwise AND of 256 bits (representing \xe2\x80\xa60CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa6ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa6CgPerforms an element-by-element conversion of packed \xe2\x80\xa6ClPerforms element-by-element conversion of the lower half \xe2\x80\xa6CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CfNormalize the mantissas of packed double-precision \xe2\x80\xa6CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa6CfNormalize the mantissas of packed single-precision \xe2\x80\xa6CnLoad 512-bits (composed of 16 packed 32-bit integers) from \xe2\x80\xa6CmLoad 512-bits (composed of 8 packed 64-bit integers) from \xe2\x80\xa6CgLoad 512-bits of integer data from memory into dst. \xe2\x80\xa6CmLoad 512-bits (composed of 64 packed 8-bit integers) from \xe2\x80\xa6CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CnCompute the bitwise OR of packed double-precision (64-bit) \xe2\x80\xa6CnCompute the bitwise OR of packed single-precision (32-bit) \xe2\x80\xa6CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa6ClSet each packed 16-bit integer in dst to all ones or all \xe2\x80\xa6ClSet each packed 32-bit integer in dst to all ones or all \xe2\x80\xa6ClSet each packed 64-bit integer in dst to all ones or all \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa6DlBroadcast 32-bit integer <code>a</code> to all elements of <code>dst</code>.DlBroadcast 64-bit integer <code>a</code> to all elements of <code>dst</code>.CiSet packed 32-bit integers in dst with the repeated 4 \xe2\x80\xa6CiSet packed 64-bit integers in dst with the repeated 4 \xe2\x80\xa6DeSets packed 32-bit integers in <code>dst</code> with the supplied \xe2\x80\xa6CnSet packed 64-bit integers in dst with the supplied values \xe2\x80\xa6DhReturns vector of type <code>__m512d</code> with all elements set to \xe2\x80\xa6CjReturn vector of type __m512h with all elements set to \xe2\x80\xa6DgReturns vector of type <code>__m512</code> with all elements set to \xe2\x80\xa6>=ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa6CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa6543210CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa6CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa6CnConvert scalar BF16 (16-bit) floating point element stored \xe2\x80\xa6ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa6CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa6CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa6ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa6CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa6DhSign extend packed 8-bit integers in <code>a</code> to packed 16-bit \xe2\x80\xa6DhSign extend packed 8-bit integers in <code>a</code> to packed 32-bit \xe2\x80\xa6DjSign extend packed 8-bit integers in the low 8 bytes of <code>a</code> \xe2\x80\xa6DeZeroes extend packed unsigned 8-bit integers in <code>a</code> to \xe2\x80\xa600ClConvert packed BF16 (16-bit) floating-point even-indexed \xe2\x80\xa6CkConvert packed BF16 (16-bit) floating-point odd-indexed \xe2\x80\xa6BjCopy the lower 16-bit integer in a to dst.BmReturns the lowest element of <code>a</code>.0CkCopy 16-bit integer a to the lower elements of dst, and \xe2\x80\xa6DjReturns a vector whose lowest element is <code>a</code> and all higher \xe2\x80\xa60CgMultiply groups of 4 adjacent pairs of signed 8-bit \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CjMultiply groups of 2 adjacent pairs of unsigned 16-bit \xe2\x80\xa60ChReturns the <code>imm8</code> element of <code>a</code>.DnExtracts an 32-bit integer from <code>a</code> selected with <code>IMM8</code>DnExtracts an 64-bit integer from <code>a</code> selected with <code>IMM1</code>CmExtracts the specified bits from the lower 64 bits of the \xe2\x80\xa6CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa6CnStores 2 double-precision (64-bit) floating-point elements \xe2\x80\xa6CnStores 4 single-precision (32-bit) floating-point elements \xe2\x80\xa61CnStores 2 single-precision (32-bit) floating-point elements \xe2\x80\xa6CkMultiplies corresponding pairs of packed 8-bit unsigned \xe2\x80\xa6CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa6CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa6CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa6CiBlend packed double-precision (64-bit) floating-point \xe2\x80\xa6CgBlend packed half-precision (16-bit) floating-point \xe2\x80\xa6CiBlend packed single-precision (32-bit) floating-point \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa6CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6543210CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa6ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa6ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa6CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa6CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa610CnMove packed 8-bit integers from a into dst using writemask \xe2\x80\xa6CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa6CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa6CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa6000C`Compute the approximate reciprocal of packed \xe2\x80\xa60CcCompute the approximate reciprocal of the lower \xe2\x80\xa60ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6CiCompute the approximate reciprocal square root of the \xe2\x80\xa6CiStore packed double-precision (64-bit) floating-point \xe2\x80\xa6CiStore packed single-precision (32-bit) floating-point \xe2\x80\xa6ClStore a double-precision (64-bit) floating-point element \xe2\x80\xa6CjStore the lower half-precision (16-bit) floating-point \xe2\x80\xa6ClStore a single-precision (32-bit) floating-point element \xe2\x80\xa6CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa6ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa6ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa6CkLoad a double-precision (64-bit) floating-point element \xe2\x80\xa6CnLoad a half-precision (16-bit) floating-point element from \xe2\x80\xa6CkLoad a single-precision (32-bit) floating-point element \xe2\x80\xa6CkMove the lower double-precision (64-bit) floating-point \xe2\x80\xa6CiMove the lower half-precision (16-bit) floating-point \xe2\x80\xa6CkMove the lower single-precision (32-bit) floating-point \xe2\x80\xa6CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa6CfCompute the square root of packed double-precision \xe2\x80\xa6CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa6CfCompute the square root of packed single-precision \xe2\x80\xa6CiCompute the square root of the lower double-precision \xe2\x80\xa6CgCompute the square root of the lower half-precision \xe2\x80\xa6CiCompute the square root of the lower single-precision \xe2\x80\xa6CnReturns a mask of the most significant bit of each element \xe2\x80\xa6CeSet each bit of mask register k based on the most \xe2\x80\xa6008CnShuffles double-precision (64-bit) floating-point elements \xe2\x80\xa6CnShuffles single-precision (32-bit) floating-point elements \xe2\x80\xa6ClReduce the packed half-precision (16-bit) floating-point \xe2\x80\xa6000CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa6CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa6CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa6ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa6CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa6ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa6BoReturns a vector with all elements set to zero.EbShuffles 32-bit integers in <code>a</code> using the control in <code>IMM8</code>.CmThis is one of the two SM3 message scheduling intrinsics. \xe2\x80\xa60CmThis intrinsic performs four rounds of SM4 key expansion. \xe2\x80\xa6CiCompute the square root of the lower double-precision \xe2\x80\xa6CgCompute the square root of the lower half-precision \xe2\x80\xa6CiCompute the square root of the lower single-precision \xe2\x80\xa6DfTests whether the specified bits in <code>a</code> 128-bit integer \xe2\x80\xa6CiTests whether the specified bits in a 128-bit integer \xe2\x80\xa6ClUnpacks and interleave 8-bit integers from the high half \xe2\x80\xa6CnUnpacks and interleave 8-bit integers from the low half of \xe2\x80\xa6CiPerform matrix multiplication of two tiles containing \xe2\x80\xa60CmStores the current tile configuration to a 64-byte memory \xe2\x80\xa6BbPerforms checked integer addition.DhAdvances the cursor by asserting that <code>n</code> bytes have been \xe2\x80\xa6ChLowers in MIR to <code>Rvalue::Aggregate</code> with \xe2\x80\xa6DaExtracts the values from an array of <code>MaybeUninit</code> \xe2\x80\xa6EjReturns a <code>&amp;[Cell&lt;T&gt;; N]</code> from a <code>&amp;Cell&lt;[T; N]&gt;</code>DkEquivalent to <code>CString::as_bytes()</code> except that the returned \xe2\x80\xa6EdReturns a <code>&amp;[Cell&lt;T&gt;]</code> from a <code>&amp;Cell&lt;[T]&gt;</code>CmA guard for unsafe functions that cannot ever be executed \xe2\x80\xa6CkDivides an iterator into sequential blocks of the given \xe2\x80\xa6CcThe pivot columns of the complement to the subspaceChSelects which function to call depending on the context.DcSame as <code>format_args</code>, but can be used in some const \xe2\x80\xa6CeConverts a general element into a string for display.0ClGives the name of an element. The default implementation \xe2\x80\xa601ChExposes the \xe2\x80\x9cprovenance\xe2\x80\x9d part of the pointer for \xe2\x80\xa60000DcClones and appends all elements in a slice to the <code>Vec</code>.CjReturns the value that would be obtained by taking the \xe2\x80\xa60DhCreates a new instance of an <code>Error</code> from a particular OS \xe2\x80\xa6DoCreates a <code>Vec&lt;T, A&gt;</code> directly from a pointer, a length, a \xe2\x80\xa6DdCreates an ASCII character from the byte <code>b</code>, without \xe2\x80\xa6CoAttempts to converts a Vec&lt;u8&gt; to a <code>CString</code>.DkReads from indices in <code>slice</code> to construct a SIMD vector. If \xe2\x80\xa6ClConditionally read elementwise from pointers into a SIMD \xe2\x80\xa6DfGet read-write access to the contents of an <code>UnsafePinned</code>.DhReturns a mutable reference into the given <code>Arc</code>, without \xe2\x80\xa6DkReturns a mutable reference into the given <code>Rc</code>, without any \xe2\x80\xa6DeGets a mutable reference to the data inside of this <code>Pin</code>.ClReturns a raw pointer to an element or subslice, without \xe2\x80\xa6CmReturns a mutable pointer to the output at this location, \xe2\x80\xa6CjSet the pivots to -1 in every entry. This is called by \xe2\x80\xa6DdConverts this <code>OsString</code> into a boxed <code>OsStr</code>.DkReturns <code>true</code> if the address is a globally routable unicast \xe2\x80\xa6E`Determines if <code>File</code> has an efficient <code>write_vectored</code> \xe2\x80\xa6EgDetermines if this <code>Write</code>r has an efficient <code>write_vectored</code> \xe2\x80\xa60CmIterate through all nonzero bidegrees in increasing order \xe2\x80\xa6DaExecutes an operation of the <code>IP_ADD_MEMBERSHIP</code> type.DcExecutes an operation of the <code>IPV6_ADD_MEMBERSHIP</code> type.CcConstructs a new pin by mapping the interior value.BgPerforms checked integer multiplicationDhGets the value of the <code>IP_MULTICAST_LOOP</code> option for this \xe2\x80\xa6DjGets the value of the <code>IPV6_MULTICAST_LOOP</code> option for this \xe2\x80\xa6CnReturns the smallest power of two greater than or equal to \xe2\x80\xa600000DiEmits a <code>nontemporal</code> store, which gives a hint to the CPU \xe2\x80\xa6CdGiven a module specification string, load a json \xe2\x80\xa6Bax -&gt; y -&gt; permanent_classes0BfAdds a trailing separator to the path.CkQuery the user for a module and its save directory. See \xe2\x80\xa6ChReads the exact number of bytes required to fill the \xe2\x80\xa60BiComputes products in $\\Mod_{C\\lambda^2}$.C`Sets the write timeout to the timeout specified.0BfSets the write timeout for the socket.0ClCalculates the offset from a pointer vector elementwise, \xe2\x80\xa6AoWrites to a vector of pointers.BdPerforms checked integer subtractionCmRemoves an element from anywhere in the deque and returns \xe2\x80\xa6CjDoes a three-way comparison between the two arguments, \xe2\x80\xa6CiConverts this C string to a byte slice containing the \xe2\x80\xa6CdTrims a trailing separator from a path, if possible.EeExecutes a fallible <code>OP</code> on a value returned by <code>init</code> with \xe2\x80\xa6EfExecutes a fallible <code>OP</code> on the given <code>init</code> value with each \xe2\x80\xa6CbThe checked version of <code>from_secs_f32</code>.CbThe checked version of <code>from_secs_f64</code>.DiConstructs a new <code>Arc</code> with uninitialized contents, in the \xe2\x80\xa6CkConstructs a new box with uninitialized contents in the \xe2\x80\xa6DhConstructs a new <code>Rc</code> with uninitialized contents, in the \xe2\x80\xa6DkConstructs a new <code>Arc</code> with uninitialized contents, with the \xe2\x80\xa6DkConstructs a new <code>Box</code> with uninitialized contents, with the \xe2\x80\xa6DjConstructs a new <code>Rc</code> with uninitialized contents, with the \xe2\x80\xa6CfTries to reserve the minimum capacity for at least \xe2\x80\xa6DhInvokes <code>try_reserve_exact</code> on the underlying instance of \xe2\x80\xa61111EaConstructs a new, empty <code>Vec&lt;T&gt;</code> with at least the specified \xe2\x80\xa6DhCreates an empty deque with space for at least <code>capacity</code> \xe2\x80\xa6DgCreates a new empty <code>String</code> with at least the specified \xe2\x80\xa6CkReturns the contained <code>Some</code> value or a default.ChReturns the contained <code>Ok</code> value or a defaultCnEnsures that a path has a trailing separator, allocating a \xe2\x80\xa6DiRuns the given closure with a <code>BorrowedBuf</code> containing the \xe2\x80\xa6DeLike <code>write_at</code>, except that it writes from a slice of \xe2\x80\xa60DhUsed to create a default <code>BuildHasher</code> instance for types \xe2\x80\xa6fU+0013AhExecutable file is busy.CmScope of an IPv6 multicast address as defined in IETF RFC \xe2\x80\xa6BnBy-value <code>RangeInclusive</code> iterator.ClThe primary separator of path components for the current \xe2\x80\xa6BiA mutable view of a tile within a matrix.CkA trait that represents a homomorphism between two modules.CmThe differential with Nassau\xe2\x80\x99s algorithm. This does not \xe2\x80\xa6ChThe network containing the remote host is not reachable.DfAn internal helper for <code>split_off</code> functions indicating \xe2\x80\xa6BfTwo indices provided were overlapping.E`For any integer <code>i</code> less than or equal to <code>MAX_PRIME</code>, \xe2\x80\xa60CnThe filesystem or storage medium is read-only, but a write \xe2\x80\xa6CfAn RAII implementation of a \xe2\x80\x9cscoped lock\xe2\x80\x9d of a \xe2\x80\xa6fU+005DAcSecondary compositeDaA homotopy of a map A -&gt; M of pair modules. We assume this \xe2\x80\xa6CcAn iterator that iterates through a sequence of \xe2\x80\xa6ChStatically guarantees that a lane count is marked as \xe2\x80\xa6AkSee <code>_mm_setcsr</code>00htruncateAainterval [0.5, 1)Aainterval [0.5, 2)hsign = 04EgReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>\xe2\x80\xa6CjCompute the bitwise OR of 16-bit masks a and b. If the \xe2\x80\xa6CjCompute the bitwise OR of 32-bit masks a and b. If the \xe2\x80\xa6CjCompute the bitwise OR of 64-bit masks a and b. If the \xe2\x80\xa6CiCompute the bitwise OR of 8-bit masks a and b. If the \xe2\x80\xa60EdConcatenates pairs of 16-byte blocks in <code>a</code> and <code>b</code> into a \xe2\x80\xa6CiConvert scalar half-precision (16-bit) floating-point \xe2\x80\xa6EfBlends packed 16-bit integers from <code>a</code> and <code>b</code> using control \xe2\x80\xa6EfBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control \xe2\x80\xa6ElBlends packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>.CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6EbCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.EbCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.EbCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality.DlCompares packed 16-bit integers in <code>a</code> and <code>b</code> for \xe2\x80\xa6DlCompares packed 32-bit integers in <code>a</code> and <code>b</code> for \xe2\x80\xa6DlCompares packed 64-bit integers in <code>a</code> and <code>b</code> for \xe2\x80\xa6ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa6CoConverts packed 32-bit integers in <code>a</code> to packed \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa61ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6ClConverts packed double-precision (64-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600333333ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa6333CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa6CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa6CnMultiplies packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6CnMultiplies packed single-precision (32-bit) floating-point \xe2\x80\xa6210DiHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> \xe2\x80\xa6CnHorizontally subtract adjacent pairs of 16-bit integers in \xe2\x80\xa6EfCopies <code>a</code> to result, and inserts the 8-bit integer <code>i</code> into \xe2\x80\xa6CmCopy a to dst, then insert 128 bits (composed of 4 packed \xe2\x80\xa6CmCopy a to dst, then insert 128 bits (composed of 2 packed \xe2\x80\xa610CmLoads 256-bits of integer data from unaligned memory into \xe2\x80\xa6CbLoads two 128-bit values (composed of 4 packed \xe2\x80\xa6CnLoad 256-bits (composed of 16 packed 16-bit integers) from \xe2\x80\xa6CmLoad 256-bits (composed of 8 packed 32-bit integers) from \xe2\x80\xa6CmLoad 256-bits (composed of 4 packed 64-bit integers) from \xe2\x80\xa6CkLoads 256-bits of integer data from memory into result. \xe2\x80\xa6CiCounts the number of leading zero bits in each packed \xe2\x80\xa60CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa6CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa6CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa6CfCompute the bitwise AND of packed double-precision \xe2\x80\xa6CfCompute the bitwise AND of packed single-precision \xe2\x80\xa6CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa6ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa6CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChMove packed double-precision (64-bit) floating-point \xe2\x80\xa6ChMove packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa6ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa6CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa6ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa6CfCompute the bitwise XOR of packed double-precision \xe2\x80\xa6CfCompute the bitwise XOR of packed single-precision \xe2\x80\xa6CiLoads packed double-precision (64-bit) floating-point \xe2\x80\xa6CiLoads packed single-precision (32-bit) floating-point \xe2\x80\xa6CnCompute the bitwise OR of packed double-precision (64-bit) \xe2\x80\xa6CnCompute the bitwise OR of packed single-precision (32-bit) \xe2\x80\xa6CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa6CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa6ChSets each bit of the returned mask based on the most \xe2\x80\xa60EeMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producingEhMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, \xe2\x80\xa61EeMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, producingEcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa6EdConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa6EdConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa6DhBroadcasts 64-bit integer <code>a</code> to all elements of returned \xe2\x80\xa6CkSets packed 64-bit integers in returned vector with the \xe2\x80\xa6CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa6210CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa6210CnStore 256-bits (composed of 8 packed 32-bit integers) from \xe2\x80\xa6CnStore 256-bits (composed of 4 packed 64-bit integers) from \xe2\x80\xa6DdStores 256-bits of integer data from <code>a</code> into memory. \xe2\x80\xa6CnStore 256-bits (composed of 32 packed 8-bit integers) from \xe2\x80\xa6CnComputes the bitwise AND of 256 bits (representing integer \xe2\x80\xa60CdUnpacks and interleave double-precision (64-bit) \xe2\x80\xa6CdUnpacks and interleave single-precision (32-bit) \xe2\x80\xa610CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000002222CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa6CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmCopy a to dst, then insert 128 bits (composed of 4 packed \xe2\x80\xa6CmCopy a to dst, then insert 256 bits (composed of 8 packed \xe2\x80\xa6CmCopy a to dst, then insert 128 bits (composed of 2 packed \xe2\x80\xa6CmCopy a to dst, then insert 256 bits (composed of 4 packed \xe2\x80\xa63210CnLoad 512-bits (composed of 32 packed 16-bit integers) from \xe2\x80\xa6CnLoad 512-bits (composed of 16 packed 32-bit integers) from \xe2\x80\xa6CmLoad 512-bits (composed of 8 packed 64-bit integers) from \xe2\x80\xa6CgLoad 512-bits of integer data from memory into dst. \xe2\x80\xa6CiCounts the number of leading zero bits in each packed \xe2\x80\xa60ClFinds the absolute value of each packed double-precision \xe2\x80\xa6ClFinds the absolute value of each packed single-precision \xe2\x80\xa6CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa6CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa6CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa6CfCompute the bitwise AND of packed double-precision \xe2\x80\xa6CfCompute the bitwise AND of packed single-precision \xe2\x80\xa6CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa6ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa6CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChMove packed double-precision (64-bit) floating-point \xe2\x80\xa6ChMove packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa6ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa6CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa6ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa6CfCompute the bitwise XOR of packed double-precision \xe2\x80\xa6CfCompute the bitwise XOR of packed single-precision \xe2\x80\xa6CnCompute the bitwise OR of packed double-precision (64-bit) \xe2\x80\xa6CnCompute the bitwise OR of packed single-precision (32-bit) \xe2\x80\xa6CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa6CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa6CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa6ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa6CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa6CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa6EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa6CiSet packed 32-bit integers in dst with the repeated 4 \xe2\x80\xa6CiSet packed 64-bit integers in dst with the repeated 4 \xe2\x80\xa6CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa6210CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa6210CjStore 512-bits (composed of 16 packed 32-bit integers) \xe2\x80\xa6CnStore 512-bits (composed of 8 packed 64-bit integers) from \xe2\x80\xa6CfStore 512-bits of integer data from a into memory. \xe2\x80\xa6CnStore 512-bits (composed of 64 packed 8-bit integers) from \xe2\x80\xa6CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa6CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa610DfDecrypt 10 rounds of unsigned 8-bit integers in <code>input</code> \xe2\x80\xa6DfDecrypt 14 rounds of unsigned 8-bit integers in <code>input</code> \xe2\x80\xa6DfEncrypt 10 rounds of unsigned 8-bit integers in <code>input</code> \xe2\x80\xa6DfEncrypt 14 rounds of unsigned 8-bit integers in <code>input</code> \xe2\x80\xa6C`Broadcasts the low double-precision (64-bit) \xe2\x80\xa6C`Broadcasts the low single-precision (32-bit) \xe2\x80\xa6CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa6ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa6ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa6ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa6CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa6CmTest each 32-bit element of a for equality with all other \xe2\x80\xa6CmTest each 64-bit element of a for equality with all other \xe2\x80\xa6CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa60DiSign extend packed 16-bit integers in <code>a</code> to packed 32-bit \xe2\x80\xa6DiSign extend packed 16-bit integers in <code>a</code> to packed 64-bit \xe2\x80\xa6ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa6DiSign extend packed 32-bit integers in <code>a</code> to packed 64-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa6DfZeroes extend packed unsigned 16-bit integers in <code>a</code> to \xe2\x80\xa60DfZeroes extend packed unsigned 32-bit integers in <code>a</code> to \xe2\x80\xa6CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa6BmReturns the lowest element of <code>a</code>.DjReturns a vector whose lowest element is <code>a</code> and all higher \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6210ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa6CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6765210765CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa6CfCompute the absolute value of packed signed 32-bit \xe2\x80\xa6CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa6ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa6CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa6CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa6CjPerforms element-by-element bitwise AND between packed \xe2\x80\xa6CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa6CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa6CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa6CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa6CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa6CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa6CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa6CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6543210ChConvert the exponent of each packed double-precision \xe2\x80\xa6CfConvert the exponent of each packed half-precision \xe2\x80\xa6ChConvert the exponent of each packed single-precision \xe2\x80\xa6CfConvert the exponent of the lower double-precision \xe2\x80\xa6CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa6CfConvert the exponent of the lower single-precision \xe2\x80\xa6CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa6543210CeMove packed 16-bit integers from a into dst using \xe2\x80\xa6CmMove packed 32-bit integers from a to dst using writemask \xe2\x80\xa6CmMove packed 64-bit integers from a to dst using writemask \xe2\x80\xa6ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa6CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa6CkExtract the reduced argument of packed double-precision \xe2\x80\xa6CiExtract the reduced argument of packed half-precision \xe2\x80\xa6CkExtract the reduced argument of packed single-precision \xe2\x80\xa6CnExtract the reduced argument of the lower double-precision \xe2\x80\xa6ClExtract the reduced argument of the lower half-precision \xe2\x80\xa6CnExtract the reduced argument of the lower single-precision \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6200CjBroadcast 8-bit integer a to all elements of dst using \xe2\x80\xa6CiShift packed 16-bit integers in a left by count while \xe2\x80\xa6CiShift packed 32-bit integers in a left by count while \xe2\x80\xa6CiShift packed 64-bit integers in a left by count while \xe2\x80\xa6CjShift packed 16-bit integers in a right by count while \xe2\x80\xa6CjShift packed 32-bit integers in a right by count while \xe2\x80\xa6CjShift packed 64-bit integers in a right by count while \xe2\x80\xa6210CiStore packed double-precision (64-bit) floating-point \xe2\x80\xa6CiStore packed single-precision (32-bit) floating-point \xe2\x80\xa6CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa6CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa6CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa6CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa6ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa6CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa6CgLoads packed 32-bit integers from memory pointed by \xe2\x80\xa6CgLoads packed 64-bit integers from memory pointed by \xe2\x80\xa6CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa6CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa6CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa6CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6543210CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa6ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa6ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa6CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa6CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa610CmMove packed 8-bit integers from a into dst using zeromask \xe2\x80\xa6CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa6CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa6CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa6000C`Compute the approximate reciprocal of packed \xe2\x80\xa60CcCompute the approximate reciprocal of the lower \xe2\x80\xa60ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6CiCompute the approximate reciprocal square root of the \xe2\x80\xa6CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa6CnShuffle half-precision (16-bit) floating-point elements in \xe2\x80\xa666ChReduce the packed 8-bit integers in a by bitwise OR. \xe2\x80\xa6CjPerforms an intermediate calculation for the next four \xe2\x80\xa6CiPerforms the final calculation for the next four SHA1 \xe2\x80\xa6ClThe intrinsic performs two rounds of SM3 operation using \xe2\x80\xa6CnThis intrinsic performs four rounds of SM4 encryption. The \xe2\x80\xa6CiTests whether the specified bits in a 128-bit integer \xe2\x80\xa6CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa6CmUnpacks and interleave 16-bit integers from the high half \xe2\x80\xa6CmUnpacks and interleave 32-bit integers from the high half \xe2\x80\xa6CmUnpacks and interleave 64-bit integers from the high half \xe2\x80\xa6ClUnpacks and interleave 16-bit integers from the low half \xe2\x80\xa6ClUnpacks and interleave 32-bit integers from the low half \xe2\x80\xa6ClUnpacks and interleave 64-bit integers from the low half \xe2\x80\xa6CmLoad tile rows from memory specifieid by base address and \xe2\x80\xa6EaProduces a padded augmented matrix from an <code>&amp;[Vec&lt;u32&gt;]</code> \xe2\x80\xa6CjReturns the value that would be obtained by taking the \xe2\x80\xa60AjSee <code>construct</code>ClReturns the value of the discriminant for the variant in \xe2\x80\xa6DmDowncasts the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a concrete \xe2\x80\xa6BeDowncasts the box to a concrete type.00D`Downcasts the <code>Rc&lt;dyn Any&gt;</code> to a concrete type.DfGiven a range <code>src</code>, clones a slice of elements in that \xe2\x80\xa6DeCopies elements from <code>src</code> range to the end of the string.ChCreates a Unix socket address in the abstract namespace.CdConverts a vector of integers to a mask, where 0 \xe2\x80\xa6BkForms a mutable slice from a pointer range.CfConverts a mutable reference to a non-zero mutable \xe2\x80\xa6DjPerforms the same functionality as <code>from_raw_parts</code>, except \xe2\x80\xa60D`Creates a <code>&amp;mut str</code> from a pointer and a length.DnConverts a <code>u32</code> to a <code>char</code>, ignoring validity. Use \xe2\x80\xa6E`Decode a UTF-16BE\xe2\x80\x93encoded slice <code>v</code> into a <code>String</code>, \xe2\x80\xa6E`Decode a UTF-16LE\xe2\x80\x93encoded slice <code>v</code> into a <code>String</code>, \xe2\x80\xa6CmCreates a C-compatible string by consuming a byte vector, \xe2\x80\xa6CbFind the block corresponding to a given generator.Dcdegree -&gt; internal_gen_idx -&gt; the offset of the generator \xe2\x80\xa600000DiInserts a value computed from <code>f</code> into the option if it is \xe2\x80\xa6DjInserts a value computed from <code>f</code> into the set if the given \xe2\x80\xa60CnGet the values of the homomorphism on the specified inputs \xe2\x80\xa6BbSignals a memory allocation error.DjConverts the <code>OsString</code> into a byte vector.  To convert the \xe2\x80\xa6DbReturns <code>self</code> with only the least significant bit set.00000000000DbExecutes an operation of the <code>IP_DROP_MEMBERSHIP</code> type.DdExecutes an operation of the <code>IPV6_DROP_MEMBERSHIP</code> type.CdWhether we should keep the quasi-inverses of the \xe2\x80\xa600CnComputes algebraic Mahowald invariants (aka algebraic root \xe2\x80\xa6CkEnsures a value is in the entry by inserting, if empty, \xe2\x80\xa60DkReturns the amount of padding we must insert after <code>self</code> to \xe2\x80\xa6DfReorders the elements of this iterator <em>in-place</em> according \xe2\x80\xa600000DjThe <code>prefetch</code> intrinsic is a hint to the code generator to \xe2\x80\xa6CmProvides a value or other type with only static lifetimes \xe2\x80\xa6DnSee documentation of <code>&lt;*const T&gt;::guaranteed_eq</code> for details.CjProject the vector onto the complement of the quotient \xe2\x80\xa6ChConditionally write pointers elementwise into a SIMD \xe2\x80\xa6ChChanges the timestamps of the file or symlink at the \xe2\x80\xa6CkReturns the remaining spare capacity of the vector as a \xe2\x80\xa6DgReturns vector content as a slice of <code>T</code>, along with the \xe2\x80\xa6CfThe dimension of the subspace part of the subquotient.CiReturns a copy of this string where each character is \xe2\x80\xa6CeMakes a copy of the value in its ASCII lower case \xe2\x80\xa61CeMakes a copy of the value in its ASCII upper case \xe2\x80\xa6DfConverts this address to an IPv4-compatible <code>IPv6</code> address.DdCreates a new <code>OwnedFd</code> instance that shares the same \xe2\x80\xa6CgReturns the unpaired surrogate which caused this error.ChWaits on this condition variable for a notification, \xe2\x80\xa60CkCreates a pointer with the given address and no provenance.0CjConverts an address to a pointer without giving it any \xe2\x80\xa6000CdAttempts to write multiple buffers into this writer.0AoProgram argument list too long.CnA bounded chain complex is a chain complex C for which C_s \xe2\x80\xa6fU+0009AjThe default random source.CbAn iterator able to yield elements from both ends.00000DhA marker trait to express that a <code>ReverseSearcher</code> can be \xe2\x80\xa6CfAn error indicating that a nul byte was not in the \xe2\x80\xa60CiThe error type returned by <code>get_disjoint_mut</code>.CmA mutable non-contiguous view of a 64 x 64 block within a \xe2\x80\xa6fU+0015ClThis is $\\mathbb{RP}_{\\mathrm{min}}^{\\mathrm{max}}$. The \xe2\x80\xa60CeRequired trait for constants used in pattern matches.CgA lazy iterator producing elements in the symmetric \xe2\x80\xa60DdDetails of the allocation that caused a <code>TryReserveError</code>AkSee <code>_mm_setcsr</code>0BhSee <code>_MM_GET_FLUSH_ZERO_MODE</code>EhFor each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em>CjCompute the bitwise OR of 16-bit masks a and b. If the \xe2\x80\xa6CjCompute the bitwise OR of 32-bit masks a and b. If the \xe2\x80\xa6CjCompute the bitwise OR of 64-bit masks a and b. If the \xe2\x80\xa6210CnConcatenate a and b into a 64-byte immediate result, shift \xe2\x80\xa60CnComputes the bitwise NOT of 256 bits (representing integer \xe2\x80\xa6CiBroadcasts 128 bits from memory (composed of 2 packed \xe2\x80\xa6CiBroadcasts 128 bits from memory (composed of 4 packed \xe2\x80\xa6CiBroadcasts a double-precision (64-bit) floating-point \xe2\x80\xa6CiBroadcasts a single-precision (32-bit) floating-point \xe2\x80\xa6E`Shifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while \xe2\x80\xa6EaShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while \xe2\x80\xa6BmCasts vector of type __m256d to type __m256i.DoCast vector of type <code>__m256h</code> to type <code>__m256i</code>. This \xe2\x80\xa6BlCasts vector of type __m256 to type __m256i.BmCasts vector of type __m256i to type __m256d.DoCast vector of type <code>__m256i</code> to type <code>__m256h</code>. This \xe2\x80\xa6BlCasts vector of type __m256i to type __m256.CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6ClConverts packed double-precision (64-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa6444CgMultiply groups of 4 adjacent pairs of signed 8-bit \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CjMultiply groups of 2 adjacent pairs of unsigned 16-bit \xe2\x80\xa60EdExtracts an 8-bit integer from <code>a</code>, selected with <code>INDEX</code>. \xe2\x80\xa6DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa6000EgCopies <code>a</code> to result, and inserts the 16-bit integer <code>i</code> into \xe2\x80\xa6EgCopies <code>a</code> to result, and inserts the 32-bit integer <code>i</code> into \xe2\x80\xa6EfCopies <code>a</code> to result, and insert the 64-bit integer <code>i</code> into \xe2\x80\xa6CbLoads two 128-bit values (composed of 2 packed \xe2\x80\xa6ClLoads two 128-bit values (composed of integer data) from \xe2\x80\xa6ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa6ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa6CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6CfCompute the square root of packed double-precision \xe2\x80\xa6CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa6CfCompute the square root of packed single-precision \xe2\x80\xa6CjStores packed double-precision (64-bit) floating-point \xe2\x80\xa6CjStores packed single-precision (32-bit) floating-point \xe2\x80\xa6CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa6CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa6CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa6CfCompute the bitwise AND of packed double-precision \xe2\x80\xa6CfCompute the bitwise AND of packed single-precision \xe2\x80\xa6CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa6ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa6CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChMove packed double-precision (64-bit) floating-point \xe2\x80\xa6ChMove packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa6ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa6CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa6ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa6CfCompute the bitwise XOR of packed double-precision \xe2\x80\xa6CfCompute the bitwise XOR of packed single-precision \xe2\x80\xa6CeSet each bit of mask register k based on the most \xe2\x80\xa6CfComputes the sum of absolute differences (SADs) of \xe2\x80\xa6EeMultiplies packed 16-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa6EdConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa6EdConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa6ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa6DnShuffles bytes from <code>a</code> according to the content of <code>b</code>.CnStores the high and low 128-bit halves (each composed of 4 \xe2\x80\xa6CjStore 256-bits (composed of 16 packed 16-bit integers) \xe2\x80\xa6CnStore 256-bits (composed of 8 packed 32-bit integers) from \xe2\x80\xa6CnStore 256-bits (composed of 4 packed 64-bit integers) from \xe2\x80\xa6DdStores 256-bits of integer data from <code>a</code> into memory. \xe2\x80\xa6CiMoves integer data from a 256-bit integer vector to a \xe2\x80\xa6DhReturns vector of type <code>__m256d</code> with indeterminate elements.DcReturn vector of type <code>__m256h</code> with indetermination \xe2\x80\xa6DkReturns vector of type <code>__m256</code> with indeterminate elements. \xe2\x80\xa6CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa6CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa6CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa6CiConcatenate a and b into a 128-byte immediate result, \xe2\x80\xa60CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa6CkCompute the bitwise NOT of 512 bits (composed of packed \xe2\x80\xa6CmCompute the bitwise NOT of 512 bits (representing integer \xe2\x80\xa6CnShift 128-bit lanes in a left by imm8 bytes while shifting \xe2\x80\xa6CfShift 128-bit lanes in a right by imm8 bytes while \xe2\x80\xa6CeCast vector of type __m512d to type __m512i. This \xe2\x80\xa6DoCast vector of type <code>__m512h</code> to type <code>__m512i</code>. This \xe2\x80\xa6CnCast vector of type __m512 to type __m512i. This intrinsic \xe2\x80\xa6CeCast vector of type __m512i to type __m512d. This \xe2\x80\xa6DoCast vector of type <code>__m512i</code> to type <code>__m512h</code>. This \xe2\x80\xa6CnCast vector of type __m512i to type __m512. This intrinsic \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000002222CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa6ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa6CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa6CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6ClGather double-precision (64-bit) floating-point elements \xe2\x80\xa6ClGather single-precision (32-bit) floating-point elements \xe2\x80\xa610ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa6ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa6CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6CfCompute the square root of packed double-precision \xe2\x80\xa6CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa6CfCompute the square root of packed single-precision \xe2\x80\xa6CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa6CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa6CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa6CfCompute the bitwise AND of packed double-precision \xe2\x80\xa6CfCompute the bitwise AND of packed single-precision \xe2\x80\xa6CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa6ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa6CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChMove packed double-precision (64-bit) floating-point \xe2\x80\xa6ChMove packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa6ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa6CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa6ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa6CfCompute the bitwise XOR of packed double-precision \xe2\x80\xa6CfCompute the bitwise XOR of packed single-precision \xe2\x80\xa6=<;=<;CeSet each bit of mask register k based on the most \xe2\x80\xa6987CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CnMultiplies elements in packed 64-bit integer vectors a and \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa6CkShuffle packed 8-bit integers in a according to shuffle \xe2\x80\xa6CjStore 512-bits (composed of 32 packed 16-bit integers) \xe2\x80\xa6CjStore 512-bits (composed of 16 packed 32-bit integers) \xe2\x80\xa6CnStore 512-bits (composed of 8 packed 64-bit integers) from \xe2\x80\xa6CfStore 512-bits of integer data from a into memory. \xe2\x80\xa6CmStore 512-bits of integer data from a into memory using a \xe2\x80\xa6ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa6CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa6ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa6DhReturns vector of type <code>__m512d</code> with indeterminate elements.DcReturn vector of type <code>__m512h</code> with indetermination \xe2\x80\xa6DkReturns vector of type <code>__m512</code> with indeterminate elements. \xe2\x80\xa6CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa6DfBroadcasts the low packed 8-bit integer from <code>a</code> to all \xe2\x80\xa6CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa6CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa610101010CkConvert the signed 32-bit integer b to a half-precision \xe2\x80\xa6CmConvert the signed 32-bit integer b to a single-precision \xe2\x80\xa6CmConvert the signed 64-bit integer b to a double-precision \xe2\x80\xa6CkConvert the signed 64-bit integer b to a half-precision \xe2\x80\xa6CmConvert the signed 64-bit integer b to a single-precision \xe2\x80\xa6CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa6CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa600ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa60002222CmConvert the unsigned 32-bit integer b to a half-precision \xe2\x80\xa6BnConvert the unsigned 32-bit integer b to a \xe2\x80\xa6BnConvert the unsigned 64-bit integer b to a \xe2\x80\xa6CmConvert the unsigned 64-bit integer b to a half-precision \xe2\x80\xa61CkConvert packed single precision (32-bit) floating-point \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa6CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6210ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa6CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa6ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa6CkTest the lower double-precision (64-bit) floating-point \xe2\x80\xa6CiTest the lower half-precision (16-bit) floating-point \xe2\x80\xa6CkTest the lower single-precision (32-bit) floating-point \xe2\x80\xa6CfConvert the exponent of the lower double-precision \xe2\x80\xa6CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa6CfConvert the exponent of the lower single-precision \xe2\x80\xa6DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa6000CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6>ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6543210CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa6ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa6CjBlend packed 8-bit integers from a and b using control \xe2\x80\xa6CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CiMultiply the lower complex number in a by the complex \xe2\x80\xa6CfNormalize the mantissas of packed double-precision \xe2\x80\xa6CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa6CfNormalize the mantissas of packed single-precision \xe2\x80\xa6CiNormalize the mantissas of the lower double-precision \xe2\x80\xa6CgNormalize the mantissas of the lower half-precision \xe2\x80\xa6CiNormalize the mantissas of the lower single-precision \xe2\x80\xa6CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa6CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa6CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CiCompute the approximate reciprocal square root of the \xe2\x80\xa60CkBroadcast 16-bit integer a to all elements of dst using \xe2\x80\xa6CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa6CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa687ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa6CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa6543210CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa6CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa6DgConditionally store 8-bit integer elements from <code>a</code> into \xe2\x80\xa6DiStores packed 32-bit integers from <code>a</code> into memory pointed \xe2\x80\xa6DiStores packed 64-bit integers from <code>a</code> into memory pointed \xe2\x80\xa6CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa6CfCompute the absolute value of packed signed 32-bit \xe2\x80\xa6CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa6ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa6CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa6CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa6CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa6CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa6CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa6CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa6CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa6CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa6CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa6CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6543210ChConvert the exponent of each packed double-precision \xe2\x80\xa6CfConvert the exponent of each packed half-precision \xe2\x80\xa6ChConvert the exponent of each packed single-precision \xe2\x80\xa6CfConvert the exponent of the lower double-precision \xe2\x80\xa6CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa6CfConvert the exponent of the lower single-precision \xe2\x80\xa6CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa6543210CnMove packed 16-bit integers from a into dst using zeromask \xe2\x80\xa6CnMove packed 32-bit integers from a into dst using zeromask \xe2\x80\xa6CnMove packed 64-bit integers from a into dst using zeromask \xe2\x80\xa6ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa6CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa6CkExtract the reduced argument of packed double-precision \xe2\x80\xa6CiExtract the reduced argument of packed half-precision \xe2\x80\xa6CkExtract the reduced argument of packed single-precision \xe2\x80\xa6CnExtract the reduced argument of the lower double-precision \xe2\x80\xa6ClExtract the reduced argument of the lower half-precision \xe2\x80\xa6CnExtract the reduced argument of the lower single-precision \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6200CjBroadcast 8-bit integer a to all elements of dst using \xe2\x80\xa6CiShift packed 16-bit integers in a left by count while \xe2\x80\xa6CiShift packed 32-bit integers in a left by count while \xe2\x80\xa6CiShift packed 64-bit integers in a left by count while \xe2\x80\xa6CjShift packed 16-bit integers in a right by count while \xe2\x80\xa6CjShift packed 32-bit integers in a right by count while \xe2\x80\xa6CjShift packed 64-bit integers in a right by count while \xe2\x80\xa6210CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa6CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa6CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa6CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa6ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa6CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CnShuffle half-precision (16-bit) floating-point elements in \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CnReduce the packed 8-bit integers in a by addition. Returns \xe2\x80\xa6CiReduce the packed 8-bit integers in a by bitwise AND. \xe2\x80\xa6CmReduce the packed 8-bit integers in a by maximum. Returns \xe2\x80\xa6CnReduce the packed unsigned 8-bit integers in a by maximum. \xe2\x80\xa6CmReduce the packed 8-bit integers in a by minimum. Returns \xe2\x80\xa6CnReduce the packed unsigned 8-bit integers in a by minimum. \xe2\x80\xa6ClReduce the packed 8-bit integers in a by multiplication. \xe2\x80\xa6CiReduce the packed 16-bit integers in a by bitwise OR. \xe2\x80\xa6CnExtract the reduced argument of the lower double-precision \xe2\x80\xa6ClExtract the reduced argument of the lower half-precision \xe2\x80\xa6CnExtract the reduced argument of the lower single-precision \xe2\x80\xa6CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60ChCalculate SHA1 state variable E after four rounds of \xe2\x80\xa6CkPerforms four rounds of SHA1 operation using an initial \xe2\x80\xa6DhShuffles 16-bit integers in the high 64 bits of <code>a</code> using \xe2\x80\xa6DkShuffles 16-bit integers in the low 64 bits of <code>a</code> using the \xe2\x80\xa6CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa6CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa6CeReturns vector of type __m128i with indeterminate \xe2\x80\xa6gReturnsCmAttribute macro applied to a function to register it as a \xe2\x80\xa60000ChAttempt to apply quasi inverse to the input. Returns \xe2\x80\xa6CkApply the quasi-inverse of the (s, t)th differential to \xe2\x80\xa6BiGenerate an arbitrary row-reduced matrix.CeReturns a unique reference to a slice of possibly \xe2\x80\xa6kAsync drop.EcCreates a new mask from the elements of <code>first</code> and <code>second</code>.BkThis is an accidentally-stable alias to \xe2\x80\xa6FiCopies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>dst</code>. The \xe2\x80\xa6DgEnsure <code>self.differentials[b.x()][b.y()][r]</code> is defined. \xe2\x80\xa6CnExtend the resolution homomorphism such that it is defined \xe2\x80\xa6CmCreates a C string wrapper from a byte slice with exactly \xe2\x80\xa6CgConverts a slice of bytes to a string slice without \xe2\x80\xa6DhConverts a vector of bytes to a <code>String</code> without checking \xe2\x80\xa6B`Returns the name of a generator.00CkChecks whether the standard library\xe2\x80\x99s panic hook will \xe2\x80\xa6CkGets the mutable reference of the contents of the cell, \xe2\x80\xa60CmInterleaves elements of this iterator and the other given \xe2\x80\xa6DdEquivalent to <code>CString::into_bytes()</code> except that the \xe2\x80\xa6DaReturns <code>self</code> with only the most significant bit set.00000000000EgThe maximum <code>t</code> for which the module is fully defined at <code>t</code>. \xe2\x80\xa60ClConstructs a new atomically reference-counted slice with \xe2\x80\xa6ClConstructs a new boxed slice with uninitialized contents \xe2\x80\xa6CaConstructs a new reference-counted slice with \xe2\x80\xa6210DfNormalize a path, including <code>..</code> without traversing the \xe2\x80\xa6DjThe <code>prefetch</code> intrinsic is a hint to the code generator to \xe2\x80\xa6DgReturns the nearest integer to an <code>f16</code>. Rounds half-way \xe2\x80\xa6DgReturns the nearest integer to an <code>f32</code>. Rounds half-way \xe2\x80\xa6DgReturns the nearest integer to an <code>f64</code>. Rounds half-way \xe2\x80\xa6CnConfigures whether the default panic hook will capture and \xe2\x80\xa6DkShifts the mask elements to the left by <code>OFFSET</code>, filling in \xe2\x80\xa6DjShifts the vector elements to the left by <code>OFFSET</code>, filling \xe2\x80\xa6CdDetermines if the <code>0</code> flag was specified.BgSets or unsets the <code>0</code> flag.CcAdds two simd vectors elementwise, with saturation.ChSubtracts two simd vectors elementwise, with saturation.B`Selects elements from a bitmask.CnTakes a substring based on a range that corresponds to the \xe2\x80\xa6EhProjects to the <code>index</code>-th element of <code>slice_ptr</code>, as the same \xe2\x80\xa6EaSwaps <code>count * size_of::&lt;T&gt;()</code> bytes between the two regions \xe2\x80\xa6DgLike <code>transmute</code>, but even less checked at compile-time: \xe2\x80\xa6CnComputes the suspension map between different unstable Ext \xe2\x80\xa6DaEquivalent to the appropriate <code>llvm.memset.p0i8.*</code> \xe2\x80\xa6CmWrites a length prefix into this hasher, as part of being \xe2\x80\xa6EkAssociated type for <code>&lt;&amp;[char; N] as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.CdZero-sized type used to mark a type parameter as \xe2\x80\xa6CmAn iterator over the non-ASCII-whitespace substrings of a \xe2\x80\xa6AkSee <code>_mm_setcsr</code>Bmuse MXCSR.RC and suppress exceptions; see \xe2\x80\xa6Ajdo not suppress exceptionsDbThe strings defined by <code>a</code> and <code>b</code> are equalChPerforms one round of an AES decryption flow on each \xe2\x80\xa6ChPerforms one round of an AES encryption flow on each \xe2\x80\xa6CnConvert scalar BF16 (16-bit) floating point element stored \xe2\x80\xa6ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa6CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa6CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa6BnSign-extend 8-bit integers to 16-bit integers.BnSign-extend 8-bit integers to 32-bit integers.BnSign-extend 8-bit integers to 64-bit integers.DcZero-extend unsigned 8-bit integers in <code>a</code> to 16-bit \xe2\x80\xa6DiZero-extend the lower eight unsigned 8-bit integers in <code>a</code> \xe2\x80\xa6DkZero-extend the lower four unsigned 8-bit integers in <code>a</code> to \xe2\x80\xa6ClConvert packed BF16 (16-bit) floating-point even-indexed \xe2\x80\xa6CkConvert packed BF16 (16-bit) floating-point odd-indexed \xe2\x80\xa6DhReturns the first element of the input vector of <code>[8 x i32]</code>.CgMultiply groups of 4 adjacent pairs of signed 8-bit \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CjMultiply groups of 2 adjacent pairs of unsigned 16-bit \xe2\x80\xa60EdExtracts a 16-bit integer from <code>a</code>, selected with <code>INDEX</code>. \xe2\x80\xa6E`Extracts a 32-bit integer from <code>a</code>, selected with <code>INDEX</code>.E`Extracts a 64-bit integer from <code>a</code>, selected with <code>INDEX</code>.CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa6CnStores 4 double-precision (64-bit) floating-point elements \xe2\x80\xa6CnStores 8 single-precision (32-bit) floating-point elements \xe2\x80\xa61CnStores 4 single-precision (32-bit) floating-point elements \xe2\x80\xa6DiCopies <code>a</code> to result, then inserts 128 bits (composed of 2 \xe2\x80\xa6DiCopies <code>a</code> to result, then inserts 128 bits (composed of 4 \xe2\x80\xa6DiVertically multiplies each unsigned 8-bit integer from <code>a</code> \xe2\x80\xa6CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa6CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa6CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa6CiBlend packed double-precision (64-bit) floating-point \xe2\x80\xa6CgBlend packed half-precision (16-bit) floating-point \xe2\x80\xa6CiBlend packed single-precision (32-bit) floating-point \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa6ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa6CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa6CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa610CnMove packed 8-bit integers from a into dst using writemask \xe2\x80\xa6CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa6CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa6CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60C`Compute the approximate reciprocal of packed \xe2\x80\xa60ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6CiStore packed double-precision (64-bit) floating-point \xe2\x80\xa6CiStore packed single-precision (32-bit) floating-point \xe2\x80\xa6CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa6<;=CfCompute the square root of packed double-precision \xe2\x80\xa6CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa6CfCompute the square root of packed single-precision \xe2\x80\xa6ClCreates mask from the most significant bit of each 8-bit \xe2\x80\xa6CeSet each bit of mask register k based on the most \xe2\x80\xa600CnShuffles double-precision (64-bit) floating-point elements \xe2\x80\xa6CnShuffles single-precision (32-bit) floating-point elements \xe2\x80\xa6ClReduce the packed half-precision (16-bit) floating-point \xe2\x80\xa6000CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa6CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa6CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa6CkReturns vector of type __m256i with all elements set to \xe2\x80\xa6DiShuffles 32-bit integers in 128-bit lanes of <code>a</code> using the \xe2\x80\xa6CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa6CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa6CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa6CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa6CmThis intrinsic performs four rounds of SM4 key expansion. \xe2\x80\xa6CnStores the high and low 128-bit halves (each composed of 2 \xe2\x80\xa6ClStores the high and low 128-bit halves (each composed of \xe2\x80\xa6CnComputes the bitwise AND of 256 bits (representing integer \xe2\x80\xa6ClUnpacks and interleave 8-bit integers from the high half \xe2\x80\xa6CnUnpacks and interleave 8-bit integers from the low half of \xe2\x80\xa6ChPerforms one round of an AES decryption flow on each \xe2\x80\xa6ChPerforms one round of an AES encryption flow on each \xe2\x80\xa6ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa6CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa61010CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa6ClPerforms element-by-element conversion of the lower half \xe2\x80\xa6CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa6CmSign extend packed 8-bit integers in the low 8 bytes of a \xe2\x80\xa64CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa60CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa6BjCopy the lower 32-bit integer in a to dst.CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa6CmScatter double-precision (64-bit) floating-point elements \xe2\x80\xa6CmScatter single-precision (32-bit) floating-point elements \xe2\x80\xa610CjVertically multiply each unsigned 8-bit integer from a \xe2\x80\xa6CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa6CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa6CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa6CiBlend packed double-precision (64-bit) floating-point \xe2\x80\xa6CgBlend packed half-precision (16-bit) floating-point \xe2\x80\xa6CiBlend packed single-precision (32-bit) floating-point \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa6ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa6CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa6CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa610CnMove packed 8-bit integers from a into dst using writemask \xe2\x80\xa6CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa6CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa6CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60C`Compute the approximate reciprocal of packed \xe2\x80\xa60ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6CiStore packed double-precision (64-bit) floating-point \xe2\x80\xa6CiStore packed single-precision (32-bit) floating-point \xe2\x80\xa6CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa6<;=CfCompute the square root of packed double-precision \xe2\x80\xa6CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa6CfCompute the square root of packed single-precision \xe2\x80\xa6CeSet each bit of mask register k based on the most \xe2\x80\xa600CmMultiply the packed complex numbers in a and b, and store \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CnReduce the packed double-precision (64-bit) floating-point \xe2\x80\xa6ClReduce the packed half-precision (16-bit) floating-point \xe2\x80\xa6CnReduce the packed single-precision (32-bit) floating-point \xe2\x80\xa6210210210CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa6CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa6CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa6DgReturn vector of type <code>__m512i</code> with all elements set to \xe2\x80\xa6DhReturns vector of type <code>__m512i</code> with all elements set to \xe2\x80\xa68CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa6CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa6CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa6CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa6CfCompute the square root of packed double-precision \xe2\x80\xa6CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa6CfCompute the square root of packed single-precision \xe2\x80\xa6CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa6CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa6CmPerforms the last round of an AES decryption flow on data \xe2\x80\xa6CmPerforms the last round of an AES encryption flow on data \xe2\x80\xa6DgBroadcasts the low packed 32-bit integer from <code>a</code> to all \xe2\x80\xa6DgBroadcasts the low packed 64-bit integer from <code>a</code> to all \xe2\x80\xa6CjBroadcasts the low packed 16-bit integer from a to all \xe2\x80\xa6CfPerforms a carry-less multiplication of two 64-bit \xe2\x80\xa6ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa6CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa6CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa6CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa65ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa6ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa6432710432710432710432CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa6CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa6CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa60CmConvert the signed 32-bit integer b to a single-precision \xe2\x80\xa6CmConvert the signed 64-bit integer b to a double-precision \xe2\x80\xa6CmConvert the signed 64-bit integer b to a single-precision \xe2\x80\xa6CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa604444ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa60001111CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6ChWrap a 128-bit AES key into a 384-bit key handle and \xe2\x80\xa6ChWrap a 256-bit AES key into a 512-bit key handle and \xe2\x80\xa6CiMultiply the lower complex number in a by the complex \xe2\x80\xa6CiNormalize the mantissas of the lower double-precision \xe2\x80\xa6CgNormalize the mantissas of the lower half-precision \xe2\x80\xa6CiNormalize the mantissas of the lower single-precision \xe2\x80\xa6CnStores 4 32-bit integer elements from a to memory starting \xe2\x80\xa6CnStores 2 64-bit integer elements from a to memory starting \xe2\x80\xa6CnStores 2 32-bit integer elements from a to memory starting \xe2\x80\xa61CgMultiply packed complex numbers in a by the complex \xe2\x80\xa67CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa6CkBlend packed 16-bit integers from a and b using control \xe2\x80\xa6CkBlend packed 32-bit integers from a and b using control \xe2\x80\xa6CkBlend packed 64-bit integers from a and b using control \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa6ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa6CkContiguously store the active double-precision (64-bit) \xe2\x80\xa6CkContiguously store the active single-precision (32-bit) \xe2\x80\xa6ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6000ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa6CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa6CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa6CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa6CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa6CiCounts the number of leading zero bits in each packed \xe2\x80\xa60CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa6CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa6CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa6ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa6CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa6CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa6EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa6CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa6210CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa6210CiStore packed 32-bit integers from a into memory using \xe2\x80\xa6CiStore packed 64-bit integers from a into memory using \xe2\x80\xa6ChStore packed 8-bit integers from a into memory using \xe2\x80\xa6CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa6CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa610CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa6ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa6CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CiMultiply the lower complex number in a by the complex \xe2\x80\xa6CfNormalize the mantissas of packed double-precision \xe2\x80\xa6CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa6CfNormalize the mantissas of packed single-precision \xe2\x80\xa6CiNormalize the mantissas of the lower double-precision \xe2\x80\xa6CgNormalize the mantissas of the lower half-precision \xe2\x80\xa6CiNormalize the mantissas of the lower single-precision \xe2\x80\xa6CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa6CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa6CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CiCompute the approximate reciprocal square root of the \xe2\x80\xa60CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa6CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa6CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa687ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa6CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa6543210CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa6CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa6CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa6CgReduce the packed 16-bit integers in a by addition. \xe2\x80\xa6CjReduce the packed 16-bit integers in a by bitwise AND. \xe2\x80\xa6CnReduce the packed 16-bit integers in a by maximum. Returns \xe2\x80\xa6CfReduce the packed unsigned 16-bit integers in a by \xe2\x80\xa6CnReduce the packed 16-bit integers in a by minimum. Returns \xe2\x80\xa61CmReduce the packed 16-bit integers in a by multiplication. \xe2\x80\xa6CjPerforms an intermediate calculation for the next four \xe2\x80\xa6CkPerforms the final calculation for the next four SHA256 \xe2\x80\xa6CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa6CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa6CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa6DdBinary searches this <code>VecDeque</code> with a key extraction \xe2\x80\xa6CmChecks whether n choose k is zero mod p. Since we don\xe2\x80\x99t \xe2\x80\xa6BmThis function does the following computation:ClThis function resolves up till a fixed stem instead of a \xe2\x80\xa60ChAsserts that an expression matches the provided pattern.CiChecks that two strings are an ASCII case-insensitive \xe2\x80\xa6CkChecks that two values are an ASCII case-insensitive match.gReturnsCiGiven a matrix M in rref, add rows to make the matrix \xe2\x80\xa6CiCreates a C string wrapper from a byte slice with any \xe2\x80\xa6CnReturns relations that the algebra wants checked to ensure \xe2\x80\xa6CnWe return Adem relations $b^2 = 0$, $P^i P^j = \\cdots$ for \xe2\x80\xa611EdUnwraps this <code>Pin&lt;Ptr&gt;</code>, returning the underlying <code>Ptr</code>.CkConverts this string to its ASCII lower case equivalent \xe2\x80\xa6CiConverts this type to its ASCII lower case equivalent \xe2\x80\xa6CkConverts this string to its ASCII upper case equivalent \xe2\x80\xa6CiConverts this type to its ASCII upper case equivalent \xe2\x80\xa6ClMaximum degree of a generator under the Steenrod action. \xe2\x80\xa60Dddegree -&gt; first square -&gt; admissible sequence idx -&gt; resultCksource_deg -&gt; target_deg -&gt; source_op -&gt; target_op1010CkCalculates the distance between two pointers within the \xe2\x80\xa6CmAppends an element if there is sufficient spare capacity, \xe2\x80\xa6CkResolves a module up to an $(n, s)$ and prints an ASCII \xe2\x80\xa6DhRotates the mask such that the first <code>OFFSET</code> elements of \xe2\x80\xa6DjRotates the vector such that the first <code>OFFSET</code> elements of \xe2\x80\xa6DhReturns the nearest integer to an <code>f128</code>. Rounds half-way \xe2\x80\xa6EcReturns either <code>true_val</code> or <code>false_val</code> depending on the \xe2\x80\xa6DoReturns either <code>true_val</code> or <code>false_val</code> depending on \xe2\x80\xa6CkRegisters a custom allocation error hook, replacing any \xe2\x80\xa6DgSets the value of the <code>IP_MULTICAST_TTL</code> option for this \xe2\x80\xa6DiShifts the mask elements to the right by <code>OFFSET</code>, filling \xe2\x80\xa6DkShifts the vector elements to the right by <code>OFFSET</code>, filling \xe2\x80\xa6ClGiven $r, s \\in \\pi_0(A)$, compute $\\sigma(r) \\sigma(s)$ \xe2\x80\xa60ClRounds each element to the closest integer-valued float. \xe2\x80\xa6BnForms a raw slice from a pointer and a length.CjCreates a non-null raw slice from a thin pointer and a \xe2\x80\xa6CmGiven a data file containing a quasi-inverse, apply it to \xe2\x80\xa6ClVisits the values representing the symmetric difference, \xe2\x80\xa6CnVisits the elements representing the symmetric difference, \xe2\x80\xa6CnImmutably borrows the wrapped value, returning an error if \xe2\x80\xa6CmConstructs a new boxed slice with uninitialized contents. \xe2\x80\xa6CmConstructs a new boxed slice with uninitialized contents, \xe2\x80\xa6DjConstructs a new, empty <code>Vec&lt;T, A&gt;</code> with at least the \xe2\x80\xa6AbFunnel Shift left.DhSee <code>super::unchecked_funnel_shl</code>; we just need the trait \xe2\x80\xa6AcFunnel Shift right.DhSee <code>super::unchecked_funnel_shr</code>; we just need the trait \xe2\x80\xa6EhReturns the contained <code>Err</code> value, consuming the <code>self</code> value, \xe2\x80\xa6DfEquivalent to the appropriate <code>llvm.memmove.p0i8.0i8.*</code> \xe2\x80\xa6EgCreates an owned <code>PathBuf</code> like <code>self</code> but with the extension \xe2\x80\xa6ClAn augmented chain complex is a map of chain complexes C \xe2\x80\xa6DnAssociated type for <code>&lt;F as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.CnThis just ensures that the containers are \xe2\x80\x9cnice enough\xe2\x80\x9d\xe2\x80\xa6CfAn error indicating that a nul byte was not in the \xe2\x80\xa60CnRAII structure used to release the shared read access of a \xe2\x80\xa600DjThe type returned by <code>query_module</code>. The value of this type \xe2\x80\xa6Di<code>U+FFFD REPLACEMENT CHARACTER</code> (\xef\xbf\xbd) is used in Unicode to \xe2\x80\xa6BhIntermediate data used by secondary codeCdAn error which can be returned when converting a \xe2\x80\xa6CkThe reason we are terminating the process during unwinding.jround downhround upAkSee <code>_mm_setcsr</code>Adinterval [0.75, 1.5)11EgReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>\xe2\x80\xa6C`Broadcasts the low double-precision (64-bit) \xe2\x80\xa6C`Broadcasts the low single-precision (32-bit) \xe2\x80\xa6CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa6ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa6ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa6ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa6CmTest each 32-bit element of a for equality with all other \xe2\x80\xa6CmTest each 64-bit element of a for equality with all other \xe2\x80\xa6BoSign-extend 16-bit integers to 32-bit integers.BoSign-extend 16-bit integers to 64-bit integers.ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa6BoSign-extend 32-bit integers to 64-bit integers.ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa6DfZeroes extend packed unsigned 16-bit integers in <code>a</code> to \xe2\x80\xa6DiZero-extend the lower four unsigned 16-bit integers in <code>a</code> \xe2\x80\xa6DdZero-extend unsigned 32-bit integers in <code>a</code> to 64-bit \xe2\x80\xa6CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa6ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa6ClExtracts 128 bits (composed of 4 packed single-precision \xe2\x80\xa6CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa6CfCompute the absolute value of packed signed 32-bit \xe2\x80\xa6CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa6ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa6CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa6CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa6CjPerforms element-by-element bitwise AND between packed \xe2\x80\xa6CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa6CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa6CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa6CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa6CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa6CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa6CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChConvert the exponent of each packed double-precision \xe2\x80\xa6CfConvert the exponent of each packed half-precision \xe2\x80\xa6ChConvert the exponent of each packed single-precision \xe2\x80\xa6CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa6543210CeMove packed 16-bit integers from a into dst using \xe2\x80\xa6CmMove packed 32-bit integers from a to dst using writemask \xe2\x80\xa6CmMove packed 64-bit integers from a to dst using writemask \xe2\x80\xa6ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa6CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa6CkExtract the reduced argument of packed double-precision \xe2\x80\xa6CiExtract the reduced argument of packed half-precision \xe2\x80\xa6CkExtract the reduced argument of packed single-precision \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6CjBroadcast 8-bit integer a to all elements of dst using \xe2\x80\xa6CiShift packed 16-bit integers in a left by count while \xe2\x80\xa6CiShift packed 32-bit integers in a left by count while \xe2\x80\xa6CiShift packed 64-bit integers in a left by count while \xe2\x80\xa6CjShift packed 16-bit integers in a right by count while \xe2\x80\xa6CjShift packed 32-bit integers in a right by count while \xe2\x80\xa6CjShift packed 64-bit integers in a right by count while \xe2\x80\xa6210CiStore packed double-precision (64-bit) floating-point \xe2\x80\xa6CiStore packed single-precision (32-bit) floating-point \xe2\x80\xa6CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa6CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa6CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa6CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa6ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa6CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa6CgLoads packed 32-bit integers from memory pointed by \xe2\x80\xa6CgLoads packed 64-bit integers from memory pointed by \xe2\x80\xa6CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa6CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa6CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa6ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa6CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa6CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa610CmMove packed 8-bit integers from a into dst using zeromask \xe2\x80\xa6CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa6CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa6CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60C`Compute the approximate reciprocal of packed \xe2\x80\xa60ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa6DjShuffles 64-bit floating-point elements in <code>a</code> across lanes \xe2\x80\xa6CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CnShuffle half-precision (16-bit) floating-point elements in \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6ChReduce the packed 8-bit integers in a by bitwise OR. \xe2\x80\xa6CnThis intrinsic performs four rounds of SM4 encryption. The \xe2\x80\xa6CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa6CmUnpacks and interleave 16-bit integers from the high half \xe2\x80\xa6CmUnpacks and interleave 32-bit integers from the high half \xe2\x80\xa6CmUnpacks and interleave 64-bit integers from the high half \xe2\x80\xa6ClUnpacks and interleave 16-bit integers from the low half \xe2\x80\xa6ClUnpacks and interleave 32-bit integers from the low half \xe2\x80\xa6ClUnpacks and interleave 64-bit integers from the low half \xe2\x80\xa6CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa6CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa6CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa6ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa6ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa6ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa6CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa6CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6101010CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CmTest each 32-bit element of a for equality with all other \xe2\x80\xa6CmTest each 64-bit element of a for equality with all other \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa6ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa6ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa6ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa6CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6CmLoads 8 double-precision (64-bit) floating-point elements \xe2\x80\xa6CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa60543543CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa6DjComputes the absolute value of packed 32-bit integers in <code>a</code>\xe2\x80\xa6CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa6ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa6CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa6CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa6CjPerforms element-by-element bitwise AND between packed \xe2\x80\xa6CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa6CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa6CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa6CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa6CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa6CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa6CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChConvert the exponent of each packed double-precision \xe2\x80\xa6CfConvert the exponent of each packed half-precision \xe2\x80\xa6ChConvert the exponent of each packed single-precision \xe2\x80\xa6CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa6543210CeMove packed 16-bit integers from a into dst using \xe2\x80\xa6CmMove packed 32-bit integers from a to dst using writemask \xe2\x80\xa6CmMove packed 64-bit integers from a to dst using writemask \xe2\x80\xa6ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa6CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa6CkExtract the reduced argument of packed double-precision \xe2\x80\xa6CiExtract the reduced argument of packed half-precision \xe2\x80\xa6CkExtract the reduced argument of packed single-precision \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6CjBroadcast 8-bit integer a to all elements of dst using \xe2\x80\xa6CiShift packed 16-bit integers in a left by count while \xe2\x80\xa6CiShift packed 32-bit integers in a left by count while \xe2\x80\xa6CiShift packed 64-bit integers in a left by count while \xe2\x80\xa6CjShift packed 16-bit integers in a right by count while \xe2\x80\xa6CjShift packed 32-bit integers in a right by count while \xe2\x80\xa6CjShift packed 64-bit integers in a right by count while \xe2\x80\xa6210CiStore packed double-precision (64-bit) floating-point \xe2\x80\xa6CiStore packed single-precision (32-bit) floating-point \xe2\x80\xa6CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa6CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa6CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa6CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa6ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa6CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa6CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa6CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa6CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa6ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa6ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa6CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa6CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa610CmMove packed 8-bit integers from a into dst using zeromask \xe2\x80\xa6CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa6CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa6CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60C`Compute the approximate reciprocal of packed \xe2\x80\xa60ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa6CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CnShuffle half-precision (16-bit) floating-point elements in \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa677CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa6ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa6ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa6CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa6CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa6ClBroadcast the low 8-bits from input mask k to all 64-bit \xe2\x80\xa6CmBroadcast the low 16-bits from input mask k to all 32-bit \xe2\x80\xa6CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa6ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa6ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa6ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa6ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa6CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa6CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa60CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa6CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa61ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa612CjAdd the lower double-precision (64-bit) floating-point \xe2\x80\xa6ChAdd the lower half-precision (16-bit) floating-point \xe2\x80\xa6CjAdd the lower single-precision (32-bit) floating-point \xe2\x80\xa6CnConcatenate a and b into a 32-byte immediate result, shift \xe2\x80\xa60CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60000022CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa63CmDivide the lower double-precision (64-bit) floating-point \xe2\x80\xa6CkDivide the lower half-precision (16-bit) floating-point \xe2\x80\xa6CmDivide the lower single-precision (32-bit) floating-point \xe2\x80\xa6CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa6CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa6CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa6DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa6000CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa6ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa6210C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa6CnShuffle 8-bit integers in a within 128-bit lanes using the \xe2\x80\xa6CiStore packed 16-bit integers from a into memory using \xe2\x80\xa6CiStore packed 32-bit integers from a into memory using \xe2\x80\xa6CiStore packed 64-bit integers from a into memory using \xe2\x80\xa6C`Subtract the lower double-precision (64-bit) \xe2\x80\xa6CmSubtract the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Subtract the lower single-precision (32-bit) \xe2\x80\xa6CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa6CkContiguously store the active double-precision (64-bit) \xe2\x80\xa6CkContiguously store the active single-precision (32-bit) \xe2\x80\xa6ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6000ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa6CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa6CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa6CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa6CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa6CiCounts the number of leading zero bits in each packed \xe2\x80\xa60CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa6CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa6CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa6ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa6CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa6CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa6EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa6CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa6210CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa6CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa6210CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa6CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa610ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa6CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa6CjPerforms 2 rounds of SHA256 operation using an initial \xe2\x80\xa6CgLoad 128-bits of integer data from memory into dst. \xe2\x80\xa6CnReturns an estimate of the default amount of parallelism a \xe2\x80\xa6CaDivides an iterator into sequential blocks of \xe2\x80\xa6DiStores a value into the <code>bool</code> if the current value is the \xe2\x80\xa6CkStores a value into the pointer if the current value is \xe2\x80\xa6CiStores a value into the atomic integer if the current \xe2\x80\xa6000000000CkComputes the quasi-inverse of a matrix given a rref of [\xe2\x80\xa6CkThis function prepares the Resolution object to perform \xe2\x80\xa60CiMarks the struct as non-exhaustive, indicating to the \xe2\x80\xa6CkMarks the tuple struct as non-exhaustive, indicating to \xe2\x80\xa6CmMarks the set as non-exhaustive, indicating to the reader \xe2\x80\xa6CnMarks the list as non-exhaustive, indicating to the reader \xe2\x80\xa6CmMarks the map as non-exhaustive, indicating to the reader \xe2\x80\xa6EnConverts a <code>Vec&lt;u8&gt;</code> to a <code>String</code>, substituting invalid UTF-8 \xe2\x80\xa6DiInserts the default value into the option if it is <code>None</code>, \xe2\x80\xa6CmIf the complex has been computed at bidegree (s, t). This \xe2\x80\xa6DcDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: \xe2\x80\xa6DfReturns <code>true</code> if the address is a unicast address with \xe2\x80\xa6DkReads contiguous elements from <code>slice</code>. Each element is read \xe2\x80\xa6DiRotates the mask such that the first <code>self.len() - OFFSET</code> \xe2\x80\xa6DkRotates the vector such that the first <code>self.len() - OFFSET</code> \xe2\x80\xa6DhSets the value of the <code>IP_MULTICAST_LOOP</code> option for this \xe2\x80\xa6DjSets the value of the <code>IPV6_MULTICAST_LOOP</code> option for this \xe2\x80\xa6ClUnregisters the current allocation error hook, returning \xe2\x80\xa6ClInforms the compiler that the site which is calling this \xe2\x80\xa6DiThis function produces a quasi-isomorphic quotient of <code>cc</code> \xe2\x80\xa6fU+0017CaAn error indicating that no nul byte was present.0CnA ModuleHomomorphism that simply records the matrix of the \xe2\x80\xa60CmRAII structure used to release the exclusive write access \xe2\x80\xa600AjStale network file handle.AkSee <code>_mm_setcsr</code>DhThe <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa \xe2\x80\xa6DhThe <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa \xe2\x80\xa62Cl<strong>Index only</strong>: return the most significant bitCkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa6CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa6CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa6CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa6ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa6CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa6DfBroadcasts the low packed 8-bit integer from <code>a</code> to all \xe2\x80\xa6CkCasts vector of type __m128d to type __m256d; the upper \xe2\x80\xa6BmCasts vector of type __m256d to type __m128d.EfCast vector of type <code>__m128h</code> to type <code>__m256h</code>. The upper 8 \xe2\x80\xa6DoCast vector of type <code>__m256h</code> to type <code>__m128h</code>. This \xe2\x80\xa6CmCasts vector of type __m128 to type __m256; the upper 128 \xe2\x80\xa6BkCasts vector of type __m256 to type __m128.CkCasts vector of type __m128i to type __m256i; the upper \xe2\x80\xa6BmCasts vector of type __m256i to type __m128i.CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa6CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa610101010CkConvert packed single precision (32-bit) floating-point \xe2\x80\xa6ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa6ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa6ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa6CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa6ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa6DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa6000CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa6ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa6CjBlend packed 8-bit integers from a and b using control \xe2\x80\xa6CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CfNormalize the mantissas of packed double-precision \xe2\x80\xa6CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa6CfNormalize the mantissas of packed single-precision \xe2\x80\xa6CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa6CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa6CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CkBroadcast 16-bit integer a to all elements of dst using \xe2\x80\xa6CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa6CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa676ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa6CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa6543210CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa6CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa6DiStores packed 32-bit integers from <code>a</code> into memory pointed \xe2\x80\xa6DiStores packed 64-bit integers from <code>a</code> into memory pointed \xe2\x80\xa6CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa6CfCompute the absolute value of packed signed 32-bit \xe2\x80\xa6CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa6ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa6CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa6CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa6CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa6CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa6CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa6CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa6CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa6CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa6CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChConvert the exponent of each packed double-precision \xe2\x80\xa6CfConvert the exponent of each packed half-precision \xe2\x80\xa6ChConvert the exponent of each packed single-precision \xe2\x80\xa6CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa6543210CnMove packed 16-bit integers from a into dst using zeromask \xe2\x80\xa6CnMove packed 32-bit integers from a into dst using zeromask \xe2\x80\xa6CnMove packed 64-bit integers from a into dst using zeromask \xe2\x80\xa6ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa6CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa6CkExtract the reduced argument of packed double-precision \xe2\x80\xa6CiExtract the reduced argument of packed half-precision \xe2\x80\xa6CkExtract the reduced argument of packed single-precision \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6CjBroadcast 8-bit integer a to all elements of dst using \xe2\x80\xa6CiShift packed 16-bit integers in a left by count while \xe2\x80\xa6CiShift packed 32-bit integers in a left by count while \xe2\x80\xa6CiShift packed 64-bit integers in a left by count while \xe2\x80\xa6CjShift packed 16-bit integers in a right by count while \xe2\x80\xa6CjShift packed 32-bit integers in a right by count while \xe2\x80\xa6CjShift packed 64-bit integers in a right by count while \xe2\x80\xa6210CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa6CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa6CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa6CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa6ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa6CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa6ClShuffles 256 bits (composed of 4 packed double-precision \xe2\x80\xa6ClShuffles 256 bits (composed of 8 packed single-precision \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CnShuffle half-precision (16-bit) floating-point elements in \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CnReduce the packed 8-bit integers in a by addition. Returns \xe2\x80\xa6CiReduce the packed 8-bit integers in a by bitwise AND. \xe2\x80\xa6CmReduce the packed 8-bit integers in a by maximum. Returns \xe2\x80\xa6CnReduce the packed unsigned 8-bit integers in a by maximum. \xe2\x80\xa6CmReduce the packed 8-bit integers in a by minimum. Returns \xe2\x80\xa6CnReduce the packed unsigned 8-bit integers in a by minimum. \xe2\x80\xa6ClReduce the packed 8-bit integers in a by multiplication. \xe2\x80\xa6CiReduce the packed 16-bit integers in a by bitwise OR. \xe2\x80\xa6CkShuffles 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa6CjShuffles 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa6CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa6CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa6CjReturns vector of type __m256i with with indeterminate \xe2\x80\xa6DkConstructs a 256-bit floating-point vector of <code>[4 x double]</code> \xe2\x80\xa6EfCast vector of type <code>__m256h</code> to type <code>__m128h</code>. The upper 8 \xe2\x80\xa6DjConstructs a 256-bit floating-point vector of <code>[8 x float]</code> \xe2\x80\xa6CnConstructs a 256-bit integer vector from a 128-bit integer \xe2\x80\xa6CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa6CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa6CeBroadcasts the 8 packed single-precision (32-bit) \xe2\x80\xa6CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa6CdBroadcast the 4 packed double-precision (64-bit) \xe2\x80\xa6CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa6ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa6CiBroadcasts the 8 packed 32-bit integers from a to all \xe2\x80\xa6CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa6ChBroadcast the 4 packed 64-bit integers from a to all \xe2\x80\xa6ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa6CnCast vector of type __m128d to type __m512d; the upper 384 \xe2\x80\xa6CnCast vector of type __m256d to type __m512d; the upper 256 \xe2\x80\xa6CeCast vector of type __m512d to type __m128d. This \xe2\x80\xa6CeCast vector of type __m512d to type __m256d. This \xe2\x80\xa6EgCast vector of type <code>__m128h</code> to type <code>__m512h</code>. The upper 24 \xe2\x80\xa6EgCast vector of type <code>__m256h</code> to type <code>__m512h</code>. The upper 16 \xe2\x80\xa6DoCast vector of type <code>__m512h</code> to type <code>__m128h</code>. This \xe2\x80\xa6DoCast vector of type <code>__m512h</code> to type <code>__m256h</code>. This \xe2\x80\xa6ClCast vector of type __m128 to type __m512; the upper 384 \xe2\x80\xa6ClCast vector of type __m256 to type __m512; the upper 256 \xe2\x80\xa6CmCast vector of type __m512 to type __m128. This intrinsic \xe2\x80\xa6CmCast vector of type __m512 to type __m256. This intrinsic \xe2\x80\xa6CnCast vector of type __m128i to type __m512i; the upper 384 \xe2\x80\xa6CnCast vector of type __m256i to type __m512i; the upper 256 \xe2\x80\xa6CeCast vector of type __m512i to type __m128i. This \xe2\x80\xa6CeCast vector of type __m512i to type __m256i. This \xe2\x80\xa6CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa6CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa610101010ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa6ClExtracts 256 bits (composed of 8 packed single-precision \xe2\x80\xa6ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa6CkExtract 256 bits (composed of 4 packed double-precision \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa6CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa6ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa6ChConvert the exponent of each packed double-precision \xe2\x80\xa6CfConvert the exponent of each packed half-precision \xe2\x80\xa6ChConvert the exponent of each packed single-precision \xe2\x80\xa6ClGather 32-bit integers from memory using 32-bit indices. \xe2\x80\xa6ClGather 64-bit integers from memory using 32-bit indices. \xe2\x80\xa6CnStores 8 double-precision (64-bit) floating-point elements \xe2\x80\xa6ClGather 32-bit integers from memory using 64-bit indices. \xe2\x80\xa6ClGather 64-bit integers from memory using 64-bit indices. \xe2\x80\xa6>=<;=<;CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa6ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa6CjBlend packed 8-bit integers from a and b using control \xe2\x80\xa6CgPerforms an element-by-element conversion of packed \xe2\x80\xa6ClPerforms element-by-element conversion of the lower half \xe2\x80\xa6CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CfNormalize the mantissas of packed double-precision \xe2\x80\xa6CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa6CfNormalize the mantissas of packed single-precision \xe2\x80\xa6CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa6CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa6CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa6CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CkBroadcast 16-bit integer a to all elements of dst using \xe2\x80\xa6CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa6CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa676ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa6ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa6ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa6CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa6CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa6CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa6543210CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa6CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa6CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa6DjComputes the absolute value of packed 32-bit integers in <code>a</code>\xe2\x80\xa6CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa6ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa6ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa6CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa6CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa6CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa6CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa6CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa6CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa6CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa6CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa6CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa6CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa6ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa6CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa6210ChConvert the exponent of each packed double-precision \xe2\x80\xa6CfConvert the exponent of each packed half-precision \xe2\x80\xa6ChConvert the exponent of each packed single-precision \xe2\x80\xa6CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa6CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa6CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa6543210CnMove packed 16-bit integers from a into dst using zeromask \xe2\x80\xa6CnMove packed 32-bit integers from a into dst using zeromask \xe2\x80\xa6CnMove packed 64-bit integers from a into dst using zeromask \xe2\x80\xa6ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa6CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa6CkExtract the reduced argument of packed double-precision \xe2\x80\xa6CiExtract the reduced argument of packed half-precision \xe2\x80\xa6CkExtract the reduced argument of packed single-precision \xe2\x80\xa6CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa6CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa610CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6CjBroadcast 8-bit integer a to all elements of dst using \xe2\x80\xa6CiShift packed 16-bit integers in a left by count while \xe2\x80\xa6CiShift packed 32-bit integers in a left by count while \xe2\x80\xa6CiShift packed 64-bit integers in a left by count while \xe2\x80\xa6CjShift packed 16-bit integers in a right by count while \xe2\x80\xa6CjShift packed 32-bit integers in a right by count while \xe2\x80\xa6CjShift packed 64-bit integers in a right by count while \xe2\x80\xa6210CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa6CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa6CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa6CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa6ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa6CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CnShuffle half-precision (16-bit) floating-point elements in \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CiReduce the packed 32-bit integers in a by bitwise OR. \xe2\x80\xa6CiReduce the packed 64-bit integers in a by bitwise OR. \xe2\x80\xa6CkExtract the reduced argument of packed double-precision \xe2\x80\xa6CiExtract the reduced argument of packed half-precision \xe2\x80\xa6CkExtract the reduced argument of packed single-precision \xe2\x80\xa6CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa6CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa6CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa6CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa6CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa6CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa6CnReturn vector of type __m512i with indeterminate elements. \xe2\x80\xa6CnCast vector of type __m128d to type __m512d; the upper 384 \xe2\x80\xa6CnCast vector of type __m256d to type __m512d; the upper 256 \xe2\x80\xa6EgCast vector of type <code>__m128h</code> to type <code>__m512h</code>. The upper 24 \xe2\x80\xa6EgCast vector of type <code>__m256h</code> to type <code>__m512h</code>. The upper 16 \xe2\x80\xa6ClCast vector of type __m128 to type __m512; the upper 384 \xe2\x80\xa6ClCast vector of type __m256 to type __m512; the upper 256 \xe2\x80\xa6CnCast vector of type __m128i to type __m512i; the upper 384 \xe2\x80\xa6CnCast vector of type __m256i to type __m512i; the upper 256 \xe2\x80\xa6ClDecrypt 10 rounds of 8 groups of unsigned 8-bit integers \xe2\x80\xa6ClDecrypt 14 rounds of 8 groups of unsigned 8-bit integers \xe2\x80\xa6ClEncrypt 10 rounds of 8 groups of unsigned 8-bit integers \xe2\x80\xa6ClEncrypt 14 rounds of 8 groups of unsigned 8-bit integers \xe2\x80\xa6CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa60ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa6CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa6ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa6CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa6CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa6CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa6CmSign extend packed 8-bit integers in the low 2 bytes of a \xe2\x80\xa6CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa6CkZero extend packed unsigned 8-bit integers in the low 4 \xe2\x80\xa6CkZero extend packed unsigned 8-bit integers in the low 2 \xe2\x80\xa6CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa6CnStores 2 double-precision (64-bit) floating-point elements \xe2\x80\xa6CnStores 4 single-precision (32-bit) floating-point elements \xe2\x80\xa61CnStores 2 single-precision (32-bit) floating-point elements \xe2\x80\xa6CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa6ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa6CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa6CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa6CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa6CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa6CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa6ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa6CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa6ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa6CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa6CiCompute the square root of the lower double-precision \xe2\x80\xa6CgCompute the square root of the lower half-precision \xe2\x80\xa6CiCompute the square root of the lower single-precision \xe2\x80\xa6CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa6CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa6CjAdd the lower double-precision (64-bit) floating-point \xe2\x80\xa6ChAdd the lower half-precision (16-bit) floating-point \xe2\x80\xa6CjAdd the lower single-precision (32-bit) floating-point \xe2\x80\xa6CnConcatenate a and b into a 32-byte immediate result, shift \xe2\x80\xa60CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa6CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa6CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60000022CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa63CmDivide the lower double-precision (64-bit) floating-point \xe2\x80\xa6CkDivide the lower half-precision (16-bit) floating-point \xe2\x80\xa6CmDivide the lower single-precision (32-bit) floating-point \xe2\x80\xa6CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa6CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa6CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa6CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa6ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa6CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa6210C`Multiply the lower double-precision (64-bit) \xe2\x80\xa6CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Multiply the lower single-precision (32-bit) \xe2\x80\xa6CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa6CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa6CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa6ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa6ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa6CkShuffle packed 8-bit integers in a according to shuffle \xe2\x80\xa6C`Subtract the lower double-precision (64-bit) \xe2\x80\xa6CmSubtract the lower half-precision (16-bit) floating-point \xe2\x80\xa6C`Subtract the lower single-precision (32-bit) \xe2\x80\xa6CmLoads 2 double-precision (64-bit) floating-point elements \xe2\x80\xa6CmLoads 4 single-precision (32-bit) floating-point elements \xe2\x80\xa61CmLoads 2 single-precision (32-bit) floating-point elements \xe2\x80\xa6CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa6CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa6CiBitwise ternary logic that provides the capability to \xe2\x80\xa60AnCalling this function when \xe2\x80\xa6CnReturns the amount of time elapsed from another instant to \xe2\x80\xa6CkThis function computes quasi-inverses for matrices A, B \xe2\x80\xa6CkCheck if the post-condition <code>cond</code> has been met.FkCopies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>self</code> to <code>dest</code>. The \xe2\x80\xa6DjDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> \xe2\x80\xa6DiDecrements the strong reference count on the <code>Rc&lt;T&gt;</code> \xe2\x80\xa6D`Forwards to the method defined on the type <code>dyn Any</code>.CjReturns a mutable reference to the inner value as type \xe2\x80\xa6ClForwards to the method defined on the type <code>Any</code>.20DbReturns a reference to the inner value as type <code>dyn T</code>.BdComputes the filtration one product.CjConverts with LLVM\xe2\x80\x99s fptoui/fptosi, which may return \xe2\x80\xa6DjIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> \xe2\x80\xa6DiIncrements the strong reference count on the <code>Rc&lt;T&gt;</code> \xe2\x80\xa6CmInserts a new key-value pair into the map in the gap that \xe2\x80\xa6")
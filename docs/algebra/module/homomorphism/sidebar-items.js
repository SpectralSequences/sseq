initSidebarItems({"mod":[["bounded_module_homomorphism",""],["composition_homomorphism",""],["finite_module_homomorphism",""],["fp_module_homomorphism",""],["free_module_homomorphism",""],["generic_zero_homomorphism",""],["hom_pullback",""],["quotient_homomorphism",""],["truncated_homomorphism",""]],"struct":[["BoundedModuleHomomorphism",""],["CompositionHomomorphism","A composition of two module homomorphisms. This has a more efficient implementation if the first map is a free module homomorphism. Without specialization, we stick to implementing this case."],["FPModuleHomomorphism",""],["FiniteModuleHomomorphism",""],["FreeModuleHomomorphism",""],["GenericZeroHomomorphism",""],["HomPullback","Given a map `map`: A -> B and `source` = Hom(B, X), `target` = Hom(A, X), produce the induced map `map`^* Hom(B, X) -> Hom(A, X)."],["QuotientHomomorphism",""],["QuotientHomomorphismSource",""],["TruncatedHomomorphism",""],["TruncatedHomomorphismSource",""]],"trait":[["FPModuleT",""],["IdentityHomomorphism",""],["ModuleHomomorphism","Each `ModuleHomomorphism` may come with auxiliary data, namely the kernel, image and quasi_inverse at each degree (the quasi-inverse is a map that is a right inverse when restricted to the image). These are computed via [`ModuleHomomorphism::compute_auxiliary_data_through_degree`] and retrieved through [`ModuleHomomorphism::kernel`], [`ModuleHomomorphism::quasi_inverse`] and [`ModuleHomomorphism::image`]."],["ZeroHomomorphism",""]]});
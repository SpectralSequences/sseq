<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Converts an address back to a pointer, picking up some previously ‘exposed’ provenance."><title>with_exposed_provenance in once::std_or_loom::ptr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="once" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.1 (01f6ddf75 2026-02-11)" data-channel="1.93.1" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.3/dist/katex.min.css" integrity="sha384-ThssJ7YtjywV52Gj4JE/1SQEDoMEckXyhkFVwaf4nDSm5OBlXeedVYjuuUd0Yua+" crossorigin="anonymous">
<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.3/dist/katex.min.js" integrity="sha384-Bi8OWqMXO1ta+a4EPkZv7bYGIes7C3krGSZoTGNTAnAn5eYQc7IIXrJ/7ck1drAi" crossorigin="anonymous"></script>
<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.3/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\(", right: "\\)", display: false},
                {left: "$", right: "$", display: false},
                {left: "\\[", right: "\\]", display: true}
            ],
            macros: {
                "\\Ext": "\\operatorname{Ext}",
                "\\Mod": "\\operatorname{Mod}",
                "\\Hom": "\\operatorname{Hom}",
                "\\Sq": "\\operatorname{Sq}",
                "\\F": "\\mathbb{F}",
            }
        });
    });
</script>

</head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">with_exposed_provenance</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../once/index.html">once</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In once::<wbr>std_<wbr>or_<wbr>loom::<wbr>ptr</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">once</a>::<wbr><a href="../index.html">std_or_loom</a>::<wbr><a href="index.html">ptr</a></div><h1>Function <span class="fn">with_<wbr>exposed_<wbr>provenance</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.84.0, const since 1.91.0">1.84.0 (const: 1.91.0)</span> · <a class="src" href="https://doc.rust-lang.org/1.93.1/src/core/ptr/mod.rs.html#985">Source</a> </span></div><pre class="rust item-decl"><code>pub const fn with_exposed_provenance&lt;T&gt;(addr: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.pointer.html">*const T</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Converts an address back to a pointer, picking up some previously ‘exposed’
<a href="index.html#provenance" title="mod once::std_or_loom::ptr">provenance</a>.</p>
<p>This is fully equivalent to <code>addr as *const T</code>. The provenance of the returned pointer is that
of <em>some</em> pointer that was previously exposed by passing it to
<a href="https://doc.rust-lang.org/1.93.1/std/primitive.pointer.html#method.expose_provenance" title="method pointer::expose_provenance"><code>expose_provenance</code></a>, or a <code>ptr as usize</code> cast. In addition, memory
which is outside the control of the Rust abstract machine (MMIO registers, for example) is
always considered to be accessible with an exposed provenance, so long as this memory is disjoint
from memory that will be used by the abstract machine such as the stack, heap, and statics.</p>
<p>The exact provenance that gets picked is not specified. The compiler will do its best to pick
the “right” provenance for you (whatever that may be), but currently we cannot provide any
guarantees about which provenance the resulting pointer will have – and therefore there
is no definite specification for which memory the resulting pointer may access.</p>
<p>If there is <em>no</em> previously ‘exposed’ provenance that justifies the way the returned pointer
will be used, the program has undefined behavior. In particular, the aliasing rules still apply:
pointers and references that have been invalidated due to aliasing accesses cannot be used
anymore, even if they have been exposed!</p>
<p>Due to its inherent ambiguity, this operation may not be supported by tools that help you to
stay conformant with the Rust memory model. It is recommended to use <a href="index.html#strict-provenance" title="mod once::std_or_loom::ptr">Strict
Provenance</a> APIs such as <a href="https://doc.rust-lang.org/1.93.1/std/primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a> wherever
possible.</p>
<p>On most platforms this will produce a value with the same bytes as the address. Platforms
which need to store additional information in a pointer may not support this operation,
since it is generally not possible to actually <em>compute</em> which provenance the returned
pointer has to pick up.</p>
<p>This is an <a href="index.html#exposed-provenance" title="mod once::std_or_loom::ptr">Exposed Provenance</a> API.</p>
</div></details></section></div></main></body></html>
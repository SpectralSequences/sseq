(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*!!
 *  Canvas 2 Svg v1.0.15
 *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.
 *
 *  Licensed under the MIT license:
 *  http://www.opensource.org/licenses/mit-license.php
 *
 *  Author:
 *  Kerry Liu
 *
 *  Copyright (c) 2014 Gliffy Inc.
 */

;(function() {
    "use strict";

    var STYLES, ctx, CanvasGradient, CanvasPattern, namedEntities;

    //helper function to format a string
    function format(str, args) {
        var keys = Object.keys(args), i;
        for (i=0; i<keys.length; i++) {
            str = str.replace(new RegExp("\\{" + keys[i] + "\\}", "gi"), args[keys[i]]);
        }
        return str;
    }

    //helper function that generates a random string
    function randomString(holder) {
        var chars, randomstring, i;
        if (!holder) {
            throw new Error("cannot create a random attribute name for an undefined object");
        }
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
        randomstring = "";
        do {
            randomstring = "";
            for (i = 0; i < 12; i++) {
                randomstring += chars[Math.floor(Math.random() * chars.length)];
            }
        } while (holder[randomstring]);
        return randomstring;
    }

    //helper function to map named to numbered entities
    function createNamedToNumberedLookup(items, radix) {
        var i, entity, lookup = {}, base10, base16;
        items = items.split(',');
        radix = radix || 10;
        // Map from named to numbered entities.
        for (i = 0; i < items.length; i += 2) {
            entity = '&' + items[i + 1] + ';';
            base10 = parseInt(items[i], radix);
            lookup[entity] = '&#'+base10+';';
        }
        //FF and IE need to create a regex from hex values ie &nbsp; == \xa0
        lookup["\\xa0"] = '&#160;';
        return lookup;
    }

    //helper function to map canvas-textAlign to svg-textAnchor
    function getTextAnchor(textAlign) {
        //TODO: support rtl languages
        var mapping = {"left":"start", "right":"end", "center":"middle", "start":"start", "end":"end"};
        return mapping[textAlign] || mapping.start;
    }

    //helper function to map canvas-textBaseline to svg-dominantBaseline
    function getDominantBaseline(textBaseline) {
        //INFO: not supported in all browsers
        var mapping = {"alphabetic": "alphabetic", "hanging": "hanging", "top":"text-before-edge", "bottom":"text-after-edge", "middle":"central"};
        return mapping[textBaseline] || mapping.alphabetic;
    }

    // Unpack entities lookup where the numbers are in radix 32 to reduce the size
    // entity mapping courtesy of tinymce
    namedEntities = createNamedToNumberedLookup(
        '50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +
            '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +
            '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +
            '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +
            '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +
            '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +
            '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +
            '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +
            '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +
            '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +
            'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +
            'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +
            't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +
            'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +
            'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +
            '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +
            '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +
            '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +
            '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +
            '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +
            'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +
            'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +
            'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +
            '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +
            '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);


    //Some basic mappings for attributes and default values.
    STYLES = {
        "strokeStyle":{
            svgAttr : "stroke", //corresponding svg attribute
            canvas : "#000000", //canvas default
            svg : "none",       //svg default
            apply : "stroke"    //apply on stroke() or fill()
        },
        "fillStyle":{
            svgAttr : "fill",
            canvas : "#000000",
            svg : null, //svg default is black, but we need to special case this to handle canvas stroke without fill
            apply : "fill"
        },
        "lineCap":{
            svgAttr : "stroke-linecap",
            canvas : "butt",
            svg : "butt",
            apply : "stroke"
        },
        "lineJoin":{
            svgAttr : "stroke-linejoin",
            canvas : "miter",
            svg : "miter",
            apply : "stroke"
        },
        "miterLimit":{
            svgAttr : "stroke-miterlimit",
            canvas : 10,
            svg : 4,
            apply : "stroke"
        },
        "lineWidth":{
            svgAttr : "stroke-width",
            canvas : 1,
            svg : 1,
            apply : "stroke"
        },
        "globalAlpha": {
            svgAttr : "opacity",
            canvas : 1,
            svg : 1,
            apply : "fill stroke"
        },
        "font":{
            //font converts to multiple svg attributes, there is custom logic for this
            canvas : "10px sans-serif"
        },
        "shadowColor":{
            canvas : "#000000"
        },
        "shadowOffsetX":{
            canvas : 0
        },
        "shadowOffsetY":{
            canvas : 0
        },
        "shadowBlur":{
            canvas : 0
        },
        "textAlign":{
            canvas : "start"
        },
        "textBaseline":{
            canvas : "alphabetic"
        }
    };

    /**
     *
     * @param gradientNode - reference to the gradient
     * @constructor
     */
    CanvasGradient = function(gradientNode, ctx) {
        this.__root = gradientNode;
        this.__ctx = ctx;
    };

    /**
     * Adds a color stop to the gradient root
     */
    CanvasGradient.prototype.addColorStop = function(offset, color) {
        var stop = this.__ctx.__createElement("stop"), regex, matches;
        stop.setAttribute("offset", offset);
        if(color.indexOf("rgba") !== -1) {
            //separate alpha value, since webkit can't handle it
            regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
            matches = regex.exec(color);
            stop.setAttribute("stop-color", format("rgb({r},{g},{b})", {r:matches[1], g:matches[2], b:matches[3]}));
            stop.setAttribute("stop-opacity", matches[4]);
        } else {
            stop.setAttribute("stop-color", color);
        }
        this.__root.appendChild(stop);
    };

    CanvasPattern = function(pattern, ctx) {
        this.__root = pattern;
        this.__ctx = ctx;
    };

    /**
     * The mock canvas context
     * @param o - options include:
     * width - width of your canvas (defaults to 500)
     * height - height of your canvas (defaults to 500)
     * enableMirroring - enables canvas mirroring (get image data) (defaults to false)
     * document - the document object (defaults to the current document)
     */
    ctx = function(o) {

        var defaultOptions = { width:500, height:500, enableMirroring : false}, options;

        //keep support for this way of calling C2S: new C2S(width,height)
        if(arguments.length > 1) {
            options = defaultOptions;
            options.width = arguments[0];
            options.height = arguments[1];
        } else if( !o ) {
            options = defaultOptions;
        } else {
            options = o;
        }

        if(!(this instanceof ctx)) {
            //did someone call this without new?
            return new ctx(options);
        }

        //setup options
        this.width = options.width || defaultOptions.width;
        this.height = options.height || defaultOptions.height;
        this.enableMirroring = options.enableMirroring !== undefined ? options.enableMirroring : defaultOptions.enableMirroring;

        this.canvas = this;   ///point back to this instance!
        this.__document = options.document || document;
        this.__canvas = this.__document.createElement("canvas");
        this.__ctx = this.__canvas.getContext("2d");

        this.__setDefaultStyles();
        this.__stack = [this.__getStyleState()];
        this.__groupStack = [];

        //the root svg element
        this.__root = this.__document.createElementNS("http://www.w3.org/2000/svg", "svg");
        this.__root.setAttribute("version", 1.1);
        this.__root.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        this.__root.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
        this.__root.setAttribute("width", this.width);
        this.__root.setAttribute("height", this.height);

        //make sure we don't generate the same ids in defs
        this.__ids = {};

        //defs tag
        this.__defs = this.__document.createElementNS("http://www.w3.org/2000/svg", "defs");
        this.__root.appendChild(this.__defs);

        //also add a group child. the svg element can't use the transform attribute
        this.__currentElement = this.__document.createElementNS("http://www.w3.org/2000/svg", "g");
        this.__root.appendChild(this.__currentElement);
    };


    /**
     * Creates the specified svg element
     * @private
     */
    ctx.prototype.__createElement = function (elementName, properties, resetFill) {
        if (typeof properties === "undefined") {
            properties = {};
        }

        var element = this.__document.createElementNS("http://www.w3.org/2000/svg", elementName),
            keys = Object.keys(properties), i, key;
        if(resetFill) {
            //if fill or stroke is not specified, the svg element should not display. By default SVG's fill is black.
            element.setAttribute("fill", "none");
            element.setAttribute("stroke", "none");
        }
        for(i=0; i<keys.length; i++) {
            key = keys[i];
            element.setAttribute(key, properties[key]);
        }
        return element;
    };

    /**
     * Applies default canvas styles to the context
     * @private
     */
    ctx.prototype.__setDefaultStyles = function() {
        //default 2d canvas context properties see:http://www.w3.org/TR/2dcontext/
        var keys = Object.keys(STYLES), i, key;
        for(i=0; i<keys.length; i++) {
            key = keys[i];
            this[key] = STYLES[key].canvas;
        }
    };

    /**
     * Applies styles on restore
     * @param styleState
     * @private
     */
    ctx.prototype.__applyStyleState = function(styleState) {
        var keys = Object.keys(styleState), i, key;
        for(i=0; i<keys.length; i++) {
            key = keys[i];
            this[key] = styleState[key];
        }
    };

    /**
     * Gets the current style state
     * @return {Object}
     * @private
     */
    ctx.prototype.__getStyleState = function() {
        var i, styleState = {}, keys = Object.keys(STYLES), key;
        for(i=0; i<keys.length; i++) {
            key = keys[i];
            styleState[key] = this[key];
        }
        return styleState;
    };

    /**
     * Apples the current styles to the current SVG element. On "ctx.fill" or "ctx.stroke"
     * @param type
     * @private
     */
    ctx.prototype.__applyStyleToCurrentElement = function(type) {
        var keys = Object.keys(STYLES), i, style, value, id, regex, matches;
        for(i=0; i<keys.length; i++) {
            style = STYLES[keys[i]];
            value = this[keys[i]];
            if(style.apply) {
                //is this a gradient or pattern?
                if(style.apply.indexOf("fill")!==-1 && value instanceof CanvasPattern) {
                    //pattern
                    if(value.__ctx) {
                        //copy over defs
                        while(value.__ctx.__defs.childNodes.length) {
                            id = value.__ctx.__defs.childNodes[0].getAttribute("id");
                            this.__ids[id] = id;
                            this.__defs.appendChild(value.__ctx.__defs.childNodes[0]);
                        }
                    }
                    this.__currentElement.setAttribute("fill", format("url(#{id})", {id:value.__root.getAttribute("id")}));
                }
                else if(style.apply.indexOf("fill")!==-1 && value instanceof CanvasGradient) {
                    //gradient
                    this.__currentElement.setAttribute("fill", format("url(#{id})", {id:value.__root.getAttribute("id")}));
                } else if(style.apply.indexOf(type)!==-1 && style.svg !== value) {
                    if((style.svgAttr === "stroke" || style.svgAttr === "fill") && value.indexOf("rgba") !== -1) {
                        //separate alpha value, since illustrator can't handle it
                        regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
                        matches = regex.exec(value);
                        this.__currentElement.setAttribute(style.svgAttr, format("rgb({r},{g},{b})", {r:matches[1], g:matches[2], b:matches[3]}));
                        this.__currentElement.setAttribute(style.svgAttr+"-opacity", matches[4]);
                    } else {
                        //otherwise only update attribute if right type, and not svg default
                        this.__currentElement.setAttribute(style.svgAttr, value);
                    }
                }
            }
        }

    };

    /**
     * Will return the closest group or svg node. May return the current element.
     * @private
     */
    ctx.prototype.__closestGroupOrSvg = function(node) {
        node = node || this.__currentElement;
        if(node.nodeName === "g" || node.nodeName === "svg") {
            return node;
        } else {
            return this.__closestGroupOrSvg(node.parentNode);
        }
    };

    /**
     * Returns the serialized value of the svg so far
     * @param fixNamedEntities - Standalone SVG doesn't support named entities, which document.createTextNode encodes.
     *                           If true, we attempt to find all named entities and encode it as a numeric entity.
     * @return serialized svg
     */
    ctx.prototype.getSerializedSvg = function(fixNamedEntities) {
        var serialized = new XMLSerializer().serializeToString(this.__root),
            keys, i, key, value, regexp, xmlns;

        //IE search for a duplicate xmnls because they didn't implement setAttributeNS correctly
        xmlns = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi;
        if(xmlns.test(serialized)) {
            serialized = serialized.replace('xmlns="http://www.w3.org/2000/svg','xmlns:xlink="http://www.w3.org/1999/xlink');
        }

        if(fixNamedEntities) {
            keys = Object.keys(namedEntities);
            //loop over each named entity and replace with the proper equivalent.
            for(i=0; i<keys.length; i++) {
                key = keys[i];
                value = namedEntities[key];
                regexp = new RegExp(key, "gi");
                if(regexp.test(serialized)) {
                    serialized = serialized.replace(regexp, value);
                }
            }
        }

        return serialized;
    };


    /**
     * Returns the root svg
     * @return
     */
    ctx.prototype.getSvg = function() {
        return this.__root;
    };
    /**
     * Will generate a group tag.
     */
    ctx.prototype.save = function() {
        var group = this.__createElement("g"), parent = this.__closestGroupOrSvg();
        this.__groupStack.push(parent);
        parent.appendChild(group);
        this.__currentElement = group;
        this.__stack.push(this.__getStyleState());
    };
    /**
     * Sets current element to parent, or just root if already root
     */
    ctx.prototype.restore = function(){
        this.__currentElement = this.__groupStack.pop();
        var state = this.__stack.pop();
        this.__applyStyleState(state);

    };

    /**
     * Helper method to add transform
     * @private
     */
    ctx.prototype.__addTransform = function(t) {

        //if the current element has siblings, add another group
        var parent = this.__closestGroupOrSvg();
        if(parent.childNodes.length > 0) {
            var group = this.__createElement("g");
            parent.appendChild(group);
            this.__currentElement = group;
        }

        var transform = this.__currentElement.getAttribute("transform");
        if(transform) {
            transform += " ";
        } else {
            transform = "";
        }
        transform += t;
        this.__currentElement.setAttribute("transform", transform);
    };

    /**
     *  scales the current element
     */
    ctx.prototype.scale = function(x, y) {
        if(y === undefined) {
            y = x;
        }
        this.__addTransform(format("scale({x},{y})", {x:x, y:y}));
    };

    /**
     * rotates the current element
     */
    ctx.prototype.rotate = function(angle){
        var degrees = (angle * 180 / Math.PI);
        this.__addTransform(format("rotate({angle},{cx},{cy})", {angle:degrees, cx:0, cy:0}));
    };

    /**
     * translates the current element
     */
    ctx.prototype.translate = function(x, y){
        this.__addTransform(format("translate({x},{y})", {x:x,y:y}));
    };

    /**
     * applies a transform to the current element
     */
    ctx.prototype.transform = function(a, b, c, d, e, f){
        this.__addTransform(format("matrix({a},{b},{c},{d},{e},{f})", {a:a, b:b, c:c, d:d, e:e, f:f}));
    };

    /**
     * Create a new Path Element
     */
    ctx.prototype.beginPath = function(){
        var path, parent;

        // Note that there is only one current default path, it is not part of the drawing state.
        // See also: https://html.spec.whatwg.org/multipage/scripting.html#current-default-path
        this.__currentDefaultPath = "";
        this.__currentPosition = {};

        path = this.__createElement("path", {}, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(path);
        this.__currentElement = path;
    };

    /**
     * Helper function to apply currentDefaultPath to current path element
     * @private
     */
    ctx.prototype.__applyCurrentDefaultPath = function() {
        if(this.__currentElement.nodeName === "path") {
            var d = this.__currentDefaultPath;
            this.__currentElement.setAttribute("d", d);
        } else {
            throw new Error("Attempted to apply path command to node " + this.__currentElement.nodeName);
        }
    };

    /**
     * Helper function to add path command
     * @private
     */
    ctx.prototype.__addPathCommand = function(command){
        this.__currentDefaultPath += " ";
        this.__currentDefaultPath += command;
    };

    /**
     * Adds the move command to the current path element,
     * if the currentPathElement is not empty create a new path element
     */
    ctx.prototype.moveTo = function(x,y){
        if(this.__currentElement.nodeName !== "path") {
            this.beginPath();
        }

        // creates a new subpath with the given point
        this.__currentPosition = {x: x, y: y};
        this.__addPathCommand(format("M {x} {y}", {x:x, y:y}));
    };

    /**
     * Closes the current path
     */
    ctx.prototype.closePath = function(){
        this.__addPathCommand("Z");
    };

    /**
     * Adds a line to command
     */
    ctx.prototype.lineTo = function(x, y){
        this.__currentPosition = {x: x, y: y};
        if (this.__currentDefaultPath.indexOf('M') > -1) {
            this.__addPathCommand(format("L {x} {y}", {x:x, y:y}));
        } else {
            this.__addPathCommand(format("M {x} {y}", {x:x, y:y}));
        }
    };

    /**
     * Add a bezier command
     */
    ctx.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.__currentPosition = {x: x, y: y};
        this.__addPathCommand(format("C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}",
            {cp1x:cp1x, cp1y:cp1y, cp2x:cp2x, cp2y:cp2y, x:x, y:y}));
    };

    /**
     * Adds a quadratic curve to command
     */
    ctx.prototype.quadraticCurveTo = function(cpx, cpy, x, y){
        this.__currentPosition = {x: x, y: y};
        this.__addPathCommand(format("Q {cpx} {cpy} {x} {y}", {cpx:cpx, cpy:cpy, x:x, y:y}));
    };


    /**
     * Return a new normalized vector of given vector
     */
    var normalize = function(vector) {
        var len = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
        return [vector[0] / len, vector[1] / len];
    };

    /**
     * Adds the arcTo to the current path
     *
     * @see http://www.w3.org/TR/2015/WD-2dcontext-20150514/#dom-context-2d-arcto
     */
    ctx.prototype.arcTo = function(x1, y1, x2, y2, radius) {
        // Let the point (x0, y0) be the last point in the subpath.
        var x0 = this.__currentPosition && this.__currentPosition.x;
        var y0 = this.__currentPosition && this.__currentPosition.y;

        // First ensure there is a subpath for (x1, y1).
        if (typeof x0 == "undefined" || typeof y0 == "undefined") {
            return;
        }

        // Negative values for radius must cause the implementation to throw an IndexSizeError exception.
        if (radius < 0) {
            throw new Error("IndexSizeError: The radius provided (" + radius + ") is negative.");
        }

        // If the point (x0, y0) is equal to the point (x1, y1),
        // or if the point (x1, y1) is equal to the point (x2, y2),
        // or if the radius radius is zero,
        // then the method must add the point (x1, y1) to the subpath,
        // and connect that point to the previous point (x0, y0) by a straight line.
        if (((x0 === x1) && (y0 === y1))
            || ((x1 === x2) && (y1 === y2))
            || (radius === 0)) {
            this.lineTo(x1, y1);
            return;
        }

        // Otherwise, if the points (x0, y0), (x1, y1), and (x2, y2) all lie on a single straight line,
        // then the method must add the point (x1, y1) to the subpath,
        // and connect that point to the previous point (x0, y0) by a straight line.
        var unit_vec_p1_p0 = normalize([x0 - x1, y0 - y1]);
        var unit_vec_p1_p2 = normalize([x2 - x1, y2 - y1]);
        if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {
            this.lineTo(x1, y1);
            return;
        }

        // Otherwise, let The Arc be the shortest arc given by circumference of the circle that has radius radius,
        // and that has one point tangent to the half-infinite line that crosses the point (x0, y0) and ends at the point (x1, y1),
        // and that has a different point tangent to the half-infinite line that ends at the point (x1, y1), and crosses the point (x2, y2).
        // The points at which this circle touches these two lines are called the start and end tangent points respectively.

        // note that both vectors are unit vectors, so the length is 1
        var cos = (unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1]);
        var theta = Math.acos(Math.abs(cos));

        // Calculate origin
        var unit_vec_p1_origin = normalize([
            unit_vec_p1_p0[0] + unit_vec_p1_p2[0],
            unit_vec_p1_p0[1] + unit_vec_p1_p2[1]
        ]);
        var len_p1_origin = radius / Math.sin(theta / 2);
        var x = x1 + len_p1_origin * unit_vec_p1_origin[0];
        var y = y1 + len_p1_origin * unit_vec_p1_origin[1];

        // Calculate start angle and end angle
        // rotate 90deg clockwise (note that y axis points to its down)
        var unit_vec_origin_start_tangent = [
            -unit_vec_p1_p0[1],
            unit_vec_p1_p0[0]
        ];
        // rotate 90deg counter clockwise (note that y axis points to its down)
        var unit_vec_origin_end_tangent = [
            unit_vec_p1_p2[1],
            -unit_vec_p1_p2[0]
        ];
        var getAngle = function(vector) {
            // get angle (clockwise) between vector and (1, 0)
            var x = vector[0];
            var y = vector[1];
            if (y >= 0) { // note that y axis points to its down
                return Math.acos(x);
            } else {
                return -Math.acos(x);
            }
        };
        var startAngle = getAngle(unit_vec_origin_start_tangent);
        var endAngle = getAngle(unit_vec_origin_end_tangent);

        // Connect the point (x0, y0) to the start tangent point by a straight line
        this.lineTo(x + unit_vec_origin_start_tangent[0] * radius,
                    y + unit_vec_origin_start_tangent[1] * radius);

        // Connect the start tangent point to the end tangent point by arc
        // and adding the end tangent point to the subpath.
        this.arc(x, y, radius, startAngle, endAngle);
    };

    /**
     * Sets the stroke property on the current element
     */
    ctx.prototype.stroke = function(){
        if(this.__currentElement.nodeName === "path") {
            this.__currentElement.setAttribute("paint-order", "fill stroke markers");
        }
        this.__applyCurrentDefaultPath();
        this.__applyStyleToCurrentElement("stroke");
    };

    /**
     * Sets fill properties on the current element
     */
    ctx.prototype.fill = function(){
        if(this.__currentElement.nodeName === "path") {
            this.__currentElement.setAttribute("paint-order", "stroke fill markers");
        }
        this.__applyCurrentDefaultPath();
        this.__applyStyleToCurrentElement("fill");
    };

    /**
     *  Adds a rectangle to the path.
     */
    ctx.prototype.rect = function(x, y, width, height){
        if(this.__currentElement.nodeName !== "path") {
            this.beginPath();
        }
        this.moveTo(x, y);
        this.lineTo(x+width, y);
        this.lineTo(x+width, y+height);
        this.lineTo(x, y+height);
        this.lineTo(x, y);
        this.closePath();
    };


    /**
     * adds a rectangle element
     */
    ctx.prototype.fillRect = function(x, y, width, height){
        var rect, parent;
        rect = this.__createElement("rect", {
            x : x,
            y : y,
            width : width,
            height : height
        }, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(rect);
        this.__currentElement = rect;
        this.__applyStyleToCurrentElement("fill");
    };

    /**
     * Draws a rectangle with no fill
     * @param x
     * @param y
     * @param width
     * @param height
     */
    ctx.prototype.strokeRect = function(x, y, width, height){
        var rect, parent;
        rect = this.__createElement("rect", {
            x : x,
            y : y,
            width : width,
            height : height
        }, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(rect);
        this.__currentElement = rect;
        this.__applyStyleToCurrentElement("stroke");
    };


    /**
     * "Clears" a canvas by just drawing a white rectangle in the current group.
     */
    ctx.prototype.clearRect = function(x, y, width, height) {
        var rect, parent = this.__closestGroupOrSvg();
        rect = this.__createElement("rect", {
            x : x,
            y : y,
            width : width,
            height : height,
            fill : "#FFFFFF"
        }, true);
        parent.appendChild(rect);
    };

    /**
     * Adds a linear gradient to a defs tag.
     * Returns a canvas gradient object that has a reference to it's parent def
     */
    ctx.prototype.createLinearGradient = function(x1, y1, x2, y2){
        var grad = this.__createElement("linearGradient", {
            id : randomString(this.__ids),
            x1 : x1+"px",
            x2 : x2+"px",
            y1 : y1+"px",
            y2 : y2+"px",
            "gradientUnits" : "userSpaceOnUse"
        }, false);
        this.__defs.appendChild(grad);
        return new CanvasGradient(grad, this);
    };

    /**
     * Adds a radial gradient to a defs tag.
     * Returns a canvas gradient object that has a reference to it's parent def
     */
    ctx.prototype.createRadialGradient = function(x0, y0, r0, x1, y1, r1){
        var grad = this.__createElement("radialGradient", {
            id : randomString(this.__ids),
            cx : x1+"px",
            cy : y1+"px",
            r  : r1+"px",
            fx : x0+"px",
            fy : y0+"px",
            "gradientUnits" : "userSpaceOnUse"
        }, false);
        this.__defs.appendChild(grad);
        return new CanvasGradient(grad, this);

    };

    /**
     * Parses the font string and returns svg mapping
     * @private
     */
    ctx.prototype.__parseFont = function() {
        var regex = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\"\sa-z]+?)\s*$/i;
        var fontPart = regex.exec( this.font );
        var data = {
            style : fontPart[1] || 'normal',
            size : fontPart[4] || '10px',
            family : fontPart[6] || 'sans-serif',
            weight: fontPart[3] || 'normal',
            decoration : fontPart[2] || 'normal',
            href : null
        };

        //canvas doesn't support underline natively, but we can pass this attribute
        if(this.__fontUnderline === "underline") {
            data.decoration = "underline";
        }

        //canvas also doesn't support linking, but we can pass this as well
        if(this.__fontHref) {
            data.href = this.__fontHref;
        }

        return data;
    };

    /**
     * Helper to link text fragments
     * @param font
     * @param element
     * @return {*}
     * @private
     */
    ctx.prototype.__wrapTextLink = function(font, element) {
        if(font.href) {
            var a = this.__createElement("a");
            a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", font.href);
            a.appendChild(element);
            return a;
        }
        return element;
    };

    /**
     * Fills or strokes text
     * @param text
     * @param x
     * @param y
     * @param action - stroke or fill
     * @private
     */
    ctx.prototype.__applyText = function(text, x, y, action) {
        var font = this.__parseFont(),
            parent = this.__closestGroupOrSvg(),
            textElement = this.__createElement("text", {
                "font-family" : font.family,
                "font-size" : font.size,
                "font-style" : font.style,
                "font-weight" : font.weight,
                "text-decoration" : font.decoration,
                "x" : x,
                "y" : y,
                "text-anchor": getTextAnchor(this.textAlign),
                "dominant-baseline": getDominantBaseline(this.textBaseline)
            }, true);

        textElement.appendChild(this.__document.createTextNode(text));
        this.__currentElement = textElement;
        this.__applyStyleToCurrentElement(action);
        parent.appendChild(this.__wrapTextLink(font,textElement));
    };

    /**
     * Creates a text element
     * @param text
     * @param x
     * @param y
     */
    ctx.prototype.fillText = function(text, x, y){
        this.__applyText(text, x, y, "fill");
    };

    /**
     * Strokes text
     * @param text
     * @param x
     * @param y
     */
    ctx.prototype.strokeText = function(text, x, y){
        this.__applyText(text, x, y, "stroke");
    };

    /**
     * No need to implement this for svg.
     * @param text
     * @return {TextMetrics}
     */
    ctx.prototype.measureText = function(text){
        this.__ctx.font = this.font;
        return this.__ctx.measureText(text);
    };

    /**
     *  Arc command!
     */
    ctx.prototype.arc = function(x, y, radius, startAngle, endAngle, counterClockwise) {
        // in canvas no circle is drawn if no angle is provided.
        if (startAngle === endAngle) {
            return;
        }
        startAngle = startAngle % (2*Math.PI);
        endAngle = endAngle % (2*Math.PI);
        if(startAngle === endAngle) {
            //circle time! subtract some of the angle so svg is happy (svg elliptical arc can't draw a full circle)
            endAngle = ((endAngle + (2*Math.PI)) - 0.001 * (counterClockwise ? -1 : 1)) % (2*Math.PI);
        }
        var endX = x+radius*Math.cos(endAngle),
            endY = y+radius*Math.sin(endAngle),
            startX = x+radius*Math.cos(startAngle),
            startY = y+radius*Math.sin(startAngle),
            sweepFlag = counterClockwise ? 0 : 1,
            largeArcFlag = 0,
            diff = endAngle - startAngle;

        // https://github.com/gliffy/canvas2svg/issues/4
        if(diff < 0) {
            diff += 2*Math.PI;
        }

        if(counterClockwise) {
            largeArcFlag = diff > Math.PI ? 0 : 1;
        } else {
            largeArcFlag = diff > Math.PI ? 1 : 0;
        }

        this.lineTo(startX, startY);
        this.__addPathCommand(format("A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}",
            {rx:radius, ry:radius, xAxisRotation:0, largeArcFlag:largeArcFlag, sweepFlag:sweepFlag, endX:endX, endY:endY}));

        this.__currentPosition = {x: endX, y: endY};
    };

    /**
     * Generates a ClipPath from the clip command.
     */
    ctx.prototype.clip = function(){
        var group = this.__closestGroupOrSvg(),
            clipPath = this.__createElement("clipPath"),
            id =  randomString(this.__ids),
            newGroup = this.__createElement("g");

        group.removeChild(this.__currentElement);
        clipPath.setAttribute("id", id);
        clipPath.appendChild(this.__currentElement);

        this.__defs.appendChild(clipPath);

        //set the clip path to this group
        group.setAttribute("clip-path", format("url(#{id})", {id:id}));

        //clip paths can be scaled and transformed, we need to add another wrapper group to avoid later transformations
        // to this path
        group.appendChild(newGroup);

        this.__currentElement = newGroup;

    };

    /**
     * Draws a canvas, image or mock context to this canvas.
     * Note that all svg dom manipulation uses node.childNodes rather than node.children for IE support.
     * http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage
     */
    ctx.prototype.drawImage = function(){
        //convert arguments to a real array
        var args = Array.prototype.slice.call(arguments),
            image=args[0],
            dx, dy, dw, dh, sx=0, sy=0, sw, sh, parent, svg, defs, group,
            currentElement, svgImage, canvas, context, id;

        if(args.length === 3) {
            dx = args[1];
            dy = args[2];
            sw = image.width;
            sh = image.height;
            dw = sw;
            dh = sh;
        } else if(args.length === 5) {
            dx = args[1];
            dy = args[2];
            dw = args[3];
            dh = args[4];
            sw = image.width;
            sh = image.height;
        } else if(args.length === 9) {
            sx = args[1];
            sy = args[2];
            sw = args[3];
            sh = args[4];
            dx = args[5];
            dy = args[6];
            dw = args[7];
            dh = args[8];
        } else {
            throw new Error("Inavlid number of arguments passed to drawImage: " + arguments.length);
        }

        parent = this.__closestGroupOrSvg();
        currentElement = this.__currentElement;

        if(image instanceof ctx) {
            //canvas2svg mock canvas context. In the future we may want to clone nodes instead.
            //also I'm currently ignoring dw, dh, sw, sh, sx, sy for a mock context.
            svg = image.getSvg();
            defs = svg.childNodes[0];
            while(defs.childNodes.length) {
                id = defs.childNodes[0].getAttribute("id");
                this.__ids[id] = id;
                this.__defs.appendChild(defs.childNodes[0]);
            }
            group = svg.childNodes[1];
            parent.appendChild(group);
            this.__currentElement = group;
            this.translate(dx, dy);
            this.__currentElement = currentElement;
        } else if(image.nodeName === "CANVAS" || image.nodeName === "IMG") {
            //canvas or image
            svgImage = this.__createElement("image");
            svgImage.setAttribute("width", dw);
            svgImage.setAttribute("height", dh);
            svgImage.setAttribute("preserveAspectRatio", "none");

            if(sx || sy || sw !== image.width || sh !== image.height) {
                //crop the image using a temporary canvas
                canvas = this.__document.createElement("canvas");
                canvas.width = dw;
                canvas.height = dh;
                context = canvas.getContext("2d");
                context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
                image = canvas;
            }

            svgImage.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href",
                image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src"));
            parent.appendChild(svgImage);
            this.__currentElement = svgImage;
            this.translate(dx, dy);
            this.__currentElement = currentElement;
        }
    };

    /**
     * Generates a pattern tag
     */
    ctx.prototype.createPattern = function(image, repetition){
        var pattern = this.__document.createElementNS("http://www.w3.org/2000/svg", "pattern"), id = randomString(this.__ids),
            img;
        pattern.setAttribute("id", id);
        pattern.setAttribute("width", image.width);
        pattern.setAttribute("height", image.height);
        if(image.nodeName === "CANVAS" || image.nodeName === "IMG") {
            img = this.__document.createElementNS("http://www.w3.org/2000/svg", "image");
            img.setAttribute("width", image.width);
            img.setAttribute("height", image.height);
            img.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href",
                image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src"));
            pattern.appendChild(img);
            this.__defs.appendChild(pattern);
        } else if(image instanceof ctx) {
            pattern.appendChild(image.__root.childNodes[1]);
            this.__defs.appendChild(pattern);
        }
        return new CanvasPattern(pattern, this);
    };

    /**
     * Not yet implemented
     */
    ctx.prototype.drawFocusRing = function(){};
    ctx.prototype.createImageData = function(){};
    ctx.prototype.getImageData = function(){};
    ctx.prototype.putImageData = function(){};
    ctx.prototype.globalCompositeOperation = function(){};
    ctx.prototype.setTransform = function(){};

    //add options for alternative namespace
    if (typeof window === "object") {
        window.C2S = ctx;
    }

    // CommonJS/Browserify
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = ctx;
    }

}());

},{}],2:[function(require,module,exports){
// https://d3js.org/d3-array/ v2.4.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

function count(values, valueof) {
  let count = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count;
      }
    }
  }
  return count;
}

function length(array) {
  return array.length | 0;
}

function empty(length) {
  return !(length > 0);
}

function arrayify(values) {
  return typeof values !== "object" || "length" in values ? values : Array.from(values);
}

function reducer(reduce) {
  return values => reduce(...values);
}

function cross(...values) {
  const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
  values = values.map(arrayify);
  const lengths = values.map(length);
  const j = values.length - 1;
  const index = new Array(j + 1).fill(0);
  const product = [];
  if (j < 0 || lengths.some(empty)) return product;
  while (true) {
    product.push(index.map((j, i) => values[i][j]));
    let i = j;
    while (++index[i] === lengths[i]) {
      if (i === 0) return reduce ? product.map(reduce) : product;
      index[i--] = 0;
    }
  }
}

function cumsum(values, valueof) {
  var sum = 0, index = 0;
  return Float64Array.from(values, valueof === undefined
    ? v => (sum += +v || 0)
    : v => (sum += +valueof(v, index++, values) || 0));
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function variance(values, valueof) {
  let count = 0;
  let delta;
  let mean = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  }
  if (count > 1) return sum / (count - 1);
}

function deviation(values, valueof) {
  const v = variance(values, valueof);
  return v ? Math.sqrt(v) : v;
}

function extent(values, valueof) {
  let min;
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  }
  return [min, max];
}

function identity(x) {
  return x;
}

function group(values, ...keys) {
  return nest(values, identity, identity, keys);
}

function groups(values, ...keys) {
  return nest(values, Array.from, identity, keys);
}

function rollup(values, reduce, ...keys) {
  return nest(values, identity, reduce, keys);
}

function rollups(values, reduce, ...keys) {
  return nest(values, Array.from, reduce, keys);
}

function nest(values, map, reduce, keys) {
  return (function regroup(values, i) {
    if (i >= keys.length) return reduce(values);
    const groups = new Map();
    const keyof = keys[i++];
    let index = -1;
    for (const value of values) {
      const key = keyof(value, ++index, values);
      const group = groups.get(key);
      if (group) group.push(value);
      else groups.set(key, [value]);
    }
    for (const [key, values] of groups) {
      groups.set(key, regroup(values, i));
    }
    return map(groups);
  })(values, 0);
}

var array = Array.prototype;

var slice = array.slice;

function constant(x) {
  return function() {
    return x;
  };
}

function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function sturges(values) {
  return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;
}

function bin() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);

    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
}

function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}

function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}

// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = array.length - 1, compare = ascending) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}

function number(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return min(values);
  if (p >= 1) return max(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),
      value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = number) {
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function freedmanDiaconis(values, min, max) {
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(count(values), -1 / 3)));
}

function scott(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(count(values), -1 / 3)));
}

function maxIndex(values, valueof) {
  let max;
  let maxIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  }
  return maxIndex;
}

function mean(values, valueof) {
  let count = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  }
  if (count) return sum / count;
}

function median(values, valueof) {
  return quantile(values, 0.5, valueof);
}

function* flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}

function minIndex(values, valueof) {
  let min;
  let minIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  }
  return minIndex;
}

function pairs(values, pairof = pair) {
  const pairs = [];
  let previous;
  let first = false;
  for (const value of values) {
    if (first) pairs.push(pairof(previous, value));
    previous = value;
    first = true;
  }
  return pairs;
}

function pair(a, b) {
  return [a, b];
}

function permute(source, keys) {
  return Array.from(keys, key => source[key]);
}

function least(values, compare = ascending) {
  let min;
  let defined = false;
  if (compare.length === 1) {
    let minValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? ascending(value, minValue) < 0
          : ascending(value, value) === 0) {
        min = element;
        minValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, min) < 0
          : compare(value, value) === 0) {
        min = value;
        defined = true;
      }
    }
  }
  return min;
}

function leastIndex(values, compare = ascending) {
  if (compare.length === 1) return minIndex(values, compare);
  let minValue;
  let min = -1;
  let index = -1;
  for (const value of values) {
    ++index;
    if (min < 0
        ? compare(value, value) === 0
        : compare(value, minValue) < 0) {
      minValue = value;
      min = index;
    }
  }
  return min;
}

function greatest(values, compare = ascending) {
  let max;
  let defined = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? ascending(value, maxValue) > 0
          : ascending(value, value) === 0) {
        max = element;
        maxValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, max) > 0
          : compare(value, value) === 0) {
        max = value;
        defined = true;
      }
    }
  }
  return max;
}

function greatestIndex(values, compare = ascending) {
  if (compare.length === 1) return maxIndex(values, compare);
  let maxValue;
  let max = -1;
  let index = -1;
  for (const value of values) {
    ++index;
    if (max < 0
        ? compare(value, value) === 0
        : compare(value, maxValue) > 0) {
      maxValue = value;
      max = index;
    }
  }
  return max;
}

function scan(values, compare) {
  const index = leastIndex(values, compare);
  return index < 0 ? undefined : index;
}

function shuffle(array, i0 = 0, i1 = array.length) {
  var m = i1 - (i0 = +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}

function sum(values, valueof) {
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        sum += value;
      }
    }
  }
  return sum;
}

function transpose(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min(matrix, length$1), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}

function length$1(d) {
  return d.length;
}

function zip() {
  return transpose(arguments);
}

exports.ascending = ascending;
exports.bin = bin;
exports.bisect = bisectRight;
exports.bisectLeft = bisectLeft;
exports.bisectRight = bisectRight;
exports.bisector = bisector;
exports.count = count;
exports.cross = cross;
exports.cumsum = cumsum;
exports.descending = descending;
exports.deviation = deviation;
exports.extent = extent;
exports.greatest = greatest;
exports.greatestIndex = greatestIndex;
exports.group = group;
exports.groups = groups;
exports.histogram = bin;
exports.least = least;
exports.leastIndex = leastIndex;
exports.max = max;
exports.maxIndex = maxIndex;
exports.mean = mean;
exports.median = median;
exports.merge = merge;
exports.min = min;
exports.minIndex = minIndex;
exports.pairs = pairs;
exports.permute = permute;
exports.quantile = quantile;
exports.quantileSorted = quantileSorted;
exports.quickselect = quickselect;
exports.range = range;
exports.rollup = rollup;
exports.rollups = rollups;
exports.scan = scan;
exports.shuffle = shuffle;
exports.sum = sum;
exports.thresholdFreedmanDiaconis = freedmanDiaconis;
exports.thresholdScott = scott;
exports.thresholdSturges = sturges;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
exports.ticks = ticks;
exports.transpose = transpose;
exports.variance = variance;
exports.zip = zip;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],3:[function(require,module,exports){
// https://d3js.org/d3-color/ v1.4.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? new Rgb(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? new Rgb((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

exports.color = color;
exports.cubehelix = cubehelix;
exports.gray = gray;
exports.hcl = hcl;
exports.hsl = hsl;
exports.lab = lab;
exports.lch = lch;
exports.rgb = rgb;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],4:[function(require,module,exports){
// https://d3js.org/d3-dispatch/ v1.0.6 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

exports.dispatch = dispatch;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],5:[function(require,module,exports){
// https://d3js.org/d3-drag/ v1.2.5 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-selection')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-selection'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3));
}(this, function (exports, d3Dispatch, d3Selection) { 'use strict';

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

function noevent() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
}

function nodrag(view) {
  var root = view.document.documentElement,
      selection = d3Selection.select(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = d3Selection.select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

function constant(x) {
  return function() {
    return x;
  };
}

function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: d3Selection.event.x, y: d3Selection.event.y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function drag() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = d3Dispatch.dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3Selection.mouse, this, arguments);
    if (!gesture) return;
    d3Selection.select(d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    nodrag(d3Selection.event.view);
    nopropagation();
    mousemoving = false;
    mousedownx = d3Selection.event.clientX;
    mousedowny = d3Selection.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    noevent();
    if (!mousemoving) {
      var dx = d3Selection.event.clientX - mousedownx, dy = d3Selection.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    d3Selection.select(d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(d3Selection.event.view, mousemoving);
    noevent();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3Selection.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3Selection.touch, this, arguments)) {
        nopropagation();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3Selection.event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3Selection.event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!d3Selection.customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      d3Selection.customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}

exports.drag = drag;
exports.dragDisable = nodrag;
exports.dragEnable = yesdrag;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-dispatch":4,"d3-selection":10}],6:[function(require,module,exports){
// https://d3js.org/d3-ease/ v1.0.6 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function linear(t) {
  return +t;
}

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);

var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);

var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);

exports.easeBack = backInOut;
exports.easeBackIn = backIn;
exports.easeBackInOut = backInOut;
exports.easeBackOut = backOut;
exports.easeBounce = bounceOut;
exports.easeBounceIn = bounceIn;
exports.easeBounceInOut = bounceInOut;
exports.easeBounceOut = bounceOut;
exports.easeCircle = circleInOut;
exports.easeCircleIn = circleIn;
exports.easeCircleInOut = circleInOut;
exports.easeCircleOut = circleOut;
exports.easeCubic = cubicInOut;
exports.easeCubicIn = cubicIn;
exports.easeCubicInOut = cubicInOut;
exports.easeCubicOut = cubicOut;
exports.easeElastic = elasticOut;
exports.easeElasticIn = elasticIn;
exports.easeElasticInOut = elasticInOut;
exports.easeElasticOut = elasticOut;
exports.easeExp = expInOut;
exports.easeExpIn = expIn;
exports.easeExpInOut = expInOut;
exports.easeExpOut = expOut;
exports.easeLinear = linear;
exports.easePoly = polyInOut;
exports.easePolyIn = polyIn;
exports.easePolyInOut = polyInOut;
exports.easePolyOut = polyOut;
exports.easeQuad = quadInOut;
exports.easeQuadIn = quadIn;
exports.easeQuadInOut = quadInOut;
exports.easeQuadOut = quadOut;
exports.easeSin = sinInOut;
exports.easeSinIn = sinIn;
exports.easeSinInOut = sinInOut;
exports.easeSinOut = sinOut;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],7:[function(require,module,exports){
// https://d3js.org/d3-format/ v1.4.3 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

function identity(x) {
  return x;
}

var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "-" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;

        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.format = locale.format;
  exports.formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

exports.FormatSpecifier = FormatSpecifier;
exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],8:[function(require,module,exports){
// https://d3js.org/d3-interpolate/ v1.4.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-color')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
}(this, function (exports, d3Color) { 'use strict';

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

function basis$1(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function constant(x) {
  return function() {
    return x;
  };
}

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var rgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb(start, end) {
    var r = color((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = d3Color.rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

function numberArray(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

function array(a, b) {
  return (isNumberArray(b) ? numberArray : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

function number(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

function object(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function value(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb) : string)
      : b instanceof d3Color.color ? rgb
      : b instanceof Date ? date
      : isNumberArray(b) ? numberArray
      : Array.isArray(b) ? genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : number)(a, b);
}

function discrete(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

function hue$1(a, b) {
  var i = hue(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}

function round(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
function zoom(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0  u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
}

function hsl(hue) {
  return function(start, end) {
    var h = hue((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$1 = hsl(hue);
var hslLong = hsl(nogamma);

function lab(start, end) {
  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl(hue) {
  return function(start, end) {
    var h = hue((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$1 = hcl(hue);
var hclLong = hcl(nogamma);

function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

var cubehelix$1 = cubehelix(hue);
var cubehelixLong = cubehelix(nogamma);

function piecewise(interpolate, values) {
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}

function quantize(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}

exports.interpolate = value;
exports.interpolateArray = array;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateCubehelix = cubehelix$1;
exports.interpolateCubehelixLong = cubehelixLong;
exports.interpolateDate = date;
exports.interpolateDiscrete = discrete;
exports.interpolateHcl = hcl$1;
exports.interpolateHclLong = hclLong;
exports.interpolateHsl = hsl$1;
exports.interpolateHslLong = hslLong;
exports.interpolateHue = hue$1;
exports.interpolateLab = lab;
exports.interpolateNumber = number;
exports.interpolateNumberArray = numberArray;
exports.interpolateObject = object;
exports.interpolateRgb = rgb;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateRound = round;
exports.interpolateString = string;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = zoom;
exports.piecewise = piecewise;
exports.quantize = quantize;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-color":3}],9:[function(require,module,exports){
// https://d3js.org/d3-scale/ v3.2.1 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-interpolate'), require('d3-format'), require('d3-time'), require('d3-time-format')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Array, d3Interpolate, d3Format, d3Time, d3TimeFormat) { 'use strict';

function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}

const implicit = Symbol("implicit");

function ordinal() {
  var index = new Map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new Map();
    for (const value of _) {
      const key = value + "";
      if (index.has(key)) continue;
      index.set(key, domain.push(value));
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      r0 = 0,
      r1 = 1,
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = r1 < r0,
        start = reverse ? r1 : r0,
        stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = d3Array.range(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };

  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), [r0, r1])
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

function constant(x) {
  return function() {
    return x;
  };
}

function number(x) {
  return +x;
}

var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = d3Array.bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3Interpolate.interpolate,
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3Interpolate.interpolateNumber)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = d3Interpolate.interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer()(identity, identity);
}

function tickFormat(start, stop, count, specifier) {
  var step = d3Array.tickStep(start, stop, count),
      precision;
  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
      return d3Format.formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return d3Format.format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = d3Array.tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = d3Array.tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = d3Array.tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous();

  scale.copy = function() {
    return copy(scale, linear());
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

function identity$1(domain) {
  var unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = Array.from(_, number), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity$1(domain).unknown(unknown);
  };

  domain = arguments.length ? Array.from(domain, number) : [0, 1];

  return linearish(scale);
}

function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = d3Array.ticks(u, v, n);
    } else {
      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  return scale;
}

function log() {
  var scale = loggish(transformer()).domain([1, 10]);

  scale.copy = function() {
    return copy(scale, log()).base(scale.base());
  };

  initRange.apply(scale, arguments);

  return scale;
}

function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return linearish(scale);
}

function symlog() {
  var scale = symlogish(transformer());

  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };

  return initRange.apply(scale, arguments);
}

function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(identity, identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(identity, identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return linearish(scale);
}

function pow() {
  var scale = powish(transformer());

  scale.copy = function() {
    return copy(scale, pow()).exponent(scale.exponent());
  };

  initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}

function square(x) {
  return Math.sign(x) * x * x;
}

function unsquare(x) {
  return Math.sign(x) * Math.sqrt(Math.abs(x));
}

function radial() {
  var squared = continuous(),
      range = [0, 1],
      round = false,
      unknown;

  function scale(x) {
    var y = unsquare(squared(x));
    return isNaN(y) ? unknown : round ? Math.round(y) : y;
  }

  scale.invert = function(y) {
    return squared.invert(square(y));
  };

  scale.domain = function(_) {
    return arguments.length ? (squared.domain(_), scale) : squared.domain();
  };

  scale.range = function(_) {
    return arguments.length ? (squared.range((range = Array.from(_, number)).map(square)), scale) : range.slice();
  };

  scale.rangeRound = function(_) {
    return scale.range(_).round(true);
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, scale) : round;
  };

  scale.clamp = function(_) {
    return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return radial(squared.domain(), range)
        .round(round)
        .clamp(squared.clamp())
        .unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : range[d3Array.bisect(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(linearish(scale), arguments);
}

function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number$1(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = continuous(),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target),
          step;
      if (i === tickIntervals.length) {
        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(d3Array.tickStep(start, stop, interval), 1);
        interval = millisecond;
      }
      return interval.every(step);
    }

    return interval;
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number$1)) : domain().map(date);
  };

  scale.ticks = function(interval) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1]))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

function time() {
  return initRange.apply(calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}

function utcTime() {
  return initRange.apply(calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}

function transformer$1() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = identity,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }

  scale.range = range(d3Interpolate.interpolate);

  scale.rangeRound = range(d3Interpolate.interpolateRound);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function copy$1(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = linearish(transformer$1()(identity));

  scale.copy = function() {
    return copy$1(scale, sequential());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialLog() {
  var scale = loggish(transformer$1()).domain([1, 10]);

  scale.copy = function() {
    return copy$1(scale, sequentialLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = symlogish(transformer$1());

  scale.copy = function() {
    return copy$1(scale, sequentialSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialPow() {
  var scale = powish(transformer$1());

  scale.copy = function() {
    return copy$1(scale, sequentialPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

function sequentialQuantile() {
  var domain = [],
      interpolator = identity;

  function scale(x) {
    if (!isNaN(x = +x)) return interpolator((d3Array.bisect(domain, x, 1) - 1) / (domain.length - 1));
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return scale;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.range = function() {
    return domain.map((d, i) => interpolator(i / (domain.length - 1)));
  };

  scale.quantiles = function(n) {
    return Array.from({length: n + 1}, (_, i) => d3Array.quantile(domain, i / n));
  };

  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };

  return initInterpolator.apply(scale, arguments);
}

function transformer$2() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      s = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = identity,
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = d3Interpolate.piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }

  scale.range = range(d3Interpolate.interpolate);

  scale.rangeRound = range(d3Interpolate.interpolateRound);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
    return scale;
  };
}

function diverging() {
  var scale = linearish(transformer$2()(identity));

  scale.copy = function() {
    return copy$1(scale, diverging());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingLog() {
  var scale = loggish(transformer$2()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return copy$1(scale, divergingLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSymlog() {
  var scale = symlogish(transformer$2());

  scale.copy = function() {
    return copy$1(scale, divergingSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingPow() {
  var scale = powish(transformer$2());

  scale.copy = function() {
    return copy$1(scale, divergingPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

exports.scaleBand = band;
exports.scaleDiverging = diverging;
exports.scaleDivergingLog = divergingLog;
exports.scaleDivergingPow = divergingPow;
exports.scaleDivergingSqrt = divergingSqrt;
exports.scaleDivergingSymlog = divergingSymlog;
exports.scaleIdentity = identity$1;
exports.scaleImplicit = implicit;
exports.scaleLinear = linear;
exports.scaleLog = log;
exports.scaleOrdinal = ordinal;
exports.scalePoint = point;
exports.scalePow = pow;
exports.scaleQuantile = quantile;
exports.scaleQuantize = quantize;
exports.scaleRadial = radial;
exports.scaleSequential = sequential;
exports.scaleSequentialLog = sequentialLog;
exports.scaleSequentialPow = sequentialPow;
exports.scaleSequentialQuantile = sequentialQuantile;
exports.scaleSequentialSqrt = sequentialSqrt;
exports.scaleSequentialSymlog = sequentialSymlog;
exports.scaleSqrt = sqrt;
exports.scaleSymlog = symlog;
exports.scaleThreshold = threshold;
exports.scaleTime = time;
exports.scaleUtc = utcTime;
exports.tickFormat = tickFormat;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-array":2,"d3-format":7,"d3-interpolate":8,"d3-time":12,"d3-time-format":11}],10:[function(require,module,exports){
// https://d3js.org/d3-selection/ v1.4.1 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

function matcher(selector) {
  return function() {
    return this.matches(selector);
  };
}

function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant(x) {
  return function() {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like __proto__.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

function selection_merge(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

var filterEvents = {};

exports.event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = exports.event; // Events can be reentrant (e.g., focus).
    exports.event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = exports.event;
  event1.sourceEvent = exports.event;
  exports.event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event0;
  }
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
}

function create(name) {
  return select(creator(name).call(document.documentElement));
}

var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

function sourceEvent() {
  var current = exports.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}

function point(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}

function mouse(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
}

function selectAll(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
}

function touch(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
}

function touches(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
}

exports.clientPoint = point;
exports.create = create;
exports.creator = creator;
exports.customEvent = customEvent;
exports.local = local;
exports.matcher = matcher;
exports.mouse = mouse;
exports.namespace = namespace;
exports.namespaces = namespaces;
exports.select = select;
exports.selectAll = selectAll;
exports.selection = selection;
exports.selector = selector;
exports.selectorAll = selectorAll;
exports.style = styleValue;
exports.touch = touch;
exports.touches = touches;
exports.window = defaultView;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],11:[function(require,module,exports){
// https://d3js.org/d3-time-format/ v2.2.3 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
}(this, function (exports, d3Time) { 'use strict';

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
          week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
          week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3Time.timeSunday.count(d3Time.timeYear(d) - 1, d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
  return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3Time.timeMonday.count(d3Time.timeYear(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3Time.utcSunday.count(d3Time.utcYear(d) - 1, d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
  return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3Time.utcMonday.count(d3Time.utcYear(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.timeFormat = locale.format;
  exports.timeParse = locale.parse;
  exports.utcFormat = locale.utcFormat;
  exports.utcParse = locale.utcParse;
  return locale;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

exports.isoFormat = formatIso;
exports.isoParse = parseIso;
exports.timeFormatDefaultLocale = defaultLocale;
exports.timeFormatLocale = formatLocale;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-time":12}],12:[function(require,module,exports){
// https://d3js.org/d3-time/ v1.1.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});
var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});
var minutes = minute.range;

var hour = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});
var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});
var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});
var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};
var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};
var utcYears = utcYear.range;

exports.timeDay = day;
exports.timeDays = days;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeYear = year;
exports.timeYears = years;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcYear = utcYear;
exports.utcYears = utcYears;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],13:[function(require,module,exports){
// https://d3js.org/d3-timer/ v1.0.10 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout$1(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

function interval$1(callback, delay, time) {
  var t = new Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? now() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
}

exports.interval = interval$1;
exports.now = now;
exports.timeout = timeout$1;
exports.timer = timer;
exports.timerFlush = timerFlush;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],14:[function(require,module,exports){
// https://d3js.org/d3-transition/ v1.3.2 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-dispatch'), require('d3-timer'), require('d3-interpolate'), require('d3-color'), require('d3-ease')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-timer', 'd3-interpolate', 'd3-color', 'd3-ease'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Selection, d3Dispatch, d3Timer, d3Interpolate, d3Color, d3Ease) { 'use strict';

var emptyOn = d3Dispatch.dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = d3Timer.timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return d3Timer.timeout(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    d3Timer.timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

function interrupt(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

function transition_tween(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get(node, id).value[name];
  };
}

function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? d3Interpolate.interpolateNumber
      : b instanceof d3Color.color ? d3Interpolate.interpolateRgb
      : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb)
      : d3Interpolate.interpolateString)(a, b);
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function transition_attr(name, value) {
  var fullname = d3Selection.namespace(name), i = fullname === "transform" ? d3Interpolate.interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}

function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = d3Selection.namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

function transition_delay(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

function transition_duration(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

function transition_ease(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
}

function transition_filter(match) {
  if (typeof match !== "function") match = d3Selection.matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

function transition_on(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = d3Selection.selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = d3Selection.selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

var Selection = d3Selection.selection.prototype.constructor;

function transition_selection() {
  return new Selection(this._groups, this._parents);
}

function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = d3Selection.style(this, name),
        string1 = (this.style.removeProperty(name), d3Selection.style(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = d3Selection.style(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = d3Selection.style(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = set(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? d3Interpolate.interpolateTransformCss : interpolate;
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}

function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}

function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}

function transition_transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

function transition_end() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = set(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and were done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });
  });
}

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return d3Selection.selection().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3Selection.selection.prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  end: transition_end
};

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3Ease.easeCubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = d3Timer.now(), defaultTiming;
    }
  }
  return timing;
}

function selection_transition(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

d3Selection.selection.prototype.interrupt = selection_interrupt;
d3Selection.selection.prototype.transition = selection_transition;

var root = [null];

function active(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}

exports.active = active;
exports.interrupt = interrupt;
exports.transition = transition;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-color":3,"d3-dispatch":4,"d3-ease":6,"d3-interpolate":8,"d3-selection":10,"d3-timer":13}],15:[function(require,module,exports){
// https://d3js.org/d3-zoom/ v1.8.3 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-drag'), require('d3-interpolate'), require('d3-selection'), require('d3-transition')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) { 'use strict';

function constant(x) {
  return function() {
    return x;
  };
}

function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

function noevent() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || identity;
}

function defaultWheelDelta() {
  return -d3Selection.event.deltaY * (d3Selection.event.deltaMode === 1 ? 0.05 : d3Selection.event.deltaMode ? 1 : 0.002);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

function zoom() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3Interpolate.interpolateZoom,
      listeners = d3Dispatch.dispatch("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p);
  };

  zoom.scaleTo = function(selection, k, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p);
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      d3Selection.customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = d3Selection.mouse(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      d3Transition.interrupt(this);
      g.start();
    }

    noevent();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments, true),
        v = d3Selection.select(d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = d3Selection.mouse(this),
        x0 = d3Selection.event.clientX,
        y0 = d3Selection.event.clientY;

    d3Drag.dragDisable(d3Selection.event.view);
    nopropagation();
    g.mouse = [p, this.__zoom.invert(p)];
    d3Transition.interrupt(this);
    g.start();

    function mousemoved() {
      noevent();
      if (!g.moved) {
        var dx = d3Selection.event.clientX - x0, dy = d3Selection.event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      d3Drag.dragEnable(d3Selection.event.view, g.moved);
      noevent();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = d3Selection.mouse(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (d3Selection.event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    noevent();
    if (duration > 0) d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);
    else d3Selection.select(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3Selection.event.touches,
        n = touches.length,
        g = gesture(this, arguments, d3Selection.event.changedTouches.length === n),
        started, i, t, p;

    nopropagation();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      d3Transition.interrupt(this);
      g.start();
    }
  }

  function touchmoved() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        n = touches.length, i, t, p, l;

    noevent();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    g.taps = 0;
    for (i = 0; i < n; ++i) {
      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        n = touches.length, i, t;

    nopropagation();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        var p = d3Selection.select(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
}

exports.zoom = zoom;
exports.zoomIdentity = identity;
exports.zoomTransform = transform;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-dispatch":4,"d3-drag":5,"d3-interpolate":8,"d3-selection":10,"d3-transition":14}],16:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],17:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["katex"] = factory();
	else
		root["katex"] = factory();
})((typeof self !== 'undefined' ? self : this), function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/katex.less
var katex = __webpack_require__(0);

// CONCATENATED MODULE: ./src/SourceLocation.js
/**
 * Lexing or parsing positional information for error reporting.
 * This object is immutable.
 */
var SourceLocation =
/*#__PURE__*/
function () {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  function SourceLocation(lexer, start, end) {
    this.lexer = void 0;
    this.start = void 0;
    this.end = void 0;
    this.lexer = lexer;
    this.start = start;
    this.end = end;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */


  SourceLocation.range = function range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  };

  return SourceLocation;
}();


// CONCATENATED MODULE: ./src/Token.js

/**
 * Interface required to break circular dependency between Token, Lexer, and
 * ParseError.
 */

/**
 * The resulting token returned from `lex`.
 *
 * It consists of the token text plus some position information.
 * The position information is essentially a range in an input string,
 * but instead of referencing the bare input string, we refer to the lexer.
 * That way it is possible to attach extra metadata to the input string,
 * like for example a file name or similar.
 *
 * The position information is optional, so it is OK to construct synthetic
 * tokens if appropriate. Not providing available position information may
 * lead to degraded error reporting, though.
 */
var Token_Token =
/*#__PURE__*/
function () {
  function Token(text, // the text of this token
  loc) {
    this.text = void 0;
    this.loc = void 0;
    this.text = text;
    this.loc = loc;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */


  var _proto = Token.prototype;

  _proto.range = function range(endToken, // last token of the range, inclusive
  text) // the text of the newly constructed token
  {
    return new Token(text, SourceLocation.range(this, endToken));
  };

  return Token;
}();
// CONCATENATED MODULE: ./src/ParseError.js


/**
 * This is the ParseError class, which is the main error thrown by KaTeX
 * functions when something has gone wrong. This is used to distinguish internal
 * errors from errors in the expression that the user provided.
 *
 * If possible, a caller should provide a Token or ParseNode with information
 * about where in the source string the problem occurred.
 */
var ParseError = // Error position based on passed-in Token or ParseNode.
function ParseError(message, // The error message
token) // An object providing position information
{
  this.position = void 0;
  var error = "KaTeX parse error: " + message;
  var start;
  var loc = token && token.loc;

  if (loc && loc.start <= loc.end) {
    // If we have the input and a position, make the error a bit fancier
    // Get the input
    var input = loc.lexer.input; // Prepend some information

    start = loc.start;
    var end = loc.end;

    if (start === input.length) {
      error += " at end of input: ";
    } else {
      error += " at position " + (start + 1) + ": ";
    } // Underline token in question using combining underscores


    var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332"); // Extract some context from the input and add it to the error

    var left;

    if (start > 15) {
      left = "" + input.slice(start - 15, start);
    } else {
      left = input.slice(0, start);
    }

    var right;

    if (end + 15 < input.length) {
      right = input.slice(end, end + 15) + "";
    } else {
      right = input.slice(end);
    }

    error += left + underlined + right;
  } // Some hackery to make ParseError a prototype of Error
  // See http://stackoverflow.com/a/8460753


  var self = new Error(error);
  self.name = "ParseError"; // $FlowFixMe

  self.__proto__ = ParseError.prototype; // $FlowFixMe

  self.position = start;
  return self;
}; // $FlowFixMe More hackery


ParseError.prototype.__proto__ = Error.prototype;
/* harmony default export */ var src_ParseError = (ParseError);
// CONCATENATED MODULE: ./src/utils.js
/**
 * This file contains a list of utility functions which are useful in other
 * files.
 */

/**
 * Return whether an element is contained in a list
 */
var contains = function contains(list, elem) {
  return list.indexOf(elem) !== -1;
};
/**
 * Provide a default value if a setting is undefined
 * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.
 */


var deflt = function deflt(setting, defaultIfUndefined) {
  return setting === undefined ? defaultIfUndefined : setting;
}; // hyphenate and escape adapted from Facebook's React under Apache 2 license


var uppercase = /([A-Z])/g;

var hyphenate = function hyphenate(str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};

var ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  "\"": "&quot;",
  "'": "&#x27;"
};
var ESCAPE_REGEX = /[&><"']/g;
/**
 * Escapes text to prevent scripting attacks.
 */

function utils_escape(text) {
  return String(text).replace(ESCAPE_REGEX, function (match) {
    return ESCAPE_LOOKUP[match];
  });
}
/**
 * Sometimes we want to pull out the innermost element of a group. In most
 * cases, this will just be the group itself, but when ordgroups and colors have
 * a single element, we want to pull that out.
 */


var getBaseElem = function getBaseElem(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem(group.body);
  } else {
    return group;
  }
};
/**
 * TeXbook algorithms often reference "character boxes", which are simply groups
 * with a single character in them. To decide if something is a character box,
 * we find its innermost group, and see if it is a single character.
 */


var utils_isCharacterBox = function isCharacterBox(group) {
  var baseElem = getBaseElem(group); // These are all they types of groups which hold single characters

  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
};

var assert = function assert(value) {
  if (!value) {
    throw new Error('Expected non-null, but got ' + String(value));
  }

  return value;
};
/* harmony default export */ var utils = ({
  contains: contains,
  deflt: deflt,
  escape: utils_escape,
  hyphenate: hyphenate,
  getBaseElem: getBaseElem,
  isCharacterBox: utils_isCharacterBox
});
// CONCATENATED MODULE: ./src/Settings.js
/* eslint no-console:0 */

/**
 * This is a module for storing settings passed into KaTeX. It correctly handles
 * default settings.
 */




/**
 * The main Settings object
 *
 * The current options stored are:
 *  - displayMode: Whether the expression should be typeset as inline math
 *                 (false, the default), meaning that the math starts in
 *                 \textstyle and is placed in an inline-block); or as display
 *                 math (true), meaning that the math starts in \displaystyle
 *                 and is placed in a block with vertical margin.
 */
var Settings_Settings =
/*#__PURE__*/
function () {
  function Settings(options) {
    this.displayMode = void 0;
    this.leqno = void 0;
    this.fleqn = void 0;
    this.throwOnError = void 0;
    this.errorColor = void 0;
    this.macros = void 0;
    this.colorIsTextColor = void 0;
    this.strict = void 0;
    this.maxSize = void 0;
    this.maxExpand = void 0;
    this.allowedProtocols = void 0;
    // allow null options
    options = options || {};
    this.displayMode = utils.deflt(options.displayMode, false);
    this.leqno = utils.deflt(options.leqno, false);
    this.fleqn = utils.deflt(options.fleqn, false);
    this.throwOnError = utils.deflt(options.throwOnError, true);
    this.errorColor = utils.deflt(options.errorColor, "#cc0000");
    this.macros = options.macros || {};
    this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);
    this.strict = utils.deflt(options.strict, "warn");
    this.maxSize = Math.max(0, utils.deflt(options.maxSize, Infinity));
    this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1000));
    this.allowedProtocols = utils.deflt(options.allowedProtocols, ["http", "https", "mailto", "_relative"]);
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */


  var _proto = Settings.prototype;

  _proto.reportNonstrict = function reportNonstrict(errorCode, errorMsg, token) {
    var strict = this.strict;

    if (typeof strict === "function") {
      // Allow return value of strict function to be boolean or string
      // (or null/undefined, meaning no further processing).
      strict = strict(errorCode, errorMsg, token);
    }

    if (!strict || strict === "ignore") {
      return;
    } else if (strict === true || strict === "error") {
      throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
    } else {
      // won't happen in type-safe code
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  ;

  _proto.useStrictBehavior = function useStrictBehavior(errorCode, errorMsg, token) {
    var strict = this.strict;

    if (typeof strict === "function") {
      // Allow return value of strict function to be boolean or string
      // (or null/undefined, meaning no further processing).
      // But catch any exceptions thrown by function, treating them
      // like "error".
      try {
        strict = strict(errorCode, errorMsg, token);
      } catch (error) {
        strict = "error";
      }
    }

    if (!strict || strict === "ignore") {
      return false;
    } else if (strict === true || strict === "error") {
      return true;
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
      return false;
    } else {
      // won't happen in type-safe code
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
      return false;
    }
  };

  return Settings;
}();

/* harmony default export */ var src_Settings = (Settings_Settings);
// CONCATENATED MODULE: ./src/Style.js
/**
 * This file contains information and classes for the various kinds of styles
 * used in TeX. It provides a generic `Style` class, which holds information
 * about a specific style. It then provides instances of all the different kinds
 * of styles possible, and provides functions to move between them and get
 * information about them.
 */

/**
 * The main style class. Contains a unique id for the style, a size (which is
 * the same for cramped and uncramped version of a style), and a cramped flag.
 */
var Style =
/*#__PURE__*/
function () {
  function Style(id, size, cramped) {
    this.id = void 0;
    this.size = void 0;
    this.cramped = void 0;
    this.id = id;
    this.size = size;
    this.cramped = cramped;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */


  var _proto = Style.prototype;

  _proto.sup = function sup() {
    return Style_styles[_sup[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  ;

  _proto.sub = function sub() {
    return Style_styles[_sub[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  ;

  _proto.fracNum = function fracNum() {
    return Style_styles[_fracNum[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  ;

  _proto.fracDen = function fracDen() {
    return Style_styles[_fracDen[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  ;

  _proto.cramp = function cramp() {
    return Style_styles[_cramp[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  ;

  _proto.text = function text() {
    return Style_styles[_text[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  ;

  _proto.isTight = function isTight() {
    return this.size >= 2;
  };

  return Style;
}(); // Export an interface for type checking, but don't expose the implementation.
// This way, no more styles can be generated.


// IDs of the different styles
var D = 0;
var Dc = 1;
var T = 2;
var Tc = 3;
var S = 4;
var Sc = 5;
var SS = 6;
var SSc = 7; // Instances of the different styles

var Style_styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)]; // Lookup tables for switching from one style to another

var _sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
var _sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var _fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
var _fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var _cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
var _text = [D, Dc, T, Tc, T, Tc, T, Tc]; // We only export some of the styles.

/* harmony default export */ var src_Style = ({
  DISPLAY: Style_styles[D],
  TEXT: Style_styles[T],
  SCRIPT: Style_styles[S],
  SCRIPTSCRIPT: Style_styles[SS]
});
// CONCATENATED MODULE: ./src/unicodeScripts.js
/*
 * This file defines the Unicode scripts and script families that we
 * support. To add new scripts or families, just add a new entry to the
 * scriptData array below. Adding scripts to the scriptData array allows
 * characters from that script to appear in \text{} environments.
 */

/**
 * Each script or script family has a name and an array of blocks.
 * Each block is an array of two numbers which specify the start and
 * end points (inclusive) of a block of Unicode codepoints.
 */

/**
 * Unicode block data for the families of scripts we support in \text{}.
 * Scripts only need to appear here if they do not have font metrics.
 */
var scriptData = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: 'latin',
  blocks: [[0x0100, 0x024f], // Latin Extended-A and Latin Extended-B
  [0x0300, 0x036f]]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: 'cyrillic',
  blocks: [[0x0400, 0x04ff]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900097F)
  // Bengali (098009FF)
  // Gurmukhi (0A000A7F)
  // Gujarati (0A800AFF)
  // Oriya (0B000B7F)
  // Tamil (0B800BFF)
  // Telugu (0C000C7F)
  // Kannada (0C800CFF)
  // Malayalam (0D000D7F)
  // Sinhala (0D800DFF)
  // Thai (0E000E7F)
  // Lao (0E800EFF)
  // Tibetan (0F000FFF)
  // Myanmar (1000109F)
  name: 'brahmic',
  blocks: [[0x0900, 0x109F]]
}, {
  name: 'georgian',
  blocks: [[0x10A0, 0x10ff]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [[0x3000, 0x30FF], // CJK symbols and punctuation, Hiragana, Katakana
  [0x4E00, 0x9FAF], // CJK ideograms
  [0xFF00, 0xFF60]]
}, {
  // Korean
  name: 'hangul',
  blocks: [[0xAC00, 0xD7AF]]
}];
/**
 * Given a codepoint, return the name of the script or script family
 * it is from, or null if it is not part of a known block
 */

function scriptFromCodepoint(codepoint) {
  for (var i = 0; i < scriptData.length; i++) {
    var script = scriptData[i];

    for (var _i = 0; _i < script.blocks.length; _i++) {
      var block = script.blocks[_i];

      if (codepoint >= block[0] && codepoint <= block[1]) {
        return script.name;
      }
    }
  }

  return null;
}
/**
 * A flattened version of all the supported blocks in a single array.
 * This is an optimization to make supportedCodepoint() fast.
 */

var allBlocks = [];
scriptData.forEach(function (s) {
  return s.blocks.forEach(function (b) {
    return allBlocks.push.apply(allBlocks, b);
  });
});
/**
 * Given a codepoint, return true if it falls within one of the
 * scripts or script families defined above and false otherwise.
 *
 * Micro benchmarks shows that this is faster than
 * /[\u3000-\u30FF\u4E00-\u9FAF\uFF00-\uFF60\uAC00-\uD7AF\u0900-\u109F]/.test()
 * in Firefox, Chrome and Node.
 */

function supportedCodepoint(codepoint) {
  for (var i = 0; i < allBlocks.length; i += 2) {
    if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
      return true;
    }
  }

  return false;
}
// CONCATENATED MODULE: ./src/svgGeometry.js
/**
 * This file provides support to domTree.js
 * It's a storehouse of path geometry for SVG images.
 */
// In all paths below, the viewBox-to-em scale is 1000:1.
var hLinePad = 80; // padding above a sqrt viniculum.

var svgGeometry_path = {
  // sqrtMain path geometry is from glyph U221A in the font KaTeX Main
  // All surds have 80 units padding above the viniculumn.
  sqrtMain: "M95," + (622 + hLinePad) + "c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,\n-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,\n-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,\n35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,\n-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467\ns-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422\ns-65,47,-65,47z M834 " + hLinePad + "H400000v40H845z",
  // size1 is from glyph U221A in the font KaTeX_Size1-Regular
  sqrtSize1: "M263," + (601 + hLinePad) + "c0.7,0,18,39.7,52,119c34,79.3,68.167,\n158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067\nc4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,\n175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71\nc-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,\n-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26\ns76,-59,76,-59s76,-60,76,-60z M1001 " + hLinePad + "H40000v40H1012z",
  // size2 is from glyph U221A in the font KaTeX_Size2-Regular
  // The 80 units padding is most obvious here. Note start node at M1001 80.
  sqrtSize2: "M1001," + hLinePad + "H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,\n572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,\n-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39\nc-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60\ns208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,\n-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10z\nM1001 " + hLinePad + "H400000v40H1013z",
  // size3 is from glyph U221A in the font KaTeX_Size3-Regular
  sqrtSize3: "M424," + (2398 + hLinePad) + "c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,\n-342,-109.8,-513.3,-110.5,-514c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,\n25c-5.7,9.3,-9.8,16,-12.5,20s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,\n-13s76,-122,76,-122s77,-121,77,-121s209,968,209,968c0,-2,84.7,-361.7,254,-1079\nc169.3,-717.3,254.7,-1077.7,256,-1081c4,-6.7,10,-10,18,-10H400000v40H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M1001 " + hLinePad + "H400000v40H1014z",
  // size4 is from glyph U221A in the font KaTeX_Size4-Regular
  sqrtSize4: "M473," + (2713 + hLinePad) + "c339.3,-1799.3,509.3,-2700,510,-2702\nc3.3,-7.3,9.3,-11,18,-11H400000v40H1017.7s-90.5,478,-276.2,1466c-185.7,988,\n-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,\n-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200c0,-1.3,-5.3,8.7,-16,30c-10.7,\n21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26s76,-153,76,-153s77,-151,\n77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,606z\nM1001 " + hLinePad + "H400000v40H1017z",
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
  leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
  leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
  leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
  leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
  leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
  leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
  leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
  longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
  midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
  midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
  oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
  oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
  oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
  oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
  rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
  rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
  rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
  rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
  rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
  rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
  rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
  rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
  rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
  righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
  rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
  rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
  twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
  // ditto tilde2, tilde3, & tilde4
  tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
  tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
  tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
  // ditto widehat2, widehat3, & widehat4
  widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  // widecheck paths are all inverted versions of widehat
  widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
  widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
  rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
  shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
  shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
};
/* harmony default export */ var svgGeometry = ({
  path: svgGeometry_path
});
// CONCATENATED MODULE: ./src/tree.js


/**
 * This node represents a document fragment, which contains elements, but when
 * placed into the DOM doesn't have any representation itself. It only contains
 * children and doesn't have any DOM node properties.
 */
var tree_DocumentFragment =
/*#__PURE__*/
function () {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  function DocumentFragment(children) {
    this.children = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.children = children;
    this.classes = [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
  }

  var _proto = DocumentFragment.prototype;

  _proto.hasClass = function hasClass(className) {
    return utils.contains(this.classes, className);
  }
  /** Convert the fragment into a node. */
  ;

  _proto.toNode = function toNode() {
    var frag = document.createDocumentFragment();

    for (var i = 0; i < this.children.length; i++) {
      frag.appendChild(this.children[i].toNode());
    }

    return frag;
  }
  /** Convert the fragment into HTML markup. */
  ;

  _proto.toMarkup = function toMarkup() {
    var markup = ""; // Simply concatenate the markup for the children together.

    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  ;

  _proto.toText = function toText() {
    // To avoid this, we would subclass documentFragment separately for
    // MathML, but polyfills for subclassing is expensive per PR 1469.
    // $FlowFixMe: Only works for ChildType = MathDomNode.
    var toText = function toText(child) {
      return child.toText();
    };

    return this.children.map(toText).join("");
  };

  return DocumentFragment;
}();
// CONCATENATED MODULE: ./src/domTree.js
/**
 * These objects store the data about the DOM nodes we create, as well as some
 * extra data. They can then be transformed into real DOM nodes with the
 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
 * storing extra properties on the nodes, as well as providing a way to easily
 * work with the DOM.
 *
 * Similar functions for working with MathML nodes exist in mathMLTree.js.
 *
 * TODO: refactor `span` and `anchor` into common superclass when
 * target environments support class inheritance
 */





/**
 * Create an HTML className based on a list of classes. In addition to joining
 * with spaces, we also remove empty classes.
 */
var createClass = function createClass(classes) {
  return classes.filter(function (cls) {
    return cls;
  }).join(" ");
};

var initNode = function initNode(classes, options, style) {
  this.classes = classes || [];
  this.attributes = {};
  this.height = 0;
  this.depth = 0;
  this.maxFontSize = 0;
  this.style = style || {};

  if (options) {
    if (options.style.isTight()) {
      this.classes.push("mtight");
    }

    var color = options.getColor();

    if (color) {
      this.style.color = color;
    }
  }
};
/**
 * Convert into an HTML node
 */


var _toNode = function toNode(tagName) {
  var node = document.createElement(tagName); // Apply the class

  node.className = createClass(this.classes); // Apply inline styles

  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      // $FlowFixMe Flow doesn't seem to understand span.style's type.
      node.style[style] = this.style[style];
    }
  } // Apply attributes


  for (var attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      node.setAttribute(attr, this.attributes[attr]);
    }
  } // Append the children, also as HTML nodes


  for (var i = 0; i < this.children.length; i++) {
    node.appendChild(this.children[i].toNode());
  }

  return node;
};
/**
 * Convert into an HTML markup string
 */


var _toMarkup = function toMarkup(tagName) {
  var markup = "<" + tagName; // Add the class

  if (this.classes.length) {
    markup += " class=\"" + utils.escape(createClass(this.classes)) + "\"";
  }

  var styles = ""; // Add the styles, after hyphenation

  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
    }
  }

  if (styles) {
    markup += " style=\"" + utils.escape(styles) + "\"";
  } // Add the attributes


  for (var attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      markup += " " + attr + "=\"" + utils.escape(this.attributes[attr]) + "\"";
    }
  }

  markup += ">"; // Add the markup of the children, also as markup

  for (var i = 0; i < this.children.length; i++) {
    markup += this.children[i].toMarkup();
  }

  markup += "</" + tagName + ">";
  return markup;
}; // Making the type below exact with all optional fields doesn't work due to
// - https://github.com/facebook/flow/issues/4582
// - https://github.com/facebook/flow/issues/5688
// However, since *all* fields are optional, $Shape<> works as suggested in 5688
// above.
// This type does not include all CSS properties. Additional properties should
// be added as needed.


/**
 * This node represents a span node, with a className, a list of children, and
 * an inline style. It also contains information about its height, depth, and
 * maxFontSize.
 *
 * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan
 * otherwise. This typesafety is important when HTML builders access a span's
 * children.
 */
var domTree_Span =
/*#__PURE__*/
function () {
  function Span(classes, children, options, style) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options, style);
    this.children = children || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */


  var _proto = Span.prototype;

  _proto.setAttribute = function setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  };

  _proto.hasClass = function hasClass(className) {
    return utils.contains(this.classes, className);
  };

  _proto.toNode = function toNode() {
    return _toNode.call(this, "span");
  };

  _proto.toMarkup = function toMarkup() {
    return _toMarkup.call(this, "span");
  };

  return Span;
}();
/**
 * This node represents an anchor (<a>) element with a hyperlink.  See `span`
 * for further details.
 */

var domTree_Anchor =
/*#__PURE__*/
function () {
  function Anchor(href, classes, children, options) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options);
    this.children = children || [];
    this.setAttribute('href', href);
  }

  var _proto2 = Anchor.prototype;

  _proto2.setAttribute = function setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  };

  _proto2.hasClass = function hasClass(className) {
    return utils.contains(this.classes, className);
  };

  _proto2.toNode = function toNode() {
    return _toNode.call(this, "a");
  };

  _proto2.toMarkup = function toMarkup() {
    return _toMarkup.call(this, "a");
  };

  return Anchor;
}();
/**
 * This node represents an image embed (<img>) element.
 */

var domTree_Img =
/*#__PURE__*/
function () {
  function Img(src, alt, style) {
    this.src = void 0;
    this.alt = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style;
  }

  var _proto3 = Img.prototype;

  _proto3.hasClass = function hasClass(className) {
    return utils.contains(this.classes, className);
  };

  _proto3.toNode = function toNode() {
    var node = document.createElement("img");
    node.src = this.src;
    node.alt = this.alt;
    node.className = "mord"; // Apply inline styles

    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        // $FlowFixMe
        node.style[style] = this.style[style];
      }
    }

    return node;
  };

  _proto3.toMarkup = function toMarkup() {
    var markup = "<img  src='" + this.src + " 'alt='" + this.alt + "' "; // Add the styles, after hyphenation

    var styles = "";

    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }

    if (styles) {
      markup += " style=\"" + utils.escape(styles) + "\"";
    }

    markup += "'/>";
    return markup;
  };

  return Img;
}();
var iCombinations = {
  '': "\u0131\u0302",
  '': "\u0131\u0308",
  '': "\u0131\u0301",
  // '': '\u0131\u0304', // enable when we add Extended Latin
  '': "\u0131\u0300"
};
/**
 * A symbol node contains information about a single symbol. It either renders
 * to a single text node, or a span with a single text node in it, depending on
 * whether it has CSS classes, styles, or needs italic correction.
 */

var domTree_SymbolNode =
/*#__PURE__*/
function () {
  function SymbolNode(text, height, depth, italic, skew, width, classes, style) {
    this.text = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.italic = void 0;
    this.skew = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.classes = void 0;
    this.style = void 0;
    this.text = text;
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.width = width || 0;
    this.classes = classes || [];
    this.style = style || {};
    this.maxFontSize = 0; // Mark text from non-Latin scripts with specific classes so that we
    // can specify which fonts to use.  This allows us to render these
    // characters with a serif font in situations where the browser would
    // either default to a sans serif or render a placeholder character.
    // We use CSS class names like cjk_fallback, hangul_fallback and
    // brahmic_fallback. See ./unicodeScripts.js for the set of possible
    // script names

    var script = scriptFromCodepoint(this.text.charCodeAt(0));

    if (script) {
      this.classes.push(script + "_fallback");
    }

    if (/[]/.test(this.text)) {
      // add  when we add Extended Latin
      this.text = iCombinations[this.text];
    }
  }

  var _proto4 = SymbolNode.prototype;

  _proto4.hasClass = function hasClass(className) {
    return utils.contains(this.classes, className);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  ;

  _proto4.toNode = function toNode() {
    var node = document.createTextNode(this.text);
    var span = null;

    if (this.italic > 0) {
      span = document.createElement("span");
      span.style.marginRight = this.italic + "em";
    }

    if (this.classes.length > 0) {
      span = span || document.createElement("span");
      span.className = createClass(this.classes);
    }

    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        span = span || document.createElement("span"); // $FlowFixMe Flow doesn't seem to understand span.style's type.

        span.style[style] = this.style[style];
      }
    }

    if (span) {
      span.appendChild(node);
      return span;
    } else {
      return node;
    }
  }
  /**
   * Creates markup for a symbol node.
   */
  ;

  _proto4.toMarkup = function toMarkup() {
    // TODO(alpert): More duplication than I'd like from
    // span.prototype.toMarkup and symbolNode.prototype.toNode...
    var needsSpan = false;
    var markup = "<span";

    if (this.classes.length) {
      needsSpan = true;
      markup += " class=\"";
      markup += utils.escape(createClass(this.classes));
      markup += "\"";
    }

    var styles = "";

    if (this.italic > 0) {
      styles += "margin-right:" + this.italic + "em;";
    }

    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }

    if (styles) {
      needsSpan = true;
      markup += " style=\"" + utils.escape(styles) + "\"";
    }

    var escaped = utils.escape(this.text);

    if (needsSpan) {
      markup += ">";
      markup += escaped;
      markup += "</span>";
      return markup;
    } else {
      return escaped;
    }
  };

  return SymbolNode;
}();
/**
 * SVG nodes are used to render stretchy wide elements.
 */

var SvgNode =
/*#__PURE__*/
function () {
  function SvgNode(children, attributes) {
    this.children = void 0;
    this.attributes = void 0;
    this.children = children || [];
    this.attributes = attributes || {};
  }

  var _proto5 = SvgNode.prototype;

  _proto5.toNode = function toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "svg"); // Apply attributes

    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    for (var i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }

    return node;
  };

  _proto5.toMarkup = function toMarkup() {
    var markup = "<svg"; // Apply attributes

    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + "='" + this.attributes[attr] + "'";
      }
    }

    markup += ">";

    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    markup += "</svg>";
    return markup;
  };

  return SvgNode;
}();
var domTree_PathNode =
/*#__PURE__*/
function () {
  function PathNode(pathName, alternate) {
    this.pathName = void 0;
    this.alternate = void 0;
    this.pathName = pathName;
    this.alternate = alternate; // Used only for tall \sqrt
  }

  var _proto6 = PathNode.prototype;

  _proto6.toNode = function toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "path");

    if (this.alternate) {
      node.setAttribute("d", this.alternate);
    } else {
      node.setAttribute("d", svgGeometry.path[this.pathName]);
    }

    return node;
  };

  _proto6.toMarkup = function toMarkup() {
    if (this.alternate) {
      return "<path d='" + this.alternate + "'/>";
    } else {
      return "<path d='" + svgGeometry.path[this.pathName] + "'/>";
    }
  };

  return PathNode;
}();
var LineNode =
/*#__PURE__*/
function () {
  function LineNode(attributes) {
    this.attributes = void 0;
    this.attributes = attributes || {};
  }

  var _proto7 = LineNode.prototype;

  _proto7.toNode = function toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "line"); // Apply attributes

    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    return node;
  };

  _proto7.toMarkup = function toMarkup() {
    var markup = "<line";

    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + "='" + this.attributes[attr] + "'";
      }
    }

    markup += "/>";
    return markup;
  };

  return LineNode;
}();
function assertSymbolDomNode(group) {
  if (group instanceof domTree_SymbolNode) {
    return group;
  } else {
    throw new Error("Expected symbolNode but got " + String(group) + ".");
  }
}
function assertSpan(group) {
  if (group instanceof domTree_Span) {
    return group;
  } else {
    throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
  }
}
// CONCATENATED MODULE: ./submodules/katex-fonts/fontMetricsData.js
// This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.
/* harmony default export */ var fontMetricsData = ({
  "AMS-Regular": {
    "65": [0, 0.68889, 0, 0, 0.72222],
    "66": [0, 0.68889, 0, 0, 0.66667],
    "67": [0, 0.68889, 0, 0, 0.72222],
    "68": [0, 0.68889, 0, 0, 0.72222],
    "69": [0, 0.68889, 0, 0, 0.66667],
    "70": [0, 0.68889, 0, 0, 0.61111],
    "71": [0, 0.68889, 0, 0, 0.77778],
    "72": [0, 0.68889, 0, 0, 0.77778],
    "73": [0, 0.68889, 0, 0, 0.38889],
    "74": [0.16667, 0.68889, 0, 0, 0.5],
    "75": [0, 0.68889, 0, 0, 0.77778],
    "76": [0, 0.68889, 0, 0, 0.66667],
    "77": [0, 0.68889, 0, 0, 0.94445],
    "78": [0, 0.68889, 0, 0, 0.72222],
    "79": [0.16667, 0.68889, 0, 0, 0.77778],
    "80": [0, 0.68889, 0, 0, 0.61111],
    "81": [0.16667, 0.68889, 0, 0, 0.77778],
    "82": [0, 0.68889, 0, 0, 0.72222],
    "83": [0, 0.68889, 0, 0, 0.55556],
    "84": [0, 0.68889, 0, 0, 0.66667],
    "85": [0, 0.68889, 0, 0, 0.72222],
    "86": [0, 0.68889, 0, 0, 0.72222],
    "87": [0, 0.68889, 0, 0, 1.0],
    "88": [0, 0.68889, 0, 0, 0.72222],
    "89": [0, 0.68889, 0, 0, 0.72222],
    "90": [0, 0.68889, 0, 0, 0.66667],
    "107": [0, 0.68889, 0, 0, 0.55556],
    "165": [0, 0.675, 0.025, 0, 0.75],
    "174": [0.15559, 0.69224, 0, 0, 0.94666],
    "240": [0, 0.68889, 0, 0, 0.55556],
    "295": [0, 0.68889, 0, 0, 0.54028],
    "710": [0, 0.825, 0, 0, 2.33334],
    "732": [0, 0.9, 0, 0, 2.33334],
    "770": [0, 0.825, 0, 0, 2.33334],
    "771": [0, 0.9, 0, 0, 2.33334],
    "989": [0.08167, 0.58167, 0, 0, 0.77778],
    "1008": [0, 0.43056, 0.04028, 0, 0.66667],
    "8245": [0, 0.54986, 0, 0, 0.275],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8487": [0, 0.68889, 0, 0, 0.72222],
    "8498": [0, 0.68889, 0, 0, 0.55556],
    "8502": [0, 0.68889, 0, 0, 0.66667],
    "8503": [0, 0.68889, 0, 0, 0.44445],
    "8504": [0, 0.68889, 0, 0, 0.66667],
    "8513": [0, 0.68889, 0, 0, 0.63889],
    "8592": [-0.03598, 0.46402, 0, 0, 0.5],
    "8594": [-0.03598, 0.46402, 0, 0, 0.5],
    "8602": [-0.13313, 0.36687, 0, 0, 1.0],
    "8603": [-0.13313, 0.36687, 0, 0, 1.0],
    "8606": [0.01354, 0.52239, 0, 0, 1.0],
    "8608": [0.01354, 0.52239, 0, 0, 1.0],
    "8610": [0.01354, 0.52239, 0, 0, 1.11111],
    "8611": [0.01354, 0.52239, 0, 0, 1.11111],
    "8619": [0, 0.54986, 0, 0, 1.0],
    "8620": [0, 0.54986, 0, 0, 1.0],
    "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
    "8622": [-0.13313, 0.36687, 0, 0, 1.0],
    "8624": [0, 0.69224, 0, 0, 0.5],
    "8625": [0, 0.69224, 0, 0, 0.5],
    "8630": [0, 0.43056, 0, 0, 1.0],
    "8631": [0, 0.43056, 0, 0, 1.0],
    "8634": [0.08198, 0.58198, 0, 0, 0.77778],
    "8635": [0.08198, 0.58198, 0, 0, 0.77778],
    "8638": [0.19444, 0.69224, 0, 0, 0.41667],
    "8639": [0.19444, 0.69224, 0, 0, 0.41667],
    "8642": [0.19444, 0.69224, 0, 0, 0.41667],
    "8643": [0.19444, 0.69224, 0, 0, 0.41667],
    "8644": [0.1808, 0.675, 0, 0, 1.0],
    "8646": [0.1808, 0.675, 0, 0, 1.0],
    "8647": [0.1808, 0.675, 0, 0, 1.0],
    "8648": [0.19444, 0.69224, 0, 0, 0.83334],
    "8649": [0.1808, 0.675, 0, 0, 1.0],
    "8650": [0.19444, 0.69224, 0, 0, 0.83334],
    "8651": [0.01354, 0.52239, 0, 0, 1.0],
    "8652": [0.01354, 0.52239, 0, 0, 1.0],
    "8653": [-0.13313, 0.36687, 0, 0, 1.0],
    "8654": [-0.13313, 0.36687, 0, 0, 1.0],
    "8655": [-0.13313, 0.36687, 0, 0, 1.0],
    "8666": [0.13667, 0.63667, 0, 0, 1.0],
    "8667": [0.13667, 0.63667, 0, 0, 1.0],
    "8669": [-0.13313, 0.37788, 0, 0, 1.0],
    "8672": [-0.064, 0.437, 0, 0, 1.334],
    "8674": [-0.064, 0.437, 0, 0, 1.334],
    "8705": [0, 0.825, 0, 0, 0.5],
    "8708": [0, 0.68889, 0, 0, 0.55556],
    "8709": [0.08167, 0.58167, 0, 0, 0.77778],
    "8717": [0, 0.43056, 0, 0, 0.42917],
    "8722": [-0.03598, 0.46402, 0, 0, 0.5],
    "8724": [0.08198, 0.69224, 0, 0, 0.77778],
    "8726": [0.08167, 0.58167, 0, 0, 0.77778],
    "8733": [0, 0.69224, 0, 0, 0.77778],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8737": [0, 0.69224, 0, 0, 0.72222],
    "8738": [0.03517, 0.52239, 0, 0, 0.72222],
    "8739": [0.08167, 0.58167, 0, 0, 0.22222],
    "8740": [0.25142, 0.74111, 0, 0, 0.27778],
    "8741": [0.08167, 0.58167, 0, 0, 0.38889],
    "8742": [0.25142, 0.74111, 0, 0, 0.5],
    "8756": [0, 0.69224, 0, 0, 0.66667],
    "8757": [0, 0.69224, 0, 0, 0.66667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
    "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8774": [0.30274, 0.79383, 0, 0, 0.77778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8778": [0.08167, 0.58167, 0, 0, 0.77778],
    "8782": [0.06062, 0.54986, 0, 0, 0.77778],
    "8783": [0.06062, 0.54986, 0, 0, 0.77778],
    "8785": [0.08198, 0.58198, 0, 0, 0.77778],
    "8786": [0.08198, 0.58198, 0, 0, 0.77778],
    "8787": [0.08198, 0.58198, 0, 0, 0.77778],
    "8790": [0, 0.69224, 0, 0, 0.77778],
    "8791": [0.22958, 0.72958, 0, 0, 0.77778],
    "8796": [0.08198, 0.91667, 0, 0, 0.77778],
    "8806": [0.25583, 0.75583, 0, 0, 0.77778],
    "8807": [0.25583, 0.75583, 0, 0, 0.77778],
    "8808": [0.25142, 0.75726, 0, 0, 0.77778],
    "8809": [0.25142, 0.75726, 0, 0, 0.77778],
    "8812": [0.25583, 0.75583, 0, 0, 0.5],
    "8814": [0.20576, 0.70576, 0, 0, 0.77778],
    "8815": [0.20576, 0.70576, 0, 0, 0.77778],
    "8816": [0.30274, 0.79383, 0, 0, 0.77778],
    "8817": [0.30274, 0.79383, 0, 0, 0.77778],
    "8818": [0.22958, 0.72958, 0, 0, 0.77778],
    "8819": [0.22958, 0.72958, 0, 0, 0.77778],
    "8822": [0.1808, 0.675, 0, 0, 0.77778],
    "8823": [0.1808, 0.675, 0, 0, 0.77778],
    "8828": [0.13667, 0.63667, 0, 0, 0.77778],
    "8829": [0.13667, 0.63667, 0, 0, 0.77778],
    "8830": [0.22958, 0.72958, 0, 0, 0.77778],
    "8831": [0.22958, 0.72958, 0, 0, 0.77778],
    "8832": [0.20576, 0.70576, 0, 0, 0.77778],
    "8833": [0.20576, 0.70576, 0, 0, 0.77778],
    "8840": [0.30274, 0.79383, 0, 0, 0.77778],
    "8841": [0.30274, 0.79383, 0, 0, 0.77778],
    "8842": [0.13597, 0.63597, 0, 0, 0.77778],
    "8843": [0.13597, 0.63597, 0, 0, 0.77778],
    "8847": [0.03517, 0.54986, 0, 0, 0.77778],
    "8848": [0.03517, 0.54986, 0, 0, 0.77778],
    "8858": [0.08198, 0.58198, 0, 0, 0.77778],
    "8859": [0.08198, 0.58198, 0, 0, 0.77778],
    "8861": [0.08198, 0.58198, 0, 0, 0.77778],
    "8862": [0, 0.675, 0, 0, 0.77778],
    "8863": [0, 0.675, 0, 0, 0.77778],
    "8864": [0, 0.675, 0, 0, 0.77778],
    "8865": [0, 0.675, 0, 0, 0.77778],
    "8872": [0, 0.69224, 0, 0, 0.61111],
    "8873": [0, 0.69224, 0, 0, 0.72222],
    "8874": [0, 0.69224, 0, 0, 0.88889],
    "8876": [0, 0.68889, 0, 0, 0.61111],
    "8877": [0, 0.68889, 0, 0, 0.61111],
    "8878": [0, 0.68889, 0, 0, 0.72222],
    "8879": [0, 0.68889, 0, 0, 0.72222],
    "8882": [0.03517, 0.54986, 0, 0, 0.77778],
    "8883": [0.03517, 0.54986, 0, 0, 0.77778],
    "8884": [0.13667, 0.63667, 0, 0, 0.77778],
    "8885": [0.13667, 0.63667, 0, 0, 0.77778],
    "8888": [0, 0.54986, 0, 0, 1.11111],
    "8890": [0.19444, 0.43056, 0, 0, 0.55556],
    "8891": [0.19444, 0.69224, 0, 0, 0.61111],
    "8892": [0.19444, 0.69224, 0, 0, 0.61111],
    "8901": [0, 0.54986, 0, 0, 0.27778],
    "8903": [0.08167, 0.58167, 0, 0, 0.77778],
    "8905": [0.08167, 0.58167, 0, 0, 0.77778],
    "8906": [0.08167, 0.58167, 0, 0, 0.77778],
    "8907": [0, 0.69224, 0, 0, 0.77778],
    "8908": [0, 0.69224, 0, 0, 0.77778],
    "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
    "8910": [0, 0.54986, 0, 0, 0.76042],
    "8911": [0, 0.54986, 0, 0, 0.76042],
    "8912": [0.03517, 0.54986, 0, 0, 0.77778],
    "8913": [0.03517, 0.54986, 0, 0, 0.77778],
    "8914": [0, 0.54986, 0, 0, 0.66667],
    "8915": [0, 0.54986, 0, 0, 0.66667],
    "8916": [0, 0.69224, 0, 0, 0.66667],
    "8918": [0.0391, 0.5391, 0, 0, 0.77778],
    "8919": [0.0391, 0.5391, 0, 0, 0.77778],
    "8920": [0.03517, 0.54986, 0, 0, 1.33334],
    "8921": [0.03517, 0.54986, 0, 0, 1.33334],
    "8922": [0.38569, 0.88569, 0, 0, 0.77778],
    "8923": [0.38569, 0.88569, 0, 0, 0.77778],
    "8926": [0.13667, 0.63667, 0, 0, 0.77778],
    "8927": [0.13667, 0.63667, 0, 0, 0.77778],
    "8928": [0.30274, 0.79383, 0, 0, 0.77778],
    "8929": [0.30274, 0.79383, 0, 0, 0.77778],
    "8934": [0.23222, 0.74111, 0, 0, 0.77778],
    "8935": [0.23222, 0.74111, 0, 0, 0.77778],
    "8936": [0.23222, 0.74111, 0, 0, 0.77778],
    "8937": [0.23222, 0.74111, 0, 0, 0.77778],
    "8938": [0.20576, 0.70576, 0, 0, 0.77778],
    "8939": [0.20576, 0.70576, 0, 0, 0.77778],
    "8940": [0.30274, 0.79383, 0, 0, 0.77778],
    "8941": [0.30274, 0.79383, 0, 0, 0.77778],
    "8994": [0.19444, 0.69224, 0, 0, 0.77778],
    "8995": [0.19444, 0.69224, 0, 0, 0.77778],
    "9416": [0.15559, 0.69224, 0, 0, 0.90222],
    "9484": [0, 0.69224, 0, 0, 0.5],
    "9488": [0, 0.69224, 0, 0, 0.5],
    "9492": [0, 0.37788, 0, 0, 0.5],
    "9496": [0, 0.37788, 0, 0, 0.5],
    "9585": [0.19444, 0.68889, 0, 0, 0.88889],
    "9586": [0.19444, 0.74111, 0, 0, 0.88889],
    "9632": [0, 0.675, 0, 0, 0.77778],
    "9633": [0, 0.675, 0, 0, 0.77778],
    "9650": [0, 0.54986, 0, 0, 0.72222],
    "9651": [0, 0.54986, 0, 0, 0.72222],
    "9654": [0.03517, 0.54986, 0, 0, 0.77778],
    "9660": [0, 0.54986, 0, 0, 0.72222],
    "9661": [0, 0.54986, 0, 0, 0.72222],
    "9664": [0.03517, 0.54986, 0, 0, 0.77778],
    "9674": [0.11111, 0.69224, 0, 0, 0.66667],
    "9733": [0.19444, 0.69224, 0, 0, 0.94445],
    "10003": [0, 0.69224, 0, 0, 0.83334],
    "10016": [0, 0.69224, 0, 0, 0.83334],
    "10731": [0.11111, 0.69224, 0, 0, 0.66667],
    "10846": [0.19444, 0.75583, 0, 0, 0.61111],
    "10877": [0.13667, 0.63667, 0, 0, 0.77778],
    "10878": [0.13667, 0.63667, 0, 0, 0.77778],
    "10885": [0.25583, 0.75583, 0, 0, 0.77778],
    "10886": [0.25583, 0.75583, 0, 0, 0.77778],
    "10887": [0.13597, 0.63597, 0, 0, 0.77778],
    "10888": [0.13597, 0.63597, 0, 0, 0.77778],
    "10889": [0.26167, 0.75726, 0, 0, 0.77778],
    "10890": [0.26167, 0.75726, 0, 0, 0.77778],
    "10891": [0.48256, 0.98256, 0, 0, 0.77778],
    "10892": [0.48256, 0.98256, 0, 0, 0.77778],
    "10901": [0.13667, 0.63667, 0, 0, 0.77778],
    "10902": [0.13667, 0.63667, 0, 0, 0.77778],
    "10933": [0.25142, 0.75726, 0, 0, 0.77778],
    "10934": [0.25142, 0.75726, 0, 0, 0.77778],
    "10935": [0.26167, 0.75726, 0, 0, 0.77778],
    "10936": [0.26167, 0.75726, 0, 0, 0.77778],
    "10937": [0.26167, 0.75726, 0, 0, 0.77778],
    "10938": [0.26167, 0.75726, 0, 0, 0.77778],
    "10949": [0.25583, 0.75583, 0, 0, 0.77778],
    "10950": [0.25583, 0.75583, 0, 0, 0.77778],
    "10955": [0.28481, 0.79383, 0, 0, 0.77778],
    "10956": [0.28481, 0.79383, 0, 0, 0.77778],
    "57350": [0.08167, 0.58167, 0, 0, 0.22222],
    "57351": [0.08167, 0.58167, 0, 0, 0.38889],
    "57352": [0.08167, 0.58167, 0, 0, 0.77778],
    "57353": [0, 0.43056, 0.04028, 0, 0.66667],
    "57356": [0.25142, 0.75726, 0, 0, 0.77778],
    "57357": [0.25142, 0.75726, 0, 0, 0.77778],
    "57358": [0.41951, 0.91951, 0, 0, 0.77778],
    "57359": [0.30274, 0.79383, 0, 0, 0.77778],
    "57360": [0.30274, 0.79383, 0, 0, 0.77778],
    "57361": [0.41951, 0.91951, 0, 0, 0.77778],
    "57366": [0.25142, 0.75726, 0, 0, 0.77778],
    "57367": [0.25142, 0.75726, 0, 0, 0.77778],
    "57368": [0.25142, 0.75726, 0, 0, 0.77778],
    "57369": [0.25142, 0.75726, 0, 0, 0.77778],
    "57370": [0.13597, 0.63597, 0, 0, 0.77778],
    "57371": [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    "48": [0, 0.43056, 0, 0, 0.5],
    "49": [0, 0.43056, 0, 0, 0.5],
    "50": [0, 0.43056, 0, 0, 0.5],
    "51": [0.19444, 0.43056, 0, 0, 0.5],
    "52": [0.19444, 0.43056, 0, 0, 0.5],
    "53": [0.19444, 0.43056, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0.19444, 0.43056, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0.19444, 0.43056, 0, 0, 0.5],
    "65": [0, 0.68333, 0, 0.19445, 0.79847],
    "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
    "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
    "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
    "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
    "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
    "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    "72": [0, 0.68333, 0.00965, 0.11111, 0.84452],
    "73": [0, 0.68333, 0.07382, 0, 0.54452],
    "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
    "76": [0, 0.68333, 0, 0.13889, 0.68972],
    "77": [0, 0.68333, 0, 0.13889, 1.2009],
    "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
    "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
    "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
    "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
    "82": [0, 0.68333, 0, 0.08334, 0.8475],
    "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
    "84": [0, 0.68333, 0.25417, 0, 0.54464],
    "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
    "86": [0, 0.68333, 0.08222, 0, 0.61278],
    "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
    "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
    "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    "90": [0, 0.68333, 0.07944, 0.13889, 0.72473]
  },
  "Fraktur-Regular": {
    "33": [0, 0.69141, 0, 0, 0.29574],
    "34": [0, 0.69141, 0, 0, 0.21471],
    "38": [0, 0.69141, 0, 0, 0.73786],
    "39": [0, 0.69141, 0, 0, 0.21201],
    "40": [0.24982, 0.74947, 0, 0, 0.38865],
    "41": [0.24982, 0.74947, 0, 0, 0.38865],
    "42": [0, 0.62119, 0, 0, 0.27764],
    "43": [0.08319, 0.58283, 0, 0, 0.75623],
    "44": [0, 0.10803, 0, 0, 0.27764],
    "45": [0.08319, 0.58283, 0, 0, 0.75623],
    "46": [0, 0.10803, 0, 0, 0.27764],
    "47": [0.24982, 0.74947, 0, 0, 0.50181],
    "48": [0, 0.47534, 0, 0, 0.50181],
    "49": [0, 0.47534, 0, 0, 0.50181],
    "50": [0, 0.47534, 0, 0, 0.50181],
    "51": [0.18906, 0.47534, 0, 0, 0.50181],
    "52": [0.18906, 0.47534, 0, 0, 0.50181],
    "53": [0.18906, 0.47534, 0, 0, 0.50181],
    "54": [0, 0.69141, 0, 0, 0.50181],
    "55": [0.18906, 0.47534, 0, 0, 0.50181],
    "56": [0, 0.69141, 0, 0, 0.50181],
    "57": [0.18906, 0.47534, 0, 0, 0.50181],
    "58": [0, 0.47534, 0, 0, 0.21606],
    "59": [0.12604, 0.47534, 0, 0, 0.21606],
    "61": [-0.13099, 0.36866, 0, 0, 0.75623],
    "63": [0, 0.69141, 0, 0, 0.36245],
    "65": [0, 0.69141, 0, 0, 0.7176],
    "66": [0, 0.69141, 0, 0, 0.88397],
    "67": [0, 0.69141, 0, 0, 0.61254],
    "68": [0, 0.69141, 0, 0, 0.83158],
    "69": [0, 0.69141, 0, 0, 0.66278],
    "70": [0.12604, 0.69141, 0, 0, 0.61119],
    "71": [0, 0.69141, 0, 0, 0.78539],
    "72": [0.06302, 0.69141, 0, 0, 0.7203],
    "73": [0, 0.69141, 0, 0, 0.55448],
    "74": [0.12604, 0.69141, 0, 0, 0.55231],
    "75": [0, 0.69141, 0, 0, 0.66845],
    "76": [0, 0.69141, 0, 0, 0.66602],
    "77": [0, 0.69141, 0, 0, 1.04953],
    "78": [0, 0.69141, 0, 0, 0.83212],
    "79": [0, 0.69141, 0, 0, 0.82699],
    "80": [0.18906, 0.69141, 0, 0, 0.82753],
    "81": [0.03781, 0.69141, 0, 0, 0.82699],
    "82": [0, 0.69141, 0, 0, 0.82807],
    "83": [0, 0.69141, 0, 0, 0.82861],
    "84": [0, 0.69141, 0, 0, 0.66899],
    "85": [0, 0.69141, 0, 0, 0.64576],
    "86": [0, 0.69141, 0, 0, 0.83131],
    "87": [0, 0.69141, 0, 0, 1.04602],
    "88": [0, 0.69141, 0, 0, 0.71922],
    "89": [0.18906, 0.69141, 0, 0, 0.83293],
    "90": [0.12604, 0.69141, 0, 0, 0.60201],
    "91": [0.24982, 0.74947, 0, 0, 0.27764],
    "93": [0.24982, 0.74947, 0, 0, 0.27764],
    "94": [0, 0.69141, 0, 0, 0.49965],
    "97": [0, 0.47534, 0, 0, 0.50046],
    "98": [0, 0.69141, 0, 0, 0.51315],
    "99": [0, 0.47534, 0, 0, 0.38946],
    "100": [0, 0.62119, 0, 0, 0.49857],
    "101": [0, 0.47534, 0, 0, 0.40053],
    "102": [0.18906, 0.69141, 0, 0, 0.32626],
    "103": [0.18906, 0.47534, 0, 0, 0.5037],
    "104": [0.18906, 0.69141, 0, 0, 0.52126],
    "105": [0, 0.69141, 0, 0, 0.27899],
    "106": [0, 0.69141, 0, 0, 0.28088],
    "107": [0, 0.69141, 0, 0, 0.38946],
    "108": [0, 0.69141, 0, 0, 0.27953],
    "109": [0, 0.47534, 0, 0, 0.76676],
    "110": [0, 0.47534, 0, 0, 0.52666],
    "111": [0, 0.47534, 0, 0, 0.48885],
    "112": [0.18906, 0.52396, 0, 0, 0.50046],
    "113": [0.18906, 0.47534, 0, 0, 0.48912],
    "114": [0, 0.47534, 0, 0, 0.38919],
    "115": [0, 0.47534, 0, 0, 0.44266],
    "116": [0, 0.62119, 0, 0, 0.33301],
    "117": [0, 0.47534, 0, 0, 0.5172],
    "118": [0, 0.52396, 0, 0, 0.5118],
    "119": [0, 0.52396, 0, 0, 0.77351],
    "120": [0.18906, 0.47534, 0, 0, 0.38865],
    "121": [0.18906, 0.47534, 0, 0, 0.49884],
    "122": [0.18906, 0.47534, 0, 0, 0.39054],
    "8216": [0, 0.69141, 0, 0, 0.21471],
    "8217": [0, 0.69141, 0, 0, 0.21471],
    "58112": [0, 0.62119, 0, 0, 0.49749],
    "58113": [0, 0.62119, 0, 0, 0.4983],
    "58114": [0.18906, 0.69141, 0, 0, 0.33328],
    "58115": [0.18906, 0.69141, 0, 0, 0.32923],
    "58116": [0.18906, 0.47534, 0, 0, 0.50343],
    "58117": [0, 0.69141, 0, 0, 0.33301],
    "58118": [0, 0.62119, 0, 0, 0.33409],
    "58119": [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    "33": [0, 0.69444, 0, 0, 0.35],
    "34": [0, 0.69444, 0, 0, 0.60278],
    "35": [0.19444, 0.69444, 0, 0, 0.95833],
    "36": [0.05556, 0.75, 0, 0, 0.575],
    "37": [0.05556, 0.75, 0, 0, 0.95833],
    "38": [0, 0.69444, 0, 0, 0.89444],
    "39": [0, 0.69444, 0, 0, 0.31944],
    "40": [0.25, 0.75, 0, 0, 0.44722],
    "41": [0.25, 0.75, 0, 0, 0.44722],
    "42": [0, 0.75, 0, 0, 0.575],
    "43": [0.13333, 0.63333, 0, 0, 0.89444],
    "44": [0.19444, 0.15556, 0, 0, 0.31944],
    "45": [0, 0.44444, 0, 0, 0.38333],
    "46": [0, 0.15556, 0, 0, 0.31944],
    "47": [0.25, 0.75, 0, 0, 0.575],
    "48": [0, 0.64444, 0, 0, 0.575],
    "49": [0, 0.64444, 0, 0, 0.575],
    "50": [0, 0.64444, 0, 0, 0.575],
    "51": [0, 0.64444, 0, 0, 0.575],
    "52": [0, 0.64444, 0, 0, 0.575],
    "53": [0, 0.64444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0, 0.64444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0, 0.64444, 0, 0, 0.575],
    "58": [0, 0.44444, 0, 0, 0.31944],
    "59": [0.19444, 0.44444, 0, 0, 0.31944],
    "60": [0.08556, 0.58556, 0, 0, 0.89444],
    "61": [-0.10889, 0.39111, 0, 0, 0.89444],
    "62": [0.08556, 0.58556, 0, 0, 0.89444],
    "63": [0, 0.69444, 0, 0, 0.54305],
    "64": [0, 0.69444, 0, 0, 0.89444],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0, 0, 0.81805],
    "67": [0, 0.68611, 0, 0, 0.83055],
    "68": [0, 0.68611, 0, 0, 0.88194],
    "69": [0, 0.68611, 0, 0, 0.75555],
    "70": [0, 0.68611, 0, 0, 0.72361],
    "71": [0, 0.68611, 0, 0, 0.90416],
    "72": [0, 0.68611, 0, 0, 0.9],
    "73": [0, 0.68611, 0, 0, 0.43611],
    "74": [0, 0.68611, 0, 0, 0.59444],
    "75": [0, 0.68611, 0, 0, 0.90138],
    "76": [0, 0.68611, 0, 0, 0.69166],
    "77": [0, 0.68611, 0, 0, 1.09166],
    "78": [0, 0.68611, 0, 0, 0.9],
    "79": [0, 0.68611, 0, 0, 0.86388],
    "80": [0, 0.68611, 0, 0, 0.78611],
    "81": [0.19444, 0.68611, 0, 0, 0.86388],
    "82": [0, 0.68611, 0, 0, 0.8625],
    "83": [0, 0.68611, 0, 0, 0.63889],
    "84": [0, 0.68611, 0, 0, 0.8],
    "85": [0, 0.68611, 0, 0, 0.88472],
    "86": [0, 0.68611, 0.01597, 0, 0.86944],
    "87": [0, 0.68611, 0.01597, 0, 1.18888],
    "88": [0, 0.68611, 0, 0, 0.86944],
    "89": [0, 0.68611, 0.02875, 0, 0.86944],
    "90": [0, 0.68611, 0, 0, 0.70277],
    "91": [0.25, 0.75, 0, 0, 0.31944],
    "92": [0.25, 0.75, 0, 0, 0.575],
    "93": [0.25, 0.75, 0, 0, 0.31944],
    "94": [0, 0.69444, 0, 0, 0.575],
    "95": [0.31, 0.13444, 0.03194, 0, 0.575],
    "97": [0, 0.44444, 0, 0, 0.55902],
    "98": [0, 0.69444, 0, 0, 0.63889],
    "99": [0, 0.44444, 0, 0, 0.51111],
    "100": [0, 0.69444, 0, 0, 0.63889],
    "101": [0, 0.44444, 0, 0, 0.52708],
    "102": [0, 0.69444, 0.10903, 0, 0.35139],
    "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
    "104": [0, 0.69444, 0, 0, 0.63889],
    "105": [0, 0.69444, 0, 0, 0.31944],
    "106": [0.19444, 0.69444, 0, 0, 0.35139],
    "107": [0, 0.69444, 0, 0, 0.60694],
    "108": [0, 0.69444, 0, 0, 0.31944],
    "109": [0, 0.44444, 0, 0, 0.95833],
    "110": [0, 0.44444, 0, 0, 0.63889],
    "111": [0, 0.44444, 0, 0, 0.575],
    "112": [0.19444, 0.44444, 0, 0, 0.63889],
    "113": [0.19444, 0.44444, 0, 0, 0.60694],
    "114": [0, 0.44444, 0, 0, 0.47361],
    "115": [0, 0.44444, 0, 0, 0.45361],
    "116": [0, 0.63492, 0, 0, 0.44722],
    "117": [0, 0.44444, 0, 0, 0.63889],
    "118": [0, 0.44444, 0.01597, 0, 0.60694],
    "119": [0, 0.44444, 0.01597, 0, 0.83055],
    "120": [0, 0.44444, 0, 0, 0.60694],
    "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
    "122": [0, 0.44444, 0, 0, 0.51111],
    "123": [0.25, 0.75, 0, 0, 0.575],
    "124": [0.25, 0.75, 0, 0, 0.31944],
    "125": [0.25, 0.75, 0, 0, 0.575],
    "126": [0.35, 0.34444, 0, 0, 0.575],
    "168": [0, 0.69444, 0, 0, 0.575],
    "172": [0, 0.44444, 0, 0, 0.76666],
    "176": [0, 0.69444, 0, 0, 0.86944],
    "177": [0.13333, 0.63333, 0, 0, 0.89444],
    "184": [0.17014, 0, 0, 0, 0.51111],
    "198": [0, 0.68611, 0, 0, 1.04166],
    "215": [0.13333, 0.63333, 0, 0, 0.89444],
    "216": [0.04861, 0.73472, 0, 0, 0.89444],
    "223": [0, 0.69444, 0, 0, 0.59722],
    "230": [0, 0.44444, 0, 0, 0.83055],
    "247": [0.13333, 0.63333, 0, 0, 0.89444],
    "248": [0.09722, 0.54167, 0, 0, 0.575],
    "305": [0, 0.44444, 0, 0, 0.31944],
    "338": [0, 0.68611, 0, 0, 1.16944],
    "339": [0, 0.44444, 0, 0, 0.89444],
    "567": [0.19444, 0.44444, 0, 0, 0.35139],
    "710": [0, 0.69444, 0, 0, 0.575],
    "711": [0, 0.63194, 0, 0, 0.575],
    "713": [0, 0.59611, 0, 0, 0.575],
    "714": [0, 0.69444, 0, 0, 0.575],
    "715": [0, 0.69444, 0, 0, 0.575],
    "728": [0, 0.69444, 0, 0, 0.575],
    "729": [0, 0.69444, 0, 0, 0.31944],
    "730": [0, 0.69444, 0, 0, 0.86944],
    "732": [0, 0.69444, 0, 0, 0.575],
    "733": [0, 0.69444, 0, 0, 0.575],
    "915": [0, 0.68611, 0, 0, 0.69166],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0, 0, 0.89444],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0, 0, 0.76666],
    "928": [0, 0.68611, 0, 0, 0.9],
    "931": [0, 0.68611, 0, 0, 0.83055],
    "933": [0, 0.68611, 0, 0, 0.89444],
    "934": [0, 0.68611, 0, 0, 0.83055],
    "936": [0, 0.68611, 0, 0, 0.89444],
    "937": [0, 0.68611, 0, 0, 0.83055],
    "8211": [0, 0.44444, 0.03194, 0, 0.575],
    "8212": [0, 0.44444, 0.03194, 0, 1.14999],
    "8216": [0, 0.69444, 0, 0, 0.31944],
    "8217": [0, 0.69444, 0, 0, 0.31944],
    "8220": [0, 0.69444, 0, 0, 0.60278],
    "8221": [0, 0.69444, 0, 0, 0.60278],
    "8224": [0.19444, 0.69444, 0, 0, 0.51111],
    "8225": [0.19444, 0.69444, 0, 0, 0.51111],
    "8242": [0, 0.55556, 0, 0, 0.34444],
    "8407": [0, 0.72444, 0.15486, 0, 0.575],
    "8463": [0, 0.69444, 0, 0, 0.66759],
    "8465": [0, 0.69444, 0, 0, 0.83055],
    "8467": [0, 0.69444, 0, 0, 0.47361],
    "8472": [0.19444, 0.44444, 0, 0, 0.74027],
    "8476": [0, 0.69444, 0, 0, 0.83055],
    "8501": [0, 0.69444, 0, 0, 0.70277],
    "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8593": [0.19444, 0.69444, 0, 0, 0.575],
    "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8595": [0.19444, 0.69444, 0, 0, 0.575],
    "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8597": [0.25, 0.75, 0, 0, 0.575],
    "8598": [0.19444, 0.69444, 0, 0, 1.14999],
    "8599": [0.19444, 0.69444, 0, 0, 1.14999],
    "8600": [0.19444, 0.69444, 0, 0, 1.14999],
    "8601": [0.19444, 0.69444, 0, 0, 1.14999],
    "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8657": [0.19444, 0.69444, 0, 0, 0.70277],
    "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8659": [0.19444, 0.69444, 0, 0, 0.70277],
    "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8661": [0.25, 0.75, 0, 0, 0.70277],
    "8704": [0, 0.69444, 0, 0, 0.63889],
    "8706": [0, 0.69444, 0.06389, 0, 0.62847],
    "8707": [0, 0.69444, 0, 0, 0.63889],
    "8709": [0.05556, 0.75, 0, 0, 0.575],
    "8711": [0, 0.68611, 0, 0, 0.95833],
    "8712": [0.08556, 0.58556, 0, 0, 0.76666],
    "8715": [0.08556, 0.58556, 0, 0, 0.76666],
    "8722": [0.13333, 0.63333, 0, 0, 0.89444],
    "8723": [0.13333, 0.63333, 0, 0, 0.89444],
    "8725": [0.25, 0.75, 0, 0, 0.575],
    "8726": [0.25, 0.75, 0, 0, 0.575],
    "8727": [-0.02778, 0.47222, 0, 0, 0.575],
    "8728": [-0.02639, 0.47361, 0, 0, 0.575],
    "8729": [-0.02639, 0.47361, 0, 0, 0.575],
    "8730": [0.18, 0.82, 0, 0, 0.95833],
    "8733": [0, 0.44444, 0, 0, 0.89444],
    "8734": [0, 0.44444, 0, 0, 1.14999],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.31944],
    "8741": [0.25, 0.75, 0, 0, 0.575],
    "8743": [0, 0.55556, 0, 0, 0.76666],
    "8744": [0, 0.55556, 0, 0, 0.76666],
    "8745": [0, 0.55556, 0, 0, 0.76666],
    "8746": [0, 0.55556, 0, 0, 0.76666],
    "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
    "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
    "8768": [0.19444, 0.69444, 0, 0, 0.31944],
    "8771": [0.00222, 0.50222, 0, 0, 0.89444],
    "8776": [0.02444, 0.52444, 0, 0, 0.89444],
    "8781": [0.00222, 0.50222, 0, 0, 0.89444],
    "8801": [0.00222, 0.50222, 0, 0, 0.89444],
    "8804": [0.19667, 0.69667, 0, 0, 0.89444],
    "8805": [0.19667, 0.69667, 0, 0, 0.89444],
    "8810": [0.08556, 0.58556, 0, 0, 1.14999],
    "8811": [0.08556, 0.58556, 0, 0, 1.14999],
    "8826": [0.08556, 0.58556, 0, 0, 0.89444],
    "8827": [0.08556, 0.58556, 0, 0, 0.89444],
    "8834": [0.08556, 0.58556, 0, 0, 0.89444],
    "8835": [0.08556, 0.58556, 0, 0, 0.89444],
    "8838": [0.19667, 0.69667, 0, 0, 0.89444],
    "8839": [0.19667, 0.69667, 0, 0, 0.89444],
    "8846": [0, 0.55556, 0, 0, 0.76666],
    "8849": [0.19667, 0.69667, 0, 0, 0.89444],
    "8850": [0.19667, 0.69667, 0, 0, 0.89444],
    "8851": [0, 0.55556, 0, 0, 0.76666],
    "8852": [0, 0.55556, 0, 0, 0.76666],
    "8853": [0.13333, 0.63333, 0, 0, 0.89444],
    "8854": [0.13333, 0.63333, 0, 0, 0.89444],
    "8855": [0.13333, 0.63333, 0, 0, 0.89444],
    "8856": [0.13333, 0.63333, 0, 0, 0.89444],
    "8857": [0.13333, 0.63333, 0, 0, 0.89444],
    "8866": [0, 0.69444, 0, 0, 0.70277],
    "8867": [0, 0.69444, 0, 0, 0.70277],
    "8868": [0, 0.69444, 0, 0, 0.89444],
    "8869": [0, 0.69444, 0, 0, 0.89444],
    "8900": [-0.02639, 0.47361, 0, 0, 0.575],
    "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
    "8902": [-0.02778, 0.47222, 0, 0, 0.575],
    "8968": [0.25, 0.75, 0, 0, 0.51111],
    "8969": [0.25, 0.75, 0, 0, 0.51111],
    "8970": [0.25, 0.75, 0, 0, 0.51111],
    "8971": [0.25, 0.75, 0, 0, 0.51111],
    "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
    "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
    "9651": [0.19444, 0.69444, 0, 0, 1.02222],
    "9657": [-0.02778, 0.47222, 0, 0, 0.575],
    "9661": [0.19444, 0.69444, 0, 0, 1.02222],
    "9667": [-0.02778, 0.47222, 0, 0, 0.575],
    "9711": [0.19444, 0.69444, 0, 0, 1.14999],
    "9824": [0.12963, 0.69444, 0, 0, 0.89444],
    "9825": [0.12963, 0.69444, 0, 0, 0.89444],
    "9826": [0.12963, 0.69444, 0, 0, 0.89444],
    "9827": [0.12963, 0.69444, 0, 0, 0.89444],
    "9837": [0, 0.75, 0, 0, 0.44722],
    "9838": [0.19444, 0.69444, 0, 0, 0.44722],
    "9839": [0.19444, 0.69444, 0, 0, 0.44722],
    "10216": [0.25, 0.75, 0, 0, 0.44722],
    "10217": [0.25, 0.75, 0, 0, 0.44722],
    "10815": [0, 0.68611, 0, 0, 0.9],
    "10927": [0.19667, 0.69667, 0, 0, 0.89444],
    "10928": [0.19667, 0.69667, 0, 0, 0.89444],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    "33": [0, 0.69444, 0.11417, 0, 0.38611],
    "34": [0, 0.69444, 0.07939, 0, 0.62055],
    "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
    "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
    "38": [0, 0.69444, 0.08528, 0, 0.88555],
    "39": [0, 0.69444, 0.12945, 0, 0.35555],
    "40": [0.25, 0.75, 0.15806, 0, 0.47333],
    "41": [0.25, 0.75, 0.03306, 0, 0.47333],
    "42": [0, 0.75, 0.14333, 0, 0.59111],
    "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
    "44": [0.19444, 0.14722, 0, 0, 0.35555],
    "45": [0, 0.44444, 0.02611, 0, 0.41444],
    "46": [0, 0.14722, 0, 0, 0.35555],
    "47": [0.25, 0.75, 0.15806, 0, 0.59111],
    "48": [0, 0.64444, 0.13167, 0, 0.59111],
    "49": [0, 0.64444, 0.13167, 0, 0.59111],
    "50": [0, 0.64444, 0.13167, 0, 0.59111],
    "51": [0, 0.64444, 0.13167, 0, 0.59111],
    "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "53": [0, 0.64444, 0.13167, 0, 0.59111],
    "54": [0, 0.64444, 0.13167, 0, 0.59111],
    "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "56": [0, 0.64444, 0.13167, 0, 0.59111],
    "57": [0, 0.64444, 0.13167, 0, 0.59111],
    "58": [0, 0.44444, 0.06695, 0, 0.35555],
    "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
    "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    "63": [0, 0.69444, 0.11472, 0, 0.59111],
    "64": [0, 0.69444, 0.09208, 0, 0.88555],
    "65": [0, 0.68611, 0, 0, 0.86555],
    "66": [0, 0.68611, 0.0992, 0, 0.81666],
    "67": [0, 0.68611, 0.14208, 0, 0.82666],
    "68": [0, 0.68611, 0.09062, 0, 0.87555],
    "69": [0, 0.68611, 0.11431, 0, 0.75666],
    "70": [0, 0.68611, 0.12903, 0, 0.72722],
    "71": [0, 0.68611, 0.07347, 0, 0.89527],
    "72": [0, 0.68611, 0.17208, 0, 0.8961],
    "73": [0, 0.68611, 0.15681, 0, 0.47166],
    "74": [0, 0.68611, 0.145, 0, 0.61055],
    "75": [0, 0.68611, 0.14208, 0, 0.89499],
    "76": [0, 0.68611, 0, 0, 0.69777],
    "77": [0, 0.68611, 0.17208, 0, 1.07277],
    "78": [0, 0.68611, 0.17208, 0, 0.8961],
    "79": [0, 0.68611, 0.09062, 0, 0.85499],
    "80": [0, 0.68611, 0.0992, 0, 0.78721],
    "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
    "82": [0, 0.68611, 0.02559, 0, 0.85944],
    "83": [0, 0.68611, 0.11264, 0, 0.64999],
    "84": [0, 0.68611, 0.12903, 0, 0.7961],
    "85": [0, 0.68611, 0.17208, 0, 0.88083],
    "86": [0, 0.68611, 0.18625, 0, 0.86555],
    "87": [0, 0.68611, 0.18625, 0, 1.15999],
    "88": [0, 0.68611, 0.15681, 0, 0.86555],
    "89": [0, 0.68611, 0.19803, 0, 0.86555],
    "90": [0, 0.68611, 0.14208, 0, 0.70888],
    "91": [0.25, 0.75, 0.1875, 0, 0.35611],
    "93": [0.25, 0.75, 0.09972, 0, 0.35611],
    "94": [0, 0.69444, 0.06709, 0, 0.59111],
    "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
    "97": [0, 0.44444, 0.09426, 0, 0.59111],
    "98": [0, 0.69444, 0.07861, 0, 0.53222],
    "99": [0, 0.44444, 0.05222, 0, 0.53222],
    "100": [0, 0.69444, 0.10861, 0, 0.59111],
    "101": [0, 0.44444, 0.085, 0, 0.53222],
    "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
    "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "104": [0, 0.69444, 0.09426, 0, 0.59111],
    "105": [0, 0.69326, 0.11387, 0, 0.35555],
    "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
    "107": [0, 0.69444, 0.11111, 0, 0.53222],
    "108": [0, 0.69444, 0.10861, 0, 0.29666],
    "109": [0, 0.44444, 0.09426, 0, 0.94444],
    "110": [0, 0.44444, 0.09426, 0, 0.64999],
    "111": [0, 0.44444, 0.07861, 0, 0.59111],
    "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
    "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "114": [0, 0.44444, 0.11111, 0, 0.50167],
    "115": [0, 0.44444, 0.08167, 0, 0.48694],
    "116": [0, 0.63492, 0.09639, 0, 0.385],
    "117": [0, 0.44444, 0.09426, 0, 0.62055],
    "118": [0, 0.44444, 0.11111, 0, 0.53222],
    "119": [0, 0.44444, 0.11111, 0, 0.76777],
    "120": [0, 0.44444, 0.12583, 0, 0.56055],
    "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
    "122": [0, 0.44444, 0.13889, 0, 0.49055],
    "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
    "163": [0, 0.69444, 0, 0, 0.86853],
    "168": [0, 0.69444, 0.11473, 0, 0.59111],
    "176": [0, 0.69444, 0, 0, 0.94888],
    "184": [0.17014, 0, 0, 0, 0.53222],
    "198": [0, 0.68611, 0.11431, 0, 1.02277],
    "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
    "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
    "230": [0, 0.44444, 0.085, 0, 0.82666],
    "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
    "305": [0, 0.44444, 0.09426, 0, 0.35555],
    "338": [0, 0.68611, 0.11431, 0, 1.14054],
    "339": [0, 0.44444, 0.085, 0, 0.82666],
    "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
    "710": [0, 0.69444, 0.06709, 0, 0.59111],
    "711": [0, 0.63194, 0.08271, 0, 0.59111],
    "713": [0, 0.59444, 0.10444, 0, 0.59111],
    "714": [0, 0.69444, 0.08528, 0, 0.59111],
    "715": [0, 0.69444, 0, 0, 0.59111],
    "728": [0, 0.69444, 0.10333, 0, 0.59111],
    "729": [0, 0.69444, 0.12945, 0, 0.35555],
    "730": [0, 0.69444, 0, 0, 0.94888],
    "732": [0, 0.69444, 0.11472, 0, 0.59111],
    "733": [0, 0.69444, 0.11472, 0, 0.59111],
    "915": [0, 0.68611, 0.12903, 0, 0.69777],
    "916": [0, 0.68611, 0, 0, 0.94444],
    "920": [0, 0.68611, 0.09062, 0, 0.88555],
    "923": [0, 0.68611, 0, 0, 0.80666],
    "926": [0, 0.68611, 0.15092, 0, 0.76777],
    "928": [0, 0.68611, 0.17208, 0, 0.8961],
    "931": [0, 0.68611, 0.11431, 0, 0.82666],
    "933": [0, 0.68611, 0.10778, 0, 0.88555],
    "934": [0, 0.68611, 0.05632, 0, 0.82666],
    "936": [0, 0.68611, 0.10778, 0, 0.88555],
    "937": [0, 0.68611, 0.0992, 0, 0.82666],
    "8211": [0, 0.44444, 0.09811, 0, 0.59111],
    "8212": [0, 0.44444, 0.09811, 0, 1.18221],
    "8216": [0, 0.69444, 0.12945, 0, 0.35555],
    "8217": [0, 0.69444, 0.12945, 0, 0.35555],
    "8220": [0, 0.69444, 0.16772, 0, 0.62055],
    "8221": [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    "33": [0, 0.69444, 0.12417, 0, 0.30667],
    "34": [0, 0.69444, 0.06961, 0, 0.51444],
    "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
    "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
    "38": [0, 0.69444, 0.09694, 0, 0.76666],
    "39": [0, 0.69444, 0.12417, 0, 0.30667],
    "40": [0.25, 0.75, 0.16194, 0, 0.40889],
    "41": [0.25, 0.75, 0.03694, 0, 0.40889],
    "42": [0, 0.75, 0.14917, 0, 0.51111],
    "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
    "44": [0.19444, 0.10556, 0, 0, 0.30667],
    "45": [0, 0.43056, 0.02826, 0, 0.35778],
    "46": [0, 0.10556, 0, 0, 0.30667],
    "47": [0.25, 0.75, 0.16194, 0, 0.51111],
    "48": [0, 0.64444, 0.13556, 0, 0.51111],
    "49": [0, 0.64444, 0.13556, 0, 0.51111],
    "50": [0, 0.64444, 0.13556, 0, 0.51111],
    "51": [0, 0.64444, 0.13556, 0, 0.51111],
    "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "53": [0, 0.64444, 0.13556, 0, 0.51111],
    "54": [0, 0.64444, 0.13556, 0, 0.51111],
    "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "56": [0, 0.64444, 0.13556, 0, 0.51111],
    "57": [0, 0.64444, 0.13556, 0, 0.51111],
    "58": [0, 0.43056, 0.0582, 0, 0.30667],
    "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
    "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    "63": [0, 0.69444, 0.1225, 0, 0.51111],
    "64": [0, 0.69444, 0.09597, 0, 0.76666],
    "65": [0, 0.68333, 0, 0, 0.74333],
    "66": [0, 0.68333, 0.10257, 0, 0.70389],
    "67": [0, 0.68333, 0.14528, 0, 0.71555],
    "68": [0, 0.68333, 0.09403, 0, 0.755],
    "69": [0, 0.68333, 0.12028, 0, 0.67833],
    "70": [0, 0.68333, 0.13305, 0, 0.65277],
    "71": [0, 0.68333, 0.08722, 0, 0.77361],
    "72": [0, 0.68333, 0.16389, 0, 0.74333],
    "73": [0, 0.68333, 0.15806, 0, 0.38555],
    "74": [0, 0.68333, 0.14028, 0, 0.525],
    "75": [0, 0.68333, 0.14528, 0, 0.76888],
    "76": [0, 0.68333, 0, 0, 0.62722],
    "77": [0, 0.68333, 0.16389, 0, 0.89666],
    "78": [0, 0.68333, 0.16389, 0, 0.74333],
    "79": [0, 0.68333, 0.09403, 0, 0.76666],
    "80": [0, 0.68333, 0.10257, 0, 0.67833],
    "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
    "82": [0, 0.68333, 0.03868, 0, 0.72944],
    "83": [0, 0.68333, 0.11972, 0, 0.56222],
    "84": [0, 0.68333, 0.13305, 0, 0.71555],
    "85": [0, 0.68333, 0.16389, 0, 0.74333],
    "86": [0, 0.68333, 0.18361, 0, 0.74333],
    "87": [0, 0.68333, 0.18361, 0, 0.99888],
    "88": [0, 0.68333, 0.15806, 0, 0.74333],
    "89": [0, 0.68333, 0.19383, 0, 0.74333],
    "90": [0, 0.68333, 0.14528, 0, 0.61333],
    "91": [0.25, 0.75, 0.1875, 0, 0.30667],
    "93": [0.25, 0.75, 0.10528, 0, 0.30667],
    "94": [0, 0.69444, 0.06646, 0, 0.51111],
    "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
    "97": [0, 0.43056, 0.07671, 0, 0.51111],
    "98": [0, 0.69444, 0.06312, 0, 0.46],
    "99": [0, 0.43056, 0.05653, 0, 0.46],
    "100": [0, 0.69444, 0.10333, 0, 0.51111],
    "101": [0, 0.43056, 0.07514, 0, 0.46],
    "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
    "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "104": [0, 0.69444, 0.07671, 0, 0.51111],
    "105": [0, 0.65536, 0.1019, 0, 0.30667],
    "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
    "107": [0, 0.69444, 0.10764, 0, 0.46],
    "108": [0, 0.69444, 0.10333, 0, 0.25555],
    "109": [0, 0.43056, 0.07671, 0, 0.81777],
    "110": [0, 0.43056, 0.07671, 0, 0.56222],
    "111": [0, 0.43056, 0.06312, 0, 0.51111],
    "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
    "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "114": [0, 0.43056, 0.10764, 0, 0.42166],
    "115": [0, 0.43056, 0.08208, 0, 0.40889],
    "116": [0, 0.61508, 0.09486, 0, 0.33222],
    "117": [0, 0.43056, 0.07671, 0, 0.53666],
    "118": [0, 0.43056, 0.10764, 0, 0.46],
    "119": [0, 0.43056, 0.10764, 0, 0.66444],
    "120": [0, 0.43056, 0.12042, 0, 0.46389],
    "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
    "122": [0, 0.43056, 0.12292, 0, 0.40889],
    "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
    "163": [0, 0.69444, 0, 0, 0.76909],
    "168": [0, 0.66786, 0.10474, 0, 0.51111],
    "176": [0, 0.69444, 0, 0, 0.83129],
    "184": [0.17014, 0, 0, 0, 0.46],
    "198": [0, 0.68333, 0.12028, 0, 0.88277],
    "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
    "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
    "230": [0, 0.43056, 0.07514, 0, 0.71555],
    "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
    "305": [0, 0.43056, 0, 0.02778, 0.32246],
    "338": [0, 0.68333, 0.12028, 0, 0.98499],
    "339": [0, 0.43056, 0.07514, 0, 0.71555],
    "567": [0.19444, 0.43056, 0, 0.08334, 0.38403],
    "710": [0, 0.69444, 0.06646, 0, 0.51111],
    "711": [0, 0.62847, 0.08295, 0, 0.51111],
    "713": [0, 0.56167, 0.10333, 0, 0.51111],
    "714": [0, 0.69444, 0.09694, 0, 0.51111],
    "715": [0, 0.69444, 0, 0, 0.51111],
    "728": [0, 0.69444, 0.10806, 0, 0.51111],
    "729": [0, 0.66786, 0.11752, 0, 0.30667],
    "730": [0, 0.69444, 0, 0, 0.83129],
    "732": [0, 0.66786, 0.11585, 0, 0.51111],
    "733": [0, 0.69444, 0.1225, 0, 0.51111],
    "915": [0, 0.68333, 0.13305, 0, 0.62722],
    "916": [0, 0.68333, 0, 0, 0.81777],
    "920": [0, 0.68333, 0.09403, 0, 0.76666],
    "923": [0, 0.68333, 0, 0, 0.69222],
    "926": [0, 0.68333, 0.15294, 0, 0.66444],
    "928": [0, 0.68333, 0.16389, 0, 0.74333],
    "931": [0, 0.68333, 0.12028, 0, 0.71555],
    "933": [0, 0.68333, 0.11111, 0, 0.76666],
    "934": [0, 0.68333, 0.05986, 0, 0.71555],
    "936": [0, 0.68333, 0.11111, 0, 0.76666],
    "937": [0, 0.68333, 0.10257, 0, 0.71555],
    "8211": [0, 0.43056, 0.09208, 0, 0.51111],
    "8212": [0, 0.43056, 0.09208, 0, 1.02222],
    "8216": [0, 0.69444, 0.12417, 0, 0.30667],
    "8217": [0, 0.69444, 0.12417, 0, 0.30667],
    "8220": [0, 0.69444, 0.1685, 0, 0.51444],
    "8221": [0, 0.69444, 0.06961, 0, 0.51444],
    "8463": [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.27778],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.77778],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.19444, 0.10556, 0, 0, 0.27778],
    "45": [0, 0.43056, 0, 0, 0.33333],
    "46": [0, 0.10556, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.64444, 0, 0, 0.5],
    "49": [0, 0.64444, 0, 0, 0.5],
    "50": [0, 0.64444, 0, 0, 0.5],
    "51": [0, 0.64444, 0, 0, 0.5],
    "52": [0, 0.64444, 0, 0, 0.5],
    "53": [0, 0.64444, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0, 0.64444, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0, 0.64444, 0, 0, 0.5],
    "58": [0, 0.43056, 0, 0, 0.27778],
    "59": [0.19444, 0.43056, 0, 0, 0.27778],
    "60": [0.0391, 0.5391, 0, 0, 0.77778],
    "61": [-0.13313, 0.36687, 0, 0, 0.77778],
    "62": [0.0391, 0.5391, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.77778],
    "65": [0, 0.68333, 0, 0, 0.75],
    "66": [0, 0.68333, 0, 0, 0.70834],
    "67": [0, 0.68333, 0, 0, 0.72222],
    "68": [0, 0.68333, 0, 0, 0.76389],
    "69": [0, 0.68333, 0, 0, 0.68056],
    "70": [0, 0.68333, 0, 0, 0.65278],
    "71": [0, 0.68333, 0, 0, 0.78472],
    "72": [0, 0.68333, 0, 0, 0.75],
    "73": [0, 0.68333, 0, 0, 0.36111],
    "74": [0, 0.68333, 0, 0, 0.51389],
    "75": [0, 0.68333, 0, 0, 0.77778],
    "76": [0, 0.68333, 0, 0, 0.625],
    "77": [0, 0.68333, 0, 0, 0.91667],
    "78": [0, 0.68333, 0, 0, 0.75],
    "79": [0, 0.68333, 0, 0, 0.77778],
    "80": [0, 0.68333, 0, 0, 0.68056],
    "81": [0.19444, 0.68333, 0, 0, 0.77778],
    "82": [0, 0.68333, 0, 0, 0.73611],
    "83": [0, 0.68333, 0, 0, 0.55556],
    "84": [0, 0.68333, 0, 0, 0.72222],
    "85": [0, 0.68333, 0, 0, 0.75],
    "86": [0, 0.68333, 0.01389, 0, 0.75],
    "87": [0, 0.68333, 0.01389, 0, 1.02778],
    "88": [0, 0.68333, 0, 0, 0.75],
    "89": [0, 0.68333, 0.025, 0, 0.75],
    "90": [0, 0.68333, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.27778],
    "92": [0.25, 0.75, 0, 0, 0.5],
    "93": [0.25, 0.75, 0, 0, 0.27778],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.31, 0.12056, 0.02778, 0, 0.5],
    "97": [0, 0.43056, 0, 0, 0.5],
    "98": [0, 0.69444, 0, 0, 0.55556],
    "99": [0, 0.43056, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.55556],
    "101": [0, 0.43056, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.07778, 0, 0.30556],
    "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.55556],
    "105": [0, 0.66786, 0, 0, 0.27778],
    "106": [0.19444, 0.66786, 0, 0, 0.30556],
    "107": [0, 0.69444, 0, 0, 0.52778],
    "108": [0, 0.69444, 0, 0, 0.27778],
    "109": [0, 0.43056, 0, 0, 0.83334],
    "110": [0, 0.43056, 0, 0, 0.55556],
    "111": [0, 0.43056, 0, 0, 0.5],
    "112": [0.19444, 0.43056, 0, 0, 0.55556],
    "113": [0.19444, 0.43056, 0, 0, 0.52778],
    "114": [0, 0.43056, 0, 0, 0.39167],
    "115": [0, 0.43056, 0, 0, 0.39445],
    "116": [0, 0.61508, 0, 0, 0.38889],
    "117": [0, 0.43056, 0, 0, 0.55556],
    "118": [0, 0.43056, 0.01389, 0, 0.52778],
    "119": [0, 0.43056, 0.01389, 0, 0.72222],
    "120": [0, 0.43056, 0, 0, 0.52778],
    "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
    "122": [0, 0.43056, 0, 0, 0.44445],
    "123": [0.25, 0.75, 0, 0, 0.5],
    "124": [0.25, 0.75, 0, 0, 0.27778],
    "125": [0.25, 0.75, 0, 0, 0.5],
    "126": [0.35, 0.31786, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "167": [0.19444, 0.69444, 0, 0, 0.44445],
    "168": [0, 0.66786, 0, 0, 0.5],
    "172": [0, 0.43056, 0, 0, 0.66667],
    "176": [0, 0.69444, 0, 0, 0.75],
    "177": [0.08333, 0.58333, 0, 0, 0.77778],
    "182": [0.19444, 0.69444, 0, 0, 0.61111],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "198": [0, 0.68333, 0, 0, 0.90278],
    "215": [0.08333, 0.58333, 0, 0, 0.77778],
    "216": [0.04861, 0.73194, 0, 0, 0.77778],
    "223": [0, 0.69444, 0, 0, 0.5],
    "230": [0, 0.43056, 0, 0, 0.72222],
    "247": [0.08333, 0.58333, 0, 0, 0.77778],
    "248": [0.09722, 0.52778, 0, 0, 0.5],
    "305": [0, 0.43056, 0, 0, 0.27778],
    "338": [0, 0.68333, 0, 0, 1.01389],
    "339": [0, 0.43056, 0, 0, 0.77778],
    "567": [0.19444, 0.43056, 0, 0, 0.30556],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.62847, 0, 0, 0.5],
    "713": [0, 0.56778, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.66786, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.75],
    "732": [0, 0.66786, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.68333, 0, 0, 0.625],
    "916": [0, 0.68333, 0, 0, 0.83334],
    "920": [0, 0.68333, 0, 0, 0.77778],
    "923": [0, 0.68333, 0, 0, 0.69445],
    "926": [0, 0.68333, 0, 0, 0.66667],
    "928": [0, 0.68333, 0, 0, 0.75],
    "931": [0, 0.68333, 0, 0, 0.72222],
    "933": [0, 0.68333, 0, 0, 0.77778],
    "934": [0, 0.68333, 0, 0, 0.72222],
    "936": [0, 0.68333, 0, 0, 0.77778],
    "937": [0, 0.68333, 0, 0, 0.72222],
    "8211": [0, 0.43056, 0.02778, 0, 0.5],
    "8212": [0, 0.43056, 0.02778, 0, 1.0],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5],
    "8224": [0.19444, 0.69444, 0, 0, 0.44445],
    "8225": [0.19444, 0.69444, 0, 0, 0.44445],
    "8230": [0, 0.12, 0, 0, 1.172],
    "8242": [0, 0.55556, 0, 0, 0.275],
    "8407": [0, 0.71444, 0.15382, 0, 0.5],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8465": [0, 0.69444, 0, 0, 0.72222],
    "8467": [0, 0.69444, 0, 0.11111, 0.41667],
    "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
    "8476": [0, 0.69444, 0, 0, 0.72222],
    "8501": [0, 0.69444, 0, 0, 0.61111],
    "8592": [-0.13313, 0.36687, 0, 0, 1.0],
    "8593": [0.19444, 0.69444, 0, 0, 0.5],
    "8594": [-0.13313, 0.36687, 0, 0, 1.0],
    "8595": [0.19444, 0.69444, 0, 0, 0.5],
    "8596": [-0.13313, 0.36687, 0, 0, 1.0],
    "8597": [0.25, 0.75, 0, 0, 0.5],
    "8598": [0.19444, 0.69444, 0, 0, 1.0],
    "8599": [0.19444, 0.69444, 0, 0, 1.0],
    "8600": [0.19444, 0.69444, 0, 0, 1.0],
    "8601": [0.19444, 0.69444, 0, 0, 1.0],
    "8614": [0.011, 0.511, 0, 0, 1.0],
    "8617": [0.011, 0.511, 0, 0, 1.126],
    "8618": [0.011, 0.511, 0, 0, 1.126],
    "8636": [-0.13313, 0.36687, 0, 0, 1.0],
    "8637": [-0.13313, 0.36687, 0, 0, 1.0],
    "8640": [-0.13313, 0.36687, 0, 0, 1.0],
    "8641": [-0.13313, 0.36687, 0, 0, 1.0],
    "8652": [0.011, 0.671, 0, 0, 1.0],
    "8656": [-0.13313, 0.36687, 0, 0, 1.0],
    "8657": [0.19444, 0.69444, 0, 0, 0.61111],
    "8658": [-0.13313, 0.36687, 0, 0, 1.0],
    "8659": [0.19444, 0.69444, 0, 0, 0.61111],
    "8660": [-0.13313, 0.36687, 0, 0, 1.0],
    "8661": [0.25, 0.75, 0, 0, 0.61111],
    "8704": [0, 0.69444, 0, 0, 0.55556],
    "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
    "8707": [0, 0.69444, 0, 0, 0.55556],
    "8709": [0.05556, 0.75, 0, 0, 0.5],
    "8711": [0, 0.68333, 0, 0, 0.83334],
    "8712": [0.0391, 0.5391, 0, 0, 0.66667],
    "8715": [0.0391, 0.5391, 0, 0, 0.66667],
    "8722": [0.08333, 0.58333, 0, 0, 0.77778],
    "8723": [0.08333, 0.58333, 0, 0, 0.77778],
    "8725": [0.25, 0.75, 0, 0, 0.5],
    "8726": [0.25, 0.75, 0, 0, 0.5],
    "8727": [-0.03472, 0.46528, 0, 0, 0.5],
    "8728": [-0.05555, 0.44445, 0, 0, 0.5],
    "8729": [-0.05555, 0.44445, 0, 0, 0.5],
    "8730": [0.2, 0.8, 0, 0, 0.83334],
    "8733": [0, 0.43056, 0, 0, 0.77778],
    "8734": [0, 0.43056, 0, 0, 1.0],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.27778],
    "8741": [0.25, 0.75, 0, 0, 0.5],
    "8743": [0, 0.55556, 0, 0, 0.66667],
    "8744": [0, 0.55556, 0, 0, 0.66667],
    "8745": [0, 0.55556, 0, 0, 0.66667],
    "8746": [0, 0.55556, 0, 0, 0.66667],
    "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8768": [0.19444, 0.69444, 0, 0, 0.27778],
    "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8773": [-0.022, 0.589, 0, 0, 1.0],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8784": [-0.133, 0.67, 0, 0, 0.778],
    "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8804": [0.13597, 0.63597, 0, 0, 0.77778],
    "8805": [0.13597, 0.63597, 0, 0, 0.77778],
    "8810": [0.0391, 0.5391, 0, 0, 1.0],
    "8811": [0.0391, 0.5391, 0, 0, 1.0],
    "8826": [0.0391, 0.5391, 0, 0, 0.77778],
    "8827": [0.0391, 0.5391, 0, 0, 0.77778],
    "8834": [0.0391, 0.5391, 0, 0, 0.77778],
    "8835": [0.0391, 0.5391, 0, 0, 0.77778],
    "8838": [0.13597, 0.63597, 0, 0, 0.77778],
    "8839": [0.13597, 0.63597, 0, 0, 0.77778],
    "8846": [0, 0.55556, 0, 0, 0.66667],
    "8849": [0.13597, 0.63597, 0, 0, 0.77778],
    "8850": [0.13597, 0.63597, 0, 0, 0.77778],
    "8851": [0, 0.55556, 0, 0, 0.66667],
    "8852": [0, 0.55556, 0, 0, 0.66667],
    "8853": [0.08333, 0.58333, 0, 0, 0.77778],
    "8854": [0.08333, 0.58333, 0, 0, 0.77778],
    "8855": [0.08333, 0.58333, 0, 0, 0.77778],
    "8856": [0.08333, 0.58333, 0, 0, 0.77778],
    "8857": [0.08333, 0.58333, 0, 0, 0.77778],
    "8866": [0, 0.69444, 0, 0, 0.61111],
    "8867": [0, 0.69444, 0, 0, 0.61111],
    "8868": [0, 0.69444, 0, 0, 0.77778],
    "8869": [0, 0.69444, 0, 0, 0.77778],
    "8872": [0.249, 0.75, 0, 0, 0.867],
    "8900": [-0.05555, 0.44445, 0, 0, 0.5],
    "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
    "8902": [-0.03472, 0.46528, 0, 0, 0.5],
    "8904": [0.005, 0.505, 0, 0, 0.9],
    "8942": [0.03, 0.9, 0, 0, 0.278],
    "8943": [-0.19, 0.31, 0, 0, 1.172],
    "8945": [-0.1, 0.82, 0, 0, 1.282],
    "8968": [0.25, 0.75, 0, 0, 0.44445],
    "8969": [0.25, 0.75, 0, 0, 0.44445],
    "8970": [0.25, 0.75, 0, 0, 0.44445],
    "8971": [0.25, 0.75, 0, 0, 0.44445],
    "8994": [-0.14236, 0.35764, 0, 0, 1.0],
    "8995": [-0.14236, 0.35764, 0, 0, 1.0],
    "9136": [0.244, 0.744, 0, 0, 0.412],
    "9137": [0.244, 0.744, 0, 0, 0.412],
    "9651": [0.19444, 0.69444, 0, 0, 0.88889],
    "9657": [-0.03472, 0.46528, 0, 0, 0.5],
    "9661": [0.19444, 0.69444, 0, 0, 0.88889],
    "9667": [-0.03472, 0.46528, 0, 0, 0.5],
    "9711": [0.19444, 0.69444, 0, 0, 1.0],
    "9824": [0.12963, 0.69444, 0, 0, 0.77778],
    "9825": [0.12963, 0.69444, 0, 0, 0.77778],
    "9826": [0.12963, 0.69444, 0, 0, 0.77778],
    "9827": [0.12963, 0.69444, 0, 0, 0.77778],
    "9837": [0, 0.75, 0, 0, 0.38889],
    "9838": [0.19444, 0.69444, 0, 0, 0.38889],
    "9839": [0.19444, 0.69444, 0, 0, 0.38889],
    "10216": [0.25, 0.75, 0, 0, 0.38889],
    "10217": [0.25, 0.75, 0, 0, 0.38889],
    "10222": [0.244, 0.744, 0, 0, 0.412],
    "10223": [0.244, 0.744, 0, 0, 0.412],
    "10229": [0.011, 0.511, 0, 0, 1.609],
    "10230": [0.011, 0.511, 0, 0, 1.638],
    "10231": [0.011, 0.511, 0, 0, 1.859],
    "10232": [0.024, 0.525, 0, 0, 1.609],
    "10233": [0.024, 0.525, 0, 0, 1.638],
    "10234": [0.024, 0.525, 0, 0, 1.858],
    "10236": [0.011, 0.511, 0, 0, 1.638],
    "10815": [0, 0.68333, 0, 0, 0.75],
    "10927": [0.13597, 0.63597, 0, 0, 0.77778],
    "10928": [0.13597, 0.63597, 0, 0, 0.77778],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0.04835, 0, 0.8664],
    "67": [0, 0.68611, 0.06979, 0, 0.81694],
    "68": [0, 0.68611, 0.03194, 0, 0.93812],
    "69": [0, 0.68611, 0.05451, 0, 0.81007],
    "70": [0, 0.68611, 0.15972, 0, 0.68889],
    "71": [0, 0.68611, 0, 0, 0.88673],
    "72": [0, 0.68611, 0.08229, 0, 0.98229],
    "73": [0, 0.68611, 0.07778, 0, 0.51111],
    "74": [0, 0.68611, 0.10069, 0, 0.63125],
    "75": [0, 0.68611, 0.06979, 0, 0.97118],
    "76": [0, 0.68611, 0, 0, 0.75555],
    "77": [0, 0.68611, 0.11424, 0, 1.14201],
    "78": [0, 0.68611, 0.11424, 0, 0.95034],
    "79": [0, 0.68611, 0.03194, 0, 0.83666],
    "80": [0, 0.68611, 0.15972, 0, 0.72309],
    "81": [0.19444, 0.68611, 0, 0, 0.86861],
    "82": [0, 0.68611, 0.00421, 0, 0.87235],
    "83": [0, 0.68611, 0.05382, 0, 0.69271],
    "84": [0, 0.68611, 0.15972, 0, 0.63663],
    "85": [0, 0.68611, 0.11424, 0, 0.80027],
    "86": [0, 0.68611, 0.25555, 0, 0.67778],
    "87": [0, 0.68611, 0.15972, 0, 1.09305],
    "88": [0, 0.68611, 0.07778, 0, 0.94722],
    "89": [0, 0.68611, 0.25555, 0, 0.67458],
    "90": [0, 0.68611, 0.06979, 0, 0.77257],
    "97": [0, 0.44444, 0, 0, 0.63287],
    "98": [0, 0.69444, 0, 0, 0.52083],
    "99": [0, 0.44444, 0, 0, 0.51342],
    "100": [0, 0.69444, 0, 0, 0.60972],
    "101": [0, 0.44444, 0, 0, 0.55361],
    "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
    "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
    "104": [0, 0.69444, 0, 0, 0.66759],
    "105": [0, 0.69326, 0, 0, 0.4048],
    "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
    "107": [0, 0.69444, 0.01852, 0, 0.6037],
    "108": [0, 0.69444, 0.0088, 0, 0.34815],
    "109": [0, 0.44444, 0, 0, 1.0324],
    "110": [0, 0.44444, 0, 0, 0.71296],
    "111": [0, 0.44444, 0, 0, 0.58472],
    "112": [0.19444, 0.44444, 0, 0, 0.60092],
    "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
    "114": [0, 0.44444, 0.03194, 0, 0.5287],
    "115": [0, 0.44444, 0, 0, 0.53125],
    "116": [0, 0.63492, 0, 0, 0.41528],
    "117": [0, 0.44444, 0, 0, 0.68102],
    "118": [0, 0.44444, 0.03704, 0, 0.56666],
    "119": [0, 0.44444, 0.02778, 0, 0.83148],
    "120": [0, 0.44444, 0, 0, 0.65903],
    "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
    "122": [0, 0.44444, 0.04213, 0, 0.55509],
    "915": [0, 0.68611, 0.15972, 0, 0.65694],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0.03194, 0, 0.86722],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0.07458, 0, 0.84125],
    "928": [0, 0.68611, 0.08229, 0, 0.98229],
    "931": [0, 0.68611, 0.05451, 0, 0.88507],
    "933": [0, 0.68611, 0.15972, 0, 0.67083],
    "934": [0, 0.68611, 0, 0, 0.76666],
    "936": [0, 0.68611, 0.11653, 0, 0.71402],
    "937": [0, 0.68611, 0.04835, 0, 0.8789],
    "945": [0, 0.44444, 0, 0, 0.76064],
    "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
    "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
    "948": [0, 0.69444, 0.03819, 0, 0.52222],
    "949": [0, 0.44444, 0, 0, 0.52882],
    "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
    "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
    "952": [0, 0.69444, 0.03194, 0, 0.5618],
    "953": [0, 0.44444, 0, 0, 0.41204],
    "954": [0, 0.44444, 0, 0, 0.66759],
    "955": [0, 0.69444, 0, 0, 0.67083],
    "956": [0.19444, 0.44444, 0, 0, 0.70787],
    "957": [0, 0.44444, 0.06898, 0, 0.57685],
    "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
    "959": [0, 0.44444, 0, 0, 0.58472],
    "960": [0, 0.44444, 0.03704, 0, 0.68241],
    "961": [0.19444, 0.44444, 0, 0, 0.6118],
    "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
    "963": [0, 0.44444, 0.03704, 0, 0.68588],
    "964": [0, 0.44444, 0.13472, 0, 0.52083],
    "965": [0, 0.44444, 0.03704, 0, 0.63055],
    "966": [0.19444, 0.44444, 0, 0, 0.74722],
    "967": [0.19444, 0.44444, 0, 0, 0.71805],
    "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
    "969": [0, 0.44444, 0.03704, 0, 0.71782],
    "977": [0, 0.69444, 0, 0, 0.69155],
    "981": [0.19444, 0.69444, 0, 0, 0.7125],
    "982": [0, 0.44444, 0.03194, 0, 0.975],
    "1009": [0.19444, 0.44444, 0, 0, 0.6118],
    "1013": [0, 0.44444, 0, 0, 0.48333]
  },
  "Math-Italic": {
    "65": [0, 0.68333, 0, 0.13889, 0.75],
    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
    "71": [0, 0.68333, 0, 0.08334, 0.78625],
    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
    "76": [0, 0.68333, 0, 0.02778, 0.68056],
    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
    "82": [0, 0.68333, 0.00773, 0.08334, 0.75929],
    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
    "86": [0, 0.68333, 0.22222, 0, 0.58333],
    "87": [0, 0.68333, 0.13889, 0, 0.94445],
    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
    "89": [0, 0.68333, 0.22222, 0, 0.58056],
    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
    "97": [0, 0.43056, 0, 0, 0.52859],
    "98": [0, 0.69444, 0, 0, 0.42917],
    "99": [0, 0.43056, 0, 0.05556, 0.43276],
    "100": [0, 0.69444, 0, 0.16667, 0.52049],
    "101": [0, 0.43056, 0, 0.05556, 0.46563],
    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    "104": [0, 0.69444, 0, 0, 0.57616],
    "105": [0, 0.65952, 0, 0, 0.34451],
    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
    "107": [0, 0.69444, 0.03148, 0, 0.5206],
    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
    "109": [0, 0.43056, 0, 0, 0.87801],
    "110": [0, 0.43056, 0, 0, 0.60023],
    "111": [0, 0.43056, 0, 0.05556, 0.48472],
    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
    "115": [0, 0.43056, 0, 0.05556, 0.46875],
    "116": [0, 0.61508, 0, 0.08334, 0.36111],
    "117": [0, 0.43056, 0, 0.02778, 0.57246],
    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
    "120": [0, 0.43056, 0, 0.02778, 0.57153],
    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
    "916": [0, 0.68333, 0, 0.16667, 0.83334],
    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "923": [0, 0.68333, 0, 0.16667, 0.69445],
    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
    "934": [0, 0.68333, 0, 0.08334, 0.66667],
    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
    "945": [0, 0.43056, 0.0037, 0.02778, 0.6397],
    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
    "949": [0, 0.43056, 0, 0.08334, 0.46632],
    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
    "953": [0, 0.43056, 0, 0.05556, 0.35394],
    "954": [0, 0.43056, 0, 0, 0.57616],
    "955": [0, 0.69444, 0, 0, 0.58334],
    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    "959": [0, 0.43056, 0, 0.05556, 0.48472],
    "960": [0, 0.43056, 0.03588, 0, 0.57003],
    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    "963": [0, 0.43056, 0.03588, 0, 0.57141],
    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    "969": [0, 0.43056, 0.03588, 0, 0.62245],
    "977": [0, 0.69444, 0, 0.08334, 0.59144],
    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
    "982": [0, 0.43056, 0.02778, 0, 0.82813],
    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "1013": [0, 0.43056, 0, 0.05556, 0.4059]
  },
  "Math-Regular": {
    "65": [0, 0.68333, 0, 0.13889, 0.75],
    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
    "71": [0, 0.68333, 0, 0.08334, 0.78625],
    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
    "76": [0, 0.68333, 0, 0.02778, 0.68056],
    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
    "82": [0, 0.68333, 0.00773, 0.08334, 0.75929],
    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
    "86": [0, 0.68333, 0.22222, 0, 0.58333],
    "87": [0, 0.68333, 0.13889, 0, 0.94445],
    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
    "89": [0, 0.68333, 0.22222, 0, 0.58056],
    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
    "97": [0, 0.43056, 0, 0, 0.52859],
    "98": [0, 0.69444, 0, 0, 0.42917],
    "99": [0, 0.43056, 0, 0.05556, 0.43276],
    "100": [0, 0.69444, 0, 0.16667, 0.52049],
    "101": [0, 0.43056, 0, 0.05556, 0.46563],
    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    "104": [0, 0.69444, 0, 0, 0.57616],
    "105": [0, 0.65952, 0, 0, 0.34451],
    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
    "107": [0, 0.69444, 0.03148, 0, 0.5206],
    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
    "109": [0, 0.43056, 0, 0, 0.87801],
    "110": [0, 0.43056, 0, 0, 0.60023],
    "111": [0, 0.43056, 0, 0.05556, 0.48472],
    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
    "115": [0, 0.43056, 0, 0.05556, 0.46875],
    "116": [0, 0.61508, 0, 0.08334, 0.36111],
    "117": [0, 0.43056, 0, 0.02778, 0.57246],
    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
    "120": [0, 0.43056, 0, 0.02778, 0.57153],
    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
    "916": [0, 0.68333, 0, 0.16667, 0.83334],
    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "923": [0, 0.68333, 0, 0.16667, 0.69445],
    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
    "934": [0, 0.68333, 0, 0.08334, 0.66667],
    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
    "945": [0, 0.43056, 0.0037, 0.02778, 0.6397],
    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
    "949": [0, 0.43056, 0, 0.08334, 0.46632],
    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
    "953": [0, 0.43056, 0, 0.05556, 0.35394],
    "954": [0, 0.43056, 0, 0, 0.57616],
    "955": [0, 0.69444, 0, 0, 0.58334],
    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    "959": [0, 0.43056, 0, 0.05556, 0.48472],
    "960": [0, 0.43056, 0.03588, 0, 0.57003],
    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    "963": [0, 0.43056, 0.03588, 0, 0.57141],
    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    "969": [0, 0.43056, 0.03588, 0, 0.62245],
    "977": [0, 0.69444, 0, 0.08334, 0.59144],
    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
    "982": [0, 0.43056, 0.02778, 0, 0.82813],
    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "1013": [0, 0.43056, 0, 0.05556, 0.4059]
  },
  "SansSerif-Bold": {
    "33": [0, 0.69444, 0, 0, 0.36667],
    "34": [0, 0.69444, 0, 0, 0.55834],
    "35": [0.19444, 0.69444, 0, 0, 0.91667],
    "36": [0.05556, 0.75, 0, 0, 0.55],
    "37": [0.05556, 0.75, 0, 0, 1.02912],
    "38": [0, 0.69444, 0, 0, 0.83056],
    "39": [0, 0.69444, 0, 0, 0.30556],
    "40": [0.25, 0.75, 0, 0, 0.42778],
    "41": [0.25, 0.75, 0, 0, 0.42778],
    "42": [0, 0.75, 0, 0, 0.55],
    "43": [0.11667, 0.61667, 0, 0, 0.85556],
    "44": [0.10556, 0.13056, 0, 0, 0.30556],
    "45": [0, 0.45833, 0, 0, 0.36667],
    "46": [0, 0.13056, 0, 0, 0.30556],
    "47": [0.25, 0.75, 0, 0, 0.55],
    "48": [0, 0.69444, 0, 0, 0.55],
    "49": [0, 0.69444, 0, 0, 0.55],
    "50": [0, 0.69444, 0, 0, 0.55],
    "51": [0, 0.69444, 0, 0, 0.55],
    "52": [0, 0.69444, 0, 0, 0.55],
    "53": [0, 0.69444, 0, 0, 0.55],
    "54": [0, 0.69444, 0, 0, 0.55],
    "55": [0, 0.69444, 0, 0, 0.55],
    "56": [0, 0.69444, 0, 0, 0.55],
    "57": [0, 0.69444, 0, 0, 0.55],
    "58": [0, 0.45833, 0, 0, 0.30556],
    "59": [0.10556, 0.45833, 0, 0, 0.30556],
    "61": [-0.09375, 0.40625, 0, 0, 0.85556],
    "63": [0, 0.69444, 0, 0, 0.51945],
    "64": [0, 0.69444, 0, 0, 0.73334],
    "65": [0, 0.69444, 0, 0, 0.73334],
    "66": [0, 0.69444, 0, 0, 0.73334],
    "67": [0, 0.69444, 0, 0, 0.70278],
    "68": [0, 0.69444, 0, 0, 0.79445],
    "69": [0, 0.69444, 0, 0, 0.64167],
    "70": [0, 0.69444, 0, 0, 0.61111],
    "71": [0, 0.69444, 0, 0, 0.73334],
    "72": [0, 0.69444, 0, 0, 0.79445],
    "73": [0, 0.69444, 0, 0, 0.33056],
    "74": [0, 0.69444, 0, 0, 0.51945],
    "75": [0, 0.69444, 0, 0, 0.76389],
    "76": [0, 0.69444, 0, 0, 0.58056],
    "77": [0, 0.69444, 0, 0, 0.97778],
    "78": [0, 0.69444, 0, 0, 0.79445],
    "79": [0, 0.69444, 0, 0, 0.79445],
    "80": [0, 0.69444, 0, 0, 0.70278],
    "81": [0.10556, 0.69444, 0, 0, 0.79445],
    "82": [0, 0.69444, 0, 0, 0.70278],
    "83": [0, 0.69444, 0, 0, 0.61111],
    "84": [0, 0.69444, 0, 0, 0.73334],
    "85": [0, 0.69444, 0, 0, 0.76389],
    "86": [0, 0.69444, 0.01528, 0, 0.73334],
    "87": [0, 0.69444, 0.01528, 0, 1.03889],
    "88": [0, 0.69444, 0, 0, 0.73334],
    "89": [0, 0.69444, 0.0275, 0, 0.73334],
    "90": [0, 0.69444, 0, 0, 0.67223],
    "91": [0.25, 0.75, 0, 0, 0.34306],
    "93": [0.25, 0.75, 0, 0, 0.34306],
    "94": [0, 0.69444, 0, 0, 0.55],
    "95": [0.35, 0.10833, 0.03056, 0, 0.55],
    "97": [0, 0.45833, 0, 0, 0.525],
    "98": [0, 0.69444, 0, 0, 0.56111],
    "99": [0, 0.45833, 0, 0, 0.48889],
    "100": [0, 0.69444, 0, 0, 0.56111],
    "101": [0, 0.45833, 0, 0, 0.51111],
    "102": [0, 0.69444, 0.07639, 0, 0.33611],
    "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
    "104": [0, 0.69444, 0, 0, 0.56111],
    "105": [0, 0.69444, 0, 0, 0.25556],
    "106": [0.19444, 0.69444, 0, 0, 0.28611],
    "107": [0, 0.69444, 0, 0, 0.53056],
    "108": [0, 0.69444, 0, 0, 0.25556],
    "109": [0, 0.45833, 0, 0, 0.86667],
    "110": [0, 0.45833, 0, 0, 0.56111],
    "111": [0, 0.45833, 0, 0, 0.55],
    "112": [0.19444, 0.45833, 0, 0, 0.56111],
    "113": [0.19444, 0.45833, 0, 0, 0.56111],
    "114": [0, 0.45833, 0.01528, 0, 0.37222],
    "115": [0, 0.45833, 0, 0, 0.42167],
    "116": [0, 0.58929, 0, 0, 0.40417],
    "117": [0, 0.45833, 0, 0, 0.56111],
    "118": [0, 0.45833, 0.01528, 0, 0.5],
    "119": [0, 0.45833, 0.01528, 0, 0.74445],
    "120": [0, 0.45833, 0, 0, 0.5],
    "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
    "122": [0, 0.45833, 0, 0, 0.47639],
    "126": [0.35, 0.34444, 0, 0, 0.55],
    "168": [0, 0.69444, 0, 0, 0.55],
    "176": [0, 0.69444, 0, 0, 0.73334],
    "180": [0, 0.69444, 0, 0, 0.55],
    "184": [0.17014, 0, 0, 0, 0.48889],
    "305": [0, 0.45833, 0, 0, 0.25556],
    "567": [0.19444, 0.45833, 0, 0, 0.28611],
    "710": [0, 0.69444, 0, 0, 0.55],
    "711": [0, 0.63542, 0, 0, 0.55],
    "713": [0, 0.63778, 0, 0, 0.55],
    "728": [0, 0.69444, 0, 0, 0.55],
    "729": [0, 0.69444, 0, 0, 0.30556],
    "730": [0, 0.69444, 0, 0, 0.73334],
    "732": [0, 0.69444, 0, 0, 0.55],
    "733": [0, 0.69444, 0, 0, 0.55],
    "915": [0, 0.69444, 0, 0, 0.58056],
    "916": [0, 0.69444, 0, 0, 0.91667],
    "920": [0, 0.69444, 0, 0, 0.85556],
    "923": [0, 0.69444, 0, 0, 0.67223],
    "926": [0, 0.69444, 0, 0, 0.73334],
    "928": [0, 0.69444, 0, 0, 0.79445],
    "931": [0, 0.69444, 0, 0, 0.79445],
    "933": [0, 0.69444, 0, 0, 0.85556],
    "934": [0, 0.69444, 0, 0, 0.79445],
    "936": [0, 0.69444, 0, 0, 0.85556],
    "937": [0, 0.69444, 0, 0, 0.79445],
    "8211": [0, 0.45833, 0.03056, 0, 0.55],
    "8212": [0, 0.45833, 0.03056, 0, 1.10001],
    "8216": [0, 0.69444, 0, 0, 0.30556],
    "8217": [0, 0.69444, 0, 0, 0.30556],
    "8220": [0, 0.69444, 0, 0, 0.55834],
    "8221": [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    "33": [0, 0.69444, 0.05733, 0, 0.31945],
    "34": [0, 0.69444, 0.00316, 0, 0.5],
    "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
    "36": [0.05556, 0.75, 0.11156, 0, 0.5],
    "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
    "38": [0, 0.69444, 0.03058, 0, 0.75834],
    "39": [0, 0.69444, 0.07816, 0, 0.27778],
    "40": [0.25, 0.75, 0.13164, 0, 0.38889],
    "41": [0.25, 0.75, 0.02536, 0, 0.38889],
    "42": [0, 0.75, 0.11775, 0, 0.5],
    "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0.01946, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0.13164, 0, 0.5],
    "48": [0, 0.65556, 0.11156, 0, 0.5],
    "49": [0, 0.65556, 0.11156, 0, 0.5],
    "50": [0, 0.65556, 0.11156, 0, 0.5],
    "51": [0, 0.65556, 0.11156, 0, 0.5],
    "52": [0, 0.65556, 0.11156, 0, 0.5],
    "53": [0, 0.65556, 0.11156, 0, 0.5],
    "54": [0, 0.65556, 0.11156, 0, 0.5],
    "55": [0, 0.65556, 0.11156, 0, 0.5],
    "56": [0, 0.65556, 0.11156, 0, 0.5],
    "57": [0, 0.65556, 0.11156, 0, 0.5],
    "58": [0, 0.44444, 0.02502, 0, 0.27778],
    "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
    "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
    "63": [0, 0.69444, 0.11809, 0, 0.47222],
    "64": [0, 0.69444, 0.07555, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0.08293, 0, 0.66667],
    "67": [0, 0.69444, 0.11983, 0, 0.63889],
    "68": [0, 0.69444, 0.07555, 0, 0.72223],
    "69": [0, 0.69444, 0.11983, 0, 0.59722],
    "70": [0, 0.69444, 0.13372, 0, 0.56945],
    "71": [0, 0.69444, 0.11983, 0, 0.66667],
    "72": [0, 0.69444, 0.08094, 0, 0.70834],
    "73": [0, 0.69444, 0.13372, 0, 0.27778],
    "74": [0, 0.69444, 0.08094, 0, 0.47222],
    "75": [0, 0.69444, 0.11983, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0.08094, 0, 0.875],
    "78": [0, 0.69444, 0.08094, 0, 0.70834],
    "79": [0, 0.69444, 0.07555, 0, 0.73611],
    "80": [0, 0.69444, 0.08293, 0, 0.63889],
    "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
    "82": [0, 0.69444, 0.08293, 0, 0.64584],
    "83": [0, 0.69444, 0.09205, 0, 0.55556],
    "84": [0, 0.69444, 0.13372, 0, 0.68056],
    "85": [0, 0.69444, 0.08094, 0, 0.6875],
    "86": [0, 0.69444, 0.1615, 0, 0.66667],
    "87": [0, 0.69444, 0.1615, 0, 0.94445],
    "88": [0, 0.69444, 0.13372, 0, 0.66667],
    "89": [0, 0.69444, 0.17261, 0, 0.66667],
    "90": [0, 0.69444, 0.11983, 0, 0.61111],
    "91": [0.25, 0.75, 0.15942, 0, 0.28889],
    "93": [0.25, 0.75, 0.08719, 0, 0.28889],
    "94": [0, 0.69444, 0.0799, 0, 0.5],
    "95": [0.35, 0.09444, 0.08616, 0, 0.5],
    "97": [0, 0.44444, 0.00981, 0, 0.48056],
    "98": [0, 0.69444, 0.03057, 0, 0.51667],
    "99": [0, 0.44444, 0.08336, 0, 0.44445],
    "100": [0, 0.69444, 0.09483, 0, 0.51667],
    "101": [0, 0.44444, 0.06778, 0, 0.44445],
    "102": [0, 0.69444, 0.21705, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
    "104": [0, 0.69444, 0.01778, 0, 0.51667],
    "105": [0, 0.67937, 0.09718, 0, 0.23889],
    "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
    "107": [0, 0.69444, 0.08336, 0, 0.48889],
    "108": [0, 0.69444, 0.09483, 0, 0.23889],
    "109": [0, 0.44444, 0.01778, 0, 0.79445],
    "110": [0, 0.44444, 0.01778, 0, 0.51667],
    "111": [0, 0.44444, 0.06613, 0, 0.5],
    "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
    "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
    "114": [0, 0.44444, 0.10836, 0, 0.34167],
    "115": [0, 0.44444, 0.0778, 0, 0.38333],
    "116": [0, 0.57143, 0.07225, 0, 0.36111],
    "117": [0, 0.44444, 0.04169, 0, 0.51667],
    "118": [0, 0.44444, 0.10836, 0, 0.46111],
    "119": [0, 0.44444, 0.10836, 0, 0.68334],
    "120": [0, 0.44444, 0.09169, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
    "122": [0, 0.44444, 0.08752, 0, 0.43472],
    "126": [0.35, 0.32659, 0.08826, 0, 0.5],
    "168": [0, 0.67937, 0.06385, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.73752],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0.04169, 0, 0.23889],
    "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
    "710": [0, 0.69444, 0.0799, 0, 0.5],
    "711": [0, 0.63194, 0.08432, 0, 0.5],
    "713": [0, 0.60889, 0.08776, 0, 0.5],
    "714": [0, 0.69444, 0.09205, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0.09483, 0, 0.5],
    "729": [0, 0.67937, 0.07774, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.73752],
    "732": [0, 0.67659, 0.08826, 0, 0.5],
    "733": [0, 0.69444, 0.09205, 0, 0.5],
    "915": [0, 0.69444, 0.13372, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0.07555, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0.12816, 0, 0.66667],
    "928": [0, 0.69444, 0.08094, 0, 0.70834],
    "931": [0, 0.69444, 0.11983, 0, 0.72222],
    "933": [0, 0.69444, 0.09031, 0, 0.77778],
    "934": [0, 0.69444, 0.04603, 0, 0.72222],
    "936": [0, 0.69444, 0.09031, 0, 0.77778],
    "937": [0, 0.69444, 0.08293, 0, 0.72222],
    "8211": [0, 0.44444, 0.08616, 0, 0.5],
    "8212": [0, 0.44444, 0.08616, 0, 1.0],
    "8216": [0, 0.69444, 0.07816, 0, 0.27778],
    "8217": [0, 0.69444, 0.07816, 0, 0.27778],
    "8220": [0, 0.69444, 0.14205, 0, 0.5],
    "8221": [0, 0.69444, 0.00316, 0, 0.5]
  },
  "SansSerif-Regular": {
    "33": [0, 0.69444, 0, 0, 0.31945],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.75834],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.65556, 0, 0, 0.5],
    "49": [0, 0.65556, 0, 0, 0.5],
    "50": [0, 0.65556, 0, 0, 0.5],
    "51": [0, 0.65556, 0, 0, 0.5],
    "52": [0, 0.65556, 0, 0, 0.5],
    "53": [0, 0.65556, 0, 0, 0.5],
    "54": [0, 0.65556, 0, 0, 0.5],
    "55": [0, 0.65556, 0, 0, 0.5],
    "56": [0, 0.65556, 0, 0, 0.5],
    "57": [0, 0.65556, 0, 0, 0.5],
    "58": [0, 0.44444, 0, 0, 0.27778],
    "59": [0.125, 0.44444, 0, 0, 0.27778],
    "61": [-0.13, 0.37, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0, 0, 0.66667],
    "67": [0, 0.69444, 0, 0, 0.63889],
    "68": [0, 0.69444, 0, 0, 0.72223],
    "69": [0, 0.69444, 0, 0, 0.59722],
    "70": [0, 0.69444, 0, 0, 0.56945],
    "71": [0, 0.69444, 0, 0, 0.66667],
    "72": [0, 0.69444, 0, 0, 0.70834],
    "73": [0, 0.69444, 0, 0, 0.27778],
    "74": [0, 0.69444, 0, 0, 0.47222],
    "75": [0, 0.69444, 0, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0, 0, 0.875],
    "78": [0, 0.69444, 0, 0, 0.70834],
    "79": [0, 0.69444, 0, 0, 0.73611],
    "80": [0, 0.69444, 0, 0, 0.63889],
    "81": [0.125, 0.69444, 0, 0, 0.73611],
    "82": [0, 0.69444, 0, 0, 0.64584],
    "83": [0, 0.69444, 0, 0, 0.55556],
    "84": [0, 0.69444, 0, 0, 0.68056],
    "85": [0, 0.69444, 0, 0, 0.6875],
    "86": [0, 0.69444, 0.01389, 0, 0.66667],
    "87": [0, 0.69444, 0.01389, 0, 0.94445],
    "88": [0, 0.69444, 0, 0, 0.66667],
    "89": [0, 0.69444, 0.025, 0, 0.66667],
    "90": [0, 0.69444, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.28889],
    "93": [0.25, 0.75, 0, 0, 0.28889],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.35, 0.09444, 0.02778, 0, 0.5],
    "97": [0, 0.44444, 0, 0, 0.48056],
    "98": [0, 0.69444, 0, 0, 0.51667],
    "99": [0, 0.44444, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.51667],
    "101": [0, 0.44444, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.06944, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.51667],
    "105": [0, 0.67937, 0, 0, 0.23889],
    "106": [0.19444, 0.67937, 0, 0, 0.26667],
    "107": [0, 0.69444, 0, 0, 0.48889],
    "108": [0, 0.69444, 0, 0, 0.23889],
    "109": [0, 0.44444, 0, 0, 0.79445],
    "110": [0, 0.44444, 0, 0, 0.51667],
    "111": [0, 0.44444, 0, 0, 0.5],
    "112": [0.19444, 0.44444, 0, 0, 0.51667],
    "113": [0.19444, 0.44444, 0, 0, 0.51667],
    "114": [0, 0.44444, 0.01389, 0, 0.34167],
    "115": [0, 0.44444, 0, 0, 0.38333],
    "116": [0, 0.57143, 0, 0, 0.36111],
    "117": [0, 0.44444, 0, 0, 0.51667],
    "118": [0, 0.44444, 0.01389, 0, 0.46111],
    "119": [0, 0.44444, 0.01389, 0, 0.68334],
    "120": [0, 0.44444, 0, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
    "122": [0, 0.44444, 0, 0, 0.43472],
    "126": [0.35, 0.32659, 0, 0, 0.5],
    "168": [0, 0.67937, 0, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.66667],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0, 0, 0.23889],
    "567": [0.19444, 0.44444, 0, 0, 0.26667],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.63194, 0, 0, 0.5],
    "713": [0, 0.60889, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.67937, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.66667],
    "732": [0, 0.67659, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.69444, 0, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0, 0, 0.66667],
    "928": [0, 0.69444, 0, 0, 0.70834],
    "931": [0, 0.69444, 0, 0, 0.72222],
    "933": [0, 0.69444, 0, 0, 0.77778],
    "934": [0, 0.69444, 0, 0, 0.72222],
    "936": [0, 0.69444, 0, 0, 0.77778],
    "937": [0, 0.69444, 0, 0, 0.72222],
    "8211": [0, 0.44444, 0.02778, 0, 0.5],
    "8212": [0, 0.44444, 0.02778, 0, 1.0],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    "65": [0, 0.7, 0.22925, 0, 0.80253],
    "66": [0, 0.7, 0.04087, 0, 0.90757],
    "67": [0, 0.7, 0.1689, 0, 0.66619],
    "68": [0, 0.7, 0.09371, 0, 0.77443],
    "69": [0, 0.7, 0.18583, 0, 0.56162],
    "70": [0, 0.7, 0.13634, 0, 0.89544],
    "71": [0, 0.7, 0.17322, 0, 0.60961],
    "72": [0, 0.7, 0.29694, 0, 0.96919],
    "73": [0, 0.7, 0.19189, 0, 0.80907],
    "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
    "75": [0, 0.7, 0.31259, 0, 0.91364],
    "76": [0, 0.7, 0.19189, 0, 0.87373],
    "77": [0, 0.7, 0.15981, 0, 1.08031],
    "78": [0, 0.7, 0.3525, 0, 0.9015],
    "79": [0, 0.7, 0.08078, 0, 0.73787],
    "80": [0, 0.7, 0.08078, 0, 1.01262],
    "81": [0, 0.7, 0.03305, 0, 0.88282],
    "82": [0, 0.7, 0.06259, 0, 0.85],
    "83": [0, 0.7, 0.19189, 0, 0.86767],
    "84": [0, 0.7, 0.29087, 0, 0.74697],
    "85": [0, 0.7, 0.25815, 0, 0.79996],
    "86": [0, 0.7, 0.27523, 0, 0.62204],
    "87": [0, 0.7, 0.27523, 0, 0.80532],
    "88": [0, 0.7, 0.26006, 0, 0.94445],
    "89": [0, 0.7, 0.2939, 0, 0.70961],
    "90": [0, 0.7, 0.24037, 0, 0.8212]
  },
  "Size1-Regular": {
    "40": [0.35001, 0.85, 0, 0, 0.45834],
    "41": [0.35001, 0.85, 0, 0, 0.45834],
    "47": [0.35001, 0.85, 0, 0, 0.57778],
    "91": [0.35001, 0.85, 0, 0, 0.41667],
    "92": [0.35001, 0.85, 0, 0, 0.57778],
    "93": [0.35001, 0.85, 0, 0, 0.41667],
    "123": [0.35001, 0.85, 0, 0, 0.58334],
    "125": [0.35001, 0.85, 0, 0, 0.58334],
    "710": [0, 0.72222, 0, 0, 0.55556],
    "732": [0, 0.72222, 0, 0, 0.55556],
    "770": [0, 0.72222, 0, 0, 0.55556],
    "771": [0, 0.72222, 0, 0, 0.55556],
    "8214": [-0.00099, 0.601, 0, 0, 0.77778],
    "8593": [1e-05, 0.6, 0, 0, 0.66667],
    "8595": [1e-05, 0.6, 0, 0, 0.66667],
    "8657": [1e-05, 0.6, 0, 0, 0.77778],
    "8659": [1e-05, 0.6, 0, 0, 0.77778],
    "8719": [0.25001, 0.75, 0, 0, 0.94445],
    "8720": [0.25001, 0.75, 0, 0, 0.94445],
    "8721": [0.25001, 0.75, 0, 0, 1.05556],
    "8730": [0.35001, 0.85, 0, 0, 1.0],
    "8739": [-0.00599, 0.606, 0, 0, 0.33333],
    "8741": [-0.00599, 0.606, 0, 0, 0.55556],
    "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8896": [0.25001, 0.75, 0, 0, 0.83334],
    "8897": [0.25001, 0.75, 0, 0, 0.83334],
    "8898": [0.25001, 0.75, 0, 0, 0.83334],
    "8899": [0.25001, 0.75, 0, 0, 0.83334],
    "8968": [0.35001, 0.85, 0, 0, 0.47222],
    "8969": [0.35001, 0.85, 0, 0, 0.47222],
    "8970": [0.35001, 0.85, 0, 0, 0.47222],
    "8971": [0.35001, 0.85, 0, 0, 0.47222],
    "9168": [-0.00099, 0.601, 0, 0, 0.66667],
    "10216": [0.35001, 0.85, 0, 0, 0.47222],
    "10217": [0.35001, 0.85, 0, 0, 0.47222],
    "10752": [0.25001, 0.75, 0, 0, 1.11111],
    "10753": [0.25001, 0.75, 0, 0, 1.11111],
    "10754": [0.25001, 0.75, 0, 0, 1.11111],
    "10756": [0.25001, 0.75, 0, 0, 0.83334],
    "10758": [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    "40": [0.65002, 1.15, 0, 0, 0.59722],
    "41": [0.65002, 1.15, 0, 0, 0.59722],
    "47": [0.65002, 1.15, 0, 0, 0.81111],
    "91": [0.65002, 1.15, 0, 0, 0.47222],
    "92": [0.65002, 1.15, 0, 0, 0.81111],
    "93": [0.65002, 1.15, 0, 0, 0.47222],
    "123": [0.65002, 1.15, 0, 0, 0.66667],
    "125": [0.65002, 1.15, 0, 0, 0.66667],
    "710": [0, 0.75, 0, 0, 1.0],
    "732": [0, 0.75, 0, 0, 1.0],
    "770": [0, 0.75, 0, 0, 1.0],
    "771": [0, 0.75, 0, 0, 1.0],
    "8719": [0.55001, 1.05, 0, 0, 1.27778],
    "8720": [0.55001, 1.05, 0, 0, 1.27778],
    "8721": [0.55001, 1.05, 0, 0, 1.44445],
    "8730": [0.65002, 1.15, 0, 0, 1.0],
    "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8896": [0.55001, 1.05, 0, 0, 1.11111],
    "8897": [0.55001, 1.05, 0, 0, 1.11111],
    "8898": [0.55001, 1.05, 0, 0, 1.11111],
    "8899": [0.55001, 1.05, 0, 0, 1.11111],
    "8968": [0.65002, 1.15, 0, 0, 0.52778],
    "8969": [0.65002, 1.15, 0, 0, 0.52778],
    "8970": [0.65002, 1.15, 0, 0, 0.52778],
    "8971": [0.65002, 1.15, 0, 0, 0.52778],
    "10216": [0.65002, 1.15, 0, 0, 0.61111],
    "10217": [0.65002, 1.15, 0, 0, 0.61111],
    "10752": [0.55001, 1.05, 0, 0, 1.51112],
    "10753": [0.55001, 1.05, 0, 0, 1.51112],
    "10754": [0.55001, 1.05, 0, 0, 1.51112],
    "10756": [0.55001, 1.05, 0, 0, 1.11111],
    "10758": [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    "40": [0.95003, 1.45, 0, 0, 0.73611],
    "41": [0.95003, 1.45, 0, 0, 0.73611],
    "47": [0.95003, 1.45, 0, 0, 1.04445],
    "91": [0.95003, 1.45, 0, 0, 0.52778],
    "92": [0.95003, 1.45, 0, 0, 1.04445],
    "93": [0.95003, 1.45, 0, 0, 0.52778],
    "123": [0.95003, 1.45, 0, 0, 0.75],
    "125": [0.95003, 1.45, 0, 0, 0.75],
    "710": [0, 0.75, 0, 0, 1.44445],
    "732": [0, 0.75, 0, 0, 1.44445],
    "770": [0, 0.75, 0, 0, 1.44445],
    "771": [0, 0.75, 0, 0, 1.44445],
    "8730": [0.95003, 1.45, 0, 0, 1.0],
    "8968": [0.95003, 1.45, 0, 0, 0.58334],
    "8969": [0.95003, 1.45, 0, 0, 0.58334],
    "8970": [0.95003, 1.45, 0, 0, 0.58334],
    "8971": [0.95003, 1.45, 0, 0, 0.58334],
    "10216": [0.95003, 1.45, 0, 0, 0.75],
    "10217": [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    "40": [1.25003, 1.75, 0, 0, 0.79167],
    "41": [1.25003, 1.75, 0, 0, 0.79167],
    "47": [1.25003, 1.75, 0, 0, 1.27778],
    "91": [1.25003, 1.75, 0, 0, 0.58334],
    "92": [1.25003, 1.75, 0, 0, 1.27778],
    "93": [1.25003, 1.75, 0, 0, 0.58334],
    "123": [1.25003, 1.75, 0, 0, 0.80556],
    "125": [1.25003, 1.75, 0, 0, 0.80556],
    "710": [0, 0.825, 0, 0, 1.8889],
    "732": [0, 0.825, 0, 0, 1.8889],
    "770": [0, 0.825, 0, 0, 1.8889],
    "771": [0, 0.825, 0, 0, 1.8889],
    "8730": [1.25003, 1.75, 0, 0, 1.0],
    "8968": [1.25003, 1.75, 0, 0, 0.63889],
    "8969": [1.25003, 1.75, 0, 0, 0.63889],
    "8970": [1.25003, 1.75, 0, 0, 0.63889],
    "8971": [1.25003, 1.75, 0, 0, 0.63889],
    "9115": [0.64502, 1.155, 0, 0, 0.875],
    "9116": [1e-05, 0.6, 0, 0, 0.875],
    "9117": [0.64502, 1.155, 0, 0, 0.875],
    "9118": [0.64502, 1.155, 0, 0, 0.875],
    "9119": [1e-05, 0.6, 0, 0, 0.875],
    "9120": [0.64502, 1.155, 0, 0, 0.875],
    "9121": [0.64502, 1.155, 0, 0, 0.66667],
    "9122": [-0.00099, 0.601, 0, 0, 0.66667],
    "9123": [0.64502, 1.155, 0, 0, 0.66667],
    "9124": [0.64502, 1.155, 0, 0, 0.66667],
    "9125": [-0.00099, 0.601, 0, 0, 0.66667],
    "9126": [0.64502, 1.155, 0, 0, 0.66667],
    "9127": [1e-05, 0.9, 0, 0, 0.88889],
    "9128": [0.65002, 1.15, 0, 0, 0.88889],
    "9129": [0.90001, 0, 0, 0, 0.88889],
    "9130": [0, 0.3, 0, 0, 0.88889],
    "9131": [1e-05, 0.9, 0, 0, 0.88889],
    "9132": [0.65002, 1.15, 0, 0, 0.88889],
    "9133": [0.90001, 0, 0, 0, 0.88889],
    "9143": [0.88502, 0.915, 0, 0, 1.05556],
    "10216": [1.25003, 1.75, 0, 0, 0.80556],
    "10217": [1.25003, 1.75, 0, 0, 0.80556],
    "57344": [-0.00499, 0.605, 0, 0, 1.05556],
    "57345": [-0.00499, 0.605, 0, 0, 1.05556],
    "57680": [0, 0.12, 0, 0, 0.45],
    "57681": [0, 0.12, 0, 0, 0.45],
    "57682": [0, 0.12, 0, 0, 0.45],
    "57683": [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    "32": [0, 0, 0, 0, 0.525],
    "33": [0, 0.61111, 0, 0, 0.525],
    "34": [0, 0.61111, 0, 0, 0.525],
    "35": [0, 0.61111, 0, 0, 0.525],
    "36": [0.08333, 0.69444, 0, 0, 0.525],
    "37": [0.08333, 0.69444, 0, 0, 0.525],
    "38": [0, 0.61111, 0, 0, 0.525],
    "39": [0, 0.61111, 0, 0, 0.525],
    "40": [0.08333, 0.69444, 0, 0, 0.525],
    "41": [0.08333, 0.69444, 0, 0, 0.525],
    "42": [0, 0.52083, 0, 0, 0.525],
    "43": [-0.08056, 0.53055, 0, 0, 0.525],
    "44": [0.13889, 0.125, 0, 0, 0.525],
    "45": [-0.08056, 0.53055, 0, 0, 0.525],
    "46": [0, 0.125, 0, 0, 0.525],
    "47": [0.08333, 0.69444, 0, 0, 0.525],
    "48": [0, 0.61111, 0, 0, 0.525],
    "49": [0, 0.61111, 0, 0, 0.525],
    "50": [0, 0.61111, 0, 0, 0.525],
    "51": [0, 0.61111, 0, 0, 0.525],
    "52": [0, 0.61111, 0, 0, 0.525],
    "53": [0, 0.61111, 0, 0, 0.525],
    "54": [0, 0.61111, 0, 0, 0.525],
    "55": [0, 0.61111, 0, 0, 0.525],
    "56": [0, 0.61111, 0, 0, 0.525],
    "57": [0, 0.61111, 0, 0, 0.525],
    "58": [0, 0.43056, 0, 0, 0.525],
    "59": [0.13889, 0.43056, 0, 0, 0.525],
    "60": [-0.05556, 0.55556, 0, 0, 0.525],
    "61": [-0.19549, 0.41562, 0, 0, 0.525],
    "62": [-0.05556, 0.55556, 0, 0, 0.525],
    "63": [0, 0.61111, 0, 0, 0.525],
    "64": [0, 0.61111, 0, 0, 0.525],
    "65": [0, 0.61111, 0, 0, 0.525],
    "66": [0, 0.61111, 0, 0, 0.525],
    "67": [0, 0.61111, 0, 0, 0.525],
    "68": [0, 0.61111, 0, 0, 0.525],
    "69": [0, 0.61111, 0, 0, 0.525],
    "70": [0, 0.61111, 0, 0, 0.525],
    "71": [0, 0.61111, 0, 0, 0.525],
    "72": [0, 0.61111, 0, 0, 0.525],
    "73": [0, 0.61111, 0, 0, 0.525],
    "74": [0, 0.61111, 0, 0, 0.525],
    "75": [0, 0.61111, 0, 0, 0.525],
    "76": [0, 0.61111, 0, 0, 0.525],
    "77": [0, 0.61111, 0, 0, 0.525],
    "78": [0, 0.61111, 0, 0, 0.525],
    "79": [0, 0.61111, 0, 0, 0.525],
    "80": [0, 0.61111, 0, 0, 0.525],
    "81": [0.13889, 0.61111, 0, 0, 0.525],
    "82": [0, 0.61111, 0, 0, 0.525],
    "83": [0, 0.61111, 0, 0, 0.525],
    "84": [0, 0.61111, 0, 0, 0.525],
    "85": [0, 0.61111, 0, 0, 0.525],
    "86": [0, 0.61111, 0, 0, 0.525],
    "87": [0, 0.61111, 0, 0, 0.525],
    "88": [0, 0.61111, 0, 0, 0.525],
    "89": [0, 0.61111, 0, 0, 0.525],
    "90": [0, 0.61111, 0, 0, 0.525],
    "91": [0.08333, 0.69444, 0, 0, 0.525],
    "92": [0.08333, 0.69444, 0, 0, 0.525],
    "93": [0.08333, 0.69444, 0, 0, 0.525],
    "94": [0, 0.61111, 0, 0, 0.525],
    "95": [0.09514, 0, 0, 0, 0.525],
    "96": [0, 0.61111, 0, 0, 0.525],
    "97": [0, 0.43056, 0, 0, 0.525],
    "98": [0, 0.61111, 0, 0, 0.525],
    "99": [0, 0.43056, 0, 0, 0.525],
    "100": [0, 0.61111, 0, 0, 0.525],
    "101": [0, 0.43056, 0, 0, 0.525],
    "102": [0, 0.61111, 0, 0, 0.525],
    "103": [0.22222, 0.43056, 0, 0, 0.525],
    "104": [0, 0.61111, 0, 0, 0.525],
    "105": [0, 0.61111, 0, 0, 0.525],
    "106": [0.22222, 0.61111, 0, 0, 0.525],
    "107": [0, 0.61111, 0, 0, 0.525],
    "108": [0, 0.61111, 0, 0, 0.525],
    "109": [0, 0.43056, 0, 0, 0.525],
    "110": [0, 0.43056, 0, 0, 0.525],
    "111": [0, 0.43056, 0, 0, 0.525],
    "112": [0.22222, 0.43056, 0, 0, 0.525],
    "113": [0.22222, 0.43056, 0, 0, 0.525],
    "114": [0, 0.43056, 0, 0, 0.525],
    "115": [0, 0.43056, 0, 0, 0.525],
    "116": [0, 0.55358, 0, 0, 0.525],
    "117": [0, 0.43056, 0, 0, 0.525],
    "118": [0, 0.43056, 0, 0, 0.525],
    "119": [0, 0.43056, 0, 0, 0.525],
    "120": [0, 0.43056, 0, 0, 0.525],
    "121": [0.22222, 0.43056, 0, 0, 0.525],
    "122": [0, 0.43056, 0, 0, 0.525],
    "123": [0.08333, 0.69444, 0, 0, 0.525],
    "124": [0.08333, 0.69444, 0, 0, 0.525],
    "125": [0.08333, 0.69444, 0, 0, 0.525],
    "126": [0, 0.61111, 0, 0, 0.525],
    "127": [0, 0.61111, 0, 0, 0.525],
    "160": [0, 0, 0, 0, 0.525],
    "176": [0, 0.61111, 0, 0, 0.525],
    "184": [0.19445, 0, 0, 0, 0.525],
    "305": [0, 0.43056, 0, 0, 0.525],
    "567": [0.22222, 0.43056, 0, 0, 0.525],
    "711": [0, 0.56597, 0, 0, 0.525],
    "713": [0, 0.56555, 0, 0, 0.525],
    "714": [0, 0.61111, 0, 0, 0.525],
    "715": [0, 0.61111, 0, 0, 0.525],
    "728": [0, 0.61111, 0, 0, 0.525],
    "730": [0, 0.61111, 0, 0, 0.525],
    "770": [0, 0.61111, 0, 0, 0.525],
    "771": [0, 0.61111, 0, 0, 0.525],
    "776": [0, 0.61111, 0, 0, 0.525],
    "915": [0, 0.61111, 0, 0, 0.525],
    "916": [0, 0.61111, 0, 0, 0.525],
    "920": [0, 0.61111, 0, 0, 0.525],
    "923": [0, 0.61111, 0, 0, 0.525],
    "926": [0, 0.61111, 0, 0, 0.525],
    "928": [0, 0.61111, 0, 0, 0.525],
    "931": [0, 0.61111, 0, 0, 0.525],
    "933": [0, 0.61111, 0, 0, 0.525],
    "934": [0, 0.61111, 0, 0, 0.525],
    "936": [0, 0.61111, 0, 0, 0.525],
    "937": [0, 0.61111, 0, 0, 0.525],
    "8216": [0, 0.61111, 0, 0, 0.525],
    "8217": [0, 0.61111, 0, 0, 0.525],
    "8242": [0, 0.61111, 0, 0, 0.525],
    "9251": [0.11111, 0.21944, 0, 0, 0.525]
  }
});
// CONCATENATED MODULE: ./src/fontMetrics.js


/**
 * This file contains metrics regarding fonts and individual symbols. The sigma
 * and xi variables, as well as the metricMap map contain data extracted from
 * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
 * `metrics` variable and the getCharacterMetrics function.
 */
// In TeX, there are actually three sets of dimensions, one for each of
// textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:
// 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are
// provided in the the arrays below, in that order.
//
// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.
// This was determined by running the following script:
//
//     latex -interaction=nonstopmode \
//     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
//     '$a$ \expandafter\show\the\textfont2' \
//     '\expandafter\show\the\scriptfont2' \
//     '\expandafter\show\the\scriptscriptfont2' \
//     '\stop'
//
// The metrics themselves were retreived using the following commands:
//
//     tftopl cmsy10
//     tftopl cmsy7
//     tftopl cmsy5
//
// The output of each of these commands is quite lengthy.  The only part we
// care about is the FONTDIMEN section. Each value is measured in EMs.
var sigmasAndXis = {
  slant: [0.250, 0.250, 0.250],
  // sigma1
  space: [0.000, 0.000, 0.000],
  // sigma2
  stretch: [0.000, 0.000, 0.000],
  // sigma3
  shrink: [0.000, 0.000, 0.000],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1.000, 1.171, 1.472],
  // sigma6
  extraSpace: [0.000, 0.000, 0.000],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.150, 0.143, 0.200],
  // sigma16
  sub2: [0.247, 0.286, 0.400],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.050, 0.071, 0.100],
  // sigma19
  delim1: [2.390, 1.700, 1.980],
  // sigma20
  delim2: [1.010, 1.157, 1.420],
  // sigma21
  axisHeight: [0.250, 0.250, 0.250],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.less; if you change it make sure the
  // values match.
  ptPerEm: [10.0, 10.0, 10.0],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2]
}; // This map contains a mapping from font name and character code to character
// metrics, including height, depth, italic correction, and skew (kern from the
// character to the corresponding \skewchar)
// This map is generated via `make metrics`. It should not be changed manually.

 // These are very rough approximations.  We default to Times New Roman which
// should have Latin-1 and Cyrillic characters, but may not depending on the
// operating system.  The metrics do not account for extra height from the
// accents.  In the case of Cyrillic characters which have both ascenders and
// descenders we prefer approximations with ascenders, primarily to prevent
// the fraction bar or root line from intersecting the glyph.
// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.

var extraCharacterMap = {
  // Latin-1
  '': 'A',
  '': 'C',
  '': 'D',
  '': 'o',
  '': 'a',
  '': 'c',
  '': 'd',
  '': 'o',
  // Cyrillic
  '': 'A',
  '': 'B',
  '': 'B',
  '': 'F',
  '': 'A',
  '': 'E',
  '': 'K',
  '': '3',
  '': 'N',
  '': 'N',
  '': 'K',
  '': 'N',
  '': 'M',
  '': 'H',
  '': 'O',
  '': 'N',
  '': 'P',
  '': 'C',
  '': 'T',
  '': 'y',
  '': 'O',
  '': 'X',
  '': 'U',
  '': 'h',
  '': 'W',
  '': 'W',
  '': 'B',
  '': 'X',
  '': 'B',
  '': '3',
  '': 'X',
  '': 'R',
  '': 'a',
  '': 'b',
  '': 'a',
  '': 'r',
  '': 'y',
  '': 'e',
  '': 'm',
  '': 'e',
  '': 'n',
  '': 'n',
  '': 'n',
  '': 'n',
  '': 'm',
  '': 'n',
  '': 'o',
  '': 'n',
  '': 'p',
  '': 'c',
  '': 'o',
  '': 'y',
  '': 'b',
  '': 'x',
  '': 'n',
  '': 'n',
  '': 'w',
  '': 'w',
  '': 'a',
  '': 'm',
  '': 'a',
  '': 'e',
  '': 'm',
  '': 'r'
};

/**
 * This function adds new font metrics to default metricMap
 * It can also override existing metrics
 */
function setFontMetrics(fontName, metrics) {
  fontMetricsData[fontName] = metrics;
}
/**
 * This function is a convenience function for looking up information in the
 * metricMap table. It takes a character as a string, and a font.
 *
 * Note: the `width` property may be undefined if fontMetricsData.js wasn't
 * built using `Make extended_metrics`.
 */

function getCharacterMetrics(character, font, mode) {
  if (!fontMetricsData[font]) {
    throw new Error("Font metrics not found for font: " + font + ".");
  }

  var ch = character.charCodeAt(0);
  var metrics = fontMetricsData[font][ch];

  if (!metrics && character[0] in extraCharacterMap) {
    ch = extraCharacterMap[character[0]].charCodeAt(0);
    metrics = fontMetricsData[font][ch];
  }

  if (!metrics && mode === 'text') {
    // We don't typically have font metrics for Asian scripts.
    // But since we support them in text mode, we need to return
    // some sort of metrics.
    // So if the character is in a script we support but we
    // don't have metrics for it, just use the metrics for
    // the Latin capital letter M. This is close enough because
    // we (currently) only care about the height of the glpyh
    // not its width.
    if (supportedCodepoint(ch)) {
      metrics = fontMetricsData[font][77]; // 77 is the charcode for 'M'
    }
  }

  if (metrics) {
    return {
      depth: metrics[0],
      height: metrics[1],
      italic: metrics[2],
      skew: metrics[3],
      width: metrics[4]
    };
  }
}
var fontMetricsBySizeIndex = {};
/**
 * Get the font metrics for a given size.
 */

function getGlobalMetrics(size) {
  var sizeIndex;

  if (size >= 5) {
    sizeIndex = 0;
  } else if (size >= 3) {
    sizeIndex = 1;
  } else {
    sizeIndex = 2;
  }

  if (!fontMetricsBySizeIndex[sizeIndex]) {
    var metrics = fontMetricsBySizeIndex[sizeIndex] = {
      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
    };

    for (var key in sigmasAndXis) {
      if (sigmasAndXis.hasOwnProperty(key)) {
        metrics[key] = sigmasAndXis[key][sizeIndex];
      }
    }
  }

  return fontMetricsBySizeIndex[sizeIndex];
}
// CONCATENATED MODULE: ./src/symbols.js
/**
 * This file holds a list of all no-argument functions and single-character
 * symbols (like 'a' or ';').
 *
 * For each of the symbols, there are three properties they can have:
 * - font (required): the font to be used for this symbol. Either "main" (the
     normal font), or "ams" (the ams fonts).
 * - group (required): the ParseNode group type the symbol should have (i.e.
     "textord", "mathord", etc).
     See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types
 * - replace: the character that this symbol or function should be
 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
 *   character in the main font).
 *
 * The outermost map in the table indicates what mode the symbols should be
 * accepted in (e.g. "math" or "text").
 */
// Some of these have a "-token" suffix since these are also used as `ParseNode`
// types for raw text tokens, and we want to avoid conflicts with higher-level
// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by
// looking up the `symbols` map.
var ATOMS = {
  "bin": 1,
  "close": 1,
  "inner": 1,
  "open": 1,
  "punct": 1,
  "rel": 1
};
var NON_ATOMS = {
  "accent-token": 1,
  "mathord": 1,
  "op-token": 1,
  "spacing": 1,
  "textord": 1
};
var symbols = {
  "math": {},
  "text": {}
};
/* harmony default export */ var src_symbols = (symbols);
/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */

function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
  symbols[mode][name] = {
    font: font,
    group: group,
    replace: replace
  };

  if (acceptUnicodeChar && replace) {
    symbols[mode][replace] = symbols[mode][name];
  }
} // Some abbreviations for commonly used strings.
// This helps minify the code, and also spotting typos using jshint.
// modes:

var symbols_math = "math";
var symbols_text = "text"; // fonts:

var main = "main";
var ams = "ams"; // groups:

var symbols_accent = "accent-token";
var bin = "bin";
var symbols_close = "close";
var symbols_inner = "inner";
var mathord = "mathord";
var op = "op-token";
var symbols_open = "open";
var punct = "punct";
var rel = "rel";
var symbols_spacing = "spacing";
var symbols_textord = "textord"; // Now comes the symbol table
// Relation Symbols

defineSymbol(symbols_math, main, rel, "\u2261", "\\equiv", true);
defineSymbol(symbols_math, main, rel, "\u227A", "\\prec", true);
defineSymbol(symbols_math, main, rel, "\u227B", "\\succ", true);
defineSymbol(symbols_math, main, rel, "\u223C", "\\sim", true);
defineSymbol(symbols_math, main, rel, "\u22A5", "\\perp");
defineSymbol(symbols_math, main, rel, "\u2AAF", "\\preceq", true);
defineSymbol(symbols_math, main, rel, "\u2AB0", "\\succeq", true);
defineSymbol(symbols_math, main, rel, "\u2243", "\\simeq", true);
defineSymbol(symbols_math, main, rel, "\u2223", "\\mid", true);
defineSymbol(symbols_math, main, rel, "\u226A", "\\ll", true);
defineSymbol(symbols_math, main, rel, "\u226B", "\\gg", true);
defineSymbol(symbols_math, main, rel, "\u224D", "\\asymp", true);
defineSymbol(symbols_math, main, rel, "\u2225", "\\parallel");
defineSymbol(symbols_math, main, rel, "\u22C8", "\\bowtie", true);
defineSymbol(symbols_math, main, rel, "\u2323", "\\smile", true);
defineSymbol(symbols_math, main, rel, "\u2291", "\\sqsubseteq", true);
defineSymbol(symbols_math, main, rel, "\u2292", "\\sqsupseteq", true);
defineSymbol(symbols_math, main, rel, "\u2250", "\\doteq", true);
defineSymbol(symbols_math, main, rel, "\u2322", "\\frown", true);
defineSymbol(symbols_math, main, rel, "\u220B", "\\ni", true);
defineSymbol(symbols_math, main, rel, "\u221D", "\\propto", true);
defineSymbol(symbols_math, main, rel, "\u22A2", "\\vdash", true);
defineSymbol(symbols_math, main, rel, "\u22A3", "\\dashv", true);
defineSymbol(symbols_math, main, rel, "\u220B", "\\owns"); // Punctuation

defineSymbol(symbols_math, main, punct, ".", "\\ldotp");
defineSymbol(symbols_math, main, punct, "\u22C5", "\\cdotp"); // Misc Symbols

defineSymbol(symbols_math, main, symbols_textord, "#", "\\#");
defineSymbol(symbols_text, main, symbols_textord, "#", "\\#");
defineSymbol(symbols_math, main, symbols_textord, "&", "\\&");
defineSymbol(symbols_text, main, symbols_textord, "&", "\\&");
defineSymbol(symbols_math, main, symbols_textord, "\u2135", "\\aleph", true);
defineSymbol(symbols_math, main, symbols_textord, "\u2200", "\\forall", true);
defineSymbol(symbols_math, main, symbols_textord, "\u210F", "\\hbar", true);
defineSymbol(symbols_math, main, symbols_textord, "\u2203", "\\exists", true);
defineSymbol(symbols_math, main, symbols_textord, "\u2207", "\\nabla", true);
defineSymbol(symbols_math, main, symbols_textord, "\u266D", "\\flat", true);
defineSymbol(symbols_math, main, symbols_textord, "\u2113", "\\ell", true);
defineSymbol(symbols_math, main, symbols_textord, "\u266E", "\\natural", true);
defineSymbol(symbols_math, main, symbols_textord, "\u2663", "\\clubsuit", true);
defineSymbol(symbols_math, main, symbols_textord, "\u2118", "\\wp", true);
defineSymbol(symbols_math, main, symbols_textord, "\u266F", "\\sharp", true);
defineSymbol(symbols_math, main, symbols_textord, "\u2662", "\\diamondsuit", true);
defineSymbol(symbols_math, main, symbols_textord, "\u211C", "\\Re", true);
defineSymbol(symbols_math, main, symbols_textord, "\u2661", "\\heartsuit", true);
defineSymbol(symbols_math, main, symbols_textord, "\u2111", "\\Im", true);
defineSymbol(symbols_math, main, symbols_textord, "\u2660", "\\spadesuit", true);
defineSymbol(symbols_text, main, symbols_textord, "\xA7", "\\S", true);
defineSymbol(symbols_text, main, symbols_textord, "\xB6", "\\P", true); // Math and Text

defineSymbol(symbols_math, main, symbols_textord, "\u2020", "\\dag");
defineSymbol(symbols_text, main, symbols_textord, "\u2020", "\\dag");
defineSymbol(symbols_text, main, symbols_textord, "\u2020", "\\textdagger");
defineSymbol(symbols_math, main, symbols_textord, "\u2021", "\\ddag");
defineSymbol(symbols_text, main, symbols_textord, "\u2021", "\\ddag");
defineSymbol(symbols_text, main, symbols_textord, "\u2021", "\\textdaggerdbl"); // Large Delimiters

defineSymbol(symbols_math, main, symbols_close, "\u23B1", "\\rmoustache", true);
defineSymbol(symbols_math, main, symbols_open, "\u23B0", "\\lmoustache", true);
defineSymbol(symbols_math, main, symbols_close, "\u27EF", "\\rgroup", true);
defineSymbol(symbols_math, main, symbols_open, "\u27EE", "\\lgroup", true); // Binary Operators

defineSymbol(symbols_math, main, bin, "\u2213", "\\mp", true);
defineSymbol(symbols_math, main, bin, "\u2296", "\\ominus", true);
defineSymbol(symbols_math, main, bin, "\u228E", "\\uplus", true);
defineSymbol(symbols_math, main, bin, "\u2293", "\\sqcap", true);
defineSymbol(symbols_math, main, bin, "\u2217", "\\ast");
defineSymbol(symbols_math, main, bin, "\u2294", "\\sqcup", true);
defineSymbol(symbols_math, main, bin, "\u25EF", "\\bigcirc");
defineSymbol(symbols_math, main, bin, "\u2219", "\\bullet");
defineSymbol(symbols_math, main, bin, "\u2021", "\\ddagger");
defineSymbol(symbols_math, main, bin, "\u2240", "\\wr", true);
defineSymbol(symbols_math, main, bin, "\u2A3F", "\\amalg");
defineSymbol(symbols_math, main, bin, "&", "\\And"); // from amsmath
// Arrow Symbols

defineSymbol(symbols_math, main, rel, "\u27F5", "\\longleftarrow", true);
defineSymbol(symbols_math, main, rel, "\u21D0", "\\Leftarrow", true);
defineSymbol(symbols_math, main, rel, "\u27F8", "\\Longleftarrow", true);
defineSymbol(symbols_math, main, rel, "\u27F6", "\\longrightarrow", true);
defineSymbol(symbols_math, main, rel, "\u21D2", "\\Rightarrow", true);
defineSymbol(symbols_math, main, rel, "\u27F9", "\\Longrightarrow", true);
defineSymbol(symbols_math, main, rel, "\u2194", "\\leftrightarrow", true);
defineSymbol(symbols_math, main, rel, "\u27F7", "\\longleftrightarrow", true);
defineSymbol(symbols_math, main, rel, "\u21D4", "\\Leftrightarrow", true);
defineSymbol(symbols_math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
defineSymbol(symbols_math, main, rel, "\u21A6", "\\mapsto", true);
defineSymbol(symbols_math, main, rel, "\u27FC", "\\longmapsto", true);
defineSymbol(symbols_math, main, rel, "\u2197", "\\nearrow", true);
defineSymbol(symbols_math, main, rel, "\u21A9", "\\hookleftarrow", true);
defineSymbol(symbols_math, main, rel, "\u21AA", "\\hookrightarrow", true);
defineSymbol(symbols_math, main, rel, "\u2198", "\\searrow", true);
defineSymbol(symbols_math, main, rel, "\u21BC", "\\leftharpoonup", true);
defineSymbol(symbols_math, main, rel, "\u21C0", "\\rightharpoonup", true);
defineSymbol(symbols_math, main, rel, "\u2199", "\\swarrow", true);
defineSymbol(symbols_math, main, rel, "\u21BD", "\\leftharpoondown", true);
defineSymbol(symbols_math, main, rel, "\u21C1", "\\rightharpoondown", true);
defineSymbol(symbols_math, main, rel, "\u2196", "\\nwarrow", true);
defineSymbol(symbols_math, main, rel, "\u21CC", "\\rightleftharpoons", true); // AMS Negated Binary Relations

defineSymbol(symbols_math, ams, rel, "\u226E", "\\nless", true); // Symbol names preceeded by "@" each have a corresponding macro.

defineSymbol(symbols_math, ams, rel, "\uE010", "\\@nleqslant");
defineSymbol(symbols_math, ams, rel, "\uE011", "\\@nleqq");
defineSymbol(symbols_math, ams, rel, "\u2A87", "\\lneq", true);
defineSymbol(symbols_math, ams, rel, "\u2268", "\\lneqq", true);
defineSymbol(symbols_math, ams, rel, "\uE00C", "\\@lvertneqq");
defineSymbol(symbols_math, ams, rel, "\u22E6", "\\lnsim", true);
defineSymbol(symbols_math, ams, rel, "\u2A89", "\\lnapprox", true);
defineSymbol(symbols_math, ams, rel, "\u2280", "\\nprec", true); // unicode-math maps \u22e0 to \npreccurlyeq. We'll use the AMS synonym.

defineSymbol(symbols_math, ams, rel, "\u22E0", "\\npreceq", true);
defineSymbol(symbols_math, ams, rel, "\u22E8", "\\precnsim", true);
defineSymbol(symbols_math, ams, rel, "\u2AB9", "\\precnapprox", true);
defineSymbol(symbols_math, ams, rel, "\u2241", "\\nsim", true);
defineSymbol(symbols_math, ams, rel, "\uE006", "\\@nshortmid");
defineSymbol(symbols_math, ams, rel, "\u2224", "\\nmid", true);
defineSymbol(symbols_math, ams, rel, "\u22AC", "\\nvdash", true);
defineSymbol(symbols_math, ams, rel, "\u22AD", "\\nvDash", true);
defineSymbol(symbols_math, ams, rel, "\u22EA", "\\ntriangleleft");
defineSymbol(symbols_math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
defineSymbol(symbols_math, ams, rel, "\u228A", "\\subsetneq", true);
defineSymbol(symbols_math, ams, rel, "\uE01A", "\\@varsubsetneq");
defineSymbol(symbols_math, ams, rel, "\u2ACB", "\\subsetneqq", true);
defineSymbol(symbols_math, ams, rel, "\uE017", "\\@varsubsetneqq");
defineSymbol(symbols_math, ams, rel, "\u226F", "\\ngtr", true);
defineSymbol(symbols_math, ams, rel, "\uE00F", "\\@ngeqslant");
defineSymbol(symbols_math, ams, rel, "\uE00E", "\\@ngeqq");
defineSymbol(symbols_math, ams, rel, "\u2A88", "\\gneq", true);
defineSymbol(symbols_math, ams, rel, "\u2269", "\\gneqq", true);
defineSymbol(symbols_math, ams, rel, "\uE00D", "\\@gvertneqq");
defineSymbol(symbols_math, ams, rel, "\u22E7", "\\gnsim", true);
defineSymbol(symbols_math, ams, rel, "\u2A8A", "\\gnapprox", true);
defineSymbol(symbols_math, ams, rel, "\u2281", "\\nsucc", true); // unicode-math maps \u22e1 to \nsucccurlyeq. We'll use the AMS synonym.

defineSymbol(symbols_math, ams, rel, "\u22E1", "\\nsucceq", true);
defineSymbol(symbols_math, ams, rel, "\u22E9", "\\succnsim", true);
defineSymbol(symbols_math, ams, rel, "\u2ABA", "\\succnapprox", true); // unicode-math maps \u2246 to \simneqq. We'll use the AMS synonym.

defineSymbol(symbols_math, ams, rel, "\u2246", "\\ncong", true);
defineSymbol(symbols_math, ams, rel, "\uE007", "\\@nshortparallel");
defineSymbol(symbols_math, ams, rel, "\u2226", "\\nparallel", true);
defineSymbol(symbols_math, ams, rel, "\u22AF", "\\nVDash", true);
defineSymbol(symbols_math, ams, rel, "\u22EB", "\\ntriangleright");
defineSymbol(symbols_math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
defineSymbol(symbols_math, ams, rel, "\uE018", "\\@nsupseteqq");
defineSymbol(symbols_math, ams, rel, "\u228B", "\\supsetneq", true);
defineSymbol(symbols_math, ams, rel, "\uE01B", "\\@varsupsetneq");
defineSymbol(symbols_math, ams, rel, "\u2ACC", "\\supsetneqq", true);
defineSymbol(symbols_math, ams, rel, "\uE019", "\\@varsupsetneqq");
defineSymbol(symbols_math, ams, rel, "\u22AE", "\\nVdash", true);
defineSymbol(symbols_math, ams, rel, "\u2AB5", "\\precneqq", true);
defineSymbol(symbols_math, ams, rel, "\u2AB6", "\\succneqq", true);
defineSymbol(symbols_math, ams, rel, "\uE016", "\\@nsubseteqq");
defineSymbol(symbols_math, ams, bin, "\u22B4", "\\unlhd");
defineSymbol(symbols_math, ams, bin, "\u22B5", "\\unrhd"); // AMS Negated Arrows

defineSymbol(symbols_math, ams, rel, "\u219A", "\\nleftarrow", true);
defineSymbol(symbols_math, ams, rel, "\u219B", "\\nrightarrow", true);
defineSymbol(symbols_math, ams, rel, "\u21CD", "\\nLeftarrow", true);
defineSymbol(symbols_math, ams, rel, "\u21CF", "\\nRightarrow", true);
defineSymbol(symbols_math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
defineSymbol(symbols_math, ams, rel, "\u21CE", "\\nLeftrightarrow", true); // AMS Misc

defineSymbol(symbols_math, ams, rel, "\u25B3", "\\vartriangle");
defineSymbol(symbols_math, ams, symbols_textord, "\u210F", "\\hslash");
defineSymbol(symbols_math, ams, symbols_textord, "\u25BD", "\\triangledown");
defineSymbol(symbols_math, ams, symbols_textord, "\u25CA", "\\lozenge");
defineSymbol(symbols_math, ams, symbols_textord, "\u24C8", "\\circledS");
defineSymbol(symbols_math, ams, symbols_textord, "\xAE", "\\circledR");
defineSymbol(symbols_text, ams, symbols_textord, "\xAE", "\\circledR");
defineSymbol(symbols_math, ams, symbols_textord, "\u2221", "\\measuredangle", true);
defineSymbol(symbols_math, ams, symbols_textord, "\u2204", "\\nexists");
defineSymbol(symbols_math, ams, symbols_textord, "\u2127", "\\mho");
defineSymbol(symbols_math, ams, symbols_textord, "\u2132", "\\Finv", true);
defineSymbol(symbols_math, ams, symbols_textord, "\u2141", "\\Game", true);
defineSymbol(symbols_math, ams, symbols_textord, "\u2035", "\\backprime");
defineSymbol(symbols_math, ams, symbols_textord, "\u25B2", "\\blacktriangle");
defineSymbol(symbols_math, ams, symbols_textord, "\u25BC", "\\blacktriangledown");
defineSymbol(symbols_math, ams, symbols_textord, "\u25A0", "\\blacksquare");
defineSymbol(symbols_math, ams, symbols_textord, "\u29EB", "\\blacklozenge");
defineSymbol(symbols_math, ams, symbols_textord, "\u2605", "\\bigstar");
defineSymbol(symbols_math, ams, symbols_textord, "\u2222", "\\sphericalangle", true);
defineSymbol(symbols_math, ams, symbols_textord, "\u2201", "\\complement", true); // unicode-math maps U+F0 () to \matheth. We map to AMS function \eth

defineSymbol(symbols_math, ams, symbols_textord, "\xF0", "\\eth", true);
defineSymbol(symbols_math, ams, symbols_textord, "\u2571", "\\diagup");
defineSymbol(symbols_math, ams, symbols_textord, "\u2572", "\\diagdown");
defineSymbol(symbols_math, ams, symbols_textord, "\u25A1", "\\square");
defineSymbol(symbols_math, ams, symbols_textord, "\u25A1", "\\Box");
defineSymbol(symbols_math, ams, symbols_textord, "\u25CA", "\\Diamond"); // unicode-math maps U+A5 to \mathyen. We map to AMS function \yen

defineSymbol(symbols_math, ams, symbols_textord, "\xA5", "\\yen", true);
defineSymbol(symbols_text, ams, symbols_textord, "\xA5", "\\yen", true);
defineSymbol(symbols_math, ams, symbols_textord, "\u2713", "\\checkmark", true);
defineSymbol(symbols_text, ams, symbols_textord, "\u2713", "\\checkmark"); // AMS Hebrew

defineSymbol(symbols_math, ams, symbols_textord, "\u2136", "\\beth", true);
defineSymbol(symbols_math, ams, symbols_textord, "\u2138", "\\daleth", true);
defineSymbol(symbols_math, ams, symbols_textord, "\u2137", "\\gimel", true); // AMS Greek

defineSymbol(symbols_math, ams, symbols_textord, "\u03DD", "\\digamma");
defineSymbol(symbols_math, ams, symbols_textord, "\u03F0", "\\varkappa"); // AMS Delimiters

defineSymbol(symbols_math, ams, symbols_open, "\u250C", "\\ulcorner", true);
defineSymbol(symbols_math, ams, symbols_close, "\u2510", "\\urcorner", true);
defineSymbol(symbols_math, ams, symbols_open, "\u2514", "\\llcorner", true);
defineSymbol(symbols_math, ams, symbols_close, "\u2518", "\\lrcorner", true); // AMS Binary Relations

defineSymbol(symbols_math, ams, rel, "\u2266", "\\leqq", true);
defineSymbol(symbols_math, ams, rel, "\u2A7D", "\\leqslant", true);
defineSymbol(symbols_math, ams, rel, "\u2A95", "\\eqslantless", true);
defineSymbol(symbols_math, ams, rel, "\u2272", "\\lesssim", true);
defineSymbol(symbols_math, ams, rel, "\u2A85", "\\lessapprox", true);
defineSymbol(symbols_math, ams, rel, "\u224A", "\\approxeq", true);
defineSymbol(symbols_math, ams, bin, "\u22D6", "\\lessdot");
defineSymbol(symbols_math, ams, rel, "\u22D8", "\\lll", true);
defineSymbol(symbols_math, ams, rel, "\u2276", "\\lessgtr", true);
defineSymbol(symbols_math, ams, rel, "\u22DA", "\\lesseqgtr", true);
defineSymbol(symbols_math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
defineSymbol(symbols_math, ams, rel, "\u2251", "\\doteqdot");
defineSymbol(symbols_math, ams, rel, "\u2253", "\\risingdotseq", true);
defineSymbol(symbols_math, ams, rel, "\u2252", "\\fallingdotseq", true);
defineSymbol(symbols_math, ams, rel, "\u223D", "\\backsim", true);
defineSymbol(symbols_math, ams, rel, "\u22CD", "\\backsimeq", true);
defineSymbol(symbols_math, ams, rel, "\u2AC5", "\\subseteqq", true);
defineSymbol(symbols_math, ams, rel, "\u22D0", "\\Subset", true);
defineSymbol(symbols_math, ams, rel, "\u228F", "\\sqsubset", true);
defineSymbol(symbols_math, ams, rel, "\u227C", "\\preccurlyeq", true);
defineSymbol(symbols_math, ams, rel, "\u22DE", "\\curlyeqprec", true);
defineSymbol(symbols_math, ams, rel, "\u227E", "\\precsim", true);
defineSymbol(symbols_math, ams, rel, "\u2AB7", "\\precapprox", true);
defineSymbol(symbols_math, ams, rel, "\u22B2", "\\vartriangleleft");
defineSymbol(symbols_math, ams, rel, "\u22B4", "\\trianglelefteq");
defineSymbol(symbols_math, ams, rel, "\u22A8", "\\vDash", true);
defineSymbol(symbols_math, ams, rel, "\u22AA", "\\Vvdash", true);
defineSymbol(symbols_math, ams, rel, "\u2323", "\\smallsmile");
defineSymbol(symbols_math, ams, rel, "\u2322", "\\smallfrown");
defineSymbol(symbols_math, ams, rel, "\u224F", "\\bumpeq", true);
defineSymbol(symbols_math, ams, rel, "\u224E", "\\Bumpeq", true);
defineSymbol(symbols_math, ams, rel, "\u2267", "\\geqq", true);
defineSymbol(symbols_math, ams, rel, "\u2A7E", "\\geqslant", true);
defineSymbol(symbols_math, ams, rel, "\u2A96", "\\eqslantgtr", true);
defineSymbol(symbols_math, ams, rel, "\u2273", "\\gtrsim", true);
defineSymbol(symbols_math, ams, rel, "\u2A86", "\\gtrapprox", true);
defineSymbol(symbols_math, ams, bin, "\u22D7", "\\gtrdot");
defineSymbol(symbols_math, ams, rel, "\u22D9", "\\ggg", true);
defineSymbol(symbols_math, ams, rel, "\u2277", "\\gtrless", true);
defineSymbol(symbols_math, ams, rel, "\u22DB", "\\gtreqless", true);
defineSymbol(symbols_math, ams, rel, "\u2A8C", "\\gtreqqless", true);
defineSymbol(symbols_math, ams, rel, "\u2256", "\\eqcirc", true);
defineSymbol(symbols_math, ams, rel, "\u2257", "\\circeq", true);
defineSymbol(symbols_math, ams, rel, "\u225C", "\\triangleq", true);
defineSymbol(symbols_math, ams, rel, "\u223C", "\\thicksim");
defineSymbol(symbols_math, ams, rel, "\u2248", "\\thickapprox");
defineSymbol(symbols_math, ams, rel, "\u2AC6", "\\supseteqq", true);
defineSymbol(symbols_math, ams, rel, "\u22D1", "\\Supset", true);
defineSymbol(symbols_math, ams, rel, "\u2290", "\\sqsupset", true);
defineSymbol(symbols_math, ams, rel, "\u227D", "\\succcurlyeq", true);
defineSymbol(symbols_math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
defineSymbol(symbols_math, ams, rel, "\u227F", "\\succsim", true);
defineSymbol(symbols_math, ams, rel, "\u2AB8", "\\succapprox", true);
defineSymbol(symbols_math, ams, rel, "\u22B3", "\\vartriangleright");
defineSymbol(symbols_math, ams, rel, "\u22B5", "\\trianglerighteq");
defineSymbol(symbols_math, ams, rel, "\u22A9", "\\Vdash", true);
defineSymbol(symbols_math, ams, rel, "\u2223", "\\shortmid");
defineSymbol(symbols_math, ams, rel, "\u2225", "\\shortparallel");
defineSymbol(symbols_math, ams, rel, "\u226C", "\\between", true);
defineSymbol(symbols_math, ams, rel, "\u22D4", "\\pitchfork", true);
defineSymbol(symbols_math, ams, rel, "\u221D", "\\varpropto");
defineSymbol(symbols_math, ams, rel, "\u25C0", "\\blacktriangleleft"); // unicode-math says that \therefore is a mathord atom.
// We kept the amssymb atom type, which is rel.

defineSymbol(symbols_math, ams, rel, "\u2234", "\\therefore", true);
defineSymbol(symbols_math, ams, rel, "\u220D", "\\backepsilon");
defineSymbol(symbols_math, ams, rel, "\u25B6", "\\blacktriangleright"); // unicode-math says that \because is a mathord atom.
// We kept the amssymb atom type, which is rel.

defineSymbol(symbols_math, ams, rel, "\u2235", "\\because", true);
defineSymbol(symbols_math, ams, rel, "\u22D8", "\\llless");
defineSymbol(symbols_math, ams, rel, "\u22D9", "\\gggtr");
defineSymbol(symbols_math, ams, bin, "\u22B2", "\\lhd");
defineSymbol(symbols_math, ams, bin, "\u22B3", "\\rhd");
defineSymbol(symbols_math, ams, rel, "\u2242", "\\eqsim", true);
defineSymbol(symbols_math, main, rel, "\u22C8", "\\Join");
defineSymbol(symbols_math, ams, rel, "\u2251", "\\Doteq", true); // AMS Binary Operators

defineSymbol(symbols_math, ams, bin, "\u2214", "\\dotplus", true);
defineSymbol(symbols_math, ams, bin, "\u2216", "\\smallsetminus");
defineSymbol(symbols_math, ams, bin, "\u22D2", "\\Cap", true);
defineSymbol(symbols_math, ams, bin, "\u22D3", "\\Cup", true);
defineSymbol(symbols_math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
defineSymbol(symbols_math, ams, bin, "\u229F", "\\boxminus", true);
defineSymbol(symbols_math, ams, bin, "\u229E", "\\boxplus", true);
defineSymbol(symbols_math, ams, bin, "\u22C7", "\\divideontimes", true);
defineSymbol(symbols_math, ams, bin, "\u22C9", "\\ltimes", true);
defineSymbol(symbols_math, ams, bin, "\u22CA", "\\rtimes", true);
defineSymbol(symbols_math, ams, bin, "\u22CB", "\\leftthreetimes", true);
defineSymbol(symbols_math, ams, bin, "\u22CC", "\\rightthreetimes", true);
defineSymbol(symbols_math, ams, bin, "\u22CF", "\\curlywedge", true);
defineSymbol(symbols_math, ams, bin, "\u22CE", "\\curlyvee", true);
defineSymbol(symbols_math, ams, bin, "\u229D", "\\circleddash", true);
defineSymbol(symbols_math, ams, bin, "\u229B", "\\circledast", true);
defineSymbol(symbols_math, ams, bin, "\u22C5", "\\centerdot");
defineSymbol(symbols_math, ams, bin, "\u22BA", "\\intercal", true);
defineSymbol(symbols_math, ams, bin, "\u22D2", "\\doublecap");
defineSymbol(symbols_math, ams, bin, "\u22D3", "\\doublecup");
defineSymbol(symbols_math, ams, bin, "\u22A0", "\\boxtimes", true); // AMS Arrows
// Note: unicode-math maps \u21e2 to their own function \rightdasharrow.
// We'll map it to AMS function \dashrightarrow. It produces the same atom.

defineSymbol(symbols_math, ams, rel, "\u21E2", "\\dashrightarrow", true); // unicode-math maps \u21e0 to \leftdasharrow. We'll use the AMS synonym.

defineSymbol(symbols_math, ams, rel, "\u21E0", "\\dashleftarrow", true);
defineSymbol(symbols_math, ams, rel, "\u21C7", "\\leftleftarrows", true);
defineSymbol(symbols_math, ams, rel, "\u21C6", "\\leftrightarrows", true);
defineSymbol(symbols_math, ams, rel, "\u21DA", "\\Lleftarrow", true);
defineSymbol(symbols_math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
defineSymbol(symbols_math, ams, rel, "\u21A2", "\\leftarrowtail", true);
defineSymbol(symbols_math, ams, rel, "\u21AB", "\\looparrowleft", true);
defineSymbol(symbols_math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
defineSymbol(symbols_math, ams, rel, "\u21B6", "\\curvearrowleft", true); // unicode-math maps \u21ba to \acwopencirclearrow. We'll use the AMS synonym.

defineSymbol(symbols_math, ams, rel, "\u21BA", "\\circlearrowleft", true);
defineSymbol(symbols_math, ams, rel, "\u21B0", "\\Lsh", true);
defineSymbol(symbols_math, ams, rel, "\u21C8", "\\upuparrows", true);
defineSymbol(symbols_math, ams, rel, "\u21BF", "\\upharpoonleft", true);
defineSymbol(symbols_math, ams, rel, "\u21C3", "\\downharpoonleft", true);
defineSymbol(symbols_math, ams, rel, "\u22B8", "\\multimap", true);
defineSymbol(symbols_math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
defineSymbol(symbols_math, ams, rel, "\u21C9", "\\rightrightarrows", true);
defineSymbol(symbols_math, ams, rel, "\u21C4", "\\rightleftarrows", true);
defineSymbol(symbols_math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
defineSymbol(symbols_math, ams, rel, "\u21A3", "\\rightarrowtail", true);
defineSymbol(symbols_math, ams, rel, "\u21AC", "\\looparrowright", true);
defineSymbol(symbols_math, ams, rel, "\u21B7", "\\curvearrowright", true); // unicode-math maps \u21bb to \cwopencirclearrow. We'll use the AMS synonym.

defineSymbol(symbols_math, ams, rel, "\u21BB", "\\circlearrowright", true);
defineSymbol(symbols_math, ams, rel, "\u21B1", "\\Rsh", true);
defineSymbol(symbols_math, ams, rel, "\u21CA", "\\downdownarrows", true);
defineSymbol(symbols_math, ams, rel, "\u21BE", "\\upharpoonright", true);
defineSymbol(symbols_math, ams, rel, "\u21C2", "\\downharpoonright", true);
defineSymbol(symbols_math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
defineSymbol(symbols_math, ams, rel, "\u21DD", "\\leadsto");
defineSymbol(symbols_math, ams, rel, "\u21DB", "\\Rrightarrow", true);
defineSymbol(symbols_math, ams, rel, "\u21BE", "\\restriction");
defineSymbol(symbols_math, main, symbols_textord, "\u2018", "`");
defineSymbol(symbols_math, main, symbols_textord, "$", "\\$");
defineSymbol(symbols_text, main, symbols_textord, "$", "\\$");
defineSymbol(symbols_text, main, symbols_textord, "$", "\\textdollar");
defineSymbol(symbols_math, main, symbols_textord, "%", "\\%");
defineSymbol(symbols_text, main, symbols_textord, "%", "\\%");
defineSymbol(symbols_math, main, symbols_textord, "_", "\\_");
defineSymbol(symbols_text, main, symbols_textord, "_", "\\_");
defineSymbol(symbols_text, main, symbols_textord, "_", "\\textunderscore");
defineSymbol(symbols_math, main, symbols_textord, "\u2220", "\\angle", true);
defineSymbol(symbols_math, main, symbols_textord, "\u221E", "\\infty", true);
defineSymbol(symbols_math, main, symbols_textord, "\u2032", "\\prime");
defineSymbol(symbols_math, main, symbols_textord, "\u25B3", "\\triangle");
defineSymbol(symbols_math, main, symbols_textord, "\u0393", "\\Gamma", true);
defineSymbol(symbols_math, main, symbols_textord, "\u0394", "\\Delta", true);
defineSymbol(symbols_math, main, symbols_textord, "\u0398", "\\Theta", true);
defineSymbol(symbols_math, main, symbols_textord, "\u039B", "\\Lambda", true);
defineSymbol(symbols_math, main, symbols_textord, "\u039E", "\\Xi", true);
defineSymbol(symbols_math, main, symbols_textord, "\u03A0", "\\Pi", true);
defineSymbol(symbols_math, main, symbols_textord, "\u03A3", "\\Sigma", true);
defineSymbol(symbols_math, main, symbols_textord, "\u03A5", "\\Upsilon", true);
defineSymbol(symbols_math, main, symbols_textord, "\u03A6", "\\Phi", true);
defineSymbol(symbols_math, main, symbols_textord, "\u03A8", "\\Psi", true);
defineSymbol(symbols_math, main, symbols_textord, "\u03A9", "\\Omega", true);
defineSymbol(symbols_math, main, symbols_textord, "A", "\u0391");
defineSymbol(symbols_math, main, symbols_textord, "B", "\u0392");
defineSymbol(symbols_math, main, symbols_textord, "E", "\u0395");
defineSymbol(symbols_math, main, symbols_textord, "Z", "\u0396");
defineSymbol(symbols_math, main, symbols_textord, "H", "\u0397");
defineSymbol(symbols_math, main, symbols_textord, "I", "\u0399");
defineSymbol(symbols_math, main, symbols_textord, "K", "\u039A");
defineSymbol(symbols_math, main, symbols_textord, "M", "\u039C");
defineSymbol(symbols_math, main, symbols_textord, "N", "\u039D");
defineSymbol(symbols_math, main, symbols_textord, "O", "\u039F");
defineSymbol(symbols_math, main, symbols_textord, "P", "\u03A1");
defineSymbol(symbols_math, main, symbols_textord, "T", "\u03A4");
defineSymbol(symbols_math, main, symbols_textord, "X", "\u03A7");
defineSymbol(symbols_math, main, symbols_textord, "\xAC", "\\neg", true);
defineSymbol(symbols_math, main, symbols_textord, "\xAC", "\\lnot");
defineSymbol(symbols_math, main, symbols_textord, "\u22A4", "\\top");
defineSymbol(symbols_math, main, symbols_textord, "\u22A5", "\\bot");
defineSymbol(symbols_math, main, symbols_textord, "\u2205", "\\emptyset");
defineSymbol(symbols_math, ams, symbols_textord, "\u2205", "\\varnothing");
defineSymbol(symbols_math, main, mathord, "\u03B1", "\\alpha", true);
defineSymbol(symbols_math, main, mathord, "\u03B2", "\\beta", true);
defineSymbol(symbols_math, main, mathord, "\u03B3", "\\gamma", true);
defineSymbol(symbols_math, main, mathord, "\u03B4", "\\delta", true);
defineSymbol(symbols_math, main, mathord, "\u03F5", "\\epsilon", true);
defineSymbol(symbols_math, main, mathord, "\u03B6", "\\zeta", true);
defineSymbol(symbols_math, main, mathord, "\u03B7", "\\eta", true);
defineSymbol(symbols_math, main, mathord, "\u03B8", "\\theta", true);
defineSymbol(symbols_math, main, mathord, "\u03B9", "\\iota", true);
defineSymbol(symbols_math, main, mathord, "\u03BA", "\\kappa", true);
defineSymbol(symbols_math, main, mathord, "\u03BB", "\\lambda", true);
defineSymbol(symbols_math, main, mathord, "\u03BC", "\\mu", true);
defineSymbol(symbols_math, main, mathord, "\u03BD", "\\nu", true);
defineSymbol(symbols_math, main, mathord, "\u03BE", "\\xi", true);
defineSymbol(symbols_math, main, mathord, "\u03BF", "\\omicron", true);
defineSymbol(symbols_math, main, mathord, "\u03C0", "\\pi", true);
defineSymbol(symbols_math, main, mathord, "\u03C1", "\\rho", true);
defineSymbol(symbols_math, main, mathord, "\u03C3", "\\sigma", true);
defineSymbol(symbols_math, main, mathord, "\u03C4", "\\tau", true);
defineSymbol(symbols_math, main, mathord, "\u03C5", "\\upsilon", true);
defineSymbol(symbols_math, main, mathord, "\u03D5", "\\phi", true);
defineSymbol(symbols_math, main, mathord, "\u03C7", "\\chi", true);
defineSymbol(symbols_math, main, mathord, "\u03C8", "\\psi", true);
defineSymbol(symbols_math, main, mathord, "\u03C9", "\\omega", true);
defineSymbol(symbols_math, main, mathord, "\u03B5", "\\varepsilon", true);
defineSymbol(symbols_math, main, mathord, "\u03D1", "\\vartheta", true);
defineSymbol(symbols_math, main, mathord, "\u03D6", "\\varpi", true);
defineSymbol(symbols_math, main, mathord, "\u03F1", "\\varrho", true);
defineSymbol(symbols_math, main, mathord, "\u03C2", "\\varsigma", true);
defineSymbol(symbols_math, main, mathord, "\u03C6", "\\varphi", true);
defineSymbol(symbols_math, main, bin, "\u2217", "*");
defineSymbol(symbols_math, main, bin, "+", "+");
defineSymbol(symbols_math, main, bin, "\u2212", "-");
defineSymbol(symbols_math, main, bin, "\u22C5", "\\cdot", true);
defineSymbol(symbols_math, main, bin, "\u2218", "\\circ");
defineSymbol(symbols_math, main, bin, "\xF7", "\\div", true);
defineSymbol(symbols_math, main, bin, "\xB1", "\\pm", true);
defineSymbol(symbols_math, main, bin, "\xD7", "\\times", true);
defineSymbol(symbols_math, main, bin, "\u2229", "\\cap", true);
defineSymbol(symbols_math, main, bin, "\u222A", "\\cup", true);
defineSymbol(symbols_math, main, bin, "\u2216", "\\setminus");
defineSymbol(symbols_math, main, bin, "\u2227", "\\land");
defineSymbol(symbols_math, main, bin, "\u2228", "\\lor");
defineSymbol(symbols_math, main, bin, "\u2227", "\\wedge", true);
defineSymbol(symbols_math, main, bin, "\u2228", "\\vee", true);
defineSymbol(symbols_math, main, symbols_textord, "\u221A", "\\surd");
defineSymbol(symbols_math, main, symbols_open, "(", "(");
defineSymbol(symbols_math, main, symbols_open, "[", "[");
defineSymbol(symbols_math, main, symbols_open, "\u27E8", "\\langle", true);
defineSymbol(symbols_math, main, symbols_open, "\u2223", "\\lvert");
defineSymbol(symbols_math, main, symbols_open, "\u2225", "\\lVert");
defineSymbol(symbols_math, main, symbols_close, ")", ")");
defineSymbol(symbols_math, main, symbols_close, "]", "]");
defineSymbol(symbols_math, main, symbols_close, "?", "?");
defineSymbol(symbols_math, main, symbols_close, "!", "!");
defineSymbol(symbols_math, main, symbols_close, "\u27E9", "\\rangle", true);
defineSymbol(symbols_math, main, symbols_close, "\u2223", "\\rvert");
defineSymbol(symbols_math, main, symbols_close, "\u2225", "\\rVert");
defineSymbol(symbols_math, main, rel, "=", "=");
defineSymbol(symbols_math, main, rel, "<", "<");
defineSymbol(symbols_math, main, rel, ">", ">");
defineSymbol(symbols_math, main, rel, ":", ":");
defineSymbol(symbols_math, main, rel, "\u2248", "\\approx", true);
defineSymbol(symbols_math, main, rel, "\u2245", "\\cong", true);
defineSymbol(symbols_math, main, rel, "\u2265", "\\ge");
defineSymbol(symbols_math, main, rel, "\u2265", "\\geq", true);
defineSymbol(symbols_math, main, rel, "\u2190", "\\gets");
defineSymbol(symbols_math, main, rel, ">", "\\gt");
defineSymbol(symbols_math, main, rel, "\u2208", "\\in", true);
defineSymbol(symbols_math, main, rel, "\uE020", "\\@not");
defineSymbol(symbols_math, main, rel, "\u2282", "\\subset", true);
defineSymbol(symbols_math, main, rel, "\u2283", "\\supset", true);
defineSymbol(symbols_math, main, rel, "\u2286", "\\subseteq", true);
defineSymbol(symbols_math, main, rel, "\u2287", "\\supseteq", true);
defineSymbol(symbols_math, ams, rel, "\u2288", "\\nsubseteq", true);
defineSymbol(symbols_math, ams, rel, "\u2289", "\\nsupseteq", true);
defineSymbol(symbols_math, main, rel, "\u22A8", "\\models");
defineSymbol(symbols_math, main, rel, "\u2190", "\\leftarrow", true);
defineSymbol(symbols_math, main, rel, "\u2264", "\\le");
defineSymbol(symbols_math, main, rel, "\u2264", "\\leq", true);
defineSymbol(symbols_math, main, rel, "<", "\\lt");
defineSymbol(symbols_math, main, rel, "\u2192", "\\rightarrow", true);
defineSymbol(symbols_math, main, rel, "\u2192", "\\to");
defineSymbol(symbols_math, ams, rel, "\u2271", "\\ngeq", true);
defineSymbol(symbols_math, ams, rel, "\u2270", "\\nleq", true);
defineSymbol(symbols_math, main, symbols_spacing, "\xA0", "\\ ");
defineSymbol(symbols_math, main, symbols_spacing, "\xA0", "~");
defineSymbol(symbols_math, main, symbols_spacing, "\xA0", "\\space"); // Ref: LaTeX Source 2e: \DeclareRobustCommand{\nobreakspace}{%

defineSymbol(symbols_math, main, symbols_spacing, "\xA0", "\\nobreakspace");
defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "\\ ");
defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "~");
defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "\\space");
defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "\\nobreakspace");
defineSymbol(symbols_math, main, symbols_spacing, null, "\\nobreak");
defineSymbol(symbols_math, main, symbols_spacing, null, "\\allowbreak");
defineSymbol(symbols_math, main, punct, ",", ",");
defineSymbol(symbols_math, main, punct, ";", ";");
defineSymbol(symbols_math, ams, bin, "\u22BC", "\\barwedge", true);
defineSymbol(symbols_math, ams, bin, "\u22BB", "\\veebar", true);
defineSymbol(symbols_math, main, bin, "\u2299", "\\odot", true);
defineSymbol(symbols_math, main, bin, "\u2295", "\\oplus", true);
defineSymbol(symbols_math, main, bin, "\u2297", "\\otimes", true);
defineSymbol(symbols_math, main, symbols_textord, "\u2202", "\\partial", true);
defineSymbol(symbols_math, main, bin, "\u2298", "\\oslash", true);
defineSymbol(symbols_math, ams, bin, "\u229A", "\\circledcirc", true);
defineSymbol(symbols_math, ams, bin, "\u22A1", "\\boxdot", true);
defineSymbol(symbols_math, main, bin, "\u25B3", "\\bigtriangleup");
defineSymbol(symbols_math, main, bin, "\u25BD", "\\bigtriangledown");
defineSymbol(symbols_math, main, bin, "\u2020", "\\dagger");
defineSymbol(symbols_math, main, bin, "\u22C4", "\\diamond");
defineSymbol(symbols_math, main, bin, "\u22C6", "\\star");
defineSymbol(symbols_math, main, bin, "\u25C3", "\\triangleleft");
defineSymbol(symbols_math, main, bin, "\u25B9", "\\triangleright");
defineSymbol(symbols_math, main, symbols_open, "{", "\\{");
defineSymbol(symbols_text, main, symbols_textord, "{", "\\{");
defineSymbol(symbols_text, main, symbols_textord, "{", "\\textbraceleft");
defineSymbol(symbols_math, main, symbols_close, "}", "\\}");
defineSymbol(symbols_text, main, symbols_textord, "}", "\\}");
defineSymbol(symbols_text, main, symbols_textord, "}", "\\textbraceright");
defineSymbol(symbols_math, main, symbols_open, "{", "\\lbrace");
defineSymbol(symbols_math, main, symbols_close, "}", "\\rbrace");
defineSymbol(symbols_math, main, symbols_open, "[", "\\lbrack");
defineSymbol(symbols_text, main, symbols_textord, "[", "\\lbrack");
defineSymbol(symbols_math, main, symbols_close, "]", "\\rbrack");
defineSymbol(symbols_text, main, symbols_textord, "]", "\\rbrack");
defineSymbol(symbols_math, main, symbols_open, "(", "\\lparen");
defineSymbol(symbols_math, main, symbols_close, ")", "\\rparen");
defineSymbol(symbols_text, main, symbols_textord, "<", "\\textless"); // in T1 fontenc

defineSymbol(symbols_text, main, symbols_textord, ">", "\\textgreater"); // in T1 fontenc

defineSymbol(symbols_math, main, symbols_open, "\u230A", "\\lfloor", true);
defineSymbol(symbols_math, main, symbols_close, "\u230B", "\\rfloor", true);
defineSymbol(symbols_math, main, symbols_open, "\u2308", "\\lceil", true);
defineSymbol(symbols_math, main, symbols_close, "\u2309", "\\rceil", true);
defineSymbol(symbols_math, main, symbols_textord, "\\", "\\backslash");
defineSymbol(symbols_math, main, symbols_textord, "\u2223", "|");
defineSymbol(symbols_math, main, symbols_textord, "\u2223", "\\vert");
defineSymbol(symbols_text, main, symbols_textord, "|", "\\textbar"); // in T1 fontenc

defineSymbol(symbols_math, main, symbols_textord, "\u2225", "\\|");
defineSymbol(symbols_math, main, symbols_textord, "\u2225", "\\Vert");
defineSymbol(symbols_text, main, symbols_textord, "\u2225", "\\textbardbl");
defineSymbol(symbols_text, main, symbols_textord, "~", "\\textasciitilde");
defineSymbol(symbols_text, main, symbols_textord, "\\", "\\textbackslash");
defineSymbol(symbols_text, main, symbols_textord, "^", "\\textasciicircum");
defineSymbol(symbols_math, main, rel, "\u2191", "\\uparrow", true);
defineSymbol(symbols_math, main, rel, "\u21D1", "\\Uparrow", true);
defineSymbol(symbols_math, main, rel, "\u2193", "\\downarrow", true);
defineSymbol(symbols_math, main, rel, "\u21D3", "\\Downarrow", true);
defineSymbol(symbols_math, main, rel, "\u2195", "\\updownarrow", true);
defineSymbol(symbols_math, main, rel, "\u21D5", "\\Updownarrow", true);
defineSymbol(symbols_math, main, op, "\u2210", "\\coprod");
defineSymbol(symbols_math, main, op, "\u22C1", "\\bigvee");
defineSymbol(symbols_math, main, op, "\u22C0", "\\bigwedge");
defineSymbol(symbols_math, main, op, "\u2A04", "\\biguplus");
defineSymbol(symbols_math, main, op, "\u22C2", "\\bigcap");
defineSymbol(symbols_math, main, op, "\u22C3", "\\bigcup");
defineSymbol(symbols_math, main, op, "\u222B", "\\int");
defineSymbol(symbols_math, main, op, "\u222B", "\\intop");
defineSymbol(symbols_math, main, op, "\u222C", "\\iint");
defineSymbol(symbols_math, main, op, "\u222D", "\\iiint");
defineSymbol(symbols_math, main, op, "\u220F", "\\prod");
defineSymbol(symbols_math, main, op, "\u2211", "\\sum");
defineSymbol(symbols_math, main, op, "\u2A02", "\\bigotimes");
defineSymbol(symbols_math, main, op, "\u2A01", "\\bigoplus");
defineSymbol(symbols_math, main, op, "\u2A00", "\\bigodot");
defineSymbol(symbols_math, main, op, "\u222E", "\\oint");
defineSymbol(symbols_math, main, op, "\u222F", "\\oiint");
defineSymbol(symbols_math, main, op, "\u2230", "\\oiiint");
defineSymbol(symbols_math, main, op, "\u2A06", "\\bigsqcup");
defineSymbol(symbols_math, main, op, "\u222B", "\\smallint");
defineSymbol(symbols_text, main, symbols_inner, "\u2026", "\\textellipsis");
defineSymbol(symbols_math, main, symbols_inner, "\u2026", "\\mathellipsis");
defineSymbol(symbols_text, main, symbols_inner, "\u2026", "\\ldots", true);
defineSymbol(symbols_math, main, symbols_inner, "\u2026", "\\ldots", true);
defineSymbol(symbols_math, main, symbols_inner, "\u22EF", "\\@cdots", true);
defineSymbol(symbols_math, main, symbols_inner, "\u22F1", "\\ddots", true);
defineSymbol(symbols_math, main, symbols_textord, "\u22EE", "\\varvdots"); // \vdots is a macro

defineSymbol(symbols_math, main, symbols_accent, "\u02CA", "\\acute");
defineSymbol(symbols_math, main, symbols_accent, "\u02CB", "\\grave");
defineSymbol(symbols_math, main, symbols_accent, "\xA8", "\\ddot");
defineSymbol(symbols_math, main, symbols_accent, "~", "\\tilde");
defineSymbol(symbols_math, main, symbols_accent, "\u02C9", "\\bar");
defineSymbol(symbols_math, main, symbols_accent, "\u02D8", "\\breve");
defineSymbol(symbols_math, main, symbols_accent, "\u02C7", "\\check");
defineSymbol(symbols_math, main, symbols_accent, "^", "\\hat");
defineSymbol(symbols_math, main, symbols_accent, "\u20D7", "\\vec");
defineSymbol(symbols_math, main, symbols_accent, "\u02D9", "\\dot");
defineSymbol(symbols_math, main, symbols_accent, "\u02DA", "\\mathring");
defineSymbol(symbols_math, main, mathord, "\u0131", "\\imath", true);
defineSymbol(symbols_math, main, mathord, "\u0237", "\\jmath", true);
defineSymbol(symbols_text, main, symbols_textord, "\u0131", "\\i", true);
defineSymbol(symbols_text, main, symbols_textord, "\u0237", "\\j", true);
defineSymbol(symbols_text, main, symbols_textord, "\xDF", "\\ss", true);
defineSymbol(symbols_text, main, symbols_textord, "\xE6", "\\ae", true);
defineSymbol(symbols_text, main, symbols_textord, "\xE6", "\\ae", true);
defineSymbol(symbols_text, main, symbols_textord, "\u0153", "\\oe", true);
defineSymbol(symbols_text, main, symbols_textord, "\xF8", "\\o", true);
defineSymbol(symbols_text, main, symbols_textord, "\xC6", "\\AE", true);
defineSymbol(symbols_text, main, symbols_textord, "\u0152", "\\OE", true);
defineSymbol(symbols_text, main, symbols_textord, "\xD8", "\\O", true);
defineSymbol(symbols_text, main, symbols_accent, "\u02CA", "\\'"); // acute

defineSymbol(symbols_text, main, symbols_accent, "\u02CB", "\\`"); // grave

defineSymbol(symbols_text, main, symbols_accent, "\u02C6", "\\^"); // circumflex

defineSymbol(symbols_text, main, symbols_accent, "\u02DC", "\\~"); // tilde

defineSymbol(symbols_text, main, symbols_accent, "\u02C9", "\\="); // macron

defineSymbol(symbols_text, main, symbols_accent, "\u02D8", "\\u"); // breve

defineSymbol(symbols_text, main, symbols_accent, "\u02D9", "\\."); // dot above

defineSymbol(symbols_text, main, symbols_accent, "\u02DA", "\\r"); // ring above

defineSymbol(symbols_text, main, symbols_accent, "\u02C7", "\\v"); // caron

defineSymbol(symbols_text, main, symbols_accent, "\xA8", '\\"'); // diaresis

defineSymbol(symbols_text, main, symbols_accent, "\u02DD", "\\H"); // double acute

defineSymbol(symbols_text, main, symbols_accent, "\u25EF", "\\textcircled"); // \bigcirc glyph
// These ligatures are detected and created in Parser.js's `formLigatures`.

var ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};
defineSymbol(symbols_text, main, symbols_textord, "\u2013", "--");
defineSymbol(symbols_text, main, symbols_textord, "\u2013", "\\textendash");
defineSymbol(symbols_text, main, symbols_textord, "\u2014", "---");
defineSymbol(symbols_text, main, symbols_textord, "\u2014", "\\textemdash");
defineSymbol(symbols_text, main, symbols_textord, "\u2018", "`");
defineSymbol(symbols_text, main, symbols_textord, "\u2018", "\\textquoteleft");
defineSymbol(symbols_text, main, symbols_textord, "\u2019", "'");
defineSymbol(symbols_text, main, symbols_textord, "\u2019", "\\textquoteright");
defineSymbol(symbols_text, main, symbols_textord, "\u201C", "``");
defineSymbol(symbols_text, main, symbols_textord, "\u201C", "\\textquotedblleft");
defineSymbol(symbols_text, main, symbols_textord, "\u201D", "''");
defineSymbol(symbols_text, main, symbols_textord, "\u201D", "\\textquotedblright"); //  \degree from gensymb package

defineSymbol(symbols_math, main, symbols_textord, "\xB0", "\\degree", true);
defineSymbol(symbols_text, main, symbols_textord, "\xB0", "\\degree"); // \textdegree from inputenc package

defineSymbol(symbols_text, main, symbols_textord, "\xB0", "\\textdegree", true); // TODO: In LaTeX, \pounds can generate a different character in text and math
// mode, but among our fonts, only Main-Italic defines this character "163".

defineSymbol(symbols_math, main, mathord, "\xA3", "\\pounds");
defineSymbol(symbols_math, main, mathord, "\xA3", "\\mathsterling", true);
defineSymbol(symbols_text, main, mathord, "\xA3", "\\pounds");
defineSymbol(symbols_text, main, mathord, "\xA3", "\\textsterling", true);
defineSymbol(symbols_math, ams, symbols_textord, "\u2720", "\\maltese");
defineSymbol(symbols_text, ams, symbols_textord, "\u2720", "\\maltese");
defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "\\ ");
defineSymbol(symbols_text, main, symbols_spacing, "\xA0", " ");
defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "~"); // There are lots of symbols which are the same, so we add them in afterwards.
// All of these are textords in math mode

var mathTextSymbols = "0123456789/@.\"";

for (var symbols_i = 0; symbols_i < mathTextSymbols.length; symbols_i++) {
  var symbols_ch = mathTextSymbols.charAt(symbols_i);
  defineSymbol(symbols_math, main, symbols_textord, symbols_ch, symbols_ch);
} // All of these are textords in text mode


var textSymbols = "0123456789!@*()-=+[]<>|\";:?/.,";

for (var src_symbols_i = 0; src_symbols_i < textSymbols.length; src_symbols_i++) {
  var _ch = textSymbols.charAt(src_symbols_i);

  defineSymbol(symbols_text, main, symbols_textord, _ch, _ch);
} // All of these are textords in text mode, and mathords in math mode


var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

for (var symbols_i2 = 0; symbols_i2 < letters.length; symbols_i2++) {
  var _ch2 = letters.charAt(symbols_i2);

  defineSymbol(symbols_math, main, mathord, _ch2, _ch2);
  defineSymbol(symbols_text, main, symbols_textord, _ch2, _ch2);
} // Blackboard bold and script letters in Unicode range


defineSymbol(symbols_math, ams, symbols_textord, "C", "\u2102"); // blackboard bold

defineSymbol(symbols_text, ams, symbols_textord, "C", "\u2102");
defineSymbol(symbols_math, ams, symbols_textord, "H", "\u210D");
defineSymbol(symbols_text, ams, symbols_textord, "H", "\u210D");
defineSymbol(symbols_math, ams, symbols_textord, "N", "\u2115");
defineSymbol(symbols_text, ams, symbols_textord, "N", "\u2115");
defineSymbol(symbols_math, ams, symbols_textord, "P", "\u2119");
defineSymbol(symbols_text, ams, symbols_textord, "P", "\u2119");
defineSymbol(symbols_math, ams, symbols_textord, "Q", "\u211A");
defineSymbol(symbols_text, ams, symbols_textord, "Q", "\u211A");
defineSymbol(symbols_math, ams, symbols_textord, "R", "\u211D");
defineSymbol(symbols_text, ams, symbols_textord, "R", "\u211D");
defineSymbol(symbols_math, ams, symbols_textord, "Z", "\u2124");
defineSymbol(symbols_text, ams, symbols_textord, "Z", "\u2124");
defineSymbol(symbols_math, main, mathord, "h", "\u210E"); // italic h, Planck constant

defineSymbol(symbols_text, main, mathord, "h", "\u210E"); // The next loop loads wide (surrogate pair) characters.
// We support some letters in the Unicode range U+1D400 to U+1D7FF,
// Mathematical Alphanumeric Symbols.
// Some editors do not deal well with wide characters. So don't write the
// string into this file. Instead, create the string from the surrogate pair.

var symbols_wideChar = "";

for (var symbols_i3 = 0; symbols_i3 < letters.length; symbols_i3++) {
  var _ch3 = letters.charAt(symbols_i3); // The hex numbers in the next line are a surrogate pair.
  // 0xD835 is the high surrogate for all letters in the range we support.
  // 0xDC00 is the low surrogate for bold A.


  symbols_wideChar = String.fromCharCode(0xD835, 0xDC00 + symbols_i3); // A-Z a-z bold

  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
  symbols_wideChar = String.fromCharCode(0xD835, 0xDC34 + symbols_i3); // A-Z a-z italic

  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
  symbols_wideChar = String.fromCharCode(0xD835, 0xDC68 + symbols_i3); // A-Z a-z bold italic

  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
  symbols_wideChar = String.fromCharCode(0xD835, 0xDD04 + symbols_i3); // A-Z a-z Fractur

  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
  symbols_wideChar = String.fromCharCode(0xD835, 0xDDA0 + symbols_i3); // A-Z a-z sans-serif

  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
  symbols_wideChar = String.fromCharCode(0xD835, 0xDDD4 + symbols_i3); // A-Z a-z sans bold

  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
  symbols_wideChar = String.fromCharCode(0xD835, 0xDE08 + symbols_i3); // A-Z a-z sans italic

  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
  symbols_wideChar = String.fromCharCode(0xD835, 0xDE70 + symbols_i3); // A-Z a-z monospace

  defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
  defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);

  if (symbols_i3 < 26) {
    // KaTeX fonts have only capital letters for blackboard bold and script.
    // See exception for k below.
    symbols_wideChar = String.fromCharCode(0xD835, 0xDD38 + symbols_i3); // A-Z double struck

    defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
    defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
    symbols_wideChar = String.fromCharCode(0xD835, 0xDC9C + symbols_i3); // A-Z script

    defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
    defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
  } // TODO: Add bold script when it is supported by a KaTeX font.

} // "k" is the only double struck lower case letter in the KaTeX fonts.


symbols_wideChar = String.fromCharCode(0xD835, 0xDD5C); // k double struck

defineSymbol(symbols_math, main, mathord, "k", symbols_wideChar);
defineSymbol(symbols_text, main, symbols_textord, "k", symbols_wideChar); // Next, some wide character numerals

for (var symbols_i4 = 0; symbols_i4 < 10; symbols_i4++) {
  var _ch4 = symbols_i4.toString();

  symbols_wideChar = String.fromCharCode(0xD835, 0xDFCE + symbols_i4); // 0-9 bold

  defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
  defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
  symbols_wideChar = String.fromCharCode(0xD835, 0xDFE2 + symbols_i4); // 0-9 sans serif

  defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
  defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
  symbols_wideChar = String.fromCharCode(0xD835, 0xDFEC + symbols_i4); // 0-9 bold sans

  defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
  defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
  symbols_wideChar = String.fromCharCode(0xD835, 0xDFF6 + symbols_i4); // 0-9 monospace

  defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
  defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
} // We add these Latin-1 letters as symbols for backwards-compatibility,
// but they are not actually in the font, nor are they supported by the
// Unicode accent mechanism, so they fall back to Times font and look ugly.
// TODO(edemaine): Fix this.


var extraLatin = "";

for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
  var _ch5 = extraLatin.charAt(_i5);

  defineSymbol(symbols_math, main, mathord, _ch5, _ch5);
  defineSymbol(symbols_text, main, symbols_textord, _ch5, _ch5);
}

defineSymbol(symbols_text, main, symbols_textord, "", ""); // Unicode versions of existing characters

defineSymbol(symbols_text, main, symbols_textord, "\u2013", "");
defineSymbol(symbols_text, main, symbols_textord, "\u2014", "");
defineSymbol(symbols_text, main, symbols_textord, "\u2018", "");
defineSymbol(symbols_text, main, symbols_textord, "\u2019", "");
defineSymbol(symbols_text, main, symbols_textord, "\u201C", "");
defineSymbol(symbols_text, main, symbols_textord, "\u201D", "");
// CONCATENATED MODULE: ./src/wide-character.js
/**
 * This file provides support for Unicode range U+1D400 to U+1D7FF,
 * Mathematical Alphanumeric Symbols.
 *
 * Function wideCharacterFont takes a wide character as input and returns
 * the font information necessary to render it properly.
 */

/**
 * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf
 * That document sorts characters into groups by font type, say bold or italic.
 *
 * In the arrays below, each subarray consists three elements:
 *      * The CSS class of that group when in math mode.
 *      * The CSS class of that group when in text mode.
 *      * The font name, so that KaTeX can get font metrics.
 */

var wideLatinLetterData = [["mathbf", "textbf", "Main-Bold"], // A-Z bold upright
["mathbf", "textbf", "Main-Bold"], // a-z bold upright
["mathdefault", "textit", "Math-Italic"], // A-Z italic
["mathdefault", "textit", "Math-Italic"], // a-z italic
["boldsymbol", "boldsymbol", "Main-BoldItalic"], // A-Z bold italic
["boldsymbol", "boldsymbol", "Main-BoldItalic"], // a-z bold italic
// Map fancy A-Z letters to script, not calligraphic.
// This aligns with unicode-math and math fonts (except Cambria Math).
["mathscr", "textscr", "Script-Regular"], // A-Z script
["", "", ""], // a-z script.  No font
["", "", ""], // A-Z bold script. No font
["", "", ""], // a-z bold script. No font
["mathfrak", "textfrak", "Fraktur-Regular"], // A-Z Fraktur
["mathfrak", "textfrak", "Fraktur-Regular"], // a-z Fraktur
["mathbb", "textbb", "AMS-Regular"], // A-Z double-struck
["mathbb", "textbb", "AMS-Regular"], // k double-struck
["", "", ""], // A-Z bold Fraktur No font metrics
["", "", ""], // a-z bold Fraktur.   No font.
["mathsf", "textsf", "SansSerif-Regular"], // A-Z sans-serif
["mathsf", "textsf", "SansSerif-Regular"], // a-z sans-serif
["mathboldsf", "textboldsf", "SansSerif-Bold"], // A-Z bold sans-serif
["mathboldsf", "textboldsf", "SansSerif-Bold"], // a-z bold sans-serif
["mathitsf", "textitsf", "SansSerif-Italic"], // A-Z italic sans-serif
["mathitsf", "textitsf", "SansSerif-Italic"], // a-z italic sans-serif
["", "", ""], // A-Z bold italic sans. No font
["", "", ""], // a-z bold italic sans. No font
["mathtt", "texttt", "Typewriter-Regular"], // A-Z monospace
["mathtt", "texttt", "Typewriter-Regular"]];
var wideNumeralData = [["mathbf", "textbf", "Main-Bold"], // 0-9 bold
["", "", ""], // 0-9 double-struck. No KaTeX font.
["mathsf", "textsf", "SansSerif-Regular"], // 0-9 sans-serif
["mathboldsf", "textboldsf", "SansSerif-Bold"], // 0-9 bold sans-serif
["mathtt", "texttt", "Typewriter-Regular"]];
var wide_character_wideCharacterFont = function wideCharacterFont(wideChar, mode) {
  // IE doesn't support codePointAt(). So work with the surrogate pair.
  var H = wideChar.charCodeAt(0); // high surrogate

  var L = wideChar.charCodeAt(1); // low surrogate

  var codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000;
  var j = mode === "math" ? 0 : 1; // column index for CSS class.

  if (0x1D400 <= codePoint && codePoint < 0x1D6A4) {
    // wideLatinLetterData contains exactly 26 chars on each row.
    // So we can calculate the relevant row. No traverse necessary.
    var i = Math.floor((codePoint - 0x1D400) / 26);
    return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
  } else if (0x1D7CE <= codePoint && codePoint <= 0x1D7FF) {
    // Numerals, ten per row.
    var _i = Math.floor((codePoint - 0x1D7CE) / 10);

    return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
  } else if (codePoint === 0x1D6A5 || codePoint === 0x1D6A6) {
    // dotless i or j
    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
  } else if (0x1D6A6 < codePoint && codePoint < 0x1D7CE) {
    // Greek letters. Not supported, yet.
    return ["", ""];
  } else {
    // We don't support any wide characters outside 1D4001D7FF.
    throw new src_ParseError("Unsupported character: " + wideChar);
  }
};
// CONCATENATED MODULE: ./src/Options.js
/**
 * This file contains information about the options that the Parser carries
 * around with it while parsing. Data is held in an `Options` object, and when
 * recursing, a new `Options` object can be created with the `.with*` and
 * `.reset` functions.
 */

var sizeStyleMap = [// Each element contains [textsize, scriptsize, scriptscriptsize].
// The size mappings are taken from TeX with \normalsize=10pt.
[1, 1, 1], // size1: [5, 5, 5]              \tiny
[2, 1, 1], // size2: [6, 5, 5]
[3, 1, 1], // size3: [7, 5, 5]              \scriptsize
[4, 2, 1], // size4: [8, 6, 5]              \footnotesize
[5, 2, 1], // size5: [9, 6, 5]              \small
[6, 3, 1], // size6: [10, 7, 5]             \normalsize
[7, 4, 2], // size7: [12, 8, 6]             \large
[8, 6, 3], // size8: [14.4, 10, 7]          \Large
[9, 7, 6], // size9: [17.28, 12, 10]        \LARGE
[10, 8, 7], // size10: [20.74, 14.4, 12]     \huge
[11, 10, 9]];
var sizeMultipliers = [// fontMetrics.js:getGlobalMetrics also uses size indexes, so if
// you change size indexes, change that function.
0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488];

var sizeAtStyle = function sizeAtStyle(size, style) {
  return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
}; // In these types, "" (empty string) means "no change".


/**
 * This is the main options class. It contains the current style, size, color,
 * and font.
 *
 * Options objects should not be modified. To create a new Options with
 * different properties, call a `.having*` method.
 */
var Options_Options =
/*#__PURE__*/
function () {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm

  /**
   * The base size index.
   */
  function Options(data) {
    this.style = void 0;
    this.color = void 0;
    this.size = void 0;
    this.textSize = void 0;
    this.phantom = void 0;
    this.font = void 0;
    this.fontFamily = void 0;
    this.fontWeight = void 0;
    this.fontShape = void 0;
    this.sizeMultiplier = void 0;
    this.maxSize = void 0;
    this._fontMetrics = void 0;
    this.style = data.style;
    this.color = data.color;
    this.size = data.size || Options.BASESIZE;
    this.textSize = data.textSize || this.size;
    this.phantom = !!data.phantom;
    this.font = data.font || "";
    this.fontFamily = data.fontFamily || "";
    this.fontWeight = data.fontWeight || '';
    this.fontShape = data.fontShape || '';
    this.sizeMultiplier = sizeMultipliers[this.size - 1];
    this.maxSize = data.maxSize;
    this._fontMetrics = undefined;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */


  var _proto = Options.prototype;

  _proto.extend = function extend(extension) {
    var data = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize
    };

    for (var key in extension) {
      if (extension.hasOwnProperty(key)) {
        data[key] = extension[key];
      }
    }

    return new Options(data);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  ;

  _proto.havingStyle = function havingStyle(style) {
    if (this.style === style) {
      return this;
    } else {
      return this.extend({
        style: style,
        size: sizeAtStyle(this.textSize, style)
      });
    }
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  ;

  _proto.havingCrampedStyle = function havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  ;

  _proto.havingSize = function havingSize(size) {
    if (this.size === size && this.textSize === size) {
      return this;
    } else {
      return this.extend({
        style: this.style.text(),
        size: size,
        textSize: size,
        sizeMultiplier: sizeMultipliers[size - 1]
      });
    }
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  ;

  _proto.havingBaseStyle = function havingBaseStyle(style) {
    style = style || this.style.text();
    var wantSize = sizeAtStyle(Options.BASESIZE, style);

    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
      return this;
    } else {
      return this.extend({
        style: style,
        size: wantSize
      });
    }
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  ;

  _proto.havingBaseSizing = function havingBaseSizing() {
    var size;

    switch (this.style.id) {
      case 4:
      case 5:
        size = 3; // normalsize in scriptstyle

        break;

      case 6:
      case 7:
        size = 1; // normalsize in scriptscriptstyle

        break;

      default:
        size = 6;
      // normalsize in textstyle or displaystyle
    }

    return this.extend({
      style: this.style.text(),
      size: size
    });
  }
  /**
   * Create a new options object with the given color.
   */
  ;

  _proto.withColor = function withColor(color) {
    return this.extend({
      color: color
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  ;

  _proto.withPhantom = function withPhantom() {
    return this.extend({
      phantom: true
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  ;

  _proto.withFont = function withFont(font) {
    return this.extend({
      font: font
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  ;

  _proto.withTextFontFamily = function withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily: fontFamily,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  ;

  _proto.withTextFontWeight = function withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight: fontWeight,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  ;

  _proto.withTextFontShape = function withTextFontShape(fontShape) {
    return this.extend({
      fontShape: fontShape,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  ;

  _proto.sizingClasses = function sizingClasses(oldOptions) {
    if (oldOptions.size !== this.size) {
      return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
    } else {
      return [];
    }
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  ;

  _proto.baseSizingClasses = function baseSizingClasses() {
    if (this.size !== Options.BASESIZE) {
      return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
    } else {
      return [];
    }
  }
  /**
   * Return the font metrics for this size.
   */
  ;

  _proto.fontMetrics = function fontMetrics() {
    if (!this._fontMetrics) {
      this._fontMetrics = getGlobalMetrics(this.size);
    }

    return this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  ;

  _proto.getColor = function getColor() {
    if (this.phantom) {
      return "transparent";
    } else {
      return this.color;
    }
  };

  return Options;
}();

Options_Options.BASESIZE = 6;
/* harmony default export */ var src_Options = (Options_Options);
// CONCATENATED MODULE: ./src/units.js
/**
 * This file does conversion between units.  In particular, it provides
 * calculateSize to convert other units into ems.
 */

 // This table gives the number of TeX pts in one of each *absolute* TeX unit.
// Thus, multiplying a length by this number converts the length from units
// into pts.  Dividing the result by ptPerEm gives the number of ems
// *assuming* a font size of ptPerEm (normal size, normal style).

var ptPerUnit = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  "pt": 1,
  // TeX point
  "mm": 7227 / 2540,
  // millimeter
  "cm": 7227 / 254,
  // centimeter
  "in": 72.27,
  // inch
  "bp": 803 / 800,
  // big (PostScript) points
  "pc": 12,
  // pica
  "dd": 1238 / 1157,
  // didot
  "cc": 14856 / 1157,
  // cicero (12 didot)
  "nd": 685 / 642,
  // new didot
  "nc": 1370 / 107,
  // new cicero (12 new didot)
  "sp": 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  "px": 803 / 800 // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX

}; // Dictionary of relative units, for fast validity testing.

var relativeUnit = {
  "ex": true,
  "em": true,
  "mu": true
};

/**
 * Determine whether the specified unit (either a string defining the unit
 * or a "size" parse node containing a unit field) is valid.
 */
var validUnit = function validUnit(unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }

  return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
};
/*
 * Convert a "size" parse node (with numeric "number" and string "unit" fields,
 * as parsed by functions.js argType "size") into a CSS em value for the
 * current style/scale.  `options` gives the current options.
 */

var units_calculateSize = function calculateSize(sizeValue, options) {
  var scale;

  if (sizeValue.unit in ptPerUnit) {
    // Absolute units
    scale = ptPerUnit[sizeValue.unit] // Convert unit to pt
    / options.fontMetrics().ptPerEm // Convert pt to CSS em
    / options.sizeMultiplier; // Unscale to make absolute units
  } else if (sizeValue.unit === "mu") {
    // `mu` units scale with scriptstyle/scriptscriptstyle.
    scale = options.fontMetrics().cssEmPerMu;
  } else {
    // Other relative units always refer to the *textstyle* font
    // in the current size.
    var unitOptions;

    if (options.style.isTight()) {
      // isTight() means current style is script/scriptscript.
      unitOptions = options.havingStyle(options.style.text());
    } else {
      unitOptions = options;
    } // TODO: In TeX these units are relative to the quad of the current
    // *text* font, e.g. cmr10. KaTeX instead uses values from the
    // comparably-sized *Computer Modern symbol* font. At 10pt, these
    // match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;
    // cmr5=1.361133, cmsy5=1.472241. Consider $\scriptsize a\kern1emb$.
    // TeX \showlists shows a kern of 1.13889 * fontsize;
    // KaTeX shows a kern of 1.171 * fontsize.


    if (sizeValue.unit === "ex") {
      scale = unitOptions.fontMetrics().xHeight;
    } else if (sizeValue.unit === "em") {
      scale = unitOptions.fontMetrics().quad;
    } else {
      throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
    }

    if (unitOptions !== options) {
      scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
    }
  }

  return Math.min(sizeValue.number * scale, options.maxSize);
};
// CONCATENATED MODULE: ./src/buildCommon.js
/* eslint no-console:0 */

/**
 * This module contains general functions that can be used for building
 * different kinds of domTree nodes in a consistent manner.
 */







// The following have to be loaded from Main-Italic font, using class mathit
var mathitLetters = ["\\imath", "", // dotless i
"\\jmath", "", // dotless j
"\\pounds", "\\mathsterling", "\\textsterling", ""];
/**
 * Looks up the given symbol in fontMetrics, after applying any symbol
 * replacements defined in symbol.js
 */

var buildCommon_lookupSymbol = function lookupSymbol(value, // TODO(#963): Use a union type for this.
fontName, mode) {
  // Replace the value with its replaced value from symbol.js
  if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
    value = src_symbols[mode][value].replace;
  }

  return {
    value: value,
    metrics: getCharacterMetrics(value, fontName, mode)
  };
};
/**
 * Makes a symbolNode after translation via the list of symbols in symbols.js.
 * Correctly pulls out metrics for the character, and optionally takes a list of
 * classes to be attached to the node.
 *
 * TODO: make argument order closer to makeSpan
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 * TODO(#953): Make `options` mandatory and always pass it in.
 */


var buildCommon_makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {
  var lookup = buildCommon_lookupSymbol(value, fontName, mode);
  var metrics = lookup.metrics;
  value = lookup.value;
  var symbolNode;

  if (metrics) {
    var italic = metrics.italic;

    if (mode === "text" || options && options.font === "mathit") {
      italic = 0;
    }

    symbolNode = new domTree_SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
  } else {
    // TODO(emily): Figure out a good way to only print this in development
    typeof console !== "undefined" && console.warn("No character metrics for '" + value + "' in style '" + fontName + "'");
    symbolNode = new domTree_SymbolNode(value, 0, 0, 0, 0, 0, classes);
  }

  if (options) {
    symbolNode.maxFontSize = options.sizeMultiplier;

    if (options.style.isTight()) {
      symbolNode.classes.push("mtight");
    }

    var color = options.getColor();

    if (color) {
      symbolNode.style.color = color;
    }
  }

  return symbolNode;
};
/**
 * Makes a symbol in Main-Regular or AMS-Regular.
 * Used for rel, bin, open, close, inner, and punct.
 *
 * TODO(#953): Make `options` mandatory and always pass it in.
 */


var buildCommon_mathsym = function mathsym(value, mode, options, classes) {
  if (classes === void 0) {
    classes = [];
  }

  // Decide what font to render the symbol in by its entry in the symbols
  // table.
  // Have a special case for when the value = \ because the \ is used as a
  // textord in unsupported command errors but cannot be parsed as a regular
  // text ordinal and is therefore not present as a symbol in the symbols
  // table for text, as well as a special case for boldsymbol because it
  // can be used for bold + and -
  if (options && options.font && options.font === "boldsymbol" && buildCommon_lookupSymbol(value, "Main-Bold", mode).metrics) {
    return buildCommon_makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
  } else if (value === "\\" || src_symbols[mode][value].font === "main") {
    return buildCommon_makeSymbol(value, "Main-Regular", mode, options, classes);
  } else {
    return buildCommon_makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
  }
};
/**
 * Determines which of the two font names (Main-Italic and Math-Italic) and
 * corresponding style tags (maindefault or mathit) to use for default math font,
 * depending on the symbol.
 */


var buildCommon_mathdefault = function mathdefault(value, mode, options, classes) {
  if (/[0-9]/.test(value.charAt(0)) || // glyphs for \imath and \jmath do not exist in Math-Italic so we
  // need to use Main-Italic instead
  utils.contains(mathitLetters, value)) {
    return {
      fontName: "Main-Italic",
      fontClass: "mathit"
    };
  } else {
    return {
      fontName: "Math-Italic",
      fontClass: "mathdefault"
    };
  }
};
/**
 * Determines which of the font names (Main-Italic, Math-Italic, and Caligraphic)
 * and corresponding style tags (mathit, mathdefault, or mathcal) to use for font
 * "mathnormal", depending on the symbol.  Use this function instead of fontMap for
 * font "mathnormal".
 */


var buildCommon_mathnormal = function mathnormal(value, mode, options, classes) {
  if (utils.contains(mathitLetters, value)) {
    return {
      fontName: "Main-Italic",
      fontClass: "mathit"
    };
  } else if (/[0-9]/.test(value.charAt(0))) {
    return {
      fontName: "Caligraphic-Regular",
      fontClass: "mathcal"
    };
  } else {
    return {
      fontName: "Math-Italic",
      fontClass: "mathdefault"
    };
  }
};
/**
 * Determines which of the two font names (Main-Bold and Math-BoldItalic) and
 * corresponding style tags (mathbf or boldsymbol) to use for font "boldsymbol",
 * depending on the symbol.  Use this function instead of fontMap for font
 * "boldsymbol".
 */


var boldsymbol = function boldsymbol(value, mode, options, classes) {
  if (buildCommon_lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
    return {
      fontName: "Math-BoldItalic",
      fontClass: "boldsymbol"
    };
  } else {
    // Some glyphs do not exist in Math-BoldItalic so we need to use
    // Main-Bold instead.
    return {
      fontName: "Main-Bold",
      fontClass: "mathbf"
    };
  }
};
/**
 * Makes either a mathord or textord in the correct font and color.
 */


var buildCommon_makeOrd = function makeOrd(group, options, type) {
  var mode = group.mode;
  var text = group.text;
  var classes = ["mord"]; // Math mode or Old font (i.e. \rm)

  var isFont = mode === "math" || mode === "text" && options.font;
  var fontOrFamily = isFont ? options.font : options.fontFamily;

  if (text.charCodeAt(0) === 0xD835) {
    // surrogate pairs get special treatment
    var _wideCharacterFont = wide_character_wideCharacterFont(text, mode),
        wideFontName = _wideCharacterFont[0],
        wideFontClass = _wideCharacterFont[1];

    return buildCommon_makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));
  } else if (fontOrFamily) {
    var fontName;
    var fontClasses;

    if (fontOrFamily === "boldsymbol" || fontOrFamily === "mathnormal") {
      var fontData = fontOrFamily === "boldsymbol" ? boldsymbol(text, mode, options, classes) : buildCommon_mathnormal(text, mode, options, classes);
      fontName = fontData.fontName;
      fontClasses = [fontData.fontClass];
    } else if (utils.contains(mathitLetters, text)) {
      fontName = "Main-Italic";
      fontClasses = ["mathit"];
    } else if (isFont) {
      fontName = fontMap[fontOrFamily].fontName;
      fontClasses = [fontOrFamily];
    } else {
      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
    }

    if (buildCommon_lookupSymbol(text, fontName, mode).metrics) {
      return buildCommon_makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));
    } else if (ligatures.hasOwnProperty(text) && fontName.substr(0, 10) === "Typewriter") {
      // Deconstruct ligatures in monospace fonts (\texttt, \tt).
      var parts = [];

      for (var i = 0; i < text.length; i++) {
        parts.push(buildCommon_makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));
      }

      return buildCommon_makeFragment(parts);
    }
  } // Makes a symbol in the default font for mathords and textords.


  if (type === "mathord") {
    var fontLookup = buildCommon_mathdefault(text, mode, options, classes);
    return buildCommon_makeSymbol(text, fontLookup.fontName, mode, options, classes.concat([fontLookup.fontClass]));
  } else if (type === "textord") {
    var font = src_symbols[mode][text] && src_symbols[mode][text].font;

    if (font === "ams") {
      var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);

      return buildCommon_makeSymbol(text, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
    } else if (font === "main" || !font) {
      var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);

      return buildCommon_makeSymbol(text, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
    } else {
      // fonts added by plugins
      var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape); // We add font name as a css class


      return buildCommon_makeSymbol(text, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
    }
  } else {
    throw new Error("unexpected type: " + type + " in makeOrd");
  }
};
/**
 * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,
 * and styles.
 */


var buildCommon_canCombine = function canCombine(prev, next) {
  if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
    return false;
  }

  for (var style in prev.style) {
    if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
      return false;
    }
  }

  for (var _style in next.style) {
    if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
      return false;
    }
  }

  return true;
};
/**
 * Combine consequetive domTree.symbolNodes into a single symbolNode.
 * Note: this function mutates the argument.
 */


var buildCommon_tryCombineChars = function tryCombineChars(chars) {
  for (var i = 0; i < chars.length - 1; i++) {
    var prev = chars[i];
    var next = chars[i + 1];

    if (prev instanceof domTree_SymbolNode && next instanceof domTree_SymbolNode && buildCommon_canCombine(prev, next)) {
      prev.text += next.text;
      prev.height = Math.max(prev.height, next.height);
      prev.depth = Math.max(prev.depth, next.depth); // Use the last character's italic correction since we use
      // it to add padding to the right of the span created from
      // the combined characters.

      prev.italic = next.italic;
      chars.splice(i + 1, 1);
      i--;
    }
  }

  return chars;
};
/**
 * Calculate the height, depth, and maxFontSize of an element based on its
 * children.
 */


var sizeElementFromChildren = function sizeElementFromChildren(elem) {
  var height = 0;
  var depth = 0;
  var maxFontSize = 0;

  for (var i = 0; i < elem.children.length; i++) {
    var child = elem.children[i];

    if (child.height > height) {
      height = child.height;
    }

    if (child.depth > depth) {
      depth = child.depth;
    }

    if (child.maxFontSize > maxFontSize) {
      maxFontSize = child.maxFontSize;
    }
  }

  elem.height = height;
  elem.depth = depth;
  elem.maxFontSize = maxFontSize;
};
/**
 * Makes a span with the given list of classes, list of children, and options.
 *
 * TODO(#953): Ensure that `options` is always provided (currently some call
 * sites don't pass it) and make the type below mandatory.
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */


var buildCommon_makeSpan = function makeSpan(classes, children, options, style) {
  var span = new domTree_Span(classes, children, options, style);
  sizeElementFromChildren(span);
  return span;
}; // SVG one is simpler -- doesn't require height, depth, max-font setting.
// This is also a separate method for typesafety.


var buildCommon_makeSvgSpan = function makeSvgSpan(classes, children, options, style) {
  return new domTree_Span(classes, children, options, style);
};

var makeLineSpan = function makeLineSpan(className, options, thickness) {
  var line = buildCommon_makeSpan([className], [], options);
  line.height = thickness || options.fontMetrics().defaultRuleThickness;
  line.style.borderBottomWidth = line.height + "em";
  line.maxFontSize = 1.0;
  return line;
};
/**
 * Makes an anchor with the given href, list of classes, list of children,
 * and options.
 */


var buildCommon_makeAnchor = function makeAnchor(href, classes, children, options) {
  var anchor = new domTree_Anchor(href, classes, children, options);
  sizeElementFromChildren(anchor);
  return anchor;
};
/**
 * Makes a document fragment with the given list of children.
 */


var buildCommon_makeFragment = function makeFragment(children) {
  var fragment = new tree_DocumentFragment(children);
  sizeElementFromChildren(fragment);
  return fragment;
};
/**
 * Wraps group in a span if it's a document fragment, allowing to apply classes
 * and styles
 */


var buildCommon_wrapFragment = function wrapFragment(group, options) {
  if (group instanceof tree_DocumentFragment) {
    return buildCommon_makeSpan([], [group], options);
  }

  return group;
}; // These are exact object types to catch typos in the names of the optional fields.


// Computes the updated `children` list and the overall depth.
//
// This helper function for makeVList makes it easier to enforce type safety by
// allowing early exits (returns) in the logic.
var getVListChildrenAndDepth = function getVListChildrenAndDepth(params) {
  if (params.positionType === "individualShift") {
    var oldChildren = params.children;
    var children = [oldChildren[0]]; // Add in kerns to the list of params.children to get each element to be
    // shifted to the correct specified shift

    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;

    var currPos = _depth;

    for (var i = 1; i < oldChildren.length; i++) {
      var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
      var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
      currPos = currPos + diff;
      children.push({
        type: "kern",
        size: size
      });
      children.push(oldChildren[i]);
    }

    return {
      children: children,
      depth: _depth
    };
  }

  var depth;

  if (params.positionType === "top") {
    // We always start at the bottom, so calculate the bottom by adding up
    // all the sizes
    var bottom = params.positionData;

    for (var _i = 0; _i < params.children.length; _i++) {
      var child = params.children[_i];
      bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
    }

    depth = bottom;
  } else if (params.positionType === "bottom") {
    depth = -params.positionData;
  } else {
    var firstChild = params.children[0];

    if (firstChild.type !== "elem") {
      throw new Error('First child must have type "elem".');
    }

    if (params.positionType === "shift") {
      depth = -firstChild.elem.depth - params.positionData;
    } else if (params.positionType === "firstBaseline") {
      depth = -firstChild.elem.depth;
    } else {
      throw new Error("Invalid positionType " + params.positionType + ".");
    }
  }

  return {
    children: params.children,
    depth: depth
  };
};
/**
 * Makes a vertical list by stacking elements and kerns on top of each other.
 * Allows for many different ways of specifying the positioning method.
 *
 * See VListParam documentation above.
 */


var buildCommon_makeVList = function makeVList(params, options) {
  var _getVListChildrenAndD = getVListChildrenAndDepth(params),
      children = _getVListChildrenAndD.children,
      depth = _getVListChildrenAndD.depth; // Create a strut that is taller than any list item. The strut is added to
  // each item, where it will determine the item's baseline. Since it has
  // `overflow:hidden`, the strut's top edge will sit on the item's line box's
  // top edge and the strut's bottom edge will sit on the item's baseline,
  // with no additional line-height spacing. This allows the item baseline to
  // be positioned precisely without worrying about font ascent and
  // line-height.


  var pstrutSize = 0;

  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    if (child.type === "elem") {
      var elem = child.elem;
      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
    }
  }

  pstrutSize += 2;
  var pstrut = buildCommon_makeSpan(["pstrut"], []);
  pstrut.style.height = pstrutSize + "em"; // Create a new list of actual children at the correct offsets

  var realChildren = [];
  var minPos = depth;
  var maxPos = depth;
  var currPos = depth;

  for (var _i2 = 0; _i2 < children.length; _i2++) {
    var _child = children[_i2];

    if (_child.type === "kern") {
      currPos += _child.size;
    } else {
      var _elem = _child.elem;
      var classes = _child.wrapperClasses || [];
      var style = _child.wrapperStyle || {};
      var childWrap = buildCommon_makeSpan(classes, [pstrut, _elem], undefined, style);
      childWrap.style.top = -pstrutSize - currPos - _elem.depth + "em";

      if (_child.marginLeft) {
        childWrap.style.marginLeft = _child.marginLeft;
      }

      if (_child.marginRight) {
        childWrap.style.marginRight = _child.marginRight;
      }

      realChildren.push(childWrap);
      currPos += _elem.height + _elem.depth;
    }

    minPos = Math.min(minPos, currPos);
    maxPos = Math.max(maxPos, currPos);
  } // The vlist contents go in a table-cell with `vertical-align:bottom`.
  // This cell's bottom edge will determine the containing table's baseline
  // without overly expanding the containing line-box.


  var vlist = buildCommon_makeSpan(["vlist"], realChildren);
  vlist.style.height = maxPos + "em"; // A second row is used if necessary to represent the vlist's depth.

  var rows;

  if (minPos < 0) {
    // We will define depth in an empty span with display: table-cell.
    // It should render with the height that we define. But Chrome, in
    // contenteditable mode only, treats that span as if it contains some
    // text content. And that min-height over-rides our desired height.
    // So we put another empty span inside the depth strut span.
    var emptySpan = buildCommon_makeSpan([], []);
    var depthStrut = buildCommon_makeSpan(["vlist"], [emptySpan]);
    depthStrut.style.height = -minPos + "em"; // Safari wants the first row to have inline content; otherwise it
    // puts the bottom of the *second* row on the baseline.

    var topStrut = buildCommon_makeSpan(["vlist-s"], [new domTree_SymbolNode("\u200B")]);
    rows = [buildCommon_makeSpan(["vlist-r"], [vlist, topStrut]), buildCommon_makeSpan(["vlist-r"], [depthStrut])];
  } else {
    rows = [buildCommon_makeSpan(["vlist-r"], [vlist])];
  }

  var vtable = buildCommon_makeSpan(["vlist-t"], rows);

  if (rows.length === 2) {
    vtable.classes.push("vlist-t2");
  }

  vtable.height = maxPos;
  vtable.depth = -minPos;
  return vtable;
}; // Glue is a concept from TeX which is a flexible space between elements in
// either a vertical or horizontal list. In KaTeX, at least for now, it's
// static space between elements in a horizontal layout.


var buildCommon_makeGlue = function makeGlue(measurement, options) {
  // Make an empty span for the space
  var rule = buildCommon_makeSpan(["mspace"], [], options);
  var size = units_calculateSize(measurement, options);
  rule.style.marginRight = size + "em";
  return rule;
}; // Takes font options, and returns the appropriate fontLookup name


var retrieveTextFontName = function retrieveTextFontName(fontFamily, fontWeight, fontShape) {
  var baseFontName = "";

  switch (fontFamily) {
    case "amsrm":
      baseFontName = "AMS";
      break;

    case "textrm":
      baseFontName = "Main";
      break;

    case "textsf":
      baseFontName = "SansSerif";
      break;

    case "texttt":
      baseFontName = "Typewriter";
      break;

    default:
      baseFontName = fontFamily;
    // use fonts added by a plugin
  }

  var fontStylesName;

  if (fontWeight === "textbf" && fontShape === "textit") {
    fontStylesName = "BoldItalic";
  } else if (fontWeight === "textbf") {
    fontStylesName = "Bold";
  } else if (fontWeight === "textit") {
    fontStylesName = "Italic";
  } else {
    fontStylesName = "Regular";
  }

  return baseFontName + "-" + fontStylesName;
};
/**
 * Maps TeX font commands to objects containing:
 * - variant: string used for "mathvariant" attribute in buildMathML.js
 * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
 */
// A map between tex font commands an MathML mathvariant attribute values


var fontMap = {
  // styles
  "mathbf": {
    variant: "bold",
    fontName: "Main-Bold"
  },
  "mathrm": {
    variant: "normal",
    fontName: "Main-Regular"
  },
  "textit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  // Default math font, "mathnormal" and "boldsymbol" are missing because they
  // require the use of several fonts: Main-Italic and Math-Italic for default
  // math font, Main-Italic, Math-Italic, Caligraphic for "mathnormal", and
  // Math-BoldItalic and Main-Bold for "boldsymbol".  This is handled by a
  // special case in makeOrd which ends up calling mathdefault, mathnormal,
  // and boldsymbol.
  // families
  "mathbb": {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  "mathcal": {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  "mathfrak": {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  "mathscr": {
    variant: "script",
    fontName: "Script-Regular"
  },
  "mathsf": {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  "mathtt": {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
};
var svgData = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
};

var buildCommon_staticSvg = function staticSvg(value, options) {
  // Create a span with inline SVG for the element.
  var _svgData$value = svgData[value],
      pathName = _svgData$value[0],
      width = _svgData$value[1],
      height = _svgData$value[2];
  var path = new domTree_PathNode(pathName);
  var svgNode = new SvgNode([path], {
    "width": width + "em",
    "height": height + "em",
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + width + "em",
    "viewBox": "0 0 " + 1000 * width + " " + 1000 * height,
    "preserveAspectRatio": "xMinYMin"
  });
  var span = buildCommon_makeSvgSpan(["overlay"], [svgNode], options);
  span.height = height;
  span.style.height = height + "em";
  span.style.width = width + "em";
  return span;
};

/* harmony default export */ var buildCommon = ({
  fontMap: fontMap,
  makeSymbol: buildCommon_makeSymbol,
  mathsym: buildCommon_mathsym,
  makeSpan: buildCommon_makeSpan,
  makeSvgSpan: buildCommon_makeSvgSpan,
  makeLineSpan: makeLineSpan,
  makeAnchor: buildCommon_makeAnchor,
  makeFragment: buildCommon_makeFragment,
  wrapFragment: buildCommon_wrapFragment,
  makeVList: buildCommon_makeVList,
  makeOrd: buildCommon_makeOrd,
  makeGlue: buildCommon_makeGlue,
  staticSvg: buildCommon_staticSvg,
  svgData: svgData,
  tryCombineChars: buildCommon_tryCombineChars
});
// CONCATENATED MODULE: ./src/parseNode.js


/**
 * Asserts that the node is of the given type and returns it with stricter
 * typing. Throws if the node's type does not match.
 */
function assertNodeType(node, type) {
  var typedNode = checkNodeType(node, type);

  if (!typedNode) {
    throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
  } // $FlowFixMe: Unsure why.


  return typedNode;
}
/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */

function checkNodeType(node, type) {
  if (node && node.type === type) {
    // The definition of ParseNode<TYPE> doesn't communicate to flow that
    // `type: TYPE` (as that's not explicitly mentioned anywhere), though that
    // happens to be true for all our value types.
    // $FlowFixMe
    return node;
  }

  return null;
}
/**
 * Asserts that the node is of the given type and returns it with stricter
 * typing. Throws if the node's type does not match.
 */

function assertAtomFamily(node, family) {
  var typedNode = checkAtomFamily(node, family);

  if (!typedNode) {
    throw new Error("Expected node of type \"atom\" and family \"" + family + "\", but got " + (node ? node.type === "atom" ? "atom of family " + node.family : "node of type " + node.type : String(node)));
  }

  return typedNode;
}
/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */

function checkAtomFamily(node, family) {
  return node && node.type === "atom" && node.family === family ? node : null;
}
/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */

function assertSymbolNodeType(node) {
  var typedNode = checkSymbolNodeType(node);

  if (!typedNode) {
    throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
  }

  return typedNode;
}
/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */

function checkSymbolNodeType(node) {
  if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
    // $FlowFixMe
    return node;
  }

  return null;
}
// CONCATENATED MODULE: ./src/spacingData.js
/**
 * Describes spaces between different classes of atoms.
 */
var thinspace = {
  number: 3,
  unit: "mu"
};
var mediumspace = {
  number: 4,
  unit: "mu"
};
var thickspace = {
  number: 5,
  unit: "mu"
}; // Making the type below exact with all optional fields doesn't work due to
// - https://github.com/facebook/flow/issues/4582
// - https://github.com/facebook/flow/issues/5688
// However, since *all* fields are optional, $Shape<> works as suggested in 5688
// above.

// Spacing relationships for display and text styles
var spacings = {
  mord: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    minner: thinspace
  },
  mbin: {
    mord: mediumspace,
    mop: mediumspace,
    mopen: mediumspace,
    minner: mediumspace
  },
  mrel: {
    mord: thickspace,
    mop: thickspace,
    mopen: thickspace,
    minner: thickspace
  },
  mopen: {},
  mclose: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mpunct: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    mopen: thinspace,
    mclose: thinspace,
    mpunct: thinspace,
    minner: thinspace
  },
  minner: {
    mord: thinspace,
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    mopen: thinspace,
    mpunct: thinspace,
    minner: thinspace
  }
}; // Spacing relationships for script and scriptscript styles

var tightSpacings = {
  mord: {
    mop: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: thinspace
  },
  mpunct: {},
  minner: {
    mop: thinspace
  }
};
// CONCATENATED MODULE: ./src/defineFunction.js


/**
 * All registered functions.
 * `functions.js` just exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary.
 */
var _functions = {};
/**
 * All HTML builders. Should be only used in the `define*` and the `build*ML`
 * functions.
 */

var _htmlGroupBuilders = {};
/**
 * All MathML builders. Should be only used in the `define*` and the `build*ML`
 * functions.
 */

var _mathmlGroupBuilders = {};
function defineFunction(_ref) {
  var type = _ref.type,
      nodeType = _ref.nodeType,
      names = _ref.names,
      props = _ref.props,
      handler = _ref.handler,
      htmlBuilder = _ref.htmlBuilder,
      mathmlBuilder = _ref.mathmlBuilder;
  // Set default values of functions
  var data = {
    type: type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    greediness: props.greediness === undefined ? 1 : props.greediness,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    consumeMode: props.consumeMode,
    handler: handler
  };

  for (var i = 0; i < names.length; ++i) {
    // TODO: The value type of _functions should be a type union of all
    // possible `FunctionSpec<>` possibilities instead of `FunctionSpec<*>`,
    // which is an existential type.
    // $FlowFixMe
    _functions[names[i]] = data;
  }

  if (type) {
    if (htmlBuilder) {
      _htmlGroupBuilders[type] = htmlBuilder;
    }

    if (mathmlBuilder) {
      _mathmlGroupBuilders[type] = mathmlBuilder;
    }
  }
}
/**
 * Use this to register only the HTML and MathML builders for a function (e.g.
 * if the function's ParseNode is generated in Parser.js rather than via a
 * stand-alone handler provided to `defineFunction`).
 */

function defineFunctionBuilders(_ref2) {
  var type = _ref2.type,
      htmlBuilder = _ref2.htmlBuilder,
      mathmlBuilder = _ref2.mathmlBuilder;
  defineFunction({
    type: type,
    names: [],
    props: {
      numArgs: 0
    },
    handler: function handler() {
      throw new Error('Should never be called.');
    },
    htmlBuilder: htmlBuilder,
    mathmlBuilder: mathmlBuilder
  });
} // Since the corresponding buildHTML/buildMathML function expects a
// list of elements, we normalize for different kinds of arguments

var defineFunction_ordargument = function ordargument(arg) {
  var node = checkNodeType(arg, "ordgroup");
  return node ? node.body : [arg];
};
// CONCATENATED MODULE: ./src/buildHTML.js
/**
 * This file does the main work of building a domTree structure from a parse
 * tree. The entry point is the `buildHTML` function, which takes a parse tree.
 * Then, the buildExpression, buildGroup, and various groupBuilders functions
 * are called, to produce a final HTML tree.
 */









var buildHTML_makeSpan = buildCommon.makeSpan; // Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
// and the text before Rule 19.

var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
var buildHTML_styleMap = {
  "display": src_Style.DISPLAY,
  "text": src_Style.TEXT,
  "script": src_Style.SCRIPT,
  "scriptscript": src_Style.SCRIPTSCRIPT
};
var DomEnum = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
};

/**
 * Take a list of nodes, build them in order, and return a list of the built
 * nodes. documentFragments are flattened into their contents, so the
 * returned list contains no fragments. `isRealGroup` is true if `expression`
 * is a real group (no atoms will be added on either side), as opposed to
 * a partial group (e.g. one created by \color). `surrounding` is an array
 * consisting type of nodes that will be added to the left and right.
 */
var buildHTML_buildExpression = function buildExpression(expression, options, isRealGroup, surrounding) {
  if (surrounding === void 0) {
    surrounding = [null, null];
  }

  // Parse expressions into `groups`.
  var groups = [];

  for (var i = 0; i < expression.length; i++) {
    var output = buildHTML_buildGroup(expression[i], options);

    if (output instanceof tree_DocumentFragment) {
      var children = output.children;
      groups.push.apply(groups, children);
    } else {
      groups.push(output);
    }
  } // If `expression` is a partial group, let the parent handle spacings
  // to avoid processing groups multiple times.


  if (!isRealGroup) {
    return groups;
  }

  var glueOptions = options;

  if (expression.length === 1) {
    var node = checkNodeType(expression[0], "sizing") || checkNodeType(expression[0], "styling");

    if (!node) {// No match.
    } else if (node.type === "sizing") {
      glueOptions = options.havingSize(node.size);
    } else if (node.type === "styling") {
      glueOptions = options.havingStyle(buildHTML_styleMap[node.style]);
    }
  } // Dummy spans for determining spacings between surrounding atoms.
  // If `expression` has no atoms on the left or right, class "leftmost"
  // or "rightmost", respectively, is used to indicate it.


  var dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
  var dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options); // TODO: These code assumes that a node's math class is the first element
  // of its `classes` array. A later cleanup should ensure this, for
  // instance by changing the signature of `makeSpan`.
  // Before determining what spaces to insert, perform bin cancellation.
  // Binary operators change to ordinary symbols in some contexts.

  traverseNonSpaceNodes(groups, function (node, prev) {
    var prevType = prev.classes[0];
    var type = node.classes[0];

    if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
      prev.classes[0] = "mord";
    } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
      node.classes[0] = "mord";
    }
  }, {
    node: dummyPrev
  }, dummyNext);
  traverseNonSpaceNodes(groups, function (node, prev) {
    var prevType = getTypeOfDomTree(prev);
    var type = getTypeOfDomTree(node); // 'mtight' indicates that the node is script or scriptscript style.

    var space = prevType && type ? node.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;

    if (space) {
      // Insert glue (spacing) after the `prev`.
      return buildCommon.makeGlue(space, glueOptions);
    }
  }, {
    node: dummyPrev
  }, dummyNext);
  return groups;
}; // Depth-first traverse non-space `nodes`, calling `callback` with the current and
// previous node as arguments, optionally returning a node to insert after the
// previous node. `prev` is an object with the previous node and `insertAfter`
// function to insert after it. `next` is a node that will be added to the right.
// Used for bin cancellation and inserting spacings.

var traverseNonSpaceNodes = function traverseNonSpaceNodes(nodes, callback, prev, next) {
  if (next) {
    // temporarily append the right node, if exists
    nodes.push(next);
  }

  var i = 0;

  for (; i < nodes.length; i++) {
    var node = nodes[i];
    var partialGroup = buildHTML_checkPartialGroup(node);

    if (partialGroup) {
      // Recursive DFS
      traverseNonSpaceNodes(partialGroup.children, callback, prev);
      continue;
    } // Ignore explicit spaces (e.g., \;, \,) when determining what implicit
    // spacing should go between atoms of different classes


    if (node.classes[0] === "mspace") {
      continue;
    }

    var result = callback(node, prev.node);

    if (result) {
      if (prev.insertAfter) {
        prev.insertAfter(result);
      } else {
        // insert at front
        nodes.unshift(result);
        i++;
      }
    }

    prev.node = node;

    prev.insertAfter = function (index) {
      return function (n) {
        nodes.splice(index + 1, 0, n);
        i++;
      };
    }(i);
  }

  if (next) {
    nodes.pop();
  }
}; // Check if given node is a partial group, i.e., does not affect spacing around.


var buildHTML_checkPartialGroup = function checkPartialGroup(node) {
  if (node instanceof tree_DocumentFragment || node instanceof domTree_Anchor) {
    return node;
  }

  return null;
}; // Return the outermost node of a domTree.


var getOutermostNode = function getOutermostNode(node, side) {
  var partialGroup = buildHTML_checkPartialGroup(node);

  if (partialGroup) {
    var children = partialGroup.children;

    if (children.length) {
      if (side === "right") {
        return getOutermostNode(children[children.length - 1], "right");
      } else if (side === "left") {
        return getOutermostNode(children[0], "left");
      }
    }
  }

  return node;
}; // Return math atom class (mclass) of a domTree.
// If `side` is given, it will get the type of the outermost node at given side.


var getTypeOfDomTree = function getTypeOfDomTree(node, side) {
  if (!node) {
    return null;
  }

  if (side) {
    node = getOutermostNode(node, side);
  } // This makes a lot of assumptions as to where the type of atom
  // appears.  We should do a better job of enforcing this.


  return DomEnum[node.classes[0]] || null;
};
var makeNullDelimiter = function makeNullDelimiter(options, classes) {
  var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
  return buildHTML_makeSpan(classes.concat(moreClasses));
};
/**
 * buildGroup is the function that takes a group and calls the correct groupType
 * function for it. It also handles the interaction of size and style changes
 * between parents and children.
 */

var buildHTML_buildGroup = function buildGroup(group, options, baseOptions) {
  if (!group) {
    return buildHTML_makeSpan();
  }

  if (_htmlGroupBuilders[group.type]) {
    // Call the groupBuilders function
    var groupNode = _htmlGroupBuilders[group.type](group, options); // If the size changed between the parent and the current group, account
    // for that size difference.

    if (baseOptions && options.size !== baseOptions.size) {
      groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
      groupNode.height *= multiplier;
      groupNode.depth *= multiplier;
    }

    return groupNode;
  } else {
    throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
/**
 * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)
 * into an unbreakable HTML node of class .base, with proper struts to
 * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to
 * make up the entire expression as a sequence of unbreakable units.
 */

function buildHTMLUnbreakable(children, options) {
  // Compute height and depth of this chunk.
  var body = buildHTML_makeSpan(["base"], children, options); // Add strut, which ensures that the top of the HTML element falls at
  // the height of the expression, and the bottom of the HTML element
  // falls at the depth of the expression.
  // We used to have separate top and bottom struts, where the bottom strut
  // would like to use `vertical-align: top`, but in IE 9 this lowers the
  // baseline of the box to the bottom of this strut (instead of staying in
  // the normal place) so we use an absolute value for vertical-align instead.

  var strut = buildHTML_makeSpan(["strut"]);
  strut.style.height = body.height + body.depth + "em";
  strut.style.verticalAlign = -body.depth + "em";
  body.children.unshift(strut);
  return body;
}
/**
 * Take an entire parse tree, and build it into an appropriate set of HTML
 * nodes.
 */


function buildHTML(tree, options) {
  // Strip off outer tag wrapper for processing below.
  var tag = null;

  if (tree.length === 1 && tree[0].type === "tag") {
    tag = tree[0].tag;
    tree = tree[0].body;
  } // Build the expression contained in the tree


  var expression = buildHTML_buildExpression(tree, options, true);
  var children = []; // Create one base node for each chunk between potential line breaks.
  // The TeXBook [p.173] says "A formula will be broken only after a
  // relation symbol like $=$ or $<$ or $\rightarrow$, or after a binary
  // operation symbol like $+$ or $-$ or $\times$, where the relation or
  // binary operation is on the ``outer level'' of the formula (i.e., not
  // enclosed in {...} and not part of an \over construction)."

  var parts = [];

  for (var i = 0; i < expression.length; i++) {
    parts.push(expression[i]);

    if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
      // Put any post-operator glue on same line as operator.
      // Watch for \nobreak along the way, and stop at \newline.
      var nobreak = false;

      while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
        i++;
        parts.push(expression[i]);

        if (expression[i].hasClass("nobreak")) {
          nobreak = true;
        }
      } // Don't allow break if \nobreak among the post-operator glue.


      if (!nobreak) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      }
    } else if (expression[i].hasClass("newline")) {
      // Write the line except the newline
      parts.pop();

      if (parts.length > 0) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      } // Put the newline at the top level


      children.push(expression[i]);
    }
  }

  if (parts.length > 0) {
    children.push(buildHTMLUnbreakable(parts, options));
  } // Now, if there was a tag, build it too and append it as a final child.


  var tagChild;

  if (tag) {
    tagChild = buildHTMLUnbreakable(buildHTML_buildExpression(tag, options, true));
    tagChild.classes = ["tag"];
    children.push(tagChild);
  }

  var htmlNode = buildHTML_makeSpan(["katex-html"], children);
  htmlNode.setAttribute("aria-hidden", "true"); // Adjust the strut of the tag to be the maximum height of all children
  // (the height of the enclosing htmlNode) for proper vertical alignment.

  if (tagChild) {
    var strut = tagChild.children[0];
    strut.style.height = htmlNode.height + htmlNode.depth + "em";
    strut.style.verticalAlign = -htmlNode.depth + "em";
  }

  return htmlNode;
}
// CONCATENATED MODULE: ./src/mathMLTree.js
/**
 * These objects store data about MathML nodes. This is the MathML equivalent
 * of the types in domTree.js. Since MathML handles its own rendering, and
 * since we're mainly using MathML to improve accessibility, we don't manage
 * any of the styling state that the plain DOM nodes do.
 *
 * The `toNode` and `toMarkup` functions work simlarly to how they do in
 * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
 */


function newDocumentFragment(children) {
  return new tree_DocumentFragment(children);
}
/**
 * This node represents a general purpose MathML node of any type. The
 * constructor requires the type of node to create (for example, `"mo"` or
 * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
 */

var mathMLTree_MathNode =
/*#__PURE__*/
function () {
  function MathNode(type, children) {
    this.type = void 0;
    this.attributes = void 0;
    this.children = void 0;
    this.type = type;
    this.attributes = {};
    this.children = children || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */


  var _proto = MathNode.prototype;

  _proto.setAttribute = function setAttribute(name, value) {
    this.attributes[name] = value;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  ;

  _proto.getAttribute = function getAttribute(name) {
    return this.attributes[name];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  ;

  _proto.toNode = function toNode() {
    var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);

    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    for (var i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }

    return node;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  ;

  _proto.toMarkup = function toMarkup() {
    var markup = "<" + this.type; // Add the attributes

    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + "=\"";
        markup += utils.escape(this.attributes[attr]);
        markup += "\"";
      }
    }

    markup += ">";

    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    markup += "</" + this.type + ">";
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  ;

  _proto.toText = function toText() {
    return this.children.map(function (child) {
      return child.toText();
    }).join("");
  };

  return MathNode;
}();
/**
 * This node represents a piece of text.
 */

var mathMLTree_TextNode =
/*#__PURE__*/
function () {
  function TextNode(text) {
    this.text = void 0;
    this.text = text;
  }
  /**
   * Converts the text node into a DOM text node.
   */


  var _proto2 = TextNode.prototype;

  _proto2.toNode = function toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  ;

  _proto2.toMarkup = function toMarkup() {
    return utils.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text iteself).
   */
  ;

  _proto2.toText = function toText() {
    return this.text;
  };

  return TextNode;
}();
/**
 * This node represents a space, but may render as <mspace.../> or as text,
 * depending on the width.
 */

var SpaceNode =
/*#__PURE__*/
function () {
  /**
   * Create a Space node with width given in CSS ems.
   */
  function SpaceNode(width) {
    this.width = void 0;
    this.character = void 0;
    this.width = width; // See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html
    // for a table of space-like characters.  We use Unicode
    // representations instead of &LongNames; as it's not clear how to
    // make the latter via document.createTextNode.

    if (width >= 0.05555 && width <= 0.05556) {
      this.character = "\u200A"; // &VeryThinSpace;
    } else if (width >= 0.1666 && width <= 0.1667) {
      this.character = "\u2009"; // &ThinSpace;
    } else if (width >= 0.2222 && width <= 0.2223) {
      this.character = "\u2005"; // &MediumSpace;
    } else if (width >= 0.2777 && width <= 0.2778) {
      this.character = "\u2005\u200A"; // &ThickSpace;
    } else if (width >= -0.05556 && width <= -0.05555) {
      this.character = "\u200A\u2063"; // &NegativeVeryThinSpace;
    } else if (width >= -0.1667 && width <= -0.1666) {
      this.character = "\u2009\u2063"; // &NegativeThinSpace;
    } else if (width >= -0.2223 && width <= -0.2222) {
      this.character = "\u205F\u2063"; // &NegativeMediumSpace;
    } else if (width >= -0.2778 && width <= -0.2777) {
      this.character = "\u2005\u2063"; // &NegativeThickSpace;
    } else {
      this.character = null;
    }
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */


  var _proto3 = SpaceNode.prototype;

  _proto3.toNode = function toNode() {
    if (this.character) {
      return document.createTextNode(this.character);
    } else {
      var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
      node.setAttribute("width", this.width + "em");
      return node;
    }
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  ;

  _proto3.toMarkup = function toMarkup() {
    if (this.character) {
      return "<mtext>" + this.character + "</mtext>";
    } else {
      return "<mspace width=\"" + this.width + "em\"/>";
    }
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  ;

  _proto3.toText = function toText() {
    if (this.character) {
      return this.character;
    } else {
      return " ";
    }
  };

  return SpaceNode;
}();

/* harmony default export */ var mathMLTree = ({
  MathNode: mathMLTree_MathNode,
  TextNode: mathMLTree_TextNode,
  SpaceNode: SpaceNode,
  newDocumentFragment: newDocumentFragment
});
// CONCATENATED MODULE: ./src/buildMathML.js
/**
 * This file converts a parse tree into a cooresponding MathML tree. The main
 * entry point is the `buildMathML` function, which takes a parse tree from the
 * parser.
 */









/**
 * Takes a symbol and converts it into a MathML text node after performing
 * optional replacement from symbols.js.
 */
var buildMathML_makeText = function makeText(text, mode, options) {
  if (src_symbols[mode][text] && src_symbols[mode][text].replace && text.charCodeAt(0) !== 0xD835 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.substr(4, 2) === "tt" || options.font && options.font.substr(4, 2) === "tt"))) {
    text = src_symbols[mode][text].replace;
  }

  return new mathMLTree.TextNode(text);
};
/**
 * Wrap the given array of nodes in an <mrow> node if needed, i.e.,
 * unless the array has length 1.  Always returns a single node.
 */

var buildMathML_makeRow = function makeRow(body) {
  if (body.length === 1) {
    return body[0];
  } else {
    return new mathMLTree.MathNode("mrow", body);
  }
};
/**
 * Returns the math variant as a string or null if none is required.
 */

var buildMathML_getVariant = function getVariant(group, options) {
  // Handle \text... font specifiers as best we can.
  // MathML has a limited list of allowable mathvariant specifiers; see
  // https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt
  if (options.fontFamily === "texttt") {
    return "monospace";
  } else if (options.fontFamily === "textsf") {
    if (options.fontShape === "textit" && options.fontWeight === "textbf") {
      return "sans-serif-bold-italic";
    } else if (options.fontShape === "textit") {
      return "sans-serif-italic";
    } else if (options.fontWeight === "textbf") {
      return "bold-sans-serif";
    } else {
      return "sans-serif";
    }
  } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
    return "bold-italic";
  } else if (options.fontShape === "textit") {
    return "italic";
  } else if (options.fontWeight === "textbf") {
    return "bold";
  }

  var font = options.font;

  if (!font || font === "mathnormal") {
    return null;
  }

  var mode = group.mode;

  if (font === "mathit") {
    return "italic";
  } else if (font === "boldsymbol") {
    return "bold-italic";
  }

  var text = group.text;

  if (utils.contains(["\\imath", "\\jmath"], text)) {
    return null;
  }

  if (src_symbols[mode][text] && src_symbols[mode][text].replace) {
    text = src_symbols[mode][text].replace;
  }

  var fontName = buildCommon.fontMap[font].fontName;

  if (getCharacterMetrics(text, fontName, mode)) {
    return buildCommon.fontMap[font].variant;
  }

  return null;
};
/**
 * Takes a list of nodes, builds them, and returns a list of the generated
 * MathML nodes.  Also combine consecutive <mtext> outputs into a single
 * <mtext> tag.
 */

var buildMathML_buildExpression = function buildExpression(expression, options) {
  var groups = [];
  var lastGroup;

  for (var i = 0; i < expression.length; i++) {
    var group = buildMathML_buildGroup(expression[i], options);

    if (group instanceof mathMLTree_MathNode && lastGroup instanceof mathMLTree_MathNode) {
      // Concatenate adjacent <mtext>s
      if (group.type === 'mtext' && lastGroup.type === 'mtext' && group.getAttribute('mathvariant') === lastGroup.getAttribute('mathvariant')) {
        var _lastGroup$children;

        (_lastGroup$children = lastGroup.children).push.apply(_lastGroup$children, group.children);

        continue; // Concatenate adjacent <mn>s
      } else if (group.type === 'mn' && lastGroup.type === 'mn') {
        var _lastGroup$children2;

        (_lastGroup$children2 = lastGroup.children).push.apply(_lastGroup$children2, group.children);

        continue; // Concatenate <mn>...</mn> followed by <mi>.</mi>
      } else if (group.type === 'mi' && group.children.length === 1 && lastGroup.type === 'mn') {
        var child = group.children[0];

        if (child instanceof mathMLTree_TextNode && child.text === '.') {
          var _lastGroup$children3;

          (_lastGroup$children3 = lastGroup.children).push.apply(_lastGroup$children3, group.children);

          continue;
        }
      } else if (lastGroup.type === 'mi' && lastGroup.children.length === 1) {
        var lastChild = lastGroup.children[0];

        if (lastChild instanceof mathMLTree_TextNode && lastChild.text === "\u0338" && (group.type === 'mo' || group.type === 'mi' || group.type === 'mn')) {
          var _child = group.children[0];

          if (_child instanceof mathMLTree_TextNode && _child.text.length > 0) {
            // Overlay with combining character long solidus
            _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
            groups.pop();
          }
        }
      }
    }

    groups.push(group);
    lastGroup = group;
  }

  return groups;
};
/**
 * Equivalent to buildExpression, but wraps the elements in an <mrow>
 * if there's more than one.  Returns a single node instead of an array.
 */

var buildExpressionRow = function buildExpressionRow(expression, options) {
  return buildMathML_makeRow(buildMathML_buildExpression(expression, options));
};
/**
 * Takes a group from the parser and calls the appropriate groupBuilders function
 * on it to produce a MathML node.
 */

var buildMathML_buildGroup = function buildGroup(group, options) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }

  if (_mathmlGroupBuilders[group.type]) {
    // Call the groupBuilders function
    var result = _mathmlGroupBuilders[group.type](group, options);
    return result;
  } else {
    throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
/**
 * Takes a full parse tree and settings and builds a MathML representation of
 * it. In particular, we put the elements from building the parse tree into a
 * <semantics> tag so we can also include that TeX source as an annotation.
 *
 * Note that we actually return a domTree element with a `<math>` inside it so
 * we can do appropriate styling.
 */

function buildMathML(tree, texExpression, options) {
  var expression = buildMathML_buildExpression(tree, options); // Wrap up the expression in an mrow so it is presented in the semantics
  // tag correctly, unless it's a single <mrow> or <mtable>.

  var wrapper;

  if (expression.length === 1 && expression[0] instanceof mathMLTree_MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
    wrapper = expression[0];
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  } // Build a TeX annotation of the source


  var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
  annotation.setAttribute("encoding", "application/x-tex");
  var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  var math = new mathMLTree.MathNode("math", [semantics]); // You can't style <math> nodes, so we wrap the node in a span.
  // NOTE: The span class is not typed to have <math> nodes as children, and
  // we don't want to make the children type more generic since the children
  // of span are expected to have more fields in `buildHtml` contexts.
  // $FlowFixMe

  return buildCommon.makeSpan(["katex-mathml"], [math]);
}
// CONCATENATED MODULE: ./src/buildTree.js







var buildTree_optionsFromSettings = function optionsFromSettings(settings) {
  return new src_Options({
    style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
    maxSize: settings.maxSize
  });
};

var buildTree_displayWrap = function displayWrap(node, settings) {
  if (settings.displayMode) {
    var classes = ["katex-display"];

    if (settings.leqno) {
      classes.push("leqno");
    }

    if (settings.fleqn) {
      classes.push("fleqn");
    }

    node = buildCommon.makeSpan(classes, [node]);
  }

  return node;
};

var buildTree_buildTree = function buildTree(tree, expression, settings) {
  var options = buildTree_optionsFromSettings(settings);
  var mathMLNode = buildMathML(tree, expression, options);
  var htmlNode = buildHTML(tree, options);
  var katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, htmlNode]);
  return buildTree_displayWrap(katexNode, settings);
};
var buildTree_buildHTMLTree = function buildHTMLTree(tree, expression, settings) {
  var options = buildTree_optionsFromSettings(settings);
  var htmlNode = buildHTML(tree, options);
  var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  return buildTree_displayWrap(katexNode, settings);
};
/* harmony default export */ var src_buildTree = (buildTree_buildTree);
// CONCATENATED MODULE: ./src/stretchy.js
/**
 * This file provides support to buildMathML.js and buildHTML.js
 * for stretchy wide elements rendered from SVG files
 * and other CSS trickery.
 */




var stretchyCodePoint = {
  widehat: "^",
  widecheck: "",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "\u2190",
  underleftarrow: "\u2190",
  xleftarrow: "\u2190",
  overrightarrow: "\u2192",
  underrightarrow: "\u2192",
  xrightarrow: "\u2192",
  underbrace: "\u23DF",
  overbrace: "\u23DE",
  overgroup: "\u23E0",
  undergroup: "\u23E1",
  overleftrightarrow: "\u2194",
  underleftrightarrow: "\u2194",
  xleftrightarrow: "\u2194",
  Overrightarrow: "\u21D2",
  xRightarrow: "\u21D2",
  overleftharpoon: "\u21BC",
  xleftharpoonup: "\u21BC",
  overrightharpoon: "\u21C0",
  xrightharpoonup: "\u21C0",
  xLeftarrow: "\u21D0",
  xLeftrightarrow: "\u21D4",
  xhookleftarrow: "\u21A9",
  xhookrightarrow: "\u21AA",
  xmapsto: "\u21A6",
  xrightharpoondown: "\u21C1",
  xleftharpoondown: "\u21BD",
  xrightleftharpoons: "\u21CC",
  xleftrightharpoons: "\u21CB",
  xtwoheadleftarrow: "\u219E",
  xtwoheadrightarrow: "\u21A0",
  xlongequal: "=",
  xtofrom: "\u21C4",
  xrightleftarrows: "\u21C4",
  xrightequilibrium: "\u21CC",
  // Not a perfect match.
  xleftequilibrium: "\u21CB" // None better available.

};

var stretchy_mathMLnode = function mathMLnode(label) {
  var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.substr(1)])]);
  node.setAttribute("stretchy", "true");
  return node;
}; // Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.
// Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)
// Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)
// Licensed under the SIL Open Font License, Version 1.1.
// See \nhttp://scripts.sil.org/OFL
// Very Long SVGs
//    Many of the KaTeX stretchy wide elements use a long SVG image and an
//    overflow: hidden tactic to achieve a stretchy image while avoiding
//    distortion of arrowheads or brace corners.
//    The SVG typically contains a very long (400 em) arrow.
//    The SVG is in a container span that has overflow: hidden, so the span
//    acts like a window that exposes only part of the  SVG.
//    The SVG always has a longer, thinner aspect ratio than the container span.
//    After the SVG fills 100% of the height of the container span,
//    there is a long arrow shaft left over. That left-over shaft is not shown.
//    Instead, it is sliced off because the span's CSS has overflow: hidden.
//    Thus, the reader sees an arrow that matches the subject matter width
//    without distortion.
//    Some functions, such as \cancel, need to vary their aspect ratio. These
//    functions do not get the overflow SVG treatment.
// Second Brush Stroke
//    Low resolution monitors struggle to display images in fine detail.
//    So browsers apply anti-aliasing. A long straight arrow shaft therefore
//    will sometimes appear as if it has a blurred edge.
//    To mitigate this, these SVG files contain a second "brush-stroke" on the
//    arrow shafts. That is, a second long thin rectangular SVG path has been
//    written directly on top of each arrow shaft. This reinforcement causes
//    some of the screen pixels to display as black instead of the anti-aliased
//    gray pixel that a  single path would generate. So we get arrow shafts
//    whose edges appear to be sharper.
// In the katexImagesData object just below, the dimensions all
// correspond to path geometry inside the relevant SVG.
// For example, \overrightarrow uses the same arrowhead as glyph U+2192
// from the KaTeX Main font. The scaling factor is 1000.
// That is, inside the font, that arrowhead is 522 units tall, which
// corresponds to 0.522 em inside the document.


var katexImagesData = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
};

var groupLength = function groupLength(arg) {
  if (arg.type === "ordgroup") {
    return arg.body.length;
  } else {
    return 1;
  }
};

var stretchy_svgSpan = function svgSpan(group, options) {
  // Create a span with inline SVG for the element.
  function buildSvgSpan_() {
    var viewBoxWidth = 400000; // default

    var label = group.label.substr(1);

    if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
      // Each type in the `if` statement corresponds to one of the ParseNode
      // types below. This narrowing is required to access `grp.base`.
      var grp = group; // There are four SVG images available for each function.
      // Choose a taller image when there are more characters.

      var numChars = groupLength(grp.base);
      var viewBoxHeight;
      var pathName;

      var _height;

      if (numChars > 5) {
        if (label === "widehat" || label === "widecheck") {
          viewBoxHeight = 420;
          viewBoxWidth = 2364;
          _height = 0.42;
          pathName = label + "4";
        } else {
          viewBoxHeight = 312;
          viewBoxWidth = 2340;
          _height = 0.34;
          pathName = "tilde4";
        }
      } else {
        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];

        if (label === "widehat" || label === "widecheck") {
          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
          pathName = label + imgIndex;
        } else {
          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
          pathName = "tilde" + imgIndex;
        }
      }

      var path = new domTree_PathNode(pathName);
      var svgNode = new SvgNode([path], {
        "width": "100%",
        "height": _height + "em",
        "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
        "preserveAspectRatio": "none"
      });
      return {
        span: buildCommon.makeSvgSpan([], [svgNode], options),
        minWidth: 0,
        height: _height
      };
    } else {
      var spans = [];
      var data = katexImagesData[label];
      var paths = data[0],
          _minWidth = data[1],
          _viewBoxHeight = data[2];

      var _height2 = _viewBoxHeight / 1000;

      var numSvgChildren = paths.length;
      var widthClasses;
      var aligns;

      if (numSvgChildren === 1) {
        // $FlowFixMe: All these cases must be of the 4-tuple type.
        var align1 = data[3];
        widthClasses = ["hide-tail"];
        aligns = [align1];
      } else if (numSvgChildren === 2) {
        widthClasses = ["halfarrow-left", "halfarrow-right"];
        aligns = ["xMinYMin", "xMaxYMin"];
      } else if (numSvgChildren === 3) {
        widthClasses = ["brace-left", "brace-center", "brace-right"];
        aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      } else {
        throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
      }

      for (var i = 0; i < numSvgChildren; i++) {
        var _path = new domTree_PathNode(paths[i]);

        var _svgNode = new SvgNode([_path], {
          "width": "400em",
          "height": _height2 + "em",
          "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
          "preserveAspectRatio": aligns[i] + " slice"
        });

        var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);

        if (numSvgChildren === 1) {
          return {
            span: _span,
            minWidth: _minWidth,
            height: _height2
          };
        } else {
          _span.style.height = _height2 + "em";
          spans.push(_span);
        }
      }

      return {
        span: buildCommon.makeSpan(["stretchy"], spans, options),
        minWidth: _minWidth,
        height: _height2
      };
    }
  } // buildSvgSpan_()


  var _buildSvgSpan_ = buildSvgSpan_(),
      span = _buildSvgSpan_.span,
      minWidth = _buildSvgSpan_.minWidth,
      height = _buildSvgSpan_.height; // Note that we are returning span.depth = 0.
  // Any adjustments relative to the baseline must be done in buildHTML.


  span.height = height;
  span.style.height = height + "em";

  if (minWidth > 0) {
    span.style.minWidth = minWidth + "em";
  }

  return span;
};

var stretchy_encloseSpan = function encloseSpan(inner, label, pad, options) {
  // Return an image span for \cancel, \bcancel, \xcancel, or \fbox
  var img;
  var totalHeight = inner.height + inner.depth + 2 * pad;

  if (/fbox|color/.test(label)) {
    img = buildCommon.makeSpan(["stretchy", label], [], options);

    if (label === "fbox") {
      var color = options.color && options.getColor();

      if (color) {
        img.style.borderColor = color;
      }
    }
  } else {
    // \cancel, \bcancel, or \xcancel
    // Since \cancel's SVG is inline and it omits the viewBox attribute,
    // its stroke-width will not vary with span area.
    var lines = [];

    if (/^[bx]cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "0",
        "x2": "100%",
        "y2": "100%",
        "stroke-width": "0.046em"
      }));
    }

    if (/^x?cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "100%",
        "x2": "100%",
        "y2": "0",
        "stroke-width": "0.046em"
      }));
    }

    var svgNode = new SvgNode(lines, {
      "width": "100%",
      "height": totalHeight + "em"
    });
    img = buildCommon.makeSvgSpan([], [svgNode], options);
  }

  img.height = totalHeight;
  img.style.height = totalHeight + "em";
  return img;
};

/* harmony default export */ var stretchy = ({
  encloseSpan: stretchy_encloseSpan,
  mathMLnode: stretchy_mathMLnode,
  svgSpan: stretchy_svgSpan
});
// CONCATENATED MODULE: ./src/functions/accent.js









// NOTE: Unlike most `htmlBuilder`s, this one handles not only "accent", but
var accent_htmlBuilder = function htmlBuilder(grp, options) {
  // Accents are handled in the TeXbook pg. 443, rule 12.
  var base;
  var group;
  var supSub = checkNodeType(grp, "supsub");
  var supSubGroup;

  if (supSub) {
    // If our base is a character box, and we have superscripts and
    // subscripts, the supsub will defer to us. In particular, we want
    // to attach the superscripts and subscripts to the inner body (so
    // that the position of the superscripts and subscripts won't be
    // affected by the height of the accent). We accomplish this by
    // sticking the base of the accent into the base of the supsub, and
    // rendering that, while keeping track of where the accent is.
    // The real accent group is the base of the supsub group
    group = assertNodeType(supSub.base, "accent"); // The character box is the base of the accent group

    base = group.base; // Stick the character box into the base of the supsub group

    supSub.base = base; // Rerender the supsub group with its new base, and store that
    // result.

    supSubGroup = assertSpan(buildHTML_buildGroup(supSub, options)); // reset original base

    supSub.base = group;
  } else {
    group = assertNodeType(grp, "accent");
    base = group.base;
  } // Build the base group


  var body = buildHTML_buildGroup(base, options.havingCrampedStyle()); // Does the accent need to shift for the skew of a character?

  var mustShift = group.isShifty && utils.isCharacterBox(base); // Calculate the skew of the accent. This is based on the line "If the
  // nucleus is not a single character, let s = 0; otherwise set s to the
  // kern amount for the nucleus followed by the \skewchar of its font."
  // Note that our skew metrics are just the kern between each character
  // and the skewchar.

  var skew = 0;

  if (mustShift) {
    // If the base is a character box, then we want the skew of the
    // innermost character. To do that, we find the innermost character:
    var baseChar = utils.getBaseElem(base); // Then, we render its group to get the symbol inside it

    var baseGroup = buildHTML_buildGroup(baseChar, options.havingCrampedStyle()); // Finally, we pull the skew off of the symbol.

    skew = assertSymbolDomNode(baseGroup).skew; // Note that we now throw away baseGroup, because the layers we
    // removed with getBaseElem might contain things like \color which
    // we can't get rid of.
    // TODO(emily): Find a better way to get the skew
  } // calculate the amount of space between the body and the accent


  var clearance = Math.min(body.height, options.fontMetrics().xHeight); // Build the accent

  var accentBody;

  if (!group.isStretchy) {
    var accent;
    var width;

    if (group.label === "\\vec") {
      // Before version 0.9, \vec used the combining font glyph U+20D7.
      // But browsers, especially Safari, are not consistent in how they
      // render combining characters when not preceded by a character.
      // So now we use an SVG.
      // If Safari reforms, we should consider reverting to the glyph.
      accent = buildCommon.staticSvg("vec", options);
      width = buildCommon.svgData.vec[1];
    } else {
      accent = buildCommon.makeSymbol(group.label, "Main-Regular", group.mode, options); // Remove the italic correction of the accent, because it only serves to
      // shift the accent over to a place we don't want.

      accent.italic = 0;
      width = accent.width;
    }

    accentBody = buildCommon.makeSpan(["accent-body"], [accent]); // "Full" accents expand the width of the resulting symbol to be
    // at least the width of the accent, and overlap directly onto the
    // character without any vertical offset.

    var accentFull = group.label === "\\textcircled";

    if (accentFull) {
      accentBody.classes.push('accent-full');
      clearance = body.height;
    } // Shift the accent over by the skew.


    var left = skew; // CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`
    // so that the accent doesn't contribute to the bounding box.
    // We need to shift the character by its width (effectively half
    // its width) to compensate.

    if (!accentFull) {
      left -= width / 2;
    }

    accentBody.style.left = left + "em"; // \textcircled uses the \bigcirc glyph, so it needs some
    // vertical adjustment to match LaTeX.

    if (group.label === "\\textcircled") {
      accentBody.style.top = ".2em";
    }

    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: -clearance
      }, {
        type: "elem",
        elem: accentBody
      }]
    }, options);
  } else {
    accentBody = stretchy.svgSpan(group, options);
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"],
        wrapperStyle: skew > 0 ? {
          width: "calc(100% - " + 2 * skew + "em)",
          marginLeft: 2 * skew + "em"
        } : undefined
      }]
    }, options);
  }

  var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);

  if (supSubGroup) {
    // Here, we replace the "base" child of the supsub with our newly
    // generated accent.
    supSubGroup.children[0] = accentWrap; // Since we don't rerun the height calculation after replacing the
    // accent, we manually recalculate height.

    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height); // Accents should always be ords, even when their innards are not.

    supSubGroup.classes[0] = "mord";
    return supSubGroup;
  } else {
    return accentWrap;
  }
};

var accent_mathmlBuilder = function mathmlBuilder(group, options) {
  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [buildMathML_makeText(group.label, group.mode)]);
  var node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
  node.setAttribute("accent", "true");
  return node;
};

var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(function (accent) {
  return "\\" + accent;
}).join("|")); // Accents

defineFunction({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: function handler(context, args) {
    var base = args[0];
    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
    var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy: isStretchy,
      isShifty: isShifty,
      base: base
    };
  },
  htmlBuilder: accent_htmlBuilder,
  mathmlBuilder: accent_mathmlBuilder
}); // Text-mode accents

defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: false
  },
  handler: function handler(context, args) {
    var base = args[0];
    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy: false,
      isShifty: true,
      base: base
    };
  },
  htmlBuilder: accent_htmlBuilder,
  mathmlBuilder: accent_mathmlBuilder
});
// CONCATENATED MODULE: ./src/functions/accentunder.js
// Horizontal overlap functions






defineFunction({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    var base = args[0];
    return {
      type: "accentUnder",
      mode: parser.mode,
      label: funcName,
      base: base
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    // Treat under accents much like underlines.
    var innerGroup = buildHTML_buildGroup(group.base, options);
    var accentBody = stretchy.svgSpan(group, options);
    var kern = group.label === "\\utilde" ? 0.12 : 0; // Generate the vlist, with the appropriate kerns

    var vlist = buildCommon.makeVList({
      positionType: "bottom",
      positionData: accentBody.height + kern,
      children: [{
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: kern
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var accentNode = stretchy.mathMLnode(group.label);
    var node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
    node.setAttribute("accentunder", "true");
    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/arrow.js







// Helper function
var arrow_paddedNode = function paddedNode(group) {
  var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
  node.setAttribute("width", "+0.6em");
  node.setAttribute("lspace", "0.3em");
  return node;
}; // Stretchy arrows with an optional argument


defineFunction({
  type: "xArrow",
  names: ["\\xleftarrow", "\\xrightarrow", "\\xLeftarrow", "\\xRightarrow", "\\xleftrightarrow", "\\xLeftrightarrow", "\\xhookleftarrow", "\\xhookrightarrow", "\\xmapsto", "\\xrightharpoondown", "\\xrightharpoonup", "\\xleftharpoondown", "\\xleftharpoonup", "\\xrightleftharpoons", "\\xleftrightharpoons", "\\xlongequal", "\\xtwoheadrightarrow", "\\xtwoheadleftarrow", "\\xtofrom", // The next 3 functions are here to support the mhchem extension.
  // Direct use of these functions is discouraged and may break someday.
  "\\xrightleftarrows", "\\xrightequilibrium", "\\xleftequilibrium"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler: function handler(_ref, args, optArgs) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    return {
      type: "xArrow",
      mode: parser.mode,
      label: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unamibiguously determined from the passed-in `type` above.
  htmlBuilder: function htmlBuilder(group, options) {
    var style = options.style; // Build the argument groups in the appropriate style.
    // Ref: amsmath.dtx:   \hbox{$\scriptstyle\mkern#3mu{#6}\mkern#4mu$}%
    // Some groups can return document fragments.  Handle those by wrapping
    // them in a span.

    var newOptions = options.havingStyle(style.sup());
    var upperGroup = buildCommon.wrapFragment(buildHTML_buildGroup(group.body, newOptions, options), options);
    upperGroup.classes.push("x-arrow-pad");
    var lowerGroup;

    if (group.below) {
      // Build the lower group
      newOptions = options.havingStyle(style.sub());
      lowerGroup = buildCommon.wrapFragment(buildHTML_buildGroup(group.below, newOptions, options), options);
      lowerGroup.classes.push("x-arrow-pad");
    }

    var arrowBody = stretchy.svgSpan(group, options); // Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.
    // The point we want on the math axis is at 0.5 * arrowBody.height.

    var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height; // 2 mu kern. Ref: amsmath.dtx: #7\if0#2\else\mkern#2mu\fi

    var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111; // 0.111 em = 2 mu

    if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
      upperShift -= upperGroup.depth; // shift up if depth encroaches
    } // Generate the vlist


    var vlist;

    if (lowerGroup) {
      var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }, {
          type: "elem",
          elem: lowerGroup,
          shift: lowerShift
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }]
      }, options);
    } // $FlowFixMe: Replace this with passing "svg-align" into makeVList.


    vlist.children[0].children[0].children[1].classes.push("svg-align");
    return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var arrowNode = stretchy.mathMLnode(group.label);
    var node;

    if (group.body) {
      var upperNode = arrow_paddedNode(buildMathML_buildGroup(group.body, options));

      if (group.below) {
        var lowerNode = arrow_paddedNode(buildMathML_buildGroup(group.below, options));
        node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
      } else {
        node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
      }
    } else if (group.below) {
      var _lowerNode = arrow_paddedNode(buildMathML_buildGroup(group.below, options));

      node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
    } else {
      // This should never happen.
      // Parser.js throws an error if there is no argument.
      node = arrow_paddedNode();
      node = new mathMLTree.MathNode("mover", [arrowNode, node]);
    }

    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/char.js


 // \@char is an internal function that takes a grouped decimal argument like
// {123} and converts into symbol with code 123.  It is used by the *macro*
// \char defined in macros.js.

defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser;
    var arg = assertNodeType(args[0], "ordgroup");
    var group = arg.body;
    var number = "";

    for (var i = 0; i < group.length; i++) {
      var node = assertNodeType(group[i], "textord");
      number += node.text;
    }

    var code = parseInt(number);

    if (isNaN(code)) {
      throw new src_ParseError("\\@char has non-numeric argument " + number);
    }

    return {
      type: "textord",
      mode: parser.mode,
      text: String.fromCharCode(code)
    };
  }
});
// CONCATENATED MODULE: ./src/functions/color.js







var color_htmlBuilder = function htmlBuilder(group, options) {
  var elements = buildHTML_buildExpression(group.body, options.withColor(group.color), false); // \color isn't supposed to affect the type of the elements it contains.
  // To accomplish this, we wrap the results in a fragment, so the inner
  // elements will be able to directly interact with their neighbors. For
  // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`

  return buildCommon.makeFragment(elements);
};

var color_mathmlBuilder = function mathmlBuilder(group, options) {
  var inner = buildMathML_buildExpression(group.body, options.withColor(group.color));
  var node = new mathMLTree.MathNode("mstyle", inner);
  node.setAttribute("mathcolor", group.color);
  return node;
};

defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: true,
    greediness: 3,
    argTypes: ["color", "original"]
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser;
    var color = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "color",
      mode: parser.mode,
      color: color,
      body: defineFunction_ordargument(body)
    };
  },
  htmlBuilder: color_htmlBuilder,
  mathmlBuilder: color_mathmlBuilder
});
defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: true,
    greediness: 3,
    argTypes: ["color"]
  },
  handler: function handler(_ref2, args) {
    var parser = _ref2.parser,
        breakOnTokenText = _ref2.breakOnTokenText;
    var color = assertNodeType(args[0], "color-token").color; // If we see a styling function, parse out the implicit body

    var body = parser.parseExpression(true, breakOnTokenText);
    return {
      type: "color",
      mode: parser.mode,
      color: color,
      body: body
    };
  },
  htmlBuilder: color_htmlBuilder,
  mathmlBuilder: color_mathmlBuilder
});
// CONCATENATED MODULE: ./src/functions/cr.js
// Row breaks within tabular environments, and line breaks at top level





 // \\ is a macro mapping to either \cr or \newline.  Because they have the
// same signature, we implement them as one megafunction, with newRow
// indicating whether we're in the \cr case, and newLine indicating whether
// to break the line in the \newline case.

defineFunction({
  type: "cr",
  names: ["\\cr", "\\newline"],
  props: {
    numArgs: 0,
    numOptionalArgs: 1,
    argTypes: ["size"],
    allowedInText: true
  },
  handler: function handler(_ref, args, optArgs) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    var size = optArgs[0];
    var newRow = funcName === "\\cr";
    var newLine = false;

    if (!newRow) {
      if (parser.settings.displayMode && parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline " + "does nothing in display mode")) {
        newLine = false;
      } else {
        newLine = true;
      }
    }

    return {
      type: "cr",
      mode: parser.mode,
      newLine: newLine,
      newRow: newRow,
      size: size && assertNodeType(size, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder: function htmlBuilder(group, options) {
    if (group.newRow) {
      throw new src_ParseError("\\cr valid only within a tabular/array environment");
    }

    var span = buildCommon.makeSpan(["mspace"], [], options);

    if (group.newLine) {
      span.classes.push("newline");

      if (group.size) {
        span.style.marginTop = units_calculateSize(group.size, options) + "em";
      }
    }

    return span;
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mspace");

    if (group.newLine) {
      node.setAttribute("linebreak", "newline");

      if (group.size) {
        node.setAttribute("height", units_calculateSize(group.size, options) + "em");
      }
    }

    return node;
  }
});
// CONCATENATED MODULE: ./src/delimiter.js
/**
 * This file deals with creating delimiters of various sizes. The TeXbook
 * discusses these routines on page 441-442, in the "Another subroutine sets box
 * x to a specified variable delimiter" paragraph.
 *
 * There are three main routines here. `makeSmallDelim` makes a delimiter in the
 * normal font, but in either text, script, or scriptscript style.
 * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
 * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
 * smaller pieces that are stacked on top of one another.
 *
 * The functions take a parameter `center`, which determines if the delimiter
 * should be centered around the axis.
 *
 * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
 * one of the given sizes. This is used for things like `\bigl`.
 * `customSizedDelim` makes a delimiter with a given total height+depth. It is
 * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
 * delimiter which surrounds an expression of a given height an depth. It is
 * used in `\left` and `\right`.
 */








/**
 * Get the metrics for a given symbol and font, after transformation (i.e.
 * after following replacement from symbols.js)
 */
var delimiter_getMetrics = function getMetrics(symbol, font, mode) {
  var replace = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
  var metrics = getCharacterMetrics(replace || symbol, font, mode);

  if (!metrics) {
    throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
  }

  return metrics;
};
/**
 * Puts a delimiter span in a given style, and adds appropriate height, depth,
 * and maxFontSizes.
 */


var delimiter_styleWrap = function styleWrap(delim, toStyle, options, classes) {
  var newOptions = options.havingBaseStyle(toStyle);
  var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
  var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
  span.height *= delimSizeMultiplier;
  span.depth *= delimSizeMultiplier;
  span.maxFontSize = newOptions.sizeMultiplier;
  return span;
};

var centerSpan = function centerSpan(span, options, style) {
  var newOptions = options.havingBaseStyle(style);
  var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
  span.classes.push("delimcenter");
  span.style.top = shift + "em";
  span.height -= shift;
  span.depth += shift;
};
/**
 * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
 * font, but is restyled to either be in textstyle, scriptstyle, or
 * scriptscriptstyle.
 */


var delimiter_makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {
  var text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
  var span = delimiter_styleWrap(text, style, options, classes);

  if (center) {
    centerSpan(span, options, style);
  }

  return span;
};
/**
 * Builds a symbol in the given font size (note size is an integer)
 */


var delimiter_mathrmSize = function mathrmSize(value, size, mode, options) {
  return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
};
/**
 * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
 * Size3, or Size4 fonts. It is always rendered in textstyle.
 */


var delimiter_makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {
  var inner = delimiter_mathrmSize(delim, size, mode, options);
  var span = delimiter_styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner], options), src_Style.TEXT, options, classes);

  if (center) {
    centerSpan(span, options, src_Style.TEXT);
  }

  return span;
};
/**
 * Make an inner span with the given offset and in the given font. This is used
 * in `makeStackedDelim` to make the stacking pieces for the delimiter.
 */


var delimiter_makeInner = function makeInner(symbol, font, mode) {
  var sizeClass; // Apply the correct CSS class to choose the right font.

  if (font === "Size1-Regular") {
    sizeClass = "delim-size1";
  } else
    /* if (font === "Size4-Regular") */
    {
      sizeClass = "delim-size4";
    }

  var inner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]); // Since this will be passed into `makeVList` in the end, wrap the element
  // in the appropriate tag that VList uses.

  return {
    type: "elem",
    elem: inner
  };
};
/**
 * Make a stacked delimiter out of a given delimiter, with the total height at
 * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
 */


var delimiter_makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {
  // There are four parts, the top, an optional middle, a repeated part, and a
  // bottom.
  var top;
  var middle;
  var repeat;
  var bottom;
  top = repeat = bottom = delim;
  middle = null; // Also keep track of what font the delimiters are in

  var font = "Size1-Regular"; // We set the parts and font based on the symbol. Note that we use
  // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
  // repeats of the arrows

  if (delim === "\\uparrow") {
    repeat = bottom = "\u23D0";
  } else if (delim === "\\Uparrow") {
    repeat = bottom = "\u2016";
  } else if (delim === "\\downarrow") {
    top = repeat = "\u23D0";
  } else if (delim === "\\Downarrow") {
    top = repeat = "\u2016";
  } else if (delim === "\\updownarrow") {
    top = "\\uparrow";
    repeat = "\u23D0";
    bottom = "\\downarrow";
  } else if (delim === "\\Updownarrow") {
    top = "\\Uparrow";
    repeat = "\u2016";
    bottom = "\\Downarrow";
  } else if (delim === "[" || delim === "\\lbrack") {
    top = "\u23A1";
    repeat = "\u23A2";
    bottom = "\u23A3";
    font = "Size4-Regular";
  } else if (delim === "]" || delim === "\\rbrack") {
    top = "\u23A4";
    repeat = "\u23A5";
    bottom = "\u23A6";
    font = "Size4-Regular";
  } else if (delim === "\\lfloor" || delim === "\u230A") {
    repeat = top = "\u23A2";
    bottom = "\u23A3";
    font = "Size4-Regular";
  } else if (delim === "\\lceil" || delim === "\u2308") {
    top = "\u23A1";
    repeat = bottom = "\u23A2";
    font = "Size4-Regular";
  } else if (delim === "\\rfloor" || delim === "\u230B") {
    repeat = top = "\u23A5";
    bottom = "\u23A6";
    font = "Size4-Regular";
  } else if (delim === "\\rceil" || delim === "\u2309") {
    top = "\u23A4";
    repeat = bottom = "\u23A5";
    font = "Size4-Regular";
  } else if (delim === "(" || delim === "\\lparen") {
    top = "\u239B";
    repeat = "\u239C";
    bottom = "\u239D";
    font = "Size4-Regular";
  } else if (delim === ")" || delim === "\\rparen") {
    top = "\u239E";
    repeat = "\u239F";
    bottom = "\u23A0";
    font = "Size4-Regular";
  } else if (delim === "\\{" || delim === "\\lbrace") {
    top = "\u23A7";
    middle = "\u23A8";
    bottom = "\u23A9";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\}" || delim === "\\rbrace") {
    top = "\u23AB";
    middle = "\u23AC";
    bottom = "\u23AD";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\lgroup" || delim === "\u27EE") {
    top = "\u23A7";
    bottom = "\u23A9";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\rgroup" || delim === "\u27EF") {
    top = "\u23AB";
    bottom = "\u23AD";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\lmoustache" || delim === "\u23B0") {
    top = "\u23A7";
    bottom = "\u23AD";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\rmoustache" || delim === "\u23B1") {
    top = "\u23AB";
    bottom = "\u23A9";
    repeat = "\u23AA";
    font = "Size4-Regular";
  } // Get the metrics of the four sections


  var topMetrics = delimiter_getMetrics(top, font, mode);
  var topHeightTotal = topMetrics.height + topMetrics.depth;
  var repeatMetrics = delimiter_getMetrics(repeat, font, mode);
  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
  var bottomMetrics = delimiter_getMetrics(bottom, font, mode);
  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
  var middleHeightTotal = 0;
  var middleFactor = 1;

  if (middle !== null) {
    var middleMetrics = delimiter_getMetrics(middle, font, mode);
    middleHeightTotal = middleMetrics.height + middleMetrics.depth;
    middleFactor = 2; // repeat symmetrically above and below middle
  } // Calcuate the minimal height that the delimiter can have.
  // It is at least the size of the top, bottom, and optional middle combined.


  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal; // Compute the number of copies of the repeat symbol we will need

  var repeatCount = Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)); // Compute the total height of the delimiter including all the symbols

  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal; // The center of the delimiter is placed at the center of the axis. Note
  // that in this context, "center" means that the delimiter should be
  // centered around the axis in the current style, while normally it is
  // centered around the axis in textstyle.

  var axisHeight = options.fontMetrics().axisHeight;

  if (center) {
    axisHeight *= options.sizeMultiplier;
  } // Calculate the depth


  var depth = realHeightTotal / 2 - axisHeight; // Now, we start building the pieces that will go into the vlist
  // Keep a list of the inner pieces

  var inners = []; // Add the bottom symbol

  inners.push(delimiter_makeInner(bottom, font, mode));

  if (middle === null) {
    // Add that many symbols
    for (var i = 0; i < repeatCount; i++) {
      inners.push(delimiter_makeInner(repeat, font, mode));
    }
  } else {
    // When there is a middle bit, we need the middle part and two repeated
    // sections
    for (var _i = 0; _i < repeatCount; _i++) {
      inners.push(delimiter_makeInner(repeat, font, mode));
    }

    inners.push(delimiter_makeInner(middle, font, mode));

    for (var _i2 = 0; _i2 < repeatCount; _i2++) {
      inners.push(delimiter_makeInner(repeat, font, mode));
    }
  } // Add the top symbol


  inners.push(delimiter_makeInner(top, font, mode)); // Finally, build the vlist

  var newOptions = options.havingBaseStyle(src_Style.TEXT);
  var inner = buildCommon.makeVList({
    positionType: "bottom",
    positionData: depth,
    children: inners
  }, newOptions);
  return delimiter_styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner], newOptions), src_Style.TEXT, options, classes);
}; // All surds have 0.08em padding above the viniculum inside the SVG.
// That keeps browser span height rounding error from pinching the line.


var vbPad = 80; // padding above the surd, measured inside the viewBox.

var emPad = 0.08; // padding, in ems, measured in the document.

var delimiter_sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, options) {
  var alternate;

  if (sqrtName === "sqrtTall") {
    // sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular
    // One path edge has a variable length. It runs from the viniculumn
    // to a point near (14 units) the bottom of the surd. The viniculum
    // is 40 units thick. So the length of the line in question is:
    var vertSegment = viewBoxHeight - 54 - vbPad;
    alternate = "M702 " + vbPad + "H400000v40H742v" + vertSegment + "l-4 4-4 4c-.667.7\n-2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1h-12l-28-84c-16.667-52-96.667\n-294.333-240-727l-212 -643 -85 170c-4-3.333-8.333-7.667-13 -13l-13-13l77-155\n 77-156c66 199.333 139 419.667 219 661 l218 661zM702 " + vbPad + "H400000v40H742z";
  }

  var pathNode = new domTree_PathNode(sqrtName, alternate);
  var svg = new SvgNode([pathNode], {
    // Note: 1000:1 ratio of viewBox to document em width.
    "width": "400em",
    "height": height + "em",
    "viewBox": "0 0 400000 " + viewBoxHeight,
    "preserveAspectRatio": "xMinYMin slice"
  });
  return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
};
/**
 * Make a sqrt image of the given height,
 */


var makeSqrtImage = function makeSqrtImage(height, options) {
  // Define a newOptions that removes the effect of size changes such as \Huge.
  // We don't pick different a height surd for \Huge. For it, we scale up.
  var newOptions = options.havingBaseSizing(); // Pick the desired surd glyph from a sequence of surds.

  var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
  var sizeMultiplier = newOptions.sizeMultiplier; // default
  // Create a span containing an SVG image of a sqrt symbol.

  var span;
  var spanHeight = 0;
  var texHeight = 0;
  var viewBoxHeight = 0;
  var advanceWidth; // We create viewBoxes with 80 units of "padding" above each surd.
  // Then browser rounding error on the parent span height will not
  // encroach on the ink of the viniculum. But that padding is not
  // included in the TeX-like `height` used for calculation of
  // vertical alignment. So texHeight = span.height < span.style.height.

  if (delim.type === "small") {
    // Get an SVG that is derived from glyph U+221A in font KaTeX-Main.
    viewBoxHeight = 1000 + vbPad; // 1000 unit glyph height.

    if (height < 1.0) {
      sizeMultiplier = 1.0; // mimic a \textfont radical
    } else if (height < 1.4) {
      sizeMultiplier = 0.7; // mimic a \scriptfont radical
    }

    spanHeight = (1.0 + emPad) / sizeMultiplier;
    texHeight = 1.00 / sizeMultiplier;
    span = delimiter_sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, options);
    span.style.minWidth = "0.853em";
    advanceWidth = 0.833 / sizeMultiplier; // from the font.
  } else if (delim.type === "large") {
    // These SVGs come from fonts: KaTeX_Size1, _Size2, etc.
    viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];
    texHeight = sizeToMaxHeight[delim.size] / sizeMultiplier;
    spanHeight = (sizeToMaxHeight[delim.size] + emPad) / sizeMultiplier;
    span = delimiter_sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, options);
    span.style.minWidth = "1.02em";
    advanceWidth = 1.0 / sizeMultiplier; // 1.0 from the font.
  } else {
    // Tall sqrt. In TeX, this would be stacked using multiple glyphs.
    // We'll use a single SVG to accomplish the same thing.
    spanHeight = height + emPad;
    texHeight = height;
    viewBoxHeight = Math.floor(1000 * height) + vbPad;
    span = delimiter_sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, options);
    span.style.minWidth = "0.742em";
    advanceWidth = 1.056;
  }

  span.height = texHeight;
  span.style.height = spanHeight + "em";
  return {
    span: span,
    advanceWidth: advanceWidth,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: options.fontMetrics().sqrtRuleThickness * sizeMultiplier
  };
}; // There are three kinds of delimiters, delimiters that stack when they become
// too large


var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"]; // delimiters that always stack

var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"]; // and delimiters that never stack

var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"]; // Metrics of the different sizes. Found by looking at TeX's output of
// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.

var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];
/**
 * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
 */

var delimiter_makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {
  // < and > turn into \langle and \rangle in delimiters
  if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
    delim = "\\rangle";
  } // Sized delimiters are never centered.


  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
    return delimiter_makeLargeDelim(delim, size, false, options, mode, classes);
  } else if (utils.contains(stackAlwaysDelimiters, delim)) {
    return delimiter_makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
  } else {
    throw new src_ParseError("Illegal delimiter: '" + delim + "'");
  }
};
/**
 * There are three different sequences of delimiter sizes that the delimiters
 * follow depending on the kind of delimiter. This is used when creating custom
 * sized delimiters to decide whether to create a small, large, or stacked
 * delimiter.
 *
 * In real TeX, these sequences aren't explicitly defined, but are instead
 * defined inside the font metrics. Since there are only three sequences that
 * are possible for the delimiters that TeX defines, it is easier to just encode
 * them explicitly here.
 */


// Delimiters that never stack try small delimiters and large delimiters only
var stackNeverDelimiterSequence = [{
  type: "small",
  style: src_Style.SCRIPTSCRIPT
}, {
  type: "small",
  style: src_Style.SCRIPT
}, {
  type: "small",
  style: src_Style.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}]; // Delimiters that always stack try the small delimiters first, then stack

var stackAlwaysDelimiterSequence = [{
  type: "small",
  style: src_Style.SCRIPTSCRIPT
}, {
  type: "small",
  style: src_Style.SCRIPT
}, {
  type: "small",
  style: src_Style.TEXT
}, {
  type: "stack"
}]; // Delimiters that stack when large try the small and then large delimiters, and
// stack afterwards

var stackLargeDelimiterSequence = [{
  type: "small",
  style: src_Style.SCRIPTSCRIPT
}, {
  type: "small",
  style: src_Style.SCRIPT
}, {
  type: "small",
  style: src_Style.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}];
/**
 * Get the font used in a delimiter based on what kind of delimiter it is.
 * TODO(#963) Use more specific font family return type once that is introduced.
 */

var delimTypeToFont = function delimTypeToFont(type) {
  if (type.type === "small") {
    return "Main-Regular";
  } else if (type.type === "large") {
    return "Size" + type.size + "-Regular";
  } else if (type.type === "stack") {
    return "Size4-Regular";
  } else {
    throw new Error("Add support for delim type '" + type.type + "' here.");
  }
};
/**
 * Traverse a sequence of types of delimiters to decide what kind of delimiter
 * should be used to create a delimiter of the given height+depth.
 */


var traverseSequence = function traverseSequence(delim, height, sequence, options) {
  // Here, we choose the index we should start at in the sequences. In smaller
  // sizes (which correspond to larger numbers in style.size) we start earlier
  // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
  // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
  var start = Math.min(2, 3 - options.style.size);

  for (var i = start; i < sequence.length; i++) {
    if (sequence[i].type === "stack") {
      // This is always the last delimiter, so we just break the loop now.
      break;
    }

    var metrics = delimiter_getMetrics(delim, delimTypeToFont(sequence[i]), "math");
    var heightDepth = metrics.height + metrics.depth; // Small delimiters are scaled down versions of the same font, so we
    // account for the style change size.

    if (sequence[i].type === "small") {
      var newOptions = options.havingBaseStyle(sequence[i].style);
      heightDepth *= newOptions.sizeMultiplier;
    } // Check if the delimiter at this size works for the given height.


    if (heightDepth > height) {
      return sequence[i];
    }
  } // If we reached the end of the sequence, return the last sequence element.


  return sequence[sequence.length - 1];
};
/**
 * Make a delimiter of a given height+depth, with optional centering. Here, we
 * traverse the sequences, and create a delimiter that the sequence tells us to.
 */


var delimiter_makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
    delim = "\\rangle";
  } // Decide what sequence to use


  var sequence;

  if (utils.contains(stackNeverDelimiters, delim)) {
    sequence = stackNeverDelimiterSequence;
  } else if (utils.contains(stackLargeDelimiters, delim)) {
    sequence = stackLargeDelimiterSequence;
  } else {
    sequence = stackAlwaysDelimiterSequence;
  } // Look through the sequence


  var delimType = traverseSequence(delim, height, sequence, options); // Get the delimiter from font glyphs.
  // Depending on the sequence element we decided on, call the
  // appropriate function.

  if (delimType.type === "small") {
    return delimiter_makeSmallDelim(delim, delimType.style, center, options, mode, classes);
  } else if (delimType.type === "large") {
    return delimiter_makeLargeDelim(delim, delimType.size, center, options, mode, classes);
  } else
    /* if (delimType.type === "stack") */
    {
      return delimiter_makeStackedDelim(delim, height, center, options, mode, classes);
    }
};
/**
 * Make a delimiter for use with `\left` and `\right`, given a height and depth
 * of an expression that the delimiters surround.
 */


var makeLeftRightDelim = function makeLeftRightDelim(delim, height, depth, options, mode, classes) {
  // We always center \left/\right delimiters, so the axis is always shifted
  var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier; // Taken from TeX source, tex.web, function make_left_right

  var delimiterFactor = 901;
  var delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;
  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
  var totalHeight = Math.max( // In real TeX, calculations are done using integral values which are
  // 65536 per pt, or 655360 per em. So, the division here truncates in
  // TeX but doesn't here, producing different results. If we wanted to
  // exactly match TeX's calculation, we could do
  //   Math.floor(655360 * maxDistFromAxis / 500) *
  //    delimiterFactor / 655360
  // (To see the difference, compare
  //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
  // in TeX and KaTeX)
  maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend); // Finally, we defer to `makeCustomSizedDelim` with our calculated total
  // height

  return delimiter_makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
};

/* harmony default export */ var delimiter = ({
  sqrtImage: makeSqrtImage,
  sizedDelim: delimiter_makeSizedDelim,
  customSizedDelim: delimiter_makeCustomSizedDelim,
  leftRightDelim: makeLeftRightDelim
});
// CONCATENATED MODULE: ./src/functions/delimsizing.js









// Extra data needed for the delimiter handler down below
var delimiterSizes = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
};
var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];

// Delimiter functions
function checkDelimiter(delim, context) {
  var symDelim = checkSymbolNodeType(delim);

  if (symDelim && utils.contains(delimiters, symDelim.text)) {
    return symDelim;
  } else {
    throw new src_ParseError("Invalid delimiter: '" + (symDelim ? symDelim.text : JSON.stringify(delim)) + "' after '" + context.funcName + "'", delim);
  }
}

defineFunction({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1
  },
  handler: function handler(context, args) {
    var delim = checkDelimiter(args[0], context);
    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    if (group.delim === ".") {
      // Empty delimiters still count as elements, even though they don't
      // show anything.
      return buildCommon.makeSpan([group.mclass]);
    } // Use delimiter.sizedDelim to generate the delimiter.


    return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
  },
  mathmlBuilder: function mathmlBuilder(group) {
    var children = [];

    if (group.delim !== ".") {
      children.push(buildMathML_makeText(group.delim, group.mode));
    }

    var node = new mathMLTree.MathNode("mo", children);

    if (group.mclass === "mopen" || group.mclass === "mclose") {
      // Only some of the delimsizing functions act as fences, and they
      // return "mopen" or "mclose" mclass.
      node.setAttribute("fence", "true");
    } else {
      // Explicitly disable fencing if it's not a fence, to override the
      // defaults.
      node.setAttribute("fence", "false");
    }

    return node;
  }
});

function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}

defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1
  },
  handler: function handler(context, args) {
    // \left case below triggers parsing of \right in
    //   `const right = parser.parseFunction();`
    // uses this return value.
    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text
    };
  }
});
defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1
  },
  handler: function handler(context, args) {
    var delim = checkDelimiter(args[0], context);
    var parser = context.parser; // Parse out the implicit body

    ++parser.leftrightDepth; // parseExpression stops before '\\right'

    var body = parser.parseExpression(false);
    --parser.leftrightDepth; // Check the next token

    parser.expect("\\right", false);
    var right = assertNodeType(parser.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser.mode,
      body: body,
      left: delim.text,
      right: right.delim
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    assertParsed(group); // Build the inner expression

    var inner = buildHTML_buildExpression(group.body, options, true, ["mopen", "mclose"]);
    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false; // Calculate its height and depth

    for (var i = 0; i < inner.length; i++) {
      // Property `isMiddle` not defined on `span`. See comment in
      // "middle"'s htmlBuilder.
      // $FlowFixMe
      if (inner[i].isMiddle) {
        hadMiddle = true;
      } else {
        innerHeight = Math.max(inner[i].height, innerHeight);
        innerDepth = Math.max(inner[i].depth, innerDepth);
      }
    } // The size of delimiters is the same, regardless of what style we are
    // in. Thus, to correctly calculate the size of delimiter we need around
    // a group, we scale down the inner size based on the size.


    innerHeight *= options.sizeMultiplier;
    innerDepth *= options.sizeMultiplier;
    var leftDelim;

    if (group.left === ".") {
      // Empty delimiters in \left and \right make null delimiter spaces.
      leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
      // Otherwise, use leftRightDelim to generate the correct sized
      // delimiter.
      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
    } // Add it to the beginning of the expression


    inner.unshift(leftDelim); // Handle middle delimiters

    if (hadMiddle) {
      for (var _i = 1; _i < inner.length; _i++) {
        var middleDelim = inner[_i]; // Property `isMiddle` not defined on `span`. See comment in
        // "middle"'s htmlBuilder.
        // $FlowFixMe

        var isMiddle = middleDelim.isMiddle;

        if (isMiddle) {
          // Apply the options that were active when \middle was called
          inner[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
        }
      }
    }

    var rightDelim; // Same for the right delimiter

    if (group.right === ".") {
      rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, options, group.mode, ["mclose"]);
    } // Add it to the end of the expression.


    inner.push(rightDelim);
    return buildCommon.makeSpan(["minner"], inner, options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    assertParsed(group);
    var inner = buildMathML_buildExpression(group.body, options);

    if (group.left !== ".") {
      var leftNode = new mathMLTree.MathNode("mo", [buildMathML_makeText(group.left, group.mode)]);
      leftNode.setAttribute("fence", "true");
      inner.unshift(leftNode);
    }

    if (group.right !== ".") {
      var rightNode = new mathMLTree.MathNode("mo", [buildMathML_makeText(group.right, group.mode)]);
      rightNode.setAttribute("fence", "true");
      inner.push(rightNode);
    }

    return buildMathML_makeRow(inner);
  }
});
defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1
  },
  handler: function handler(context, args) {
    var delim = checkDelimiter(args[0], context);

    if (!context.parser.leftrightDepth) {
      throw new src_ParseError("\\middle without preceding \\left", delim);
    }

    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    var middleDelim;

    if (group.delim === ".") {
      middleDelim = makeNullDelimiter(options, []);
    } else {
      middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
      var isMiddle = {
        delim: group.delim,
        options: options
      }; // Property `isMiddle` not defined on `span`. It is only used in
      // this file above.
      // TODO: Fix this violation of the `span` type and possibly rename
      // things since `isMiddle` sounds like a boolean, but is a struct.
      // $FlowFixMe

      middleDelim.isMiddle = isMiddle;
    }

    return middleDelim;
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    // A Firefox \middle will strech a character vertically only if it
    // is in the fence part of the operator dictionary at:
    // https://www.w3.org/TR/MathML3/appendixc.html.
    // So we need to avoid U+2223 and use plain "|" instead.
    var textNode = group.delim === "\\vert" || group.delim === "|" ? buildMathML_makeText("|", "text") : buildMathML_makeText(group.delim, group.mode);
    var middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true"); // MathML gives 5/18em spacing to each <mo> element.
    // \middle should get delimiter spacing instead.

    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});
// CONCATENATED MODULE: ./src/functions/enclose.js









var enclose_htmlBuilder = function htmlBuilder(group, options) {
  // \cancel, \bcancel, \xcancel, \sout, \fbox, \colorbox, \fcolorbox
  // Some groups can return document fragments.  Handle those by wrapping
  // them in a span.
  var inner = buildCommon.wrapFragment(buildHTML_buildGroup(group.body, options), options);
  var label = group.label.substr(1);
  var scale = options.sizeMultiplier;
  var img;
  var imgShift = 0; // In the LaTeX cancel package, line geometry is slightly different
  // depending on whether the subject is wider than it is tall, or vice versa.
  // We don't know the width of a group, so as a proxy, we test if
  // the subject is a single character. This captures most of the
  // subjects that should get the "tall" treatment.

  var isSingleChar = utils.isCharacterBox(group.body);

  if (label === "sout") {
    img = buildCommon.makeSpan(["stretchy", "sout"]);
    img.height = options.fontMetrics().defaultRuleThickness / scale;
    imgShift = -0.5 * options.fontMetrics().xHeight;
  } else {
    // Add horizontal padding
    if (/cancel/.test(label)) {
      if (!isSingleChar) {
        inner.classes.push("cancel-pad");
      }
    } else {
      inner.classes.push("boxpad");
    } // Add vertical padding


    var vertPad = 0; // ref: LaTeX source2e: \fboxsep = 3pt;  \fboxrule = .4pt
    // ref: cancel package: \advance\totalheight2\p@ % "+2"

    if (/box/.test(label)) {
      vertPad = label === "colorbox" ? 0.3 : 0.34;
    } else {
      vertPad = isSingleChar ? 0.2 : 0;
    }

    img = stretchy.encloseSpan(inner, label, vertPad, options);
    imgShift = inner.depth + vertPad;

    if (group.backgroundColor) {
      img.style.backgroundColor = group.backgroundColor;

      if (group.borderColor) {
        img.style.borderColor = group.borderColor;
      }
    }
  }

  var vlist;

  if (group.backgroundColor) {
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [// Put the color background behind inner;
      {
        type: "elem",
        elem: img,
        shift: imgShift
      }, {
        type: "elem",
        elem: inner,
        shift: 0
      }]
    }, options);
  } else {
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [// Write the \cancel stroke on top of inner.
      {
        type: "elem",
        elem: inner,
        shift: 0
      }, {
        type: "elem",
        elem: img,
        shift: imgShift,
        wrapperClasses: /cancel/.test(label) ? ["svg-align"] : []
      }]
    }, options);
  }

  if (/cancel/.test(label)) {
    // The cancel package documentation says that cancel lines add their height
    // to the expression, but tests show that isn't how it actually works.
    vlist.height = inner.height;
    vlist.depth = inner.depth;
  }

  if (/cancel/.test(label) && !isSingleChar) {
    // cancel does not create horiz space for its line extension.
    return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
  } else {
    return buildCommon.makeSpan(["mord"], [vlist], options);
  }
};

var enclose_mathmlBuilder = function mathmlBuilder(group, options) {
  var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);

  switch (group.label) {
    case "\\cancel":
      node.setAttribute("notation", "updiagonalstrike");
      break;

    case "\\bcancel":
      node.setAttribute("notation", "downdiagonalstrike");
      break;

    case "\\sout":
      node.setAttribute("notation", "horizontalstrike");
      break;

    case "\\fbox":
      node.setAttribute("notation", "box");
      break;

    case "\\fcolorbox":
    case "\\colorbox":
      // <menclose> doesn't have a good notation option. So use <mpadded>
      // instead. Set some attributes that come included with <menclose>.
      node.setAttribute("width", "+6pt");
      node.setAttribute("height", "+6pt");
      node.setAttribute("lspace", "3pt"); // LaTeX source2e: \fboxsep = 3pt

      node.setAttribute("voffset", "3pt");

      if (group.label === "\\fcolorbox") {
        var thk = options.fontMetrics().defaultRuleThickness;
        node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
      }

      break;

    case "\\xcancel":
      node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }

  if (group.backgroundColor) {
    node.setAttribute("mathbackground", group.backgroundColor);
  }

  return node;
};

defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: true,
    greediness: 3,
    argTypes: ["color", "text"]
  },
  handler: function handler(_ref, args, optArgs) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    var color = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: color,
      body: body
    };
  },
  htmlBuilder: enclose_htmlBuilder,
  mathmlBuilder: enclose_mathmlBuilder
});
defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: true,
    greediness: 3,
    argTypes: ["color", "color", "text"]
  },
  handler: function handler(_ref2, args, optArgs) {
    var parser = _ref2.parser,
        funcName = _ref2.funcName;
    var borderColor = assertNodeType(args[0], "color-token").color;
    var backgroundColor = assertNodeType(args[1], "color-token").color;
    var body = args[2];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: backgroundColor,
      borderColor: borderColor,
      body: body
    };
  },
  htmlBuilder: enclose_htmlBuilder,
  mathmlBuilder: enclose_mathmlBuilder
});
defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: true
  },
  handler: function handler(_ref3, args) {
    var parser = _ref3.parser;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\fbox",
      body: args[0]
    };
  }
});
defineFunction({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout"],
  props: {
    numArgs: 1
  },
  handler: function handler(_ref4, args, optArgs) {
    var parser = _ref4.parser,
        funcName = _ref4.funcName;
    var body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body: body
    };
  },
  htmlBuilder: enclose_htmlBuilder,
  mathmlBuilder: enclose_mathmlBuilder
});
// CONCATENATED MODULE: ./src/defineEnvironment.js


/**
 * All registered environments.
 * `environments.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `environments.js`.
 */
var _environments = {};
function defineEnvironment(_ref) {
  var type = _ref.type,
      names = _ref.names,
      props = _ref.props,
      handler = _ref.handler,
      htmlBuilder = _ref.htmlBuilder,
      mathmlBuilder = _ref.mathmlBuilder;
  // Set default values of environments.
  var data = {
    type: type,
    numArgs: props.numArgs || 0,
    greediness: 1,
    allowedInText: false,
    numOptionalArgs: 0,
    handler: handler
  };

  for (var i = 0; i < names.length; ++i) {
    // TODO: The value type of _environments should be a type union of all
    // possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is
    // an existential type.
    // $FlowFixMe
    _environments[names[i]] = data;
  }

  if (htmlBuilder) {
    _htmlGroupBuilders[type] = htmlBuilder;
  }

  if (mathmlBuilder) {
    _mathmlGroupBuilders[type] = mathmlBuilder;
  }
}
// CONCATENATED MODULE: ./src/environments/array.js












function getHLines(parser) {
  // Return an array. The array length = number of hlines.
  // Each element in the array tells if the line is dashed.
  var hlineInfo = [];
  parser.consumeSpaces();
  var nxt = parser.nextToken.text;

  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser.consumeSpaces();
    nxt = parser.nextToken.text;
  }

  return hlineInfo;
}
/**
 * Parse the body of the environment, with rows delimited by \\ and
 * columns delimited by &, and create a nested list in row-major order
 * with one group per cell.  If given an optional argument style
 * ("text", "display", etc.), then each cell is cast into that style.
 */


function parseArray(parser, _ref, style) {
  var hskipBeforeAndAfter = _ref.hskipBeforeAndAfter,
      addJot = _ref.addJot,
      cols = _ref.cols,
      arraystretch = _ref.arraystretch,
      colSeparationType = _ref.colSeparationType;
  // Parse body of array with \\ temporarily mapped to \cr
  parser.gullet.beginGroup();
  parser.gullet.macros.set("\\\\", "\\cr"); // Get current arraystretch if it's not set by the environment

  if (!arraystretch) {
    var stretch = parser.gullet.expandMacroAsText("\\arraystretch");

    if (stretch == null) {
      // Default \arraystretch from lttab.dtx
      arraystretch = 1;
    } else {
      arraystretch = parseFloat(stretch);

      if (!arraystretch || arraystretch < 0) {
        throw new src_ParseError("Invalid \\arraystretch: " + stretch);
      }
    }
  }

  var row = [];
  var body = [row];
  var rowGaps = [];
  var hLinesBeforeRow = []; // Test for \hline at the top of the array.

  hLinesBeforeRow.push(getHLines(parser));

  while (true) {
    // eslint-disable-line no-constant-condition
    var cell = parser.parseExpression(false, "\\cr");
    cell = {
      type: "ordgroup",
      mode: parser.mode,
      body: cell
    };

    if (style) {
      cell = {
        type: "styling",
        mode: parser.mode,
        style: style,
        body: [cell]
      };
    }

    row.push(cell);
    var next = parser.nextToken.text;

    if (next === "&") {
      parser.consume();
    } else if (next === "\\end") {
      // Arrays terminate newlines with `\crcr` which consumes a `\cr` if
      // the last line is empty.
      // NOTE: Currently, `cell` is the last item added into `row`.
      if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0) {
        body.pop();
      }

      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }

      break;
    } else if (next === "\\cr") {
      var cr = assertNodeType(parser.parseFunction(), "cr");
      rowGaps.push(cr.size); // check for \hline(s) following the row separator

      hLinesBeforeRow.push(getHLines(parser));
      row = [];
      body.push(row);
    } else {
      throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
    }
  }

  parser.gullet.endGroup();
  return {
    type: "array",
    mode: parser.mode,
    addJot: addJot,
    arraystretch: arraystretch,
    body: body,
    cols: cols,
    rowGaps: rowGaps,
    hskipBeforeAndAfter: hskipBeforeAndAfter,
    hLinesBeforeRow: hLinesBeforeRow,
    colSeparationType: colSeparationType
  };
} // Decides on a style for cells in an array according to whether the given
// environment name starts with the letter 'd'.


function dCellStyle(envName) {
  if (envName.substr(0, 1) === "d") {
    return "display";
  } else {
    return "text";
  }
}

var array_htmlBuilder = function htmlBuilder(group, options) {
  var r;
  var c;
  var nr = group.body.length;
  var hLinesBeforeRow = group.hLinesBeforeRow;
  var nc = 0;
  var body = new Array(nr);
  var hlines = []; // Horizontal spacing

  var pt = 1 / options.fontMetrics().ptPerEm;
  var arraycolsep = 5 * pt; // \arraycolsep in article.cls
  // Vertical spacing

  var baselineskip = 12 * pt; // see size10.clo
  // Default \jot from ltmath.dtx
  // TODO(edemaine): allow overriding \jot via \setlength (#687)

  var jot = 3 * pt;
  var arrayskip = group.arraystretch * baselineskip;
  var arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and

  var arstrutDepth = 0.3 * arrayskip; // \@arstrutbox in lttab.dtx

  var totalHeight = 0; // Set a position for \hline(s) at the top of the array, if any.

  function setHLinePos(hlinesInGap) {
    for (var i = 0; i < hlinesInGap.length; ++i) {
      if (i > 0) {
        totalHeight += 0.25;
      }

      hlines.push({
        pos: totalHeight,
        isDashed: hlinesInGap[i]
      });
    }
  }

  setHLinePos(hLinesBeforeRow[0]);

  for (r = 0; r < group.body.length; ++r) {
    var inrow = group.body[r];
    var height = arstrutHeight; // \@array adds an \@arstrut

    var depth = arstrutDepth; // to each tow (via the template)

    if (nc < inrow.length) {
      nc = inrow.length;
    }

    var outrow = new Array(inrow.length);

    for (c = 0; c < inrow.length; ++c) {
      var elt = buildHTML_buildGroup(inrow[c], options);

      if (depth < elt.depth) {
        depth = elt.depth;
      }

      if (height < elt.height) {
        height = elt.height;
      }

      outrow[c] = elt;
    }

    var rowGap = group.rowGaps[r];
    var gap = 0;

    if (rowGap) {
      gap = units_calculateSize(rowGap, options);

      if (gap > 0) {
        // \@argarraycr
        gap += arstrutDepth;

        if (depth < gap) {
          depth = gap; // \@xargarraycr
        }

        gap = 0;
      }
    } // In AMS multiline environments such as aligned and gathered, rows
    // correspond to lines that have additional \jot added to the
    // \baselineskip via \openup.


    if (group.addJot) {
      depth += jot;
    }

    outrow.height = height;
    outrow.depth = depth;
    totalHeight += height;
    outrow.pos = totalHeight;
    totalHeight += depth + gap; // \@yargarraycr

    body[r] = outrow; // Set a position for \hline(s), if any.

    setHLinePos(hLinesBeforeRow[r + 1]);
  }

  var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
  var colDescriptions = group.cols || [];
  var cols = [];
  var colSep;
  var colDescrNum;

  for (c = 0, colDescrNum = 0; // Continue while either there are more columns or more column
  // descriptions, so trailing separators don't get lost.
  c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {
    var colDescr = colDescriptions[colDescrNum] || {};
    var firstSeparator = true;

    while (colDescr.type === "separator") {
      // If there is more than one separator in a row, add a space
      // between them.
      if (!firstSeparator) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = options.fontMetrics().doubleRuleSep + "em";
        cols.push(colSep);
      }

      if (colDescr.separator === "|") {
        var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
        separator.style.height = totalHeight + "em";
        separator.style.verticalAlign = -(totalHeight - offset) + "em";
        cols.push(separator);
      } else if (colDescr.separator === ":") {
        var _separator = buildCommon.makeSpan(["vertical-separator", "vs-dashed"], [], options);

        _separator.style.height = totalHeight + "em";
        _separator.style.verticalAlign = -(totalHeight - offset) + "em";
        cols.push(_separator);
      } else {
        throw new src_ParseError("Invalid separator type: " + colDescr.separator);
      }

      colDescrNum++;
      colDescr = colDescriptions[colDescrNum] || {};
      firstSeparator = false;
    }

    if (c >= nc) {
      continue;
    }

    var sepwidth = void 0;

    if (c > 0 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);

      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = sepwidth + "em";
        cols.push(colSep);
      }
    }

    var col = [];

    for (r = 0; r < nr; ++r) {
      var row = body[r];
      var elem = row[c];

      if (!elem) {
        continue;
      }

      var shift = row.pos - offset;
      elem.depth = row.depth;
      elem.height = row.height;
      col.push({
        type: "elem",
        elem: elem,
        shift: shift
      });
    }

    col = buildCommon.makeVList({
      positionType: "individualShift",
      children: col
    }, options);
    col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
    cols.push(col);

    if (c < nc - 1 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);

      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = sepwidth + "em";
        cols.push(colSep);
      }
    }
  }

  body = buildCommon.makeSpan(["mtable"], cols); // Add \hline(s), if any.

  if (hlines.length > 0) {
    var line = buildCommon.makeLineSpan("hline", options, 0.05);
    var dashes = buildCommon.makeLineSpan("hdashline", options, 0.05);
    var vListElems = [{
      type: "elem",
      elem: body,
      shift: 0
    }];

    while (hlines.length > 0) {
      var hline = hlines.pop();
      var lineShift = hline.pos - offset;

      if (hline.isDashed) {
        vListElems.push({
          type: "elem",
          elem: dashes,
          shift: lineShift
        });
      } else {
        vListElems.push({
          type: "elem",
          elem: line,
          shift: lineShift
        });
      }
    }

    body = buildCommon.makeVList({
      positionType: "individualShift",
      children: vListElems
    }, options);
  }

  return buildCommon.makeSpan(["mord"], [body], options);
};

var alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};

var array_mathmlBuilder = function mathmlBuilder(group, options) {
  var table = new mathMLTree.MathNode("mtable", group.body.map(function (row) {
    return new mathMLTree.MathNode("mtr", row.map(function (cell) {
      return new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(cell, options)]);
    }));
  })); // Set column alignment, row spacing, column spacing, and
  // array lines by setting attributes on the table element.
  // Set the row spacing. In MathML, we specify a gap distance.
  // We do not use rowGap[] because MathML automatically increases
  // cell height with the height/depth of the element content.
  // LaTeX \arraystretch multiplies the row baseline-to-baseline distance.
  // We simulate this by adding (arraystretch - 1)em to the gap. This
  // does a reasonable job of adjusting arrays containing 1 em tall content.
  // The 0.16 and 0.09 values are found emprically. They produce an array
  // similar to LaTeX and in which content does not interfere with \hines.

  var gap = 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
  table.setAttribute("rowspacing", gap + "em"); // MathML table lines go only between cells.
  // To place a line on an edge we'll use <menclose>, if necessary.

  var menclose = "";
  var align = "";

  if (group.cols) {
    // Find column alignment, column spacing, and  vertical lines.
    var cols = group.cols;
    var columnLines = "";
    var prevTypeWasAlign = false;
    var iStart = 0;
    var iEnd = cols.length;

    if (cols[0].type === "separator") {
      menclose += "top ";
      iStart = 1;
    }

    if (cols[cols.length - 1].type === "separator") {
      menclose += "bottom ";
      iEnd -= 1;
    }

    for (var i = iStart; i < iEnd; i++) {
      if (cols[i].type === "align") {
        align += alignMap[cols[i].align];

        if (prevTypeWasAlign) {
          columnLines += "none ";
        }

        prevTypeWasAlign = true;
      } else if (cols[i].type === "separator") {
        // MathML accepts only single lines between cells.
        // So we read only the first of consecutive separators.
        if (prevTypeWasAlign) {
          columnLines += cols[i].separator === "|" ? "solid " : "dashed ";
          prevTypeWasAlign = false;
        }
      }
    }

    table.setAttribute("columnalign", align.trim());

    if (/[sd]/.test(columnLines)) {
      table.setAttribute("columnlines", columnLines.trim());
    }
  } // Set column spacing.


  if (group.colSeparationType === "align") {
    var _cols = group.cols || [];

    var spacing = "";

    for (var _i = 1; _i < _cols.length; _i++) {
      spacing += _i % 2 ? "0em " : "1em ";
    }

    table.setAttribute("columnspacing", spacing.trim());
  } else if (group.colSeparationType === "alignat") {
    table.setAttribute("columnspacing", "0em");
  } else {
    table.setAttribute("columnspacing", "1em");
  } // Address \hline and \hdashline


  var rowLines = "";
  var hlines = group.hLinesBeforeRow;
  menclose += hlines[0].length > 0 ? "left " : "";
  menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";

  for (var _i2 = 1; _i2 < hlines.length - 1; _i2++) {
    rowLines += hlines[_i2].length === 0 ? "none " // MathML accepts only a single line between rows. Read one element.
    : hlines[_i2][0] ? "dashed " : "solid ";
  }

  if (/[sd]/.test(rowLines)) {
    table.setAttribute("rowlines", rowLines.trim());
  }

  if (menclose === "") {
    return table;
  } else {
    var wrapper = new mathMLTree.MathNode("menclose", [table]);
    wrapper.setAttribute("notation", menclose.trim());
    return wrapper;
  }
}; // Convenience function for aligned and alignedat environments.


var array_alignedHandler = function alignedHandler(context, args) {
  var cols = [];
  var res = parseArray(context.parser, {
    cols: cols,
    addJot: true
  }, "display"); // Determining number of columns.
  // 1. If the first argument is given, we use it as a number of columns,
  //    and makes sure that each row doesn't exceed that number.
  // 2. Otherwise, just count number of columns = maximum number
  //    of cells in each row ("aligned" mode -- isAligned will be true).
  //
  // At the same time, prepend empty group {} at beginning of every second
  // cell in each row (starting with second cell) so that operators become
  // binary.  This behavior is implemented in amsmath's \start@aligned.

  var numMaths;
  var numCols = 0;
  var emptyGroup = {
    type: "ordgroup",
    mode: context.mode,
    body: []
  };
  var ordgroup = checkNodeType(args[0], "ordgroup");

  if (ordgroup) {
    var arg0 = "";

    for (var i = 0; i < ordgroup.body.length; i++) {
      var textord = assertNodeType(ordgroup.body[i], "textord");
      arg0 += textord.text;
    }

    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }

  var isAligned = !numCols;
  res.body.forEach(function (row) {
    for (var _i3 = 1; _i3 < row.length; _i3 += 2) {
      // Modify ordgroup node within styling node
      var styling = assertNodeType(row[_i3], "styling");

      var _ordgroup = assertNodeType(styling.body[0], "ordgroup");

      _ordgroup.body.unshift(emptyGroup);
    }

    if (!isAligned) {
      // Case 1
      var curMaths = row.length / 2;

      if (numMaths < curMaths) {
        throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
      }
    } else if (numCols < row.length) {
      // Case 2
      numCols = row.length;
    }
  }); // Adjusting alignment.
  // In aligned mode, we add one \qquad between columns;
  // otherwise we add nothing.

  for (var _i4 = 0; _i4 < numCols; ++_i4) {
    var align = "r";
    var pregap = 0;

    if (_i4 % 2 === 1) {
      align = "l";
    } else if (_i4 > 0 && isAligned) {
      // "aligned" mode.
      pregap = 1; // add one \quad
    }

    cols[_i4] = {
      type: "align",
      align: align,
      pregap: pregap,
      postgap: 0
    };
  }

  res.colSeparationType = isAligned ? "align" : "alignat";
  return res;
}; // Arrays are part of LaTeX, defined in lttab.dtx so its documentation
// is part of the source2e.pdf file of LaTeX2e source documentation.
// {darray} is an {array} environment where cells are set in \displaystyle,
// as defined in nccmath.sty.


defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler: function handler(context, args) {
    // Since no types are specified above, the two possibilities are
    // - The argument is wrapped in {} or [], in which case Parser's
    //   parseGroup() returns an "ordgroup" wrapping some symbol node.
    // - The argument is a bare symbol node.
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function (nde) {
      var node = assertSymbolNodeType(nde);
      var ca = node.text;

      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }

      throw new src_ParseError("Unknown column alignment: " + ca, nde);
    });
    var res = {
      cols: cols,
      hskipBeforeAndAfter: true // \@preamble in lttab.dtx

    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },
  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
}); // The matrix environments of amsmath builds on the array environment
// of LaTeX, which is discussed above.

defineEnvironment({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix"],
  props: {
    numArgs: 0
  },
  handler: function handler(context) {
    var delimiters = {
      "matrix": null,
      "pmatrix": ["(", ")"],
      "bmatrix": ["[", "]"],
      "Bmatrix": ["\\{", "\\}"],
      "vmatrix": ["|", "|"],
      "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName]; // \hskip -\arraycolsep in amsmath

    var payload = {
      hskipBeforeAndAfter: false
    };
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return delimiters ? {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: delimiters[0],
      right: delimiters[1]
    } : res;
  },
  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
}); // A cases environment (in amsmath.sty) is almost equivalent to
// \def\arraystretch{1.2}%
// \left\{\begin{array}{@{}l@{\quad}l@{}}  \end{array}\right.
// {dcases} is a {cases} environment where cells are set in \displaystyle,
// as defined in mathtools.sty.

defineEnvironment({
  type: "array",
  names: ["cases", "dcases"],
  props: {
    numArgs: 0
  },
  handler: function handler(context) {
    var payload = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1.0
        /* 1em quad */

      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    };
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: "\\{",
      right: "."
    };
  },
  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
}); // An aligned environment is like the align* environment
// except it operates within math mode.
// Note that we assume \nomallineskiplimit to be zero,
// so that \strut@ is the same as \strut.

defineEnvironment({
  type: "array",
  names: ["aligned"],
  props: {
    numArgs: 0
  },
  handler: array_alignedHandler,
  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
}); // A gathered environment is like an array environment with one centered
// column, but where rows are considered lines so get \jot line spacing
// and contents are set in \displaystyle.

defineEnvironment({
  type: "array",
  names: ["gathered"],
  props: {
    numArgs: 0
  },
  handler: function handler(context) {
    var res = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: true
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
}); // alignat environment is like an align environment, but one must explicitly
// specify maximum number of columns in each row, and can adjust spacing between
// each columns.

defineEnvironment({
  type: "array",
  names: ["alignedat"],
  // One for numbered and for unnumbered;
  // but, KaTeX doesn't supports math numbering yet,
  // they make no difference for now.
  props: {
    numArgs: 1
  },
  handler: array_alignedHandler,
  htmlBuilder: array_htmlBuilder,
  mathmlBuilder: array_mathmlBuilder
}); // Catch \hline outside array environment

defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler: function handler(context, args) {
    throw new src_ParseError(context.funcName + " valid only within array environment");
  }
});
// CONCATENATED MODULE: ./src/environments.js

var environments = _environments;
/* harmony default export */ var src_environments = (environments); // All environment definitions should be imported below


// CONCATENATED MODULE: ./src/functions/environment.js



 // Environment delimiters. HTML/MathML rendering is defined in the corresponding
// defineEnvironment definitions.
// $FlowFixMe, "environment" handler returns an environment ParseNode

defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    var nameGroup = args[0];

    if (nameGroup.type !== "ordgroup") {
      throw new src_ParseError("Invalid environment name", nameGroup);
    }

    var envName = "";

    for (var i = 0; i < nameGroup.body.length; ++i) {
      envName += assertNodeType(nameGroup.body[i], "textord").text;
    }

    if (funcName === "\\begin") {
      // begin...end is similar to left...right
      if (!src_environments.hasOwnProperty(envName)) {
        throw new src_ParseError("No such environment: " + envName, nameGroup);
      } // Build the environment object. Arguments and other information will
      // be made available to the begin and end methods using properties.


      var env = src_environments[envName];

      var _parser$parseArgument = parser.parseArguments("\\begin{" + envName + "}", env),
          _args = _parser$parseArgument.args,
          optArgs = _parser$parseArgument.optArgs;

      var context = {
        mode: parser.mode,
        envName: envName,
        parser: parser
      };
      var result = env.handler(context, _args, optArgs);
      parser.expect("\\end", false);
      var endNameToken = parser.nextToken;
      var end = assertNodeType(parser.parseFunction(), "environment");

      if (end.name !== envName) {
        throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
      }

      return result;
    }

    return {
      type: "environment",
      mode: parser.mode,
      name: envName,
      nameGroup: nameGroup
    };
  }
});
// CONCATENATED MODULE: ./src/functions/mclass.js





var mclass_makeSpan = buildCommon.makeSpan;

function mclass_htmlBuilder(group, options) {
  var elements = buildHTML_buildExpression(group.body, options, true);
  return mclass_makeSpan([group.mclass], elements, options);
}

function mclass_mathmlBuilder(group, options) {
  var inner = buildMathML_buildExpression(group.body, options);
  return mathMLTree.newDocumentFragment(inner);
} // Math class commands except \mathop


defineFunction({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    var body = args[0];
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: "m" + funcName.substr(5),
      body: defineFunction_ordargument(body)
    };
  },
  htmlBuilder: mclass_htmlBuilder,
  mathmlBuilder: mclass_mathmlBuilder
});
var binrelClass = function binrelClass(arg) {
  // \binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.
  // (by rendering separately and with {}s before and after, and measuring
  // the change in spacing).  We'll do roughly the same by detecting the
  // atom type directly.
  var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;

  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
}; // \@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.
// This is equivalent to \binrel@{x}\binrel@@{y} in AMSTeX.

defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler: function handler(_ref2, args) {
    var parser = _ref2.parser;
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: [args[1]]
    };
  }
}); // Build a relation or stacked op by placing one symbol on top of another

defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler: function handler(_ref3, args) {
    var parser = _ref3.parser,
        funcName = _ref3.funcName;
    var baseArg = args[1];
    var shiftedArg = args[0];
    var mclass;

    if (funcName !== "\\stackrel") {
      // LaTeX applies \binrel spacing to \overset and \underset.
      mclass = binrelClass(baseArg);
    } else {
      mclass = "mrel"; // for \stackrel
    }

    var baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      suppressBaseShift: funcName !== "\\stackrel",
      body: defineFunction_ordargument(baseArg)
    };
    var supsub = {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: mclass,
      body: [supsub]
    };
  },
  htmlBuilder: mclass_htmlBuilder,
  mathmlBuilder: mclass_mathmlBuilder
});
// CONCATENATED MODULE: ./src/functions/font.js
// TODO(kevinb): implement \\sl and \\sc





var font_htmlBuilder = function htmlBuilder(group, options) {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildHTML_buildGroup(group.body, newOptions);
};

var font_mathmlBuilder = function mathmlBuilder(group, options) {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildMathML_buildGroup(group.body, newOptions);
};

var fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
defineFunction({
  type: "font",
  names: [// styles, except \boldsymbol defined below
  "\\mathrm", "\\mathit", "\\mathbf", "\\mathnormal", // families
  "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf", "\\mathtt", // aliases, except \bm defined below
  "\\Bbb", "\\bold", "\\frak"],
  props: {
    numArgs: 1,
    greediness: 2
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    var body = args[0];
    var func = funcName;

    if (func in fontAliases) {
      func = fontAliases[func];
    }

    return {
      type: "font",
      mode: parser.mode,
      font: func.slice(1),
      body: body
    };
  },
  htmlBuilder: font_htmlBuilder,
  mathmlBuilder: font_mathmlBuilder
});
defineFunction({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1,
    greediness: 2
  },
  handler: function handler(_ref2, args) {
    var parser = _ref2.parser;
    var body = args[0]; // amsbsy.sty's \boldsymbol uses \binrel spacing to inherit the
    // argument's bin|rel|ord status

    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(body),
      body: [{
        type: "font",
        mode: parser.mode,
        font: "boldsymbol",
        body: body
      }]
    };
  }
}); // Old font changing functions

defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: function handler(_ref3, args) {
    var parser = _ref3.parser,
        funcName = _ref3.funcName,
        breakOnTokenText = _ref3.breakOnTokenText;
    var mode = parser.mode;
    var body = parser.parseExpression(true, breakOnTokenText);
    var style = "math" + funcName.slice(1);
    return {
      type: "font",
      mode: mode,
      font: style,
      body: {
        type: "ordgroup",
        mode: parser.mode,
        body: body
      }
    };
  },
  htmlBuilder: font_htmlBuilder,
  mathmlBuilder: font_mathmlBuilder
});
// CONCATENATED MODULE: ./src/functions/genfrac.js











var genfrac_adjustStyle = function adjustStyle(size, originalStyle) {
  // Figure out what style this fraction should be in based on the
  // function used
  var style = originalStyle;

  if (size === "display") {
    // Get display style as a default.
    // If incoming style is sub/sup, use style.text() to get correct size.
    style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
  } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
    // We're in a \tfrac but incoming style is displaystyle, so:
    style = src_Style.TEXT;
  } else if (size === "script") {
    style = src_Style.SCRIPT;
  } else if (size === "scriptscript") {
    style = src_Style.SCRIPTSCRIPT;
  }

  return style;
};

var genfrac_htmlBuilder = function htmlBuilder(group, options) {
  // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
  var style = genfrac_adjustStyle(group.size, options.style);
  var nstyle = style.fracNum();
  var dstyle = style.fracDen();
  var newOptions;
  newOptions = options.havingStyle(nstyle);
  var numerm = buildHTML_buildGroup(group.numer, newOptions, options);

  if (group.continued) {
    // \cfrac inserts a \strut into the numerator.
    // Get \strut dimensions from TeXbook page 353.
    var hStrut = 8.5 / options.fontMetrics().ptPerEm;
    var dStrut = 3.5 / options.fontMetrics().ptPerEm;
    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
  }

  newOptions = options.havingStyle(dstyle);
  var denomm = buildHTML_buildGroup(group.denom, newOptions, options);
  var rule;
  var ruleWidth;
  var ruleSpacing;

  if (group.hasBarLine) {
    if (group.barSize) {
      ruleWidth = units_calculateSize(group.barSize, options);
      rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
    } else {
      rule = buildCommon.makeLineSpan("frac-line", options);
    }

    ruleWidth = rule.height;
    ruleSpacing = rule.height;
  } else {
    rule = null;
    ruleWidth = 0;
    ruleSpacing = options.fontMetrics().defaultRuleThickness;
  } // Rule 15b


  var numShift;
  var clearance;
  var denomShift;

  if (style.size === src_Style.DISPLAY.size || group.size === "display") {
    numShift = options.fontMetrics().num1;

    if (ruleWidth > 0) {
      clearance = 3 * ruleSpacing;
    } else {
      clearance = 7 * ruleSpacing;
    }

    denomShift = options.fontMetrics().denom1;
  } else {
    if (ruleWidth > 0) {
      numShift = options.fontMetrics().num2;
      clearance = ruleSpacing;
    } else {
      numShift = options.fontMetrics().num3;
      clearance = 3 * ruleSpacing;
    }

    denomShift = options.fontMetrics().denom2;
  }

  var frac;

  if (!rule) {
    // Rule 15c
    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);

    if (candidateClearance < clearance) {
      numShift += 0.5 * (clearance - candidateClearance);
      denomShift += 0.5 * (clearance - candidateClearance);
    }

    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  } else {
    // Rule 15d
    var axisHeight = options.fontMetrics().axisHeight;

    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
    }

    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
    }

    var midShift = -(axisHeight - 0.5 * ruleWidth);
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: rule,
        shift: midShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  } // Since we manually change the style sometimes (with \dfrac or \tfrac),
  // account for the possible size change here.


  newOptions = options.havingStyle(style);
  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier; // Rule 15e

  var delimSize;

  if (style.size === src_Style.DISPLAY.size) {
    delimSize = options.fontMetrics().delim1;
  } else {
    delimSize = options.fontMetrics().delim2;
  }

  var leftDelim;
  var rightDelim;

  if (group.leftDelim == null) {
    leftDelim = makeNullDelimiter(options, ["mopen"]);
  } else {
    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
  }

  if (group.continued) {
    rightDelim = buildCommon.makeSpan([]); // zero width for \cfrac
  } else if (group.rightDelim == null) {
    rightDelim = makeNullDelimiter(options, ["mclose"]);
  } else {
    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
  }

  return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
};

var genfrac_mathmlBuilder = function mathmlBuilder(group, options) {
  var node = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);

  if (!group.hasBarLine) {
    node.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    var ruleWidth = units_calculateSize(group.barSize, options);
    node.setAttribute("linethickness", ruleWidth + "em");
  }

  var style = genfrac_adjustStyle(group.size, options.style);

  if (style.size !== options.style.size) {
    node = new mathMLTree.MathNode("mstyle", [node]);
    var isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
    node.setAttribute("displaystyle", isDisplay);
    node.setAttribute("scriptlevel", "0");
  }

  if (group.leftDelim != null || group.rightDelim != null) {
    var withDelims = [];

    if (group.leftDelim != null) {
      var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }

    withDelims.push(node);

    if (group.rightDelim != null) {
      var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }

    return buildMathML_makeRow(withDelims);
  }

  return node;
};

defineFunction({
  type: "genfrac",
  names: ["\\cfrac", "\\dfrac", "\\frac", "\\tfrac", "\\dbinom", "\\binom", "\\tbinom", "\\\\atopfrac", // cant be entered directly
  "\\\\bracefrac", "\\\\brackfrac"],
  props: {
    numArgs: 2,
    greediness: 2
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size = "auto";

    switch (funcName) {
      case "\\cfrac":
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;

      case "\\\\atopfrac":
        hasBarLine = false;
        break;

      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        hasBarLine = false;
        leftDelim = "(";
        rightDelim = ")";
        break;

      case "\\\\bracefrac":
        hasBarLine = false;
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;

      case "\\\\brackfrac":
        hasBarLine = false;
        leftDelim = "[";
        rightDelim = "]";
        break;

      default:
        throw new Error("Unrecognized genfrac command");
    }

    switch (funcName) {
      case "\\cfrac":
      case "\\dfrac":
      case "\\dbinom":
        size = "display";
        break;

      case "\\tfrac":
      case "\\tbinom":
        size = "text";
        break;
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      continued: funcName === "\\cfrac",
      numer: numer,
      denom: denom,
      hasBarLine: hasBarLine,
      leftDelim: leftDelim,
      rightDelim: rightDelim,
      size: size,
      barSize: null
    };
  },
  htmlBuilder: genfrac_htmlBuilder,
  mathmlBuilder: genfrac_mathmlBuilder
}); // Infix generalized fractions -- these are not rendered directly, but replaced
// immediately by one of the variants above.

defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler: function handler(_ref2) {
    var parser = _ref2.parser,
        funcName = _ref2.funcName,
        token = _ref2.token;
    var replaceWith;

    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;

      case "\\choose":
        replaceWith = "\\binom";
        break;

      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;

      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;

      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;

      default:
        throw new Error("Unrecognized infix genfrac command");
    }

    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: replaceWith,
      token: token
    };
  }
});
var stylArray = ["display", "text", "script", "scriptscript"];

var delimFromValue = function delimFromValue(delimString) {
  var delim = null;

  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }

  return delim;
};

defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    greediness: 6,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler: function handler(_ref3, args) {
    var parser = _ref3.parser;
    var numer = args[4];
    var denom = args[5]; // Look into the parse nodes to get the desired delimiters.

    var leftNode = checkNodeType(args[0], "atom");

    if (leftNode) {
      leftNode = assertAtomFamily(args[0], "open");
    }

    var leftDelim = leftNode ? delimFromValue(leftNode.text) : null;
    var rightNode = checkNodeType(args[1], "atom");

    if (rightNode) {
      rightNode = assertAtomFamily(args[1], "close");
    }

    var rightDelim = rightNode ? delimFromValue(rightNode.text) : null;
    var barNode = assertNodeType(args[2], "size");
    var hasBarLine;
    var barSize = null;

    if (barNode.isBlank) {
      // \genfrac acts differently than \above.
      // \genfrac treats an empty size group as a signal to use a
      // standard bar size. \above would see size = 0 and omit the bar.
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    } // Find out if we want displaystyle, textstyle, etc.


    var size = "auto";
    var styl = checkNodeType(args[3], "ordgroup");

    if (styl) {
      if (styl.body.length > 0) {
        var textOrd = assertNodeType(styl.body[0], "textord");
        size = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(args[3], "textord");
      size = stylArray[Number(styl.text)];
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      numer: numer,
      denom: denom,
      continued: false,
      hasBarLine: hasBarLine,
      barSize: barSize,
      leftDelim: leftDelim,
      rightDelim: rightDelim,
      size: size
    };
  },
  htmlBuilder: genfrac_htmlBuilder,
  mathmlBuilder: genfrac_mathmlBuilder
}); // \above is an infix fraction that also defines a fraction bar size.

defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler: function handler(_ref4, args) {
    var parser = _ref4.parser,
        funcName = _ref4.funcName,
        token = _ref4.token;
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: "\\\\abovefrac",
      size: assertNodeType(args[0], "size").value,
      token: token
    };
  }
});
defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: function handler(_ref5, args) {
    var parser = _ref5.parser,
        funcName = _ref5.funcName;
    var numer = args[0];
    var barSize = assert(assertNodeType(args[1], "infix").size);
    var denom = args[2];
    var hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser.mode,
      numer: numer,
      denom: denom,
      continued: false,
      hasBarLine: hasBarLine,
      barSize: barSize,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: genfrac_htmlBuilder,
  mathmlBuilder: genfrac_mathmlBuilder
});
// CONCATENATED MODULE: ./src/functions/horizBrace.js








// NOTE: Unlike most `htmlBuilder`s, this one handles not only "horizBrace", but
var horizBrace_htmlBuilder = function htmlBuilder(grp, options) {
  var style = options.style; // Pull out the `ParseNode<"horizBrace">` if `grp` is a "supsub" node.

  var supSubGroup;
  var group;
  var supSub = checkNodeType(grp, "supsub");

  if (supSub) {
    // Ref: LaTeX source2e: }}}}\limits}
    // i.e. LaTeX treats the brace similar to an op and passes it
    // with \limits, so we need to assign supsub style.
    supSubGroup = supSub.sup ? buildHTML_buildGroup(supSub.sup, options.havingStyle(style.sup()), options) : buildHTML_buildGroup(supSub.sub, options.havingStyle(style.sub()), options);
    group = assertNodeType(supSub.base, "horizBrace");
  } else {
    group = assertNodeType(grp, "horizBrace");
  } // Build the base group


  var body = buildHTML_buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY)); // Create the stretchy element

  var braceBody = stretchy.svgSpan(group, options); // Generate the vlist, with the appropriate kerns        
  // This first vlist contains the content and the brace:   equation

  var vlist;

  if (group.isOver) {
    vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: braceBody
      }]
    }, options); // $FlowFixMe: Replace this with passing "svg-align" into makeVList.

    vlist.children[0].children[0].children[1].classes.push("svg-align");
  } else {
    vlist = buildCommon.makeVList({
      positionType: "bottom",
      positionData: body.depth + 0.1 + braceBody.height,
      children: [{
        type: "elem",
        elem: braceBody
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: body
      }]
    }, options); // $FlowFixMe: Replace this with passing "svg-align" into makeVList.

    vlist.children[0].children[0].children[0].classes.push("svg-align");
  }

  if (supSubGroup) {
    // To write the supsub, wrap the first vlist in another vlist:
    // They can't all go in the same vlist, because the note might be
    // wider than the equation. We want the equation to control the
    // brace width.
    //      note          long note           long note
    //      or         not    
    //    equation           eqn                 eqn
    var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);

    if (group.isOver) {
      vlist = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: vSpan
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: supSubGroup
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "bottom",
        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
        children: [{
          type: "elem",
          elem: supSubGroup
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: vSpan
        }]
      }, options);
    }
  }

  return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
};

var horizBrace_mathmlBuilder = function mathmlBuilder(group, options) {
  var accentNode = stretchy.mathMLnode(group.label);
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
}; // Horizontal stretchy braces


defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    return {
      type: "horizBrace",
      mode: parser.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },
  htmlBuilder: horizBrace_htmlBuilder,
  mathmlBuilder: horizBrace_mathmlBuilder
});
// CONCATENATED MODULE: ./src/functions/href.js






defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser;
    var body = args[1];
    var href = assertNodeType(args[0], "url").url;
    return {
      type: "href",
      mode: parser.mode,
      href: href,
      body: defineFunction_ordargument(body)
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    var elements = buildHTML_buildExpression(group.body, options, false);
    return buildCommon.makeAnchor(group.href, [], elements, options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var math = buildExpressionRow(group.body, options);

    if (!(math instanceof mathMLTree_MathNode)) {
      math = new mathMLTree_MathNode("mrow", [math]);
    }

    math.setAttribute("href", group.href);
    return math;
  }
});
defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: function handler(_ref2, args) {
    var parser = _ref2.parser;
    var href = assertNodeType(args[0], "url").url;
    var chars = [];

    for (var i = 0; i < href.length; i++) {
      var c = href[i];

      if (c === "~") {
        c = "\\textasciitilde";
      }

      chars.push({
        type: "textord",
        mode: "text",
        text: c
      });
    }

    var body = {
      type: "text",
      mode: parser.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser.mode,
      href: href,
      body: defineFunction_ordargument(body)
    };
  }
});
// CONCATENATED MODULE: ./src/functions/htmlmathml.js




defineFunction({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: true
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser;
    return {
      type: "htmlmathml",
      mode: parser.mode,
      html: defineFunction_ordargument(args[0]),
      mathml: defineFunction_ordargument(args[1])
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    var elements = buildHTML_buildExpression(group.html, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    return buildExpressionRow(group.mathml, options);
  }
});
// CONCATENATED MODULE: ./src/functions/kern.js
// Horizontal spacing commands




 // TODO: \hskip and \mskip should support plus and minus in lengths

defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    allowedInText: true
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    var size = assertNodeType(args[0], "size");

    if (parser.settings.strict) {
      var mathFunction = funcName[1] === 'm'; // \mkern, \mskip

      var muUnit = size.value.unit === 'mu';

      if (mathFunction) {
        if (!muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
        }

        if (parser.mode !== "math") {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
        }
      } else {
        // !mathFunction
        if (muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
        }
      }
    }

    return {
      type: "kern",
      mode: parser.mode,
      dimension: size.value
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    return buildCommon.makeGlue(group.dimension, options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var dimension = units_calculateSize(group.dimension, options);
    return new mathMLTree.SpaceNode(dimension);
  }
});
// CONCATENATED MODULE: ./src/functions/lap.js
// Horizontal overlap functions





defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    var body = args[0];
    return {
      type: "lap",
      mode: parser.mode,
      alignment: funcName.slice(5),
      body: body
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    // mathllap, mathrlap, mathclap
    var inner;

    if (group.alignment === "clap") {
      // ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/
      inner = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options)]); // wrap, since CSS will center a .clap > .inner > span

      inner = buildCommon.makeSpan(["inner"], [inner], options);
    } else {
      inner = buildCommon.makeSpan(["inner"], [buildHTML_buildGroup(group.body, options)]);
    }

    var fix = buildCommon.makeSpan(["fix"], []);
    var node = buildCommon.makeSpan([group.alignment], [inner, fix], options); // At this point, we have correctly set horizontal alignment of the
    // two items involved in the lap.
    // Next, use a strut to set the height of the HTML bounding box.
    // Otherwise, a tall argument may be misplaced.

    var strut = buildCommon.makeSpan(["strut"]);
    strut.style.height = node.height + node.depth + "em";
    strut.style.verticalAlign = -node.depth + "em";
    node.children.unshift(strut); // Next, prevent vertical misplacement when next to something tall.

    node = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options); // Get the horizontal spacing correct relative to adjacent items.

    return buildCommon.makeSpan(["mord"], [node], options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    // mathllap, mathrlap, mathclap
    var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);

    if (group.alignment !== "rlap") {
      var offset = group.alignment === "llap" ? "-1" : "-0.5";
      node.setAttribute("lspace", offset + "width");
    }

    node.setAttribute("width", "0px");
    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/math.js

 // Switching from text mode back to math mode

defineFunction({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false,
    consumeMode: "math"
  },
  handler: function handler(_ref, args) {
    var funcName = _ref.funcName,
        parser = _ref.parser;
    var outerMode = parser.mode;
    parser.switchMode("math");
    var close = funcName === "\\(" ? "\\)" : "$";
    var body = parser.parseExpression(false, close); // We can't expand the next symbol after the closing $ until after
    // switching modes back.  So don't consume within expect.

    parser.expect(close, false);
    parser.switchMode(outerMode);
    parser.consume();
    return {
      type: "styling",
      mode: parser.mode,
      style: "text",
      body: body
    };
  }
}); // Check for extra closing math delimiters

defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler: function handler(context, args) {
    throw new src_ParseError("Mismatched " + context.funcName);
  }
});
// CONCATENATED MODULE: ./src/functions/mathchoice.js






var mathchoice_chooseMathStyle = function chooseMathStyle(group, options) {
  switch (options.style.size) {
    case src_Style.DISPLAY.size:
      return group.display;

    case src_Style.TEXT.size:
      return group.text;

    case src_Style.SCRIPT.size:
      return group.script;

    case src_Style.SCRIPTSCRIPT.size:
      return group.scriptscript;

    default:
      return group.text;
  }
};

defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser;
    return {
      type: "mathchoice",
      mode: parser.mode,
      display: defineFunction_ordargument(args[0]),
      text: defineFunction_ordargument(args[1]),
      script: defineFunction_ordargument(args[2]),
      scriptscript: defineFunction_ordargument(args[3])
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    var body = mathchoice_chooseMathStyle(group, options);
    var elements = buildHTML_buildExpression(body, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var body = mathchoice_chooseMathStyle(group, options);
    return buildExpressionRow(body, options);
  }
});
// CONCATENATED MODULE: ./src/functions/op.js
// Limits, symbols









// Most operators have a large successor symbol, but these don't.
var noSuccessor = ["\\smallint"]; // NOTE: Unlike most `htmlBuilder`s, this one handles not only "op", but also
// "supsub" since some of them (like \int) can affect super/subscripting.

var op_htmlBuilder = function htmlBuilder(grp, options) {
  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  var supSub = checkNodeType(grp, "supsub");

  if (supSub) {
    // If we have limits, supsub will pass us its group to handle. Pull
    // out the superscript and subscript and set the group to the op in
    // its base.
    supGroup = supSub.sup;
    subGroup = supSub.sub;
    group = assertNodeType(supSub.base, "op");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "op");
  }

  var style = options.style;
  var large = false;

  if (style.size === src_Style.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
    // Most symbol operators get larger in displaystyle (rule 13)
    large = true;
  }

  var base;

  if (group.symbol) {
    // If this is a symbol, create the symbol.
    var fontName = large ? "Size2-Regular" : "Size1-Regular";
    var stash = "";

    if (group.name === "\\oiint" || group.name === "\\oiiint") {
      // No font glyphs yet, so use a glyph w/o the oval.
      // TODO: When font glyphs are available, delete this code.
      stash = group.name.substr(1); // $FlowFixMe

      group.name = stash === "oiint" ? "\\iint" : "\\iiint";
    }

    base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);

    if (stash.length > 0) {
      // We're in \oiint or \oiiint. Overlay the oval.
      // TODO: When font glyphs are available, delete this code.
      var italic = base.italic;
      var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
      base = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: base,
          shift: 0
        }, {
          type: "elem",
          elem: oval,
          shift: large ? 0.08 : 0
        }]
      }, options); // $FlowFixMe

      group.name = "\\" + stash;
      base.classes.unshift("mop"); // $FlowFixMe

      base.italic = italic;
    }
  } else if (group.body) {
    // If this is a list, compose that list.
    var inner = buildHTML_buildExpression(group.body, options, true);

    if (inner.length === 1 && inner[0] instanceof domTree_SymbolNode) {
      base = inner[0];
      base.classes[0] = "mop"; // replace old mclass
    } else {
      base = buildCommon.makeSpan(["mop"], buildCommon.tryCombineChars(inner), options);
    }
  } else {
    // Otherwise, this is a text operator. Build the text from the
    // operator's name.
    // TODO(emily): Add a space in the middle of some of these
    // operators, like \limsup
    var output = [];

    for (var i = 1; i < group.name.length; i++) {
      output.push(buildCommon.mathsym(group.name[i], group.mode));
    }

    base = buildCommon.makeSpan(["mop"], output, options);
  } // If content of op is a single symbol, shift it vertically.


  var baseShift = 0;
  var slant = 0;

  if ((base instanceof domTree_SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
    // We suppress the shift of the base of \overset and \underset. Otherwise,
    // shift the symbol so its center lies on the axis (rule 13). It
    // appears that our fonts have the centers of the symbols already
    // almost on the axis, so these numbers are very small. Note we
    // don't actually apply this here, but instead it is used either in
    // the vlist creation or separately when there are no limits.
    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight; // The slant of the symbol is just its italic correction.
    // $FlowFixMe

    slant = base.italic;
  }

  if (hasLimits) {
    // IE 8 clips \int if it is in a display: inline-block. We wrap it
    // in a new span so it is an inline, and works.
    base = buildCommon.makeSpan([], [base]);
    var sub;
    var sup; // We manually have to handle the superscripts and subscripts. This,
    // aside from the kern calculations, is copied from supsub.

    if (supGroup) {
      var elem = buildHTML_buildGroup(supGroup, options.havingStyle(style.sup()), options);
      sup = {
        elem: elem,
        kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
      };
    }

    if (subGroup) {
      var _elem = buildHTML_buildGroup(subGroup, options.havingStyle(style.sub()), options);

      sub = {
        elem: _elem,
        kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
      };
    } // Build the final group as a vlist of the possible subscript, base,
    // and possible superscript.


    var finalGroup;

    if (sup && sub) {
      var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;
      finalGroup = buildCommon.makeVList({
        positionType: "bottom",
        positionData: bottom,
        children: [{
          type: "kern",
          size: options.fontMetrics().bigOpSpacing5
        }, {
          type: "elem",
          elem: sub.elem,
          marginLeft: -slant + "em"
        }, {
          type: "kern",
          size: sub.kern
        }, {
          type: "elem",
          elem: base
        }, {
          type: "kern",
          size: sup.kern
        }, {
          type: "elem",
          elem: sup.elem,
          marginLeft: slant + "em"
        }, {
          type: "kern",
          size: options.fontMetrics().bigOpSpacing5
        }]
      }, options);
    } else if (sub) {
      var top = base.height - baseShift; // Shift the limits by the slant of the symbol. Note
      // that we are supposed to shift the limits by 1/2 of the slant,
      // but since we are centering the limits adding a full slant of
      // margin will shift by 1/2 that.

      finalGroup = buildCommon.makeVList({
        positionType: "top",
        positionData: top,
        children: [{
          type: "kern",
          size: options.fontMetrics().bigOpSpacing5
        }, {
          type: "elem",
          elem: sub.elem,
          marginLeft: -slant + "em"
        }, {
          type: "kern",
          size: sub.kern
        }, {
          type: "elem",
          elem: base
        }]
      }, options);
    } else if (sup) {
      var _bottom = base.depth + baseShift;

      finalGroup = buildCommon.makeVList({
        positionType: "bottom",
        positionData: _bottom,
        children: [{
          type: "elem",
          elem: base
        }, {
          type: "kern",
          size: sup.kern
        }, {
          type: "elem",
          elem: sup.elem,
          marginLeft: slant + "em"
        }, {
          type: "kern",
          size: options.fontMetrics().bigOpSpacing5
        }]
      }, options);
    } else {
      // This case probably shouldn't occur (this would mean the
      // supsub was sending us a group with no superscript or
      // subscript) but be safe.
      return base;
    }

    return buildCommon.makeSpan(["mop", "op-limits"], [finalGroup], options);
  } else {
    if (baseShift) {
      base.style.position = "relative";
      base.style.top = baseShift + "em";
    }

    return base;
  }
};

var op_mathmlBuilder = function mathmlBuilder(group, options) {
  var node;

  if (group.symbol) {
    // This is a symbol. Just add the symbol.
    node = new mathMLTree_MathNode("mo", [buildMathML_makeText(group.name, group.mode)]);

    if (utils.contains(noSuccessor, group.name)) {
      node.setAttribute("largeop", "false");
    }
  } else if (group.body) {
    // This is an operator with children. Add them.
    node = new mathMLTree_MathNode("mo", buildMathML_buildExpression(group.body, options));
  } else {
    // This is a text operator. Add all of the characters from the
    // operator's name.
    // TODO(emily): Add a space in the middle of some of these
    // operators, like \limsup.
    node = new mathMLTree_MathNode("mi", [new mathMLTree_TextNode(group.name.slice(1))]); // Append an <mo>&ApplyFunction;</mo>.
    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4

    var operator = new mathMLTree_MathNode("mo", [buildMathML_makeText("\u2061", "text")]);

    if (group.parentIsSupSub) {
      node = new mathMLTree_MathNode("mo", [node, operator]);
    } else {
      node = newDocumentFragment([node, operator]);
    }
  }

  return node;
};

var singleCharBigOps = {
  "\u220F": "\\prod",
  "\u2210": "\\coprod",
  "\u2211": "\\sum",
  "\u22C0": "\\bigwedge",
  "\u22C1": "\\bigvee",
  "\u22C2": "\\bigcap",
  "\u22C3": "\\bigcup",
  "\u2A00": "\\bigodot",
  "\u2A01": "\\bigoplus",
  "\u2A02": "\\bigotimes",
  "\u2A04": "\\biguplus",
  "\u2A06": "\\bigsqcup"
};
defineFunction({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
  props: {
    numArgs: 0
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    var fName = funcName;

    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }

    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: op_htmlBuilder,
  mathmlBuilder: op_mathmlBuilder
}); // Note: calling defineFunction with a type that's already been defined only
// works because the same htmlBuilder and mathmlBuilder are being used.

defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1
  },
  handler: function handler(_ref2, args) {
    var parser = _ref2.parser;
    var body = args[0];
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      body: defineFunction_ordargument(body)
    };
  },
  htmlBuilder: op_htmlBuilder,
  mathmlBuilder: op_mathmlBuilder
}); // There are 2 flags for operators; whether they produce limits in
// displaystyle, and whether they are symbols and should grow in
// displaystyle. These four groups cover the four possible choices.

var singleCharIntegrals = {
  "\u222B": "\\int",
  "\u222C": "\\iint",
  "\u222D": "\\iiint",
  "\u222E": "\\oint",
  "\u222F": "\\oiint",
  "\u2230": "\\oiiint"
}; // No limits, not symbols

defineFunction({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler: function handler(_ref3) {
    var parser = _ref3.parser,
        funcName = _ref3.funcName;
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: op_htmlBuilder,
  mathmlBuilder: op_mathmlBuilder
}); // Limits, not symbols

defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler: function handler(_ref4) {
    var parser = _ref4.parser,
        funcName = _ref4.funcName;
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: op_htmlBuilder,
  mathmlBuilder: op_mathmlBuilder
}); // No limits, symbols

defineFunction({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
  props: {
    numArgs: 0
  },
  handler: function handler(_ref5) {
    var parser = _ref5.parser,
        funcName = _ref5.funcName;
    var fName = funcName;

    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }

    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: op_htmlBuilder,
  mathmlBuilder: op_mathmlBuilder
});
// CONCATENATED MODULE: ./src/functions/operatorname.js





 // \operatorname
// amsopn.dtx: \mathop{#1\kern\z@\operator@font#3}\newmcodes@

defineFunction({
  type: "operatorname",
  names: ["\\operatorname"],
  props: {
    numArgs: 1
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser;
    var body = args[0];
    return {
      type: "operatorname",
      mode: parser.mode,
      body: defineFunction_ordargument(body)
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    if (group.body.length > 0) {
      var body = group.body.map(function (child) {
        // $FlowFixMe: Check if the node has a string `text` property.
        var childText = child.text;

        if (typeof childText === "string") {
          return {
            type: "textord",
            mode: child.mode,
            text: childText
          };
        } else {
          return child;
        }
      }); // Consolidate function names into symbol characters.

      var expression = buildHTML_buildExpression(body, options.withFont("mathrm"), true);

      for (var i = 0; i < expression.length; i++) {
        var child = expression[i];

        if (child instanceof domTree_SymbolNode) {
          // Per amsopn package,
          // change minus to hyphen and \ast to asterisk
          child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
        }
      }

      return buildCommon.makeSpan(["mop"], expression, options);
    } else {
      return buildCommon.makeSpan(["mop"], [], options);
    }
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    // The steps taken here are similar to the html version.
    var expression = buildMathML_buildExpression(group.body, options.withFont("mathrm")); // Is expression a string or has it something like a fraction?

    var isAllString = true; // default

    for (var i = 0; i < expression.length; i++) {
      var node = expression[i];

      if (node instanceof mathMLTree.SpaceNode) {// Do nothing
      } else if (node instanceof mathMLTree.MathNode) {
        switch (node.type) {
          case "mi":
          case "mn":
          case "ms":
          case "mspace":
          case "mtext":
            break;
          // Do nothing yet.

          case "mo":
            {
              var child = node.children[0];

              if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
              } else {
                isAllString = false;
              }

              break;
            }

          default:
            isAllString = false;
        }
      } else {
        isAllString = false;
      }
    }

    if (isAllString) {
      // Write a single TextNode instead of multiple nested tags.
      var word = expression.map(function (node) {
        return node.toText();
      }).join("");
      expression = [new mathMLTree.TextNode(word)];
    }

    var identifier = new mathMLTree.MathNode("mi", expression);
    identifier.setAttribute("mathvariant", "normal"); // \u2061 is the same as &ApplyFunction;
    // ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp

    var operator = new mathMLTree.MathNode("mo", [buildMathML_makeText("\u2061", "text")]);
    return mathMLTree.newDocumentFragment([identifier, operator]);
  }
});
// CONCATENATED MODULE: ./src/functions/ordgroup.js




defineFunctionBuilders({
  type: "ordgroup",
  htmlBuilder: function htmlBuilder(group, options) {
    if (group.semisimple) {
      return buildCommon.makeFragment(buildHTML_buildExpression(group.body, options, false));
    }

    return buildCommon.makeSpan(["mord"], buildHTML_buildExpression(group.body, options, true), options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    return buildExpressionRow(group.body, options);
  }
});
// CONCATENATED MODULE: ./src/functions/overline.js





defineFunction({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser;
    var body = args[0];
    return {
      type: "overline",
      mode: parser.mode,
      body: body
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    // Overlines are handled in the TeXbook pg 443, Rule 9.
    // Build the inner group in the cramped style.
    var innerGroup = buildHTML_buildGroup(group.body, options.havingCrampedStyle()); // Create the line above the body

    var line = buildCommon.makeLineSpan("overline-line", options); // Generate the vlist, with the appropriate kerns

    var vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: innerGroup
      }, {
        type: "kern",
        size: 3 * line.height
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: line.height
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
    operator.setAttribute("stretchy", "true");
    var node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
    node.setAttribute("accent", "true");
    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/phantom.js





defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser;
    var body = args[0];
    return {
      type: "phantom",
      mode: parser.mode,
      body: defineFunction_ordargument(body)
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    var elements = buildHTML_buildExpression(group.body, options.withPhantom(), false); // \phantom isn't supposed to affect the elements it contains.
    // See "color" for more details.

    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var inner = buildMathML_buildExpression(group.body, options);
    return new mathMLTree.MathNode("mphantom", inner);
  }
});
defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: function handler(_ref2, args) {
    var parser = _ref2.parser;
    var body = args[0];
    return {
      type: "hphantom",
      mode: parser.mode,
      body: body
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    var node = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options.withPhantom())]);
    node.height = 0;
    node.depth = 0;

    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        node.children[i].height = 0;
        node.children[i].depth = 0;
      }
    } // See smash for comment re: use of makeVList


    node = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options); // For spacing, TeX treats \smash as a math group (same spacing as ord).

    return buildCommon.makeSpan(["mord"], [node], options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var inner = buildMathML_buildExpression(defineFunction_ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner);
    var node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("height", "0px");
    node.setAttribute("depth", "0px");
    return node;
  }
});
defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: function handler(_ref3, args) {
    var parser = _ref3.parser;
    var body = args[0];
    return {
      type: "vphantom",
      mode: parser.mode,
      body: body
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    var inner = buildCommon.makeSpan(["inner"], [buildHTML_buildGroup(group.body, options.withPhantom())]);
    var fix = buildCommon.makeSpan(["fix"], []);
    return buildCommon.makeSpan(["mord", "rlap"], [inner, fix], options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var inner = buildMathML_buildExpression(defineFunction_ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner);
    var node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("width", "0px");
    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/sizing.js





function sizingGroup(value, options, baseOptions) {
  var inner = buildHTML_buildExpression(value, options, false);
  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier; // Add size-resetting classes to the inner list and set maxFontSize
  // manually. Handle nested size changes.

  for (var i = 0; i < inner.length; i++) {
    var pos = inner[i].classes.indexOf("sizing");

    if (pos < 0) {
      Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));
    } else if (inner[i].classes[pos + 1] === "reset-size" + options.size) {
      // This is a nested size change: e.g., inner[i] is the "b" in
      // `\Huge a \small b`. Override the old size (the `reset-` class)
      // but not the new size.
      inner[i].classes[pos + 1] = "reset-size" + baseOptions.size;
    }

    inner[i].height *= multiplier;
    inner[i].depth *= multiplier;
  }

  return buildCommon.makeFragment(inner);
}
var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
var sizing_htmlBuilder = function htmlBuilder(group, options) {
  // Handle sizing operators like \Huge. Real TeX doesn't actually allow
  // these functions inside of math expressions, so we do some special
  // handling.
  var newOptions = options.havingSize(group.size);
  return sizingGroup(group.body, newOptions, options);
};
defineFunction({
  type: "sizing",
  names: sizeFuncs,
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: function handler(_ref, args) {
    var breakOnTokenText = _ref.breakOnTokenText,
        funcName = _ref.funcName,
        parser = _ref.parser;
    var body = parser.parseExpression(false, breakOnTokenText);
    return {
      type: "sizing",
      mode: parser.mode,
      // Figure out what size to use based on the list of functions above
      size: sizeFuncs.indexOf(funcName) + 1,
      body: body
    };
  },
  htmlBuilder: sizing_htmlBuilder,
  mathmlBuilder: function mathmlBuilder(group, options) {
    var newOptions = options.havingSize(group.size);
    var inner = buildMathML_buildExpression(group.body, newOptions);
    var node = new mathMLTree.MathNode("mstyle", inner); // TODO(emily): This doesn't produce the correct size for nested size
    // changes, because we don't keep state of what style we're currently
    // in, so we can't reset the size to normal before changing it.  Now
    // that we're passing an options parameter we should be able to fix
    // this.

    node.setAttribute("mathsize", newOptions.sizeMultiplier + "em");
    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/raisebox.js






 // Box manipulation

defineFunction({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "text"],
    allowedInText: true
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser;
    var amount = assertNodeType(args[0], "size").value;
    var body = args[1];
    return {
      type: "raisebox",
      mode: parser.mode,
      dy: amount,
      body: body
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    var text = {
      type: "text",
      mode: group.mode,
      body: defineFunction_ordargument(group.body),
      font: "mathrm" // simulate \textrm

    };
    var sizedText = {
      type: "sizing",
      mode: group.mode,
      body: [text],
      size: 6 // simulate \normalsize

    };
    var body = sizing_htmlBuilder(sizedText, options);
    var dy = units_calculateSize(group.dy, options);
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: -dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
    var dy = group.dy.number + group.dy.unit;
    node.setAttribute("voffset", dy);
    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/rule.js





defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
  },
  handler: function handler(_ref, args, optArgs) {
    var parser = _ref.parser;
    var shift = optArgs[0];
    var width = assertNodeType(args[0], "size");
    var height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width.value,
      height: height.value
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    // Make an empty span for the rule
    var rule = buildCommon.makeSpan(["mord", "rule"], [], options); // Calculate the shift, width, and height of the rule, and account for units

    var width = units_calculateSize(group.width, options);
    var height = units_calculateSize(group.height, options);
    var shift = group.shift ? units_calculateSize(group.shift, options) : 0; // Style the rule to the right size

    rule.style.borderRightWidth = width + "em";
    rule.style.borderTopWidth = height + "em";
    rule.style.bottom = shift + "em"; // Record the height and width

    rule.width = width;
    rule.height = height + shift;
    rule.depth = -shift; // Font size is the number large enough that the browser will
    // reserve at least `absHeight` space above the baseline.
    // The 1.125 factor was empirically determined

    rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
    return rule;
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var width = units_calculateSize(group.width, options);
    var height = units_calculateSize(group.height, options);
    var shift = group.shift ? units_calculateSize(group.shift, options) : 0;
    var color = options.color && options.getColor() || "black";
    var rule = new mathMLTree.MathNode("mspace");
    rule.setAttribute("mathbackground", color);
    rule.setAttribute("width", width + "em");
    rule.setAttribute("height", height + "em");
    var wrapper = new mathMLTree.MathNode("mpadded", [rule]);

    if (shift >= 0) {
      wrapper.setAttribute("height", "+" + shift + "em");
    } else {
      wrapper.setAttribute("height", shift + "em");
      wrapper.setAttribute("depth", "+" + -shift + "em");
    }

    wrapper.setAttribute("voffset", shift + "em");
    return wrapper;
  }
});
// CONCATENATED MODULE: ./src/functions/smash.js
// smash, with optional [tb], as in AMS






defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: function handler(_ref, args, optArgs) {
    var parser = _ref.parser;
    var smashHeight = false;
    var smashDepth = false;
    var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");

    if (tbArg) {
      // Optional [tb] argument is engaged.
      // ref: amsmath: \renewcommand{\smash}[1][tb]{%
      //               def\mb@t{\ht}\def\mb@b{\dp}\def\mb@tb{\ht\z@\z@\dp}%
      var letter = "";

      for (var i = 0; i < tbArg.body.length; ++i) {
        var node = tbArg.body[i]; // $FlowFixMe: Not every node type has a `text` property.

        letter = node.text;

        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }

    var body = args[0];
    return {
      type: "smash",
      mode: parser.mode,
      body: body,
      smashHeight: smashHeight,
      smashDepth: smashDepth
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    var node = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options)]);

    if (!group.smashHeight && !group.smashDepth) {
      return node;
    }

    if (group.smashHeight) {
      node.height = 0; // In order to influence makeVList, we have to reset the children.

      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          node.children[i].height = 0;
        }
      }
    }

    if (group.smashDepth) {
      node.depth = 0;

      if (node.children) {
        for (var _i = 0; _i < node.children.length; _i++) {
          node.children[_i].depth = 0;
        }
      }
    } // At this point, we've reset the TeX-like height and depth values.
    // But the span still has an HTML line height.
    // makeVList applies "display: table-cell", which prevents the browser
    // from acting on that line height. So we'll call makeVList now.


    var smashedNode = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options); // For spacing, TeX treats \hphantom as a math group (same spacing as ord).

    return buildCommon.makeSpan(["mord"], [smashedNode], options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);

    if (group.smashHeight) {
      node.setAttribute("height", "0px");
    }

    if (group.smashDepth) {
      node.setAttribute("depth", "0px");
    }

    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/sqrt.js







defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler: function handler(_ref, args, optArgs) {
    var parser = _ref.parser;
    var index = optArgs[0];
    var body = args[0];
    return {
      type: "sqrt",
      mode: parser.mode,
      body: body,
      index: index
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    // Square roots are handled in the TeXbook pg. 443, Rule 11.
    // First, we do the same steps as in overline to build the inner group
    // and line
    var inner = buildHTML_buildGroup(group.body, options.havingCrampedStyle());

    if (inner.height === 0) {
      // Render a small surd.
      inner.height = options.fontMetrics().xHeight;
    } // Some groups can return document fragments.  Handle those by wrapping
    // them in a span.


    inner = buildCommon.wrapFragment(inner, options); // Calculate the minimum size for the \surd delimiter

    var metrics = options.fontMetrics();
    var theta = metrics.defaultRuleThickness;
    var phi = theta;

    if (options.style.id < src_Style.TEXT.id) {
      phi = options.fontMetrics().xHeight;
    } // Calculate the clearance between the body and line


    var lineClearance = theta + phi / 4;
    var minDelimiterHeight = inner.height + inner.depth + lineClearance + theta; // Create a sqrt SVG of the required minimum size

    var _delimiter$sqrtImage = delimiter.sqrtImage(minDelimiterHeight, options),
        img = _delimiter$sqrtImage.span,
        ruleWidth = _delimiter$sqrtImage.ruleWidth,
        advanceWidth = _delimiter$sqrtImage.advanceWidth;

    var delimDepth = img.height - ruleWidth; // Adjust the clearance based on the delimiter size

    if (delimDepth > inner.height + inner.depth + lineClearance) {
      lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;
    } // Shift the sqrt image


    var imgShift = img.height - inner.height - lineClearance - ruleWidth;
    inner.style.paddingLeft = advanceWidth + "em"; // Overlay the image and the argument.

    var body = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: inner,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(inner.height + imgShift)
      }, {
        type: "elem",
        elem: img
      }, {
        type: "kern",
        size: ruleWidth
      }]
    }, options);

    if (!group.index) {
      return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
    } else {
      // Handle the optional root index
      // The index is always in scriptscript style
      var newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
      var rootm = buildHTML_buildGroup(group.index, newOptions, options); // The amount the index is shifted by. This is taken from the TeX
      // source, in the definition of `\r@@t`.

      var toShift = 0.6 * (body.height - body.depth); // Build a VList with the superscript shifted up correctly

      var rootVList = buildCommon.makeVList({
        positionType: "shift",
        positionData: -toShift,
        children: [{
          type: "elem",
          elem: rootm
        }]
      }, options); // Add a class surrounding it so we can add on the appropriate
      // kerning

      var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
      return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
    }
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var body = group.body,
        index = group.index;
    return index ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
  }
});
// CONCATENATED MODULE: ./src/functions/styling.js





var styling_styleMap = {
  "display": src_Style.DISPLAY,
  "text": src_Style.TEXT,
  "script": src_Style.SCRIPT,
  "scriptscript": src_Style.SCRIPTSCRIPT
};
defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: function handler(_ref, args) {
    var breakOnTokenText = _ref.breakOnTokenText,
        funcName = _ref.funcName,
        parser = _ref.parser;
    // parse out the implicit body
    var body = parser.parseExpression(true, breakOnTokenText); // TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.
    // here and in buildHTML and de-dupe the enumeration of all the styles).
    // $FlowFixMe: The names above exactly match the styles.

    var style = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: style,
      body: body
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    // Style changes are handled in the TeXbook on pg. 442, Rule 3.
    var newStyle = styling_styleMap[group.style];
    var newOptions = options.havingStyle(newStyle).withFont('');
    return sizingGroup(group.body, newOptions, options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    // Figure out what style we're changing to.
    // TODO(kevinb): dedupe this with buildHTML.js
    // This will be easier of handling of styling nodes is in the same file.
    var styleMap = {
      "display": src_Style.DISPLAY,
      "text": src_Style.TEXT,
      "script": src_Style.SCRIPT,
      "scriptscript": src_Style.SCRIPTSCRIPT
    };
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle);
    var inner = buildMathML_buildExpression(group.body, newOptions);
    var node = new mathMLTree.MathNode("mstyle", inner);
    var styleAttributes = {
      "display": ["0", "true"],
      "text": ["0", "false"],
      "script": ["1", "false"],
      "scriptscript": ["2", "false"]
    };
    var attr = styleAttributes[group.style];
    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);
    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/supsub.js













/**
 * Sometimes, groups perform special rules when they have superscripts or
 * subscripts attached to them. This function lets the `supsub` group know that
 * Sometimes, groups perform special rules when they have superscripts or
 * its inner element should handle the superscripts and subscripts instead of
 * handling them itself.
 */
var supsub_htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {
  var base = group.base;

  if (!base) {
    return null;
  } else if (base.type === "op") {
    // Operators handle supsubs differently when they have limits
    // (e.g. `\displaystyle\sum_2^3`)
    var delegate = base.limits && (options.style.size === src_Style.DISPLAY.size || base.alwaysHandleSupSub);
    return delegate ? op_htmlBuilder : null;
  } else if (base.type === "accent") {
    return utils.isCharacterBox(base.base) ? accent_htmlBuilder : null;
  } else if (base.type === "horizBrace") {
    var isSup = !group.sub;
    return isSup === base.isOver ? horizBrace_htmlBuilder : null;
  } else {
    return null;
  }
}; // Super scripts and subscripts, whose precise placement can depend on other
// functions that precede them.


defineFunctionBuilders({
  type: "supsub",
  htmlBuilder: function htmlBuilder(group, options) {
    // Superscript and subscripts are handled in the TeXbook on page
    // 445-446, rules 18(a-f).
    // Here is where we defer to the inner group if it should handle
    // superscripts and subscripts itself.
    var builderDelegate = supsub_htmlBuilderDelegate(group, options);

    if (builderDelegate) {
      return builderDelegate(group, options);
    }

    var valueBase = group.base,
        valueSup = group.sup,
        valueSub = group.sub;
    var base = buildHTML_buildGroup(valueBase, options);
    var supm;
    var subm;
    var metrics = options.fontMetrics(); // Rule 18a

    var supShift = 0;
    var subShift = 0;
    var isCharacterBox = valueBase && utils.isCharacterBox(valueBase);

    if (valueSup) {
      var newOptions = options.havingStyle(options.style.sup());
      supm = buildHTML_buildGroup(valueSup, newOptions, options);

      if (!isCharacterBox) {
        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }

    if (valueSub) {
      var _newOptions = options.havingStyle(options.style.sub());

      subm = buildHTML_buildGroup(valueSub, _newOptions, options);

      if (!isCharacterBox) {
        subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    } // Rule 18c


    var minSupShift;

    if (options.style === src_Style.DISPLAY) {
      minSupShift = metrics.sup1;
    } else if (options.style.cramped) {
      minSupShift = metrics.sup3;
    } else {
      minSupShift = metrics.sup2;
    } // scriptspace is a font-size-independent size, so scale it
    // appropriately for use as the marginRight.


    var multiplier = options.sizeMultiplier;
    var marginRight = 0.5 / metrics.ptPerEm / multiplier + "em";
    var marginLeft = null;

    if (subm) {
      // Subscripts shouldn't be shifted by the base's italic correction.
      // Account for that by shifting the subscript back the appropriate
      // amount. Note we only do this when the base is a single symbol.
      var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");

      if (base instanceof domTree_SymbolNode || isOiint) {
        // $FlowFixMe
        marginLeft = -base.italic + "em";
      }
    }

    var supsub;

    if (supm && subm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      subShift = Math.max(subShift, metrics.sub2);
      var ruleWidth = metrics.defaultRuleThickness; // Rule 18e

      var maxWidth = 4 * ruleWidth;

      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
        subShift = maxWidth - (supShift - supm.depth) + subm.height;
        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);

        if (psi > 0) {
          supShift += psi;
          subShift -= psi;
        }
      }

      var vlistElem = [{
        type: "elem",
        elem: subm,
        shift: subShift,
        marginRight: marginRight,
        marginLeft: marginLeft
      }, {
        type: "elem",
        elem: supm,
        shift: -supShift,
        marginRight: marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "individualShift",
        children: vlistElem
      }, options);
    } else if (subm) {
      // Rule 18b
      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
      var _vlistElem = [{
        type: "elem",
        elem: subm,
        marginLeft: marginLeft,
        marginRight: marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: subShift,
        children: _vlistElem
      }, options);
    } else if (supm) {
      // Rule 18c, d
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: -supShift,
        children: [{
          type: "elem",
          elem: supm,
          marginRight: marginRight
        }]
      }, options);
    } else {
      throw new Error("supsub must have either sup or sub.");
    } // Wrap the supsub vlist in a span.msupsub to reset text-align.


    var mclass = getTypeOfDomTree(base, "right") || "mord";
    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    // Is the inner group a relevant horizonal brace?
    var isBrace = false;
    var isOver;
    var isSup;
    var horizBrace = checkNodeType(group.base, "horizBrace");

    if (horizBrace) {
      isSup = !!group.sup;

      if (isSup === horizBrace.isOver) {
        isBrace = true;
        isOver = horizBrace.isOver;
      }
    }

    if (group.base && group.base.type === "op") {
      group.base.parentIsSupSub = true;
    }

    var children = [buildMathML_buildGroup(group.base, options)];

    if (group.sub) {
      children.push(buildMathML_buildGroup(group.sub, options));
    }

    if (group.sup) {
      children.push(buildMathML_buildGroup(group.sup, options));
    }

    var nodeType;

    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      var base = group.base;

      if (base && base.type === "op" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      var _base = group.base;

      if (_base && _base.type === "op" && _base.limits && (options.style === src_Style.DISPLAY || _base.alwaysHandleSupSub)) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      var _base2 = group.base;

      if (_base2 && _base2.type === "op" && _base2.limits && options.style === src_Style.DISPLAY) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }

    var node = new mathMLTree.MathNode(nodeType, children);
    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/symbolsOp.js



 // Operator ParseNodes created in Parser.js from symbol Groups in src/symbols.js.

defineFunctionBuilders({
  type: "atom",
  htmlBuilder: function htmlBuilder(group, options) {
    return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mo", [buildMathML_makeText(group.text, group.mode)]);

    if (group.family === "bin") {
      var variant = buildMathML_getVariant(group, options);

      if (variant === "bold-italic") {
        node.setAttribute("mathvariant", variant);
      }
    } else if (group.family === "punct") {
      node.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      // Delims built here should not stretch vertically.
      // See delimsizing.js for stretchy delims.
      node.setAttribute("stretchy", "false");
    }

    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/symbolsOrd.js




// "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
var defaultVariant = {
  "mi": "italic",
  "mn": "normal",
  "mtext": "normal"
};
defineFunctionBuilders({
  type: "mathord",
  htmlBuilder: function htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "mathord");
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mi", [buildMathML_makeText(group.text, group.mode, options)]);
    var variant = buildMathML_getVariant(group, options) || "italic";

    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }

    return node;
  }
});
defineFunctionBuilders({
  type: "textord",
  htmlBuilder: function htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "textord");
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var text = buildMathML_makeText(group.text, group.mode, options);
    var variant = buildMathML_getVariant(group, options) || "normal";
    var node;

    if (group.mode === 'text') {
      node = new mathMLTree.MathNode("mtext", [text]);
    } else if (/[0-9]/.test(group.text)) {
      // TODO(kevinb) merge adjacent <mn> nodes
      // do it as a post processing step
      node = new mathMLTree.MathNode("mn", [text]);
    } else if (group.text === "\\prime") {
      node = new mathMLTree.MathNode("mo", [text]);
    } else {
      node = new mathMLTree.MathNode("mi", [text]);
    }

    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }

    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/symbolsSpacing.js



 // A map of CSS-based spacing functions to their CSS class.

var cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}; // A lookup table to determine whether a spacing function/symbol should be
// treated like a regular space character.  If a symbol or command is a key
// in this table, then it should be a regular space character.  Furthermore,
// the associated value may have a `className` specifying an extra CSS class
// to add to the created `span`.

var regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
}; // ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
// src/symbols.js.

defineFunctionBuilders({
  type: "spacing",
  htmlBuilder: function htmlBuilder(group, options) {
    if (regularSpace.hasOwnProperty(group.text)) {
      var className = regularSpace[group.text].className || ""; // Spaces are generated by adding an actual space. Each of these
      // things has an entry in the symbols table, so these will be turned
      // into appropriate outputs.

      if (group.mode === "text") {
        var ord = buildCommon.makeOrd(group, options, "textord");
        ord.classes.push(className);
        return ord;
      } else {
        return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
      }
    } else if (cssSpace.hasOwnProperty(group.text)) {
      // Spaces based on just a CSS class.
      return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
    } else {
      throw new src_ParseError("Unknown type of space \"" + group.text + "\"");
    }
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var node;

    if (regularSpace.hasOwnProperty(group.text)) {
      node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
    } else if (cssSpace.hasOwnProperty(group.text)) {
      // CSS-based MathML spaces (\nobreak, \allowbreak) are ignored
      return new mathMLTree.MathNode("mspace");
    } else {
      throw new src_ParseError("Unknown type of space \"" + group.text + "\"");
    }

    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/tag.js




var tag_pad = function pad() {
  var padNode = new mathMLTree.MathNode("mtd", []);
  padNode.setAttribute("width", "50%");
  return padNode;
};

defineFunctionBuilders({
  type: "tag",
  mathmlBuilder: function mathmlBuilder(group, options) {
    var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [tag_pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), tag_pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
    table.setAttribute("width", "100%");
    return table; // TODO: Left-aligned tags.
    // Currently, the group and options passed here do not contain
    // enough info to set tag alignment. `leqno` is in Settings but it is
    // not passed to Options. On the HTML side, leqno is
    // set by a CSS class applied in buildTree.js. That would have worked
    // in MathML if browsers supported <mlabeledtr>. Since they don't, we
    // need to rewrite the way this function is called.
  }
});
// CONCATENATED MODULE: ./src/functions/text.js



 // Non-mathy text, possibly in a font

var textFontFamilies = {
  "\\text": undefined,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
};
var textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};
var textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};

var optionsWithFont = function optionsWithFont(group, options) {
  var font = group.font; // Checks if the argument is a font family or a font style.

  if (!font) {
    return options;
  } else if (textFontFamilies[font]) {
    return options.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return options.withTextFontWeight(textFontWeights[font]);
  } else {
    return options.withTextFontShape(textFontShapes[font]);
  }
};

defineFunction({
  type: "text",
  names: [// Font families
  "\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal", // Font weights
  "\\textbf", "\\textmd", // Font Shapes
  "\\textit", "\\textup"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    greediness: 2,
    allowedInText: true,
    consumeMode: "text"
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser,
        funcName = _ref.funcName;
    var body = args[0];
    return {
      type: "text",
      mode: parser.mode,
      body: defineFunction_ordargument(body),
      font: funcName
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    var inner = buildHTML_buildExpression(group.body, newOptions, true);
    return buildCommon.makeSpan(["mord", "text"], buildCommon.tryCombineChars(inner), newOptions);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    return buildExpressionRow(group.body, newOptions);
  }
});
// CONCATENATED MODULE: ./src/functions/underline.js





defineFunction({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: function handler(_ref, args) {
    var parser = _ref.parser;
    return {
      type: "underline",
      mode: parser.mode,
      body: args[0]
    };
  },
  htmlBuilder: function htmlBuilder(group, options) {
    // Underlines are handled in the TeXbook pg 443, Rule 10.
    // Build the inner group.
    var innerGroup = buildHTML_buildGroup(group.body, options); // Create the line to go below the body

    var line = buildCommon.makeLineSpan("underline-line", options); // Generate the vlist, with the appropriate kerns

    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "kern",
        size: line.height
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: 3 * line.height
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
    operator.setAttribute("stretchy", "true");
    var node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
    node.setAttribute("accentunder", "true");
    return node;
  }
});
// CONCATENATED MODULE: ./src/functions/verb.js




defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: function handler(context, args, optArgs) {
    // \verb and \verb* are dealt with directly in Parser.js.
    // If we end up here, it's because of a failure to match the two delimiters
    // in the regex in Lexer.js.  LaTeX raises the following error when \verb is
    // terminated by end of line (or file).
    throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder: function htmlBuilder(group, options) {
    var text = makeVerb(group);
    var body = []; // \verb enters text mode and therefore is sized like \textstyle

    var newOptions = options.havingStyle(options.style.text());

    for (var i = 0; i < text.length; i++) {
      var c = text[i];

      if (c === '~') {
        c = '\\textasciitilde';
      }

      body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
    }

    return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
  },
  mathmlBuilder: function mathmlBuilder(group, options) {
    var text = new mathMLTree.TextNode(makeVerb(group));
    var node = new mathMLTree.MathNode("mtext", [text]);
    node.setAttribute("mathvariant", "monospace");
    return node;
  }
});
/**
 * Converts verb group into body string.
 *
 * \verb* replaces each space with an open box \u2423
 * \verb replaces each space with a no-break space \xA0
 */

var makeVerb = function makeVerb(group) {
  return group.body.replace(/ /g, group.star ? "\u2423" : '\xA0');
};
// CONCATENATED MODULE: ./src/functions.js
/** Include this to ensure that all functions are defined. */

var functions = _functions;
/* harmony default export */ var src_functions = (functions); // TODO(kevinb): have functions return an object and call defineFunction with
// that object in this file instead of relying on side-effects.














 // Disabled until https://github.com/KaTeX/KaTeX/pull/1794 is merged.
// import "./functions/includegraphics";

























// CONCATENATED MODULE: ./src/Lexer.js
/**
 * The Lexer class handles tokenizing the input in various ways. Since our
 * parser expects us to be able to backtrack, the lexer allows lexing from any
 * given starting point.
 *
 * Its main exposed function is the `lex` function, which takes a position to
 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
 * function.
 *
 * The various `_innerLex` functions perform the actual lexing of different
 * kinds.
 */




/* The following tokenRegex
 * - matches typical whitespace (but not NBSP etc.) using its first group
 * - does not match any control character \x00-\x1f except whitespace
 * - does not match a bare backslash
 * - matches any ASCII character except those just mentioned
 * - does not match the BMP private use area \uE000-\uF8FF
 * - does not match bare surrogate code units
 * - matches any BMP character except for those just described
 * - matches any valid Unicode surrogate pair
 * - matches a backslash followed by one or more letters
 * - matches a backslash followed by any BMP character, including newline
 * Just because the Lexer matches something doesn't mean it's valid input:
 * If there is no matching function or symbol definition, the Parser will
 * still reject the input.
 */
var spaceRegexString = "[ \r\n\t]";
var controlWordRegexString = "\\\\[a-zA-Z@]+";
var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
var controlWordWhitespaceRegexString = "" + controlWordRegexString + spaceRegexString + "*";
var controlWordWhitespaceRegex = new RegExp("^(" + controlWordRegexString + ")" + spaceRegexString + "*$");
var combiningDiacriticalMarkString = "[\u0300-\u036F]";
var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
var tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
"([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + ( // single codepoint
combiningDiacriticalMarkString + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + ( // surrogate pair
combiningDiacriticalMarkString + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\3" + // \verb*
"|\\\\verb([^*a-zA-Z]).*?\\4" + ( // \verb unstarred
"|" + controlWordWhitespaceRegexString) + ( // \macroName + spaces
"|" + controlSymbolRegexString + ")"); // \\, \', etc.

/** Main Lexer class */

var Lexer_Lexer =
/*#__PURE__*/
function () {
  // category codes, only supports comment characters (14) for now
  function Lexer(input, settings) {
    this.input = void 0;
    this.settings = void 0;
    this.tokenRegex = void 0;
    this.catcodes = void 0;
    // Separate accents from characters
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, 'g');
    this.catcodes = {
      "%": 14 // comment character

    };
  }

  var _proto = Lexer.prototype;

  _proto.setCatcode = function setCatcode(char, code) {
    this.catcodes[char] = code;
  }
  /**
   * This function lexes a single token.
   */
  ;

  _proto.lex = function lex() {
    var input = this.input;
    var pos = this.tokenRegex.lastIndex;

    if (pos === input.length) {
      return new Token_Token("EOF", new SourceLocation(this, pos, pos));
    }

    var match = this.tokenRegex.exec(input);

    if (match === null || match.index !== pos) {
      throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token_Token(input[pos], new SourceLocation(this, pos, pos + 1)));
    }

    var text = match[2] || " ";

    if (this.catcodes[text] === 14) {
      // comment character
      var nlIndex = input.indexOf('\n', this.tokenRegex.lastIndex);

      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length; // EOF

        this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would " + "fail because of commenting the end of math mode (e.g. $)");
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }

      return this.lex();
    } // Trim any trailing whitespace from control word match


    var controlMatch = text.match(controlWordWhitespaceRegex);

    if (controlMatch) {
      text = controlMatch[1];
    }

    return new Token_Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  };

  return Lexer;
}();


// CONCATENATED MODULE: ./src/Namespace.js
/**
 * A `Namespace` refers to a space of nameable things like macros or lengths,
 * which can be `set` either globally or local to a nested group, using an
 * undo stack similar to how TeX implements this functionality.
 * Performance-wise, `get` and local `set` take constant time, while global
 * `set` takes time proportional to the depth of group nesting.
 */


var Namespace_Namespace =
/*#__PURE__*/
function () {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  function Namespace(builtins, globalMacros) {
    if (builtins === void 0) {
      builtins = {};
    }

    if (globalMacros === void 0) {
      globalMacros = {};
    }

    this.current = void 0;
    this.builtins = void 0;
    this.undefStack = void 0;
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */


  var _proto = Namespace.prototype;

  _proto.beginGroup = function beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  ;

  _proto.endGroup = function endGroup() {
    if (this.undefStack.length === 0) {
      throw new src_ParseError("Unbalanced namespace destruction: attempt " + "to pop global namespace; please report this as a bug");
    }

    var undefs = this.undefStack.pop();

    for (var undef in undefs) {
      if (undefs.hasOwnProperty(undef)) {
        if (undefs[undef] === undefined) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  ;

  _proto.has = function has(name) {
    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  ;

  _proto.get = function get(name) {
    if (this.current.hasOwnProperty(name)) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   */
  ;

  _proto.set = function set(name, value, global) {
    if (global === void 0) {
      global = false;
    }

    if (global) {
      // Global set is equivalent to setting in all groups.  Simulate this
      // by destroying any undos currently scheduled for this name,
      // and adding an undo with the *new* value (in case it later gets
      // locally reset within this environment).
      for (var i = 0; i < this.undefStack.length; i++) {
        delete this.undefStack[i][name];
      }

      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value;
      }
    } else {
      // Undo this set at end of this group (possibly to `undefined`),
      // unless an undo is already in place, in which case that older
      // value is the correct one.
      var top = this.undefStack[this.undefStack.length - 1];

      if (top && !top.hasOwnProperty(name)) {
        top[name] = this.current[name];
      }
    }

    this.current[name] = value;
  };

  return Namespace;
}();


// CONCATENATED MODULE: ./src/macros.js
/**
 * Predefined macros for KaTeX.
 * This can be used to define some commands in terms of others.
 */





var builtinMacros = {};
/* harmony default export */ var macros = (builtinMacros); // This function might one day accept an additional argument and do more things.

function defineMacro(name, body) {
  builtinMacros[name] = body;
} //////////////////////////////////////////////////////////////////////
// macro tools
// LaTeX's \@firstoftwo{#1}{#2} expands to #1, skipping #2
// TeX source: \long\def\@firstoftwo#1#2{#1}

defineMacro("\\@firstoftwo", function (context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[0],
    numArgs: 0
  };
}); // LaTeX's \@secondoftwo{#1}{#2} expands to #2, skipping #1
// TeX source: \long\def\@secondoftwo#1#2{#2}

defineMacro("\\@secondoftwo", function (context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[1],
    numArgs: 0
  };
}); // LaTeX's \@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)
// symbol.  If it matches #1, then the macro expands to #2; otherwise, #3.
// Note, however, that it does not consume the next symbol in either case.

defineMacro("\\@ifnextchar", function (context) {
  var args = context.consumeArgs(3); // symbol, if, else

  var nextToken = context.future();

  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return {
      tokens: args[1],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[2],
      numArgs: 0
    };
  }
}); // LaTeX's \@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.
// If it is `*`, then it consumes the symbol, and the macro expands to #1;
// otherwise, the macro expands to #2 (without consuming the symbol).
// TeX source: \def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}

defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"); // LaTeX's \TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode

defineMacro("\\TextOrMath", function (context) {
  var args = context.consumeArgs(2);

  if (context.mode === 'text') {
    return {
      tokens: args[0],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[1],
      numArgs: 0
    };
  }
}); // Lookup table for parsing numbers in base 8 through 16

var digitToNumber = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
}; // TeX \char makes a literal character (catcode 12) using the following forms:
// (see The TeXBook, p. 43)
//   \char123  -- decimal
//   \char'123 -- octal
//   \char"123 -- hex
//   \char`x   -- character that can be written (i.e. isn't active)
//   \char`\x  -- character that cannot be written (e.g. %)
// These all refer to characters from the font, so we turn them into special
// calls to a function \@char dealt with in the Parser.

defineMacro("\\char", function (context) {
  var token = context.popToken();
  var base;
  var number = '';

  if (token.text === "'") {
    base = 8;
    token = context.popToken();
  } else if (token.text === '"') {
    base = 16;
    token = context.popToken();
  } else if (token.text === "`") {
    token = context.popToken();

    if (token.text[0] === "\\") {
      number = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new src_ParseError("\\char` missing argument");
    } else {
      number = token.text.charCodeAt(0);
    }
  } else {
    base = 10;
  }

  if (base) {
    // Parse a number in the given base, starting with first `token`.
    number = digitToNumber[token.text];

    if (number == null || number >= base) {
      throw new src_ParseError("Invalid base-" + base + " digit " + token.text);
    }

    var digit;

    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
      number *= base;
      number += digit;
      context.popToken();
    }
  }

  return "\\@char{" + number + "}";
}); // Basic support for macro definitions:
//     \def\macro{expansion}
//     \def\macro#1{expansion}
//     \def\macro#1#2{expansion}
//     \def\macro#1#2#3#4#5#6#7#8#9{expansion}
// Also the \gdef and \global\def equivalents

var macros_def = function def(context, global) {
  var arg = context.consumeArgs(1)[0];

  if (arg.length !== 1) {
    throw new src_ParseError("\\gdef's first argument must be a macro name");
  }

  var name = arg[0].text; // Count argument specifiers, and check they are in the order #1 #2 ...

  var numArgs = 0;
  arg = context.consumeArgs(1)[0];

  while (arg.length === 1 && arg[0].text === "#") {
    arg = context.consumeArgs(1)[0];

    if (arg.length !== 1) {
      throw new src_ParseError("Invalid argument number length \"" + arg.length + "\"");
    }

    if (!/^[1-9]$/.test(arg[0].text)) {
      throw new src_ParseError("Invalid argument number \"" + arg[0].text + "\"");
    }

    numArgs++;

    if (parseInt(arg[0].text) !== numArgs) {
      throw new src_ParseError("Argument number \"" + arg[0].text + "\" out of order");
    }

    arg = context.consumeArgs(1)[0];
  } // Final arg is the expansion of the macro


  context.macros.set(name, {
    tokens: arg,
    numArgs: numArgs
  }, global);
  return '';
};

defineMacro("\\gdef", function (context) {
  return macros_def(context, true);
});
defineMacro("\\def", function (context) {
  return macros_def(context, false);
});
defineMacro("\\global", function (context) {
  var next = context.consumeArgs(1)[0];

  if (next.length !== 1) {
    throw new src_ParseError("Invalid command after \\global");
  }

  var command = next[0].text; // TODO: Should expand command

  if (command === "\\def") {
    // \global\def is equivalent to \gdef
    return macros_def(context, true);
  } else {
    throw new src_ParseError("Invalid command '" + command + "' after \\global");
  }
}); // \newcommand{\macro}[args]{definition}
// \renewcommand{\macro}[args]{definition}
// TODO: Optional arguments: \newcommand{\macro}[args][default]{definition}

var macros_newcommand = function newcommand(context, existsOK, nonexistsOK) {
  var arg = context.consumeArgs(1)[0];

  if (arg.length !== 1) {
    throw new src_ParseError("\\newcommand's first argument must be a macro name");
  }

  var name = arg[0].text;
  var exists = context.isDefined(name);

  if (exists && !existsOK) {
    throw new src_ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
  }

  if (!exists && !nonexistsOK) {
    throw new src_ParseError("\\renewcommand{" + name + "} when command " + name + " " + "does not yet exist; use \\newcommand");
  }

  var numArgs = 0;
  arg = context.consumeArgs(1)[0];

  if (arg.length === 1 && arg[0].text === "[") {
    var argText = '';
    var token = context.expandNextToken();

    while (token.text !== "]" && token.text !== "EOF") {
      // TODO: Should properly expand arg, e.g., ignore {}s
      argText += token.text;
      token = context.expandNextToken();
    }

    if (!argText.match(/^\s*[0-9]+\s*$/)) {
      throw new src_ParseError("Invalid number of arguments: " + argText);
    }

    numArgs = parseInt(argText);
    arg = context.consumeArgs(1)[0];
  } // Final arg is the expansion of the macro


  context.macros.set(name, {
    tokens: arg,
    numArgs: numArgs
  });
  return '';
};

defineMacro("\\newcommand", function (context) {
  return macros_newcommand(context, false, true);
});
defineMacro("\\renewcommand", function (context) {
  return macros_newcommand(context, true, false);
});
defineMacro("\\providecommand", function (context) {
  return macros_newcommand(context, true, true);
}); //////////////////////////////////////////////////////////////////////
// Grouping
// \let\bgroup={ \let\egroup=}

defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}"); // Symbols from latex.ltx:
// \def\lq{`}
// \def\rq{'}
// \def \aa {\r a}
// \def \AA {\r A}

defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");
defineMacro("\\AA", "\\r A"); // Copyright (C) and registered (R) symbols. Use raw symbol in MathML.
// \DeclareTextCommandDefault{\textcopyright}{\textcircled{c}}
// \DeclareTextCommandDefault{\textregistered}{\textcircled{%
//      \check@mathfonts\fontsize\sf@size\z@\math@fontsfalse\selectfont R}}
// \DeclareRobustCommand{\copyright}{%
//    \ifmmode{\nfss@text{\textcopyright}}\else\textcopyright\fi}

defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}");
defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}"); // Characters omitted from Unicode range 1D4001D7FF

defineMacro("\u212C", "\\mathscr{B}"); // script

defineMacro("\u2130", "\\mathscr{E}");
defineMacro("\u2131", "\\mathscr{F}");
defineMacro("\u210B", "\\mathscr{H}");
defineMacro("\u2110", "\\mathscr{I}");
defineMacro("\u2112", "\\mathscr{L}");
defineMacro("\u2133", "\\mathscr{M}");
defineMacro("\u211B", "\\mathscr{R}");
defineMacro("\u212D", "\\mathfrak{C}"); // Fraktur

defineMacro("\u210C", "\\mathfrak{H}");
defineMacro("\u2128", "\\mathfrak{Z}"); // Define \Bbbk with a macro that works in both HTML and MathML.

defineMacro("\\Bbbk", "\\Bbb{k}"); // Unicode middle dot
// The KaTeX fonts do not contain U+00B7. Instead, \cdotp displays
// the dot at U+22C5 and gives it punct spacing.

defineMacro("\xB7", "\\cdotp"); // \llap and \rlap render their contents in text mode

defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
defineMacro("\\clap", "\\mathclap{\\textrm{#1}}"); // \not is defined by base/fontmath.ltx via
// \DeclareMathSymbol{\not}{\mathrel}{symbols}{"36}
// It's thus treated like a \mathrel, but defined by a symbol that has zero
// width but extends to the right.  We use \rlap to get that spacing.
// For MathML we write U+0338 here. buildMathML.js will then do the overlay.

defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}'); // Negated symbols from base/fontmath.ltx:
// \def\neq{\not=} \let\ne=\neq
// \DeclareRobustCommand
//   \notin{\mathrel{\m@th\mathpalette\c@ncel\in}}
// \def\c@ncel#1#2{\m@th\ooalign{$\hfil#1\mkern1mu/\hfil$\crcr$#1#2$}}

defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");
defineMacro("\\ne", "\\neq");
defineMacro("\u2260", "\\neq");
defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}" + "{\\mathrel{\\char`}}");
defineMacro("\u2209", "\\notin"); // Unicode stacked relations

defineMacro("\u2258", "\\html@mathml{" + "\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}" + "}{\\mathrel{\\char`\u2258}}");
defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}" + "{\\mathrel{\\char`\u225B}}");
defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}" + "{\\mathrel{\\char`\u225D}}");
defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}" + "{\\mathrel{\\char`\u225E}}");
defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}"); // Misc Unicode

defineMacro("\u27C2", "\\perp");
defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
defineMacro("\u220C", "\\notni");
defineMacro("\u231C", "\\ulcorner");
defineMacro("\u231D", "\\urcorner");
defineMacro("\u231E", "\\llcorner");
defineMacro("\u231F", "\\lrcorner");
defineMacro("\xA9", "\\copyright");
defineMacro("\xAE", "\\textregistered");
defineMacro("\uFE0F", "\\textregistered"); //////////////////////////////////////////////////////////////////////
// LaTeX_2
// \vdots{\vbox{\baselineskip4\p@  \lineskiplimit\z@
// \kern6\p@\hbox{.}\hbox{.}\hbox{.}}}
// We'll call \varvdots, which gets a glyph from symbols.js.
// The zero-width rule gets us an equivalent to the vertical 6pt kern.

defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("\u22EE", "\\vdots"); //////////////////////////////////////////////////////////////////////
// amsmath.sty
// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf
// Italic Greek capital letters.  AMS defines these with \DeclareMathSymbol,
// but they are equivalent to \mathit{\Letter}.

defineMacro("\\varGamma", "\\mathit{\\Gamma}");
defineMacro("\\varDelta", "\\mathit{\\Delta}");
defineMacro("\\varTheta", "\\mathit{\\Theta}");
defineMacro("\\varLambda", "\\mathit{\\Lambda}");
defineMacro("\\varXi", "\\mathit{\\Xi}");
defineMacro("\\varPi", "\\mathit{\\Pi}");
defineMacro("\\varSigma", "\\mathit{\\Sigma}");
defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
defineMacro("\\varPhi", "\\mathit{\\Phi}");
defineMacro("\\varPsi", "\\mathit{\\Psi}");
defineMacro("\\varOmega", "\\mathit{\\Omega}"); // \renewcommand{\colon}{\nobreak\mskip2mu\mathpunct{}\nonscript
// \mkern-\thinmuskip{:}\mskip6muplus1mu\relax}

defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}" + "\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu"); // \newcommand{\boxed}[1]{\fbox{\m@th$\displaystyle#1$}}

defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}"); // \def\iff{\DOTSB\;\Longleftrightarrow\;}
// \def\implies{\DOTSB\;\Longrightarrow\;}
// \def\impliedby{\DOTSB\;\Longleftarrow\;}

defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;"); // AMSMath's automatic \dots, based on \mdots@@ macro.

var dotsByToken = {
  ',': '\\dotsc',
  '\\not': '\\dotsb',
  // \keybin@ checks for the following:
  '+': '\\dotsb',
  '=': '\\dotsb',
  '<': '\\dotsb',
  '>': '\\dotsb',
  '-': '\\dotsb',
  '*': '\\dotsb',
  ':': '\\dotsb',
  // Symbols whose definition starts with \DOTSB:
  '\\DOTSB': '\\dotsb',
  '\\coprod': '\\dotsb',
  '\\bigvee': '\\dotsb',
  '\\bigwedge': '\\dotsb',
  '\\biguplus': '\\dotsb',
  '\\bigcap': '\\dotsb',
  '\\bigcup': '\\dotsb',
  '\\prod': '\\dotsb',
  '\\sum': '\\dotsb',
  '\\bigotimes': '\\dotsb',
  '\\bigoplus': '\\dotsb',
  '\\bigodot': '\\dotsb',
  '\\bigsqcup': '\\dotsb',
  '\\And': '\\dotsb',
  '\\longrightarrow': '\\dotsb',
  '\\Longrightarrow': '\\dotsb',
  '\\longleftarrow': '\\dotsb',
  '\\Longleftarrow': '\\dotsb',
  '\\longleftrightarrow': '\\dotsb',
  '\\Longleftrightarrow': '\\dotsb',
  '\\mapsto': '\\dotsb',
  '\\longmapsto': '\\dotsb',
  '\\hookrightarrow': '\\dotsb',
  '\\doteq': '\\dotsb',
  // Symbols whose definition starts with \mathbin:
  '\\mathbin': '\\dotsb',
  // Symbols whose definition starts with \mathrel:
  '\\mathrel': '\\dotsb',
  '\\relbar': '\\dotsb',
  '\\Relbar': '\\dotsb',
  '\\xrightarrow': '\\dotsb',
  '\\xleftarrow': '\\dotsb',
  // Symbols whose definition starts with \DOTSI:
  '\\DOTSI': '\\dotsi',
  '\\int': '\\dotsi',
  '\\oint': '\\dotsi',
  '\\iint': '\\dotsi',
  '\\iiint': '\\dotsi',
  '\\iiiint': '\\dotsi',
  '\\idotsint': '\\dotsi',
  // Symbols whose definition starts with \DOTSX:
  '\\DOTSX': '\\dotsx'
};
defineMacro("\\dots", function (context) {
  // TODO: If used in text mode, should expand to \textellipsis.
  // However, in KaTeX, \textellipsis and \ldots behave the same
  // (in text mode), and it's unlikely we'd see any of the math commands
  // that affect the behavior of \dots when in text mode.  So fine for now
  // (until we support \ifmmode ... \else ... \fi).
  var thedots = '\\dotso';
  var next = context.expandAfterFuture().text;

  if (next in dotsByToken) {
    thedots = dotsByToken[next];
  } else if (next.substr(0, 4) === '\\not') {
    thedots = '\\dotsb';
  } else if (next in src_symbols.math) {
    if (utils.contains(['bin', 'rel'], src_symbols.math[next].group)) {
      thedots = '\\dotsb';
    }
  }

  return thedots;
});
var spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ')': true,
  ']': true,
  '\\rbrack': true,
  '\\}': true,
  '\\rbrace': true,
  '\\rangle': true,
  '\\rceil': true,
  '\\rfloor': true,
  '\\rgroup': true,
  '\\rmoustache': true,
  '\\right': true,
  '\\bigr': true,
  '\\biggr': true,
  '\\Bigr': true,
  '\\Biggr': true,
  // \extra@ also tests for the following:
  '$': true,
  // \extrap@ checks for the following:
  ';': true,
  '.': true,
  ',': true
};
defineMacro("\\dotso", function (context) {
  var next = context.future().text;

  if (next in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\dotsc", function (context) {
  var next = context.future().text; // \dotsc uses \extra@ but not \extrap@, instead specially checking for
  // ';' and '.', but doesn't check for ','.

  if (next in spaceAfterDots && next !== ',') {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\cdots", function (context) {
  var next = context.future().text;

  if (next in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});
defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots"); // amsmath doesn't actually define \dotsx, but \dots followed by a macro
// starting with \DOTSX implies \dotso, and then \extra@ detects this case
// and forces the added `\,`.

defineMacro("\\dotsx", "\\ldots\\,"); // \let\DOTSI\relax
// \let\DOTSB\relax
// \let\DOTSX\relax

defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax"); // Spacing, based on amsmath.sty's override of LaTeX defaults
// \DeclareRobustCommand{\tmspace}[3]{%
//   \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}

defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"); // \renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip

defineMacro("\\,", "\\tmspace+{3mu}{.1667em}"); // \let\thinspace\,

defineMacro("\\thinspace", "\\,"); // \def\>{\mskip\medmuskip}
// \renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
// TODO: \> and math mode of \: should use \medmuskip = 4mu plus 2mu minus 4mu

defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "\\tmspace+{4mu}{.2222em}"); // \let\medspace\:

defineMacro("\\medspace", "\\:"); // \renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip = 5mu plus 5mu

defineMacro("\\;", "\\tmspace+{5mu}{.2777em}"); // \let\thickspace\;

defineMacro("\\thickspace", "\\;"); // \renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip

defineMacro("\\!", "\\tmspace-{3mu}{.1667em}"); // \let\negthinspace\!

defineMacro("\\negthinspace", "\\!"); // \newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
// TODO: math mode should use \medmuskip

defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}"); // \newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip

defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}"); // \def\enspace{\kern.5em }

defineMacro("\\enspace", "\\kern.5em "); // \def\enskip{\hskip.5em\relax}

defineMacro("\\enskip", "\\hskip.5em\\relax"); // \def\quad{\hskip1em\relax}

defineMacro("\\quad", "\\hskip1em\\relax"); // \def\qquad{\hskip2em\relax}

defineMacro("\\qquad", "\\hskip2em\\relax"); // \tag@in@display form of \tag

defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", function (context) {
  if (context.macros.get("\\df@tag")) {
    throw new src_ParseError("Multiple \\tag");
  }

  return "\\gdef\\df@tag{\\text{#1}}";
}); // \renewcommand{\bmod}{\nonscript\mskip-\medmuskip\mkern5mu\mathbin
//   {\operator@font mod}\penalty900
//   \mkern5mu\nonscript\mskip-\medmuskip}
// \newcommand{\pod}[1]{\allowbreak
//   \if@display\mkern18mu\else\mkern8mu\fi(#1)}
// \renewcommand{\pmod}[1]{\pod{{\operator@font mod}\mkern6mu#1}}
// \newcommand{\mod}[1]{\allowbreak\if@display\mkern18mu
//   \else\mkern12mu\fi{\operator@font mod}\,\,#1}
// TODO: math mode should use \medmuskip = 4mu plus 2mu minus 4mu

defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}" + "\\mathbin{\\rm mod}" + "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
defineMacro("\\pod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro("\\mod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}" + "{\\rm mod}\\,\\,#1"); // \pmb    --   A simulation of bold.
// It works by typesetting three copies of the argument with small offsets.
// Ref: a rather lengthy macro in ambsy.sty

defineMacro("\\pmb", "\\html@mathml{\\@binrel{#1}{" + "\\mathrlap{#1}" + "\\mathrlap{\\mkern0.4mu\\raisebox{0.4mu}{$#1$}}" + "{\\mkern0.8mu#1}" + "}}{\\mathbf{#1}}"); //////////////////////////////////////////////////////////////////////
// LaTeX source2e
// \\ defaults to \newline, but changes to \cr within array environment

defineMacro("\\\\", "\\newline"); // \def\TeX{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@}
// TODO: Doesn't normally work in math mode because \@ fails.  KaTeX doesn't
// support \@ yet, so that's omitted, and we add \text so that the result
// doesn't look funny in math mode.

defineMacro("\\TeX", "\\textrm{\\html@mathml{" + "T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX" + "}{TeX}}"); // \DeclareRobustCommand{\LaTeX}{L\kern-.36em%
//         {\sbox\z@ T%
//          \vbox to\ht\z@{\hbox{\check@mathfonts
//                               \fontsize\sf@size\z@
//                               \math@fontsfalse\selectfont
//                               A}%
//                         \vss}%
//         }%
//         \kern-.15em%
//         \TeX}
// This code aligns the top of the A with the T (from the perspective of TeX's
// boxes, though visually the A appears to extend above slightly).
// We compute the corresponding \raisebox when A is rendered at \scriptsize,
// which is size3, which has a scale factor of 0.7 (see Options.js).

var latexRaiseA = fontMetricsData['Main-Regular']["T".charCodeAt(0)][1] - 0.7 * fontMetricsData['Main-Regular']["A".charCodeAt(0)][1] + "em";
defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptsize A}") + "\\kern-.15em\\TeX}{LaTeX}}"); // New KaTeX logo based on tweaking LaTeX logo

defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptsize A}") + "\\kern-.15em\\TeX}{KaTeX}}"); // \DeclareRobustCommand\hspace{\@ifstar\@hspacer\@hspace}
// \def\@hspace#1{\hskip  #1\relax}
// \def\@hspacer#1{\vrule \@width\z@\nobreak
//                 \hskip #1\hskip \z@skip}

defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"); //////////////////////////////////////////////////////////////////////
// mathtools.sty
//\providecommand\ordinarycolon{:}

defineMacro("\\ordinarycolon", ":"); //\def\vcentcolon{\mathrel{\mathop\ordinarycolon}}
//TODO(edemaine): Not yet centered. Fix via \raisebox or #726

defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"); // \providecommand*\dblcolon{\vcentcolon\mathrel{\mkern-.9mu}\vcentcolon}

defineMacro("\\dblcolon", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}" + "{\\mathop{\\char\"2237}}"); // \providecommand*\coloneqq{\vcentcolon\mathrel{\mkern-1.2mu}=}

defineMacro("\\coloneqq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}" + "{\\mathop{\\char\"2254}}"); // 
// \providecommand*\Coloneqq{\dblcolon\mathrel{\mkern-1.2mu}=}

defineMacro("\\Coloneqq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}" + "{\\mathop{\\char\"2237\\char\"3d}}"); // \providecommand*\coloneq{\vcentcolon\mathrel{\mkern-1.2mu}\mathrel{-}}

defineMacro("\\coloneq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + "{\\mathop{\\char\"3a\\char\"2212}}"); // \providecommand*\Coloneq{\dblcolon\mathrel{\mkern-1.2mu}\mathrel{-}}

defineMacro("\\Coloneq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + "{\\mathop{\\char\"2237\\char\"2212}}"); // \providecommand*\eqqcolon{=\mathrel{\mkern-1.2mu}\vcentcolon}

defineMacro("\\eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + "{\\mathop{\\char\"2255}}"); // 
// \providecommand*\Eqqcolon{=\mathrel{\mkern-1.2mu}\dblcolon}

defineMacro("\\Eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + "{\\mathop{\\char\"3d\\char\"2237}}"); // \providecommand*\eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\vcentcolon}

defineMacro("\\eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + "{\\mathop{\\char\"2239}}"); // \providecommand*\Eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\dblcolon}

defineMacro("\\Eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + "{\\mathop{\\char\"2212\\char\"2237}}"); // \providecommand*\colonapprox{\vcentcolon\mathrel{\mkern-1.2mu}\approx}

defineMacro("\\colonapprox", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + "{\\mathop{\\char\"3a\\char\"2248}}"); // \providecommand*\Colonapprox{\dblcolon\mathrel{\mkern-1.2mu}\approx}

defineMacro("\\Colonapprox", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + "{\\mathop{\\char\"2237\\char\"2248}}"); // \providecommand*\colonsim{\vcentcolon\mathrel{\mkern-1.2mu}\sim}

defineMacro("\\colonsim", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + "{\\mathop{\\char\"3a\\char\"223c}}"); // \providecommand*\Colonsim{\dblcolon\mathrel{\mkern-1.2mu}\sim}

defineMacro("\\Colonsim", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + "{\\mathop{\\char\"2237\\char\"223c}}"); // Some Unicode characters are implemented with macros to mathtools functions.

defineMacro("\u2237", "\\dblcolon"); // ::

defineMacro("\u2239", "\\eqcolon"); // -:

defineMacro("\u2254", "\\coloneqq"); // :=

defineMacro("\u2255", "\\eqqcolon"); // =:

defineMacro("\u2A74", "\\Coloneqq"); // ::=
//////////////////////////////////////////////////////////////////////
// colonequals.sty
// Alternate names for mathtools's macros:

defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon"); // \colonapprox name is same in mathtools and colonequals.

defineMacro("\\coloncolonapprox", "\\Colonapprox"); // \colonsim name is same in mathtools and colonequals.

defineMacro("\\coloncolonsim", "\\Colonsim"); // Additional macros, implemented by analogy with mathtools definitions:

defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"); // Present in newtxmath, pxfonts and txfonts

defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
defineMacro("\\limsup", "\\DOTSB\\mathop{\\operatorname{lim\\,sup}}\\limits");
defineMacro("\\liminf", "\\DOTSB\\mathop{\\operatorname{lim\\,inf}}\\limits"); //////////////////////////////////////////////////////////////////////
// MathML alternates for KaTeX glyphs in the Unicode private area

defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{}");
defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}");
defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}");
defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}");
defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}");
defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}"); //////////////////////////////////////////////////////////////////////
// stmaryrd and semantic
// The stmaryrd and semantic packages render the next four items by calling a
// glyph. Those glyphs do not exist in the KaTeX fonts. Hence the macros.

defineMacro("\\llbracket", "\\html@mathml{" + "\\mathopen{[\\mkern-3.2mu[}}" + "{\\mathopen{\\char`\u27E6}}");
defineMacro("\\rrbracket", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu]}}" + "{\\mathclose{\\char`\u27E7}}");
defineMacro("\u27E6", "\\llbracket"); // blackboard bold [

defineMacro("\u27E7", "\\rrbracket"); // blackboard bold ]

defineMacro("\\lBrace", "\\html@mathml{" + "\\mathopen{\\{\\mkern-3.2mu[}}" + "{\\mathopen{\\char`\u2983}}");
defineMacro("\\rBrace", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu\\}}}" + "{\\mathclose{\\char`\u2984}}");
defineMacro("\u2983", "\\lBrace"); // blackboard bold {

defineMacro("\u2984", "\\rBrace"); // blackboard bold }
// TODO: Create variable sized versions of the last two items. I believe that
// will require new font glyphs.
//////////////////////////////////////////////////////////////////////
// texvc.sty
// The texvc package contains macros available in mediawiki pages.
// We omit the functions deprecated at
// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax
// We also omit texvc's \O, which conflicts with \text{\O}

defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\Alpha", "\\mathrm{A}");
defineMacro("\\Beta", "\\mathrm{B}");
defineMacro("\\bull", "\\bullet");
defineMacro("\\Chi", "\\mathrm{X}");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\Epsilon", "\\mathrm{E}");
defineMacro("\\Eta", "\\mathrm{H}");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\Iota", "\\mathrm{I}");
defineMacro("\\isin", "\\in");
defineMacro("\\Kappa", "\\mathrm{K}");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\Mu", "\\mathrm{M}");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\Nu", "\\mathrm{N}");
defineMacro("\\Omicron", "\\mathrm{O}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\Rho", "\\mathrm{P}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\Tau", "\\mathrm{T}");
defineMacro("\\thetasym", "\\vartheta"); // TODO: defineMacro("\\varcoppa", "\\\mbox{\\coppa}");

defineMacro("\\weierp", "\\wp");
defineMacro("\\Zeta", "\\mathrm{Z}"); //////////////////////////////////////////////////////////////////////
// statmath.sty
// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf

defineMacro("\\argmin", "\\DOTSB\\mathop{\\operatorname{arg\\,min}}\\limits");
defineMacro("\\argmax", "\\DOTSB\\mathop{\\operatorname{arg\\,max}}\\limits"); // Custom Khan Academy colors, should be moved to an optional package

defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
defineMacro("\\red", "\\textcolor{##df0030}{#1}");
defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
defineMacro("\\gray", "\\textcolor{gray}{##1}");
defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
// CONCATENATED MODULE: ./src/MacroExpander.js
/**
 * This file contains the gullet where macros are expanded
 * until only non-macro tokens remain.
 */







// List of commands that act like macros but aren't defined as a macro,
// function, or symbol.  Used in `isDefined`.
var implicitCommands = {
  "\\relax": true,
  // MacroExpander.js
  "^": true,
  // Parser.js
  "_": true,
  // Parser.js
  "\\limits": true,
  // Parser.js
  "\\nolimits": true // Parser.js

};

var MacroExpander_MacroExpander =
/*#__PURE__*/
function () {
  function MacroExpander(input, settings, mode) {
    this.settings = void 0;
    this.expansionCount = void 0;
    this.lexer = void 0;
    this.macros = void 0;
    this.stack = void 0;
    this.mode = void 0;
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input); // Make new global namespace

    this.macros = new Namespace_Namespace(macros, settings.macros);
    this.mode = mode;
    this.stack = []; // contains tokens in REVERSE order
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */


  var _proto = MacroExpander.prototype;

  _proto.feed = function feed(input) {
    this.lexer = new Lexer_Lexer(input, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  ;

  _proto.switchMode = function switchMode(newMode) {
    this.mode = newMode;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  ;

  _proto.beginGroup = function beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  ;

  _proto.endGroup = function endGroup() {
    this.macros.endGroup();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  ;

  _proto.future = function future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }

    return this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  ;

  _proto.popToken = function popToken() {
    this.future(); // ensure non-empty stack

    return this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  ;

  _proto.pushToken = function pushToken(token) {
    this.stack.push(token);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  ;

  _proto.pushTokens = function pushTokens(tokens) {
    var _this$stack;

    (_this$stack = this.stack).push.apply(_this$stack, tokens);
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  ;

  _proto.consumeSpaces = function consumeSpaces() {
    for (;;) {
      var token = this.future();

      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Consume the specified number of arguments from the token stream,
   * and return the resulting array of arguments.
   */
  ;

  _proto.consumeArgs = function consumeArgs(numArgs) {
    var args = []; // obtain arguments, either single token or balanced {} group

    for (var i = 0; i < numArgs; ++i) {
      this.consumeSpaces(); // ignore spaces before each argument

      var startOfArg = this.popToken();

      if (startOfArg.text === "{") {
        var arg = [];
        var depth = 1;

        while (depth !== 0) {
          var tok = this.popToken();
          arg.push(tok);

          if (tok.text === "{") {
            ++depth;
          } else if (tok.text === "}") {
            --depth;
          } else if (tok.text === "EOF") {
            throw new src_ParseError("End of input in macro argument", startOfArg);
          }
        }

        arg.pop(); // remove last }

        arg.reverse(); // like above, to fit in with stack order

        args[i] = arg;
      } else if (startOfArg.text === "EOF") {
        throw new src_ParseError("End of input expecting macro argument");
      } else {
        args[i] = [startOfArg];
      }
    }

    return args;
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order and will be returned as an array,
   * also in reverse order.
   *
   * If not, the next token will be returned without removing it
   * from the stack.  This case can be detected by a `Token` return value
   * instead of an `Array` return value.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty.
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * At the moment, macro expansion doesn't handle delimited macros,
   * i.e. things like those defined by \def\foo#1\end{}.
   * See the TeX book page 202ff. for details on how those should behave.
   */
  ;

  _proto.expandOnce = function expandOnce() {
    var topToken = this.popToken();
    var name = topToken.text;

    var expansion = this._getExpansion(name);

    if (expansion == null) {
      // mainly checking for undefined here
      // Fully expanded
      this.pushToken(topToken);
      return topToken;
    }

    this.expansionCount++;

    if (this.expansionCount > this.settings.maxExpand) {
      throw new src_ParseError("Too many expansions: infinite loop or " + "need to increase maxExpand setting");
    }

    var tokens = expansion.tokens;

    if (expansion.numArgs) {
      var args = this.consumeArgs(expansion.numArgs); // paste arguments in place of the placeholders

      tokens = tokens.slice(); // make a shallow copy

      for (var i = tokens.length - 1; i >= 0; --i) {
        var tok = tokens[i];

        if (tok.text === "#") {
          if (i === 0) {
            throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
          }

          tok = tokens[--i]; // next token on stack

          if (tok.text === "#") {
            // ##  #
            tokens.splice(i + 1, 1); // drop first #
          } else if (/^[1-9]$/.test(tok.text)) {
            var _tokens;

            // replace the placeholder with the indicated argument
            (_tokens = tokens).splice.apply(_tokens, [i, 2].concat(args[+tok.text - 1]));
          } else {
            throw new src_ParseError("Not a valid argument number", tok);
          }
        }
      }
    } // Concatenate expansion onto top of stack.


    this.pushTokens(tokens);
    return tokens;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  ;

  _proto.expandAfterFuture = function expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  ;

  _proto.expandNextToken = function expandNextToken() {
    for (;;) {
      var expanded = this.expandOnce(); // expandOnce returns Token if and only if it's fully expanded.

      if (expanded instanceof Token_Token) {
        // \relax stops the expansion, but shouldn't get returned (a
        // null return value couldn't get implemented as a function).
        if (expanded.text === "\\relax") {
          this.stack.pop();
        } else {
          return this.stack.pop(); // === expanded
        }
      }
    } // Flow unable to figure out that this pathway is impossible.
    // https://github.com/facebook/flow/issues/4808


    throw new Error(); // eslint-disable-line no-unreachable
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  ;

  _proto.expandMacro = function expandMacro(name) {
    if (!this.macros.get(name)) {
      return undefined;
    }

    var output = [];
    var oldStackLength = this.stack.length;
    this.pushToken(new Token_Token(name));

    while (this.stack.length > oldStackLength) {
      var expanded = this.expandOnce(); // expandOnce returns Token if and only if it's fully expanded.

      if (expanded instanceof Token_Token) {
        output.push(this.stack.pop());
      }
    }

    return output;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  ;

  _proto.expandMacroAsText = function expandMacroAsText(name) {
    var tokens = this.expandMacro(name);

    if (tokens) {
      return tokens.map(function (token) {
        return token.text;
      }).join("");
    } else {
      return tokens;
    }
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  ;

  _proto._getExpansion = function _getExpansion(name) {
    var definition = this.macros.get(name);

    if (definition == null) {
      // mainly checking for undefined here
      return definition;
    }

    var expansion = typeof definition === "function" ? definition(this) : definition;

    if (typeof expansion === "string") {
      var numArgs = 0;

      if (expansion.indexOf("#") !== -1) {
        var stripped = expansion.replace(/##/g, "");

        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }

      var bodyLexer = new Lexer_Lexer(expansion, this.settings);
      var tokens = [];
      var tok = bodyLexer.lex();

      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }

      tokens.reverse(); // to fit in with stack using push and pop

      var expanded = {
        tokens: tokens,
        numArgs: numArgs
      };
      return expanded;
    }

    return expansion;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  ;

  _proto.isDefined = function isDefined(name) {
    return this.macros.has(name) || src_functions.hasOwnProperty(name) || src_symbols.math.hasOwnProperty(name) || src_symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
  };

  return MacroExpander;
}();


// CONCATENATED MODULE: ./src/unicodeAccents.js
// Mapping of Unicode accent characters to their LaTeX equivalent in text and
// math mode (when they exist).
/* harmony default export */ var unicodeAccents = ({
  "\u0301": {
    text: "\\'",
    math: '\\acute'
  },
  "\u0300": {
    text: '\\`',
    math: '\\grave'
  },
  "\u0308": {
    text: '\\"',
    math: '\\ddot'
  },
  "\u0303": {
    text: '\\~',
    math: '\\tilde'
  },
  "\u0304": {
    text: '\\=',
    math: '\\bar'
  },
  "\u0306": {
    text: "\\u",
    math: '\\breve'
  },
  "\u030C": {
    text: '\\v',
    math: '\\check'
  },
  "\u0302": {
    text: '\\^',
    math: '\\hat'
  },
  "\u0307": {
    text: '\\.',
    math: '\\dot'
  },
  "\u030A": {
    text: '\\r',
    math: '\\mathring'
  },
  "\u030B": {
    text: '\\H'
  }
});
// CONCATENATED MODULE: ./src/unicodeSymbols.js
// This file is GENERATED by unicodeMake.js. DO NOT MODIFY.
/* harmony default export */ var unicodeSymbols = ({
  "\xE1": "a\u0301",
  //  = \'{a}
  "\xE0": "a\u0300",
  //  = \`{a}
  "\xE4": "a\u0308",
  //  = \"{a}
  "\u01DF": "a\u0308\u0304",
  //  = \"\={a}
  "\xE3": "a\u0303",
  //  = \~{a}
  "\u0101": "a\u0304",
  //  = \={a}
  "\u0103": "a\u0306",
  //  = \u{a}
  "\u1EAF": "a\u0306\u0301",
  //  = \u\'{a}
  "\u1EB1": "a\u0306\u0300",
  //  = \u\`{a}
  "\u1EB5": "a\u0306\u0303",
  //  = \u\~{a}
  "\u01CE": "a\u030C",
  //  = \v{a}
  "\xE2": "a\u0302",
  //  = \^{a}
  "\u1EA5": "a\u0302\u0301",
  //  = \^\'{a}
  "\u1EA7": "a\u0302\u0300",
  //  = \^\`{a}
  "\u1EAB": "a\u0302\u0303",
  //  = \^\~{a}
  "\u0227": "a\u0307",
  //  = \.{a}
  "\u01E1": "a\u0307\u0304",
  //  = \.\={a}
  "\xE5": "a\u030A",
  //  = \r{a}
  "\u01FB": "a\u030A\u0301",
  //  = \r\'{a}
  "\u1E03": "b\u0307",
  //  = \.{b}
  "\u0107": "c\u0301",
  //  = \'{c}
  "\u010D": "c\u030C",
  //  = \v{c}
  "\u0109": "c\u0302",
  //  = \^{c}
  "\u010B": "c\u0307",
  //  = \.{c}
  "\u010F": "d\u030C",
  //  = \v{d}
  "\u1E0B": "d\u0307",
  //  = \.{d}
  "\xE9": "e\u0301",
  //  = \'{e}
  "\xE8": "e\u0300",
  //  = \`{e}
  "\xEB": "e\u0308",
  //  = \"{e}
  "\u1EBD": "e\u0303",
  //  = \~{e}
  "\u0113": "e\u0304",
  //  = \={e}
  "\u1E17": "e\u0304\u0301",
  //  = \=\'{e}
  "\u1E15": "e\u0304\u0300",
  //  = \=\`{e}
  "\u0115": "e\u0306",
  //  = \u{e}
  "\u011B": "e\u030C",
  //  = \v{e}
  "\xEA": "e\u0302",
  //  = \^{e}
  "\u1EBF": "e\u0302\u0301",
  //  = \^\'{e}
  "\u1EC1": "e\u0302\u0300",
  //  = \^\`{e}
  "\u1EC5": "e\u0302\u0303",
  //  = \^\~{e}
  "\u0117": "e\u0307",
  //  = \.{e}
  "\u1E1F": "f\u0307",
  //  = \.{f}
  "\u01F5": "g\u0301",
  //  = \'{g}
  "\u1E21": "g\u0304",
  //  = \={g}
  "\u011F": "g\u0306",
  //  = \u{g}
  "\u01E7": "g\u030C",
  //  = \v{g}
  "\u011D": "g\u0302",
  //  = \^{g}
  "\u0121": "g\u0307",
  //  = \.{g}
  "\u1E27": "h\u0308",
  //  = \"{h}
  "\u021F": "h\u030C",
  //  = \v{h}
  "\u0125": "h\u0302",
  //  = \^{h}
  "\u1E23": "h\u0307",
  //  = \.{h}
  "\xED": "i\u0301",
  //  = \'{i}
  "\xEC": "i\u0300",
  //  = \`{i}
  "\xEF": "i\u0308",
  //  = \"{i}
  "\u1E2F": "i\u0308\u0301",
  //  = \"\'{i}
  "\u0129": "i\u0303",
  //  = \~{i}
  "\u012B": "i\u0304",
  //  = \={i}
  "\u012D": "i\u0306",
  //  = \u{i}
  "\u01D0": "i\u030C",
  //  = \v{i}
  "\xEE": "i\u0302",
  //  = \^{i}
  "\u01F0": "j\u030C",
  //  = \v{j}
  "\u0135": "j\u0302",
  //  = \^{j}
  "\u1E31": "k\u0301",
  //  = \'{k}
  "\u01E9": "k\u030C",
  //  = \v{k}
  "\u013A": "l\u0301",
  //  = \'{l}
  "\u013E": "l\u030C",
  //  = \v{l}
  "\u1E3F": "m\u0301",
  //  = \'{m}
  "\u1E41": "m\u0307",
  //  = \.{m}
  "\u0144": "n\u0301",
  //  = \'{n}
  "\u01F9": "n\u0300",
  //  = \`{n}
  "\xF1": "n\u0303",
  //  = \~{n}
  "\u0148": "n\u030C",
  //  = \v{n}
  "\u1E45": "n\u0307",
  //  = \.{n}
  "\xF3": "o\u0301",
  //  = \'{o}
  "\xF2": "o\u0300",
  //  = \`{o}
  "\xF6": "o\u0308",
  //  = \"{o}
  "\u022B": "o\u0308\u0304",
  //  = \"\={o}
  "\xF5": "o\u0303",
  //  = \~{o}
  "\u1E4D": "o\u0303\u0301",
  //  = \~\'{o}
  "\u1E4F": "o\u0303\u0308",
  //  = \~\"{o}
  "\u022D": "o\u0303\u0304",
  //  = \~\={o}
  "\u014D": "o\u0304",
  //  = \={o}
  "\u1E53": "o\u0304\u0301",
  //  = \=\'{o}
  "\u1E51": "o\u0304\u0300",
  //  = \=\`{o}
  "\u014F": "o\u0306",
  //  = \u{o}
  "\u01D2": "o\u030C",
  //  = \v{o}
  "\xF4": "o\u0302",
  //  = \^{o}
  "\u1ED1": "o\u0302\u0301",
  //  = \^\'{o}
  "\u1ED3": "o\u0302\u0300",
  //  = \^\`{o}
  "\u1ED7": "o\u0302\u0303",
  //  = \^\~{o}
  "\u022F": "o\u0307",
  //  = \.{o}
  "\u0231": "o\u0307\u0304",
  //  = \.\={o}
  "\u0151": "o\u030B",
  //  = \H{o}
  "\u1E55": "p\u0301",
  //  = \'{p}
  "\u1E57": "p\u0307",
  //  = \.{p}
  "\u0155": "r\u0301",
  //  = \'{r}
  "\u0159": "r\u030C",
  //  = \v{r}
  "\u1E59": "r\u0307",
  //  = \.{r}
  "\u015B": "s\u0301",
  //  = \'{s}
  "\u1E65": "s\u0301\u0307",
  //  = \'\.{s}
  "\u0161": "s\u030C",
  //  = \v{s}
  "\u1E67": "s\u030C\u0307",
  //  = \v\.{s}
  "\u015D": "s\u0302",
  //  = \^{s}
  "\u1E61": "s\u0307",
  //  = \.{s}
  "\u1E97": "t\u0308",
  //  = \"{t}
  "\u0165": "t\u030C",
  //  = \v{t}
  "\u1E6B": "t\u0307",
  //  = \.{t}
  "\xFA": "u\u0301",
  //  = \'{u}
  "\xF9": "u\u0300",
  //  = \`{u}
  "\xFC": "u\u0308",
  //  = \"{u}
  "\u01D8": "u\u0308\u0301",
  //  = \"\'{u}
  "\u01DC": "u\u0308\u0300",
  //  = \"\`{u}
  "\u01D6": "u\u0308\u0304",
  //  = \"\={u}
  "\u01DA": "u\u0308\u030C",
  //  = \"\v{u}
  "\u0169": "u\u0303",
  //  = \~{u}
  "\u1E79": "u\u0303\u0301",
  //  = \~\'{u}
  "\u016B": "u\u0304",
  //  = \={u}
  "\u1E7B": "u\u0304\u0308",
  //  = \=\"{u}
  "\u016D": "u\u0306",
  //  = \u{u}
  "\u01D4": "u\u030C",
  //  = \v{u}
  "\xFB": "u\u0302",
  //  = \^{u}
  "\u016F": "u\u030A",
  //  = \r{u}
  "\u0171": "u\u030B",
  //  = \H{u}
  "\u1E7D": "v\u0303",
  //  = \~{v}
  "\u1E83": "w\u0301",
  //  = \'{w}
  "\u1E81": "w\u0300",
  //  = \`{w}
  "\u1E85": "w\u0308",
  //  = \"{w}
  "\u0175": "w\u0302",
  //  = \^{w}
  "\u1E87": "w\u0307",
  //  = \.{w}
  "\u1E98": "w\u030A",
  //  = \r{w}
  "\u1E8D": "x\u0308",
  //  = \"{x}
  "\u1E8B": "x\u0307",
  //  = \.{x}
  "\xFD": "y\u0301",
  //  = \'{y}
  "\u1EF3": "y\u0300",
  //  = \`{y}
  "\xFF": "y\u0308",
  //  = \"{y}
  "\u1EF9": "y\u0303",
  //  = \~{y}
  "\u0233": "y\u0304",
  //  = \={y}
  "\u0177": "y\u0302",
  //  = \^{y}
  "\u1E8F": "y\u0307",
  //  = \.{y}
  "\u1E99": "y\u030A",
  //  = \r{y}
  "\u017A": "z\u0301",
  //  = \'{z}
  "\u017E": "z\u030C",
  //  = \v{z}
  "\u1E91": "z\u0302",
  //  = \^{z}
  "\u017C": "z\u0307",
  //  = \.{z}
  "\xC1": "A\u0301",
  //  = \'{A}
  "\xC0": "A\u0300",
  //  = \`{A}
  "\xC4": "A\u0308",
  //  = \"{A}
  "\u01DE": "A\u0308\u0304",
  //  = \"\={A}
  "\xC3": "A\u0303",
  //  = \~{A}
  "\u0100": "A\u0304",
  //  = \={A}
  "\u0102": "A\u0306",
  //  = \u{A}
  "\u1EAE": "A\u0306\u0301",
  //  = \u\'{A}
  "\u1EB0": "A\u0306\u0300",
  //  = \u\`{A}
  "\u1EB4": "A\u0306\u0303",
  //  = \u\~{A}
  "\u01CD": "A\u030C",
  //  = \v{A}
  "\xC2": "A\u0302",
  //  = \^{A}
  "\u1EA4": "A\u0302\u0301",
  //  = \^\'{A}
  "\u1EA6": "A\u0302\u0300",
  //  = \^\`{A}
  "\u1EAA": "A\u0302\u0303",
  //  = \^\~{A}
  "\u0226": "A\u0307",
  //  = \.{A}
  "\u01E0": "A\u0307\u0304",
  //  = \.\={A}
  "\xC5": "A\u030A",
  //  = \r{A}
  "\u01FA": "A\u030A\u0301",
  //  = \r\'{A}
  "\u1E02": "B\u0307",
  //  = \.{B}
  "\u0106": "C\u0301",
  //  = \'{C}
  "\u010C": "C\u030C",
  //  = \v{C}
  "\u0108": "C\u0302",
  //  = \^{C}
  "\u010A": "C\u0307",
  //  = \.{C}
  "\u010E": "D\u030C",
  //  = \v{D}
  "\u1E0A": "D\u0307",
  //  = \.{D}
  "\xC9": "E\u0301",
  //  = \'{E}
  "\xC8": "E\u0300",
  //  = \`{E}
  "\xCB": "E\u0308",
  //  = \"{E}
  "\u1EBC": "E\u0303",
  //  = \~{E}
  "\u0112": "E\u0304",
  //  = \={E}
  "\u1E16": "E\u0304\u0301",
  //  = \=\'{E}
  "\u1E14": "E\u0304\u0300",
  //  = \=\`{E}
  "\u0114": "E\u0306",
  //  = \u{E}
  "\u011A": "E\u030C",
  //  = \v{E}
  "\xCA": "E\u0302",
  //  = \^{E}
  "\u1EBE": "E\u0302\u0301",
  //  = \^\'{E}
  "\u1EC0": "E\u0302\u0300",
  //  = \^\`{E}
  "\u1EC4": "E\u0302\u0303",
  //  = \^\~{E}
  "\u0116": "E\u0307",
  //  = \.{E}
  "\u1E1E": "F\u0307",
  //  = \.{F}
  "\u01F4": "G\u0301",
  //  = \'{G}
  "\u1E20": "G\u0304",
  //  = \={G}
  "\u011E": "G\u0306",
  //  = \u{G}
  "\u01E6": "G\u030C",
  //  = \v{G}
  "\u011C": "G\u0302",
  //  = \^{G}
  "\u0120": "G\u0307",
  //  = \.{G}
  "\u1E26": "H\u0308",
  //  = \"{H}
  "\u021E": "H\u030C",
  //  = \v{H}
  "\u0124": "H\u0302",
  //  = \^{H}
  "\u1E22": "H\u0307",
  //  = \.{H}
  "\xCD": "I\u0301",
  //  = \'{I}
  "\xCC": "I\u0300",
  //  = \`{I}
  "\xCF": "I\u0308",
  //  = \"{I}
  "\u1E2E": "I\u0308\u0301",
  //  = \"\'{I}
  "\u0128": "I\u0303",
  //  = \~{I}
  "\u012A": "I\u0304",
  //  = \={I}
  "\u012C": "I\u0306",
  //  = \u{I}
  "\u01CF": "I\u030C",
  //  = \v{I}
  "\xCE": "I\u0302",
  //  = \^{I}
  "\u0130": "I\u0307",
  //  = \.{I}
  "\u0134": "J\u0302",
  //  = \^{J}
  "\u1E30": "K\u0301",
  //  = \'{K}
  "\u01E8": "K\u030C",
  //  = \v{K}
  "\u0139": "L\u0301",
  //  = \'{L}
  "\u013D": "L\u030C",
  //  = \v{L}
  "\u1E3E": "M\u0301",
  //  = \'{M}
  "\u1E40": "M\u0307",
  //  = \.{M}
  "\u0143": "N\u0301",
  //  = \'{N}
  "\u01F8": "N\u0300",
  //  = \`{N}
  "\xD1": "N\u0303",
  //  = \~{N}
  "\u0147": "N\u030C",
  //  = \v{N}
  "\u1E44": "N\u0307",
  //  = \.{N}
  "\xD3": "O\u0301",
  //  = \'{O}
  "\xD2": "O\u0300",
  //  = \`{O}
  "\xD6": "O\u0308",
  //  = \"{O}
  "\u022A": "O\u0308\u0304",
  //  = \"\={O}
  "\xD5": "O\u0303",
  //  = \~{O}
  "\u1E4C": "O\u0303\u0301",
  //  = \~\'{O}
  "\u1E4E": "O\u0303\u0308",
  //  = \~\"{O}
  "\u022C": "O\u0303\u0304",
  //  = \~\={O}
  "\u014C": "O\u0304",
  //  = \={O}
  "\u1E52": "O\u0304\u0301",
  //  = \=\'{O}
  "\u1E50": "O\u0304\u0300",
  //  = \=\`{O}
  "\u014E": "O\u0306",
  //  = \u{O}
  "\u01D1": "O\u030C",
  //  = \v{O}
  "\xD4": "O\u0302",
  //  = \^{O}
  "\u1ED0": "O\u0302\u0301",
  //  = \^\'{O}
  "\u1ED2": "O\u0302\u0300",
  //  = \^\`{O}
  "\u1ED6": "O\u0302\u0303",
  //  = \^\~{O}
  "\u022E": "O\u0307",
  //  = \.{O}
  "\u0230": "O\u0307\u0304",
  //  = \.\={O}
  "\u0150": "O\u030B",
  //  = \H{O}
  "\u1E54": "P\u0301",
  //  = \'{P}
  "\u1E56": "P\u0307",
  //  = \.{P}
  "\u0154": "R\u0301",
  //  = \'{R}
  "\u0158": "R\u030C",
  //  = \v{R}
  "\u1E58": "R\u0307",
  //  = \.{R}
  "\u015A": "S\u0301",
  //  = \'{S}
  "\u1E64": "S\u0301\u0307",
  //  = \'\.{S}
  "\u0160": "S\u030C",
  //  = \v{S}
  "\u1E66": "S\u030C\u0307",
  //  = \v\.{S}
  "\u015C": "S\u0302",
  //  = \^{S}
  "\u1E60": "S\u0307",
  //  = \.{S}
  "\u0164": "T\u030C",
  //  = \v{T}
  "\u1E6A": "T\u0307",
  //  = \.{T}
  "\xDA": "U\u0301",
  //  = \'{U}
  "\xD9": "U\u0300",
  //  = \`{U}
  "\xDC": "U\u0308",
  //  = \"{U}
  "\u01D7": "U\u0308\u0301",
  //  = \"\'{U}
  "\u01DB": "U\u0308\u0300",
  //  = \"\`{U}
  "\u01D5": "U\u0308\u0304",
  //  = \"\={U}
  "\u01D9": "U\u0308\u030C",
  //  = \"\v{U}
  "\u0168": "U\u0303",
  //  = \~{U}
  "\u1E78": "U\u0303\u0301",
  //  = \~\'{U}
  "\u016A": "U\u0304",
  //  = \={U}
  "\u1E7A": "U\u0304\u0308",
  //  = \=\"{U}
  "\u016C": "U\u0306",
  //  = \u{U}
  "\u01D3": "U\u030C",
  //  = \v{U}
  "\xDB": "U\u0302",
  //  = \^{U}
  "\u016E": "U\u030A",
  //  = \r{U}
  "\u0170": "U\u030B",
  //  = \H{U}
  "\u1E7C": "V\u0303",
  //  = \~{V}
  "\u1E82": "W\u0301",
  //  = \'{W}
  "\u1E80": "W\u0300",
  //  = \`{W}
  "\u1E84": "W\u0308",
  //  = \"{W}
  "\u0174": "W\u0302",
  //  = \^{W}
  "\u1E86": "W\u0307",
  //  = \.{W}
  "\u1E8C": "X\u0308",
  //  = \"{X}
  "\u1E8A": "X\u0307",
  //  = \.{X}
  "\xDD": "Y\u0301",
  //  = \'{Y}
  "\u1EF2": "Y\u0300",
  //  = \`{Y}
  "\u0178": "Y\u0308",
  //  = \"{Y}
  "\u1EF8": "Y\u0303",
  //  = \~{Y}
  "\u0232": "Y\u0304",
  //  = \={Y}
  "\u0176": "Y\u0302",
  //  = \^{Y}
  "\u1E8E": "Y\u0307",
  //  = \.{Y}
  "\u0179": "Z\u0301",
  //  = \'{Z}
  "\u017D": "Z\u030C",
  //  = \v{Z}
  "\u1E90": "Z\u0302",
  //  = \^{Z}
  "\u017B": "Z\u0307",
  //  = \.{Z}
  "\u03AC": "\u03B1\u0301",
  //  = \'{}
  "\u1F70": "\u03B1\u0300",
  //  = \`{}
  "\u1FB1": "\u03B1\u0304",
  //  = \={}
  "\u1FB0": "\u03B1\u0306",
  //  = \u{}
  "\u03AD": "\u03B5\u0301",
  //  = \'{}
  "\u1F72": "\u03B5\u0300",
  //  = \`{}
  "\u03AE": "\u03B7\u0301",
  //  = \'{}
  "\u1F74": "\u03B7\u0300",
  //  = \`{}
  "\u03AF": "\u03B9\u0301",
  //  = \'{}
  "\u1F76": "\u03B9\u0300",
  //  = \`{}
  "\u03CA": "\u03B9\u0308",
  //  = \"{}
  "\u0390": "\u03B9\u0308\u0301",
  //  = \"\'{}
  "\u1FD2": "\u03B9\u0308\u0300",
  //  = \"\`{}
  "\u1FD1": "\u03B9\u0304",
  //  = \={}
  "\u1FD0": "\u03B9\u0306",
  //  = \u{}
  "\u03CC": "\u03BF\u0301",
  //  = \'{}
  "\u1F78": "\u03BF\u0300",
  //  = \`{}
  "\u03CD": "\u03C5\u0301",
  //  = \'{}
  "\u1F7A": "\u03C5\u0300",
  //  = \`{}
  "\u03CB": "\u03C5\u0308",
  //  = \"{}
  "\u03B0": "\u03C5\u0308\u0301",
  //  = \"\'{}
  "\u1FE2": "\u03C5\u0308\u0300",
  //  = \"\`{}
  "\u1FE1": "\u03C5\u0304",
  //  = \={}
  "\u1FE0": "\u03C5\u0306",
  //  = \u{}
  "\u03CE": "\u03C9\u0301",
  //  = \'{}
  "\u1F7C": "\u03C9\u0300",
  //  = \`{}
  "\u038E": "\u03A5\u0301",
  //  = \'{}
  "\u1FEA": "\u03A5\u0300",
  //  = \`{}
  "\u03AB": "\u03A5\u0308",
  //  = \"{}
  "\u1FE9": "\u03A5\u0304",
  //  = \={}
  "\u1FE8": "\u03A5\u0306",
  //  = \u{}
  "\u038F": "\u03A9\u0301",
  //  = \'{}
  "\u1FFA": "\u03A9\u0300" //  = \`{}

});
// CONCATENATED MODULE: ./src/Parser.js
/* eslint no-constant-condition:0 */















/**
 * This file contains the parser used to parse out a TeX expression from the
 * input. Since TeX isn't context-free, standard parsers don't work particularly
 * well.
 *
 * The strategy of this parser is as such:
 *
 * The main functions (the `.parse...` ones) take a position in the current
 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
 * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When
 * individual tokens are needed at a position, the lexer is called to pull out a
 * token, which is then used.
 *
 * The parser has a property called "mode" indicating the mode that
 * the parser is currently in. Currently it has to be one of "math" or
 * "text", which denotes whether the current environment is a math-y
 * one or a text-y one (e.g. inside \text). Currently, this serves to
 * limit the functions which can be used in text mode.
 *
 * The main functions then return an object which contains the useful data that
 * was parsed at its given point, and a new position at the end of the parsed
 * data. The main functions can call each other and continue the parsing by
 * using the returned position as a new starting point.
 *
 * There are also extra `.handle...` functions, which pull out some reused
 * functionality into self-contained functions.
 *
 * The functions return ParseNodes.
 */
var Parser_Parser =
/*#__PURE__*/
function () {
  function Parser(input, settings) {
    this.mode = void 0;
    this.gullet = void 0;
    this.settings = void 0;
    this.leftrightDepth = void 0;
    this.nextToken = void 0;
    // Start in math mode
    this.mode = "math"; // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)

    this.gullet = new MacroExpander_MacroExpander(input, settings, this.mode); // Store the settings for use in parsing

    this.settings = settings; // Count leftright depth (for \middle errors)

    this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */


  var _proto = Parser.prototype;

  _proto.expect = function expect(text, consume) {
    if (consume === void 0) {
      consume = true;
    }

    if (this.nextToken.text !== text) {
      throw new src_ParseError("Expected '" + text + "', got '" + this.nextToken.text + "'", this.nextToken);
    }

    if (consume) {
      this.consume();
    }
  }
  /**
   * Considers the current look ahead token as consumed,
   * and fetches the one after that as the new look ahead.
   */
  ;

  _proto.consume = function consume() {
    this.nextToken = this.gullet.expandNextToken();
  }
  /**
   * Switches between "text" and "math" modes.
   */
  ;

  _proto.switchMode = function switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  ;

  _proto.parse = function parse() {
    // Create a group namespace for the math expression.
    // (LaTeX creates a new group for every $...$, $$...$$, \[...\].)
    this.gullet.beginGroup(); // Use old \color behavior (same as LaTeX's \textcolor) if requested.
    // We do this within the group for the math expression, so it doesn't
    // pollute settings.macros.

    if (this.settings.colorIsTextColor) {
      this.gullet.macros.set("\\color", "\\textcolor");
    } // Try to parse the input


    this.consume();
    var parse = this.parseExpression(false); // If we succeeded, make sure there's an EOF at the end

    this.expect("EOF", false); // End the group namespace for the expression

    this.gullet.endGroup();
    return parse;
  };

  _proto.parseExpression = function parseExpression(breakOnInfix, breakOnTokenText) {
    var body = []; // Keep adding atoms to the body until we can't parse any more atoms (either
    // we reached the end, a }, or a \right)

    while (true) {
      // Ignore spaces in math mode
      if (this.mode === "math") {
        this.consumeSpaces();
      }

      var lex = this.nextToken;

      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }

      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }

      if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
        break;
      }

      var atom = this.parseAtom(breakOnTokenText);

      if (!atom) {
        break;
      }

      body.push(atom);
    }

    if (this.mode === "text") {
      this.formLigatures(body);
    }

    return this.handleInfixNodes(body);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  ;

  _proto.handleInfixNodes = function handleInfixNodes(body) {
    var overIndex = -1;
    var funcName;

    for (var i = 0; i < body.length; i++) {
      var node = checkNodeType(body[i], "infix");

      if (node) {
        if (overIndex !== -1) {
          throw new src_ParseError("only one infix operator per group", node.token);
        }

        overIndex = i;
        funcName = node.replaceWith;
      }
    }

    if (overIndex !== -1 && funcName) {
      var numerNode;
      var denomNode;
      var numerBody = body.slice(0, overIndex);
      var denomBody = body.slice(overIndex + 1);

      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = {
          type: "ordgroup",
          mode: this.mode,
          body: numerBody
        };
      }

      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = {
          type: "ordgroup",
          mode: this.mode,
          body: denomBody
        };
      }

      var _node;

      if (funcName === "\\\\abovefrac") {
        _node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        _node = this.callFunction(funcName, [numerNode, denomNode], []);
      }

      return [_node];
    } else {
      return body;
    }
  } // The greediness of a superscript or subscript
  ;

  /**
   * Handle a subscript or superscript with nice errors.
   */
  _proto.handleSupSubscript = function handleSupSubscript(name) {
    var symbolToken = this.nextToken;
    var symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces(); // ignore spaces before sup/subscript argument

    var group = this.parseGroup(name, false, Parser.SUPSUB_GREEDINESS);

    if (!group) {
      throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
    }

    return group;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  ;

  _proto.handleUnsupportedCmd = function handleUnsupportedCmd() {
    var text = this.nextToken.text;
    var textordArray = [];

    for (var i = 0; i < text.length; i++) {
      textordArray.push({
        type: "textord",
        mode: "text",
        text: text[i]
      });
    }

    var textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };
    var colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };
    this.consume();
    return colorNode;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  ;

  _proto.parseAtom = function parseAtom(breakOnTokenText) {
    // The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    var base = this.parseGroup("atom", false, null, breakOnTokenText); // In text mode, we don't have superscripts or subscripts

    if (this.mode === "text") {
      return base;
    } // Note that base may be empty (i.e. null) at this point.


    var superscript;
    var subscript;

    while (true) {
      // Guaranteed in math mode, so eat any spaces first.
      this.consumeSpaces(); // Lex the first token

      var lex = this.nextToken;

      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        // We got a limit control
        var opNode = checkNodeType(base, "op");

        if (opNode) {
          var limits = lex.text === "\\limits";
          opNode.limits = limits;
          opNode.alwaysHandleSupSub = true;
        } else {
          throw new src_ParseError("Limit controls must follow a math operator", lex);
        }

        this.consume();
      } else if (lex.text === "^") {
        // We got a superscript start
        if (superscript) {
          throw new src_ParseError("Double superscript", lex);
        }

        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        // We got a subscript start
        if (subscript) {
          throw new src_ParseError("Double subscript", lex);
        }

        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        // We got a prime
        if (superscript) {
          throw new src_ParseError("Double superscript", lex);
        }

        var prime = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }; // Many primes can be grouped together, so we handle this here

        var primes = [prime];
        this.consume(); // Keep lexing tokens until we get something that's not a prime

        while (this.nextToken.text === "'") {
          // For each one, add another prime to the list
          primes.push(prime);
          this.consume();
        } // If there's a superscript following the primes, combine that
        // superscript in with the primes.


        if (this.nextToken.text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        } // Put everything into an ordgroup as the superscript


        superscript = {
          type: "ordgroup",
          mode: this.mode,
          body: primes
        };
      } else {
        // If it wasn't ^, _, or ', stop parsing super/subscripts
        break;
      }
    } // Base must be set if superscript or subscript are set per logic above,
    // but need to check here for type check to pass.


    if (superscript || subscript) {
      // If we got either a superscript or subscript, create a supsub
      return {
        type: "supsub",
        mode: this.mode,
        base: base,
        sup: superscript,
        sub: subscript
      };
    } else {
      // Otherwise return the original body
      return base;
    }
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  ;

  _proto.parseFunction = function parseFunction(breakOnTokenText, name, // For error reporting.
  greediness) {
    var token = this.nextToken;
    var func = token.text;
    var funcData = src_functions[func];

    if (!funcData) {
      return null;
    }

    if (greediness != null && funcData.greediness <= greediness) {
      throw new src_ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
    } // hyperref package sets the catcode of % as an active character


    if (funcData.argTypes && funcData.argTypes[0] === "url") {
      this.gullet.lexer.setCatcode("%", 13);
    } // Consume the command token after possibly switching to the
    // mode specified by the function (for instant mode switching),
    // and then immediately switch back.


    if (funcData.consumeMode) {
      var oldMode = this.mode;
      this.switchMode(funcData.consumeMode);
      this.consume();
      this.switchMode(oldMode);
    } else {
      this.consume();
    }

    var _this$parseArguments = this.parseArguments(func, funcData),
        args = _this$parseArguments.args,
        optArgs = _this$parseArguments.optArgs;

    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  ;

  _proto.callFunction = function callFunction(name, args, optArgs, token, breakOnTokenText) {
    var context = {
      funcName: name,
      parser: this,
      token: token,
      breakOnTokenText: breakOnTokenText
    };
    var func = src_functions[name];

    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new src_ParseError("No function handler for " + name);
    }
  }
  /**
   * Parses the arguments of a function or environment
   */
  ;

  _proto.parseArguments = function parseArguments(func, // Should look like "\name" or "\begin{name}".
  funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;

    if (totalArgs === 0) {
      return {
        args: [],
        optArgs: []
      };
    }

    var baseGreediness = funcData.greediness;
    var args = [];
    var optArgs = [];

    for (var i = 0; i < totalArgs; i++) {
      var argType = funcData.argTypes && funcData.argTypes[i];
      var isOptional = i < funcData.numOptionalArgs; // Ignore spaces between arguments.  As the TeXbook says:
      // "After you have said \def\row#1#2{...}, you are allowed to
      //  put spaces between the arguments (e.g., \row x n), because
      //  TeX doesnt use single spaces as undelimited arguments."

      if (i > 0 && !isOptional) {
        this.consumeSpaces();
      } // Also consume leading spaces in math mode, as parseSymbol
      // won't know what to do with them.  This can only happen with
      // macros, e.g. \frac\foo\foo where \foo expands to a space symbol.
      // In LaTeX, the \foo's get treated as (blank) arguments).
      // In KaTeX, for now, both spaces will get consumed.
      // TODO(edemaine)


      if (i === 0 && !isOptional && this.mode === "math") {
        this.consumeSpaces();
      }

      var nextToken = this.nextToken;
      var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional, baseGreediness);

      if (!arg) {
        if (isOptional) {
          optArgs.push(null);
          continue;
        }

        throw new src_ParseError("Expected group after '" + func + "'", nextToken);
      }

      (isOptional ? optArgs : args).push(arg);
    }

    return {
      args: args,
      optArgs: optArgs
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  ;

  _proto.parseGroupOfType = function parseGroupOfType(name, type, optional, greediness) {
    switch (type) {
      case "color":
        return this.parseColorGroup(optional);

      case "size":
        return this.parseSizeGroup(optional);

      case "url":
        return this.parseUrlGroup(optional);

      case "math":
      case "text":
        return this.parseGroup(name, optional, greediness, undefined, type);

      case "raw":
        {
          if (optional && this.nextToken.text === "{") {
            return null;
          }

          var token = this.parseStringGroup("raw", optional, true);

          if (token) {
            return {
              type: "raw",
              mode: "text",
              string: token.text
            };
          } else {
            throw new src_ParseError("Expected raw group", this.nextToken);
          }
        }

      case "original":
      case null:
      case undefined:
        return this.parseGroup(name, optional, greediness);

      default:
        throw new src_ParseError("Unknown group type as " + name, this.nextToken);
    }
  };

  _proto.consumeSpaces = function consumeSpaces() {
    while (this.nextToken.text === " ") {
      this.consume();
    }
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  ;

  _proto.parseStringGroup = function parseStringGroup(modeName, // Used to describe the mode in error messages.
  optional, raw) {
    var groupBegin = optional ? "[" : "{";
    var groupEnd = optional ? "]" : "}";
    var nextToken = this.nextToken;

    if (nextToken.text !== groupBegin) {
      if (optional) {
        return null;
      } else if (raw && nextToken.text !== "EOF" && /[^{}[\]]/.test(nextToken.text)) {
        // allow a single character in raw string group
        this.gullet.lexer.setCatcode("%", 14); // reset the catcode of %

        this.consume();
        return nextToken;
      }
    }

    var outerMode = this.mode;
    this.mode = "text";
    this.expect(groupBegin);
    var str = "";
    var firstToken = this.nextToken;
    var nested = 0; // allow nested braces in raw string group

    var lastToken = firstToken;

    while (raw && nested > 0 || this.nextToken.text !== groupEnd) {
      switch (this.nextToken.text) {
        case "EOF":
          throw new src_ParseError("Unexpected end of input in " + modeName, firstToken.range(lastToken, str));

        case groupBegin:
          nested++;
          break;

        case groupEnd:
          nested--;
          break;
      }

      lastToken = this.nextToken;
      str += lastToken.text;
      this.consume();
    }

    this.mode = outerMode;
    this.gullet.lexer.setCatcode("%", 14); // reset the catcode of %

    this.expect(groupEnd);
    return firstToken.range(lastToken, str);
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  ;

  _proto.parseRegexGroup = function parseRegexGroup(regex, modeName) {
    var outerMode = this.mode;
    this.mode = "text";
    var firstToken = this.nextToken;
    var lastToken = firstToken;
    var str = "";

    while (this.nextToken.text !== "EOF" && regex.test(str + this.nextToken.text)) {
      lastToken = this.nextToken;
      str += lastToken.text;
      this.consume();
    }

    if (str === "") {
      throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }

    this.mode = outerMode;
    return firstToken.range(lastToken, str);
  }
  /**
   * Parses a color description.
   */
  ;

  _proto.parseColorGroup = function parseColorGroup(optional) {
    var res = this.parseStringGroup("color", optional);

    if (!res) {
      return null;
    }

    var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);

    if (!match) {
      throw new src_ParseError("Invalid color: '" + res.text + "'", res);
    }

    var color = match[0];

    if (/^[0-9a-f]{6}$/i.test(color)) {
      // We allow a 6-digit HTML color spec without a leading "#".
      // This follows the xcolor package's HTML color model.
      // Predefined color names are all missed by this RegEx pattern.
      color = "#" + color;
    }

    return {
      type: "color-token",
      mode: this.mode,
      color: color
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  ;

  _proto.parseSizeGroup = function parseSizeGroup(optional) {
    var res;
    var isBlank = false;

    if (!optional && this.nextToken.text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }

    if (!res) {
      return null;
    }

    if (!optional && res.text.length === 0) {
      // Because we've tested for what is !optional, this block won't
      // affect \kern, \hspace, etc. It will capture the mandatory arguments
      // to \genfrac and \above.
      res.text = "0pt"; // Enable \above{}

      isBlank = true; // This is here specifically for \genfrac
    }

    var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);

    if (!match) {
      throw new src_ParseError("Invalid size: '" + res.text + "'", res);
    }

    var data = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };

    if (!validUnit(data)) {
      throw new src_ParseError("Invalid unit: '" + data.unit + "'", res);
    }

    return {
      type: "size",
      mode: this.mode,
      value: data,
      isBlank: isBlank
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols.
   */
  ;

  _proto.parseUrlGroup = function parseUrlGroup(optional) {
    var res = this.parseStringGroup("url", optional, true); // get raw string

    if (!res) {
      return null;
    } // hyperref package allows backslashes alone in href, but doesn't
    // generate valid links in such cases; we interpret this as
    // "undefined" behaviour, and keep them as-is. Some browser will
    // replace backslashes with forward slashes.


    var url = res.text.replace(/\\([#$%&~_^{}])/g, '$1');
    var protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
    protocol = protocol != null ? protocol[1] : "_relative";
    var allowed = this.settings.allowedProtocols;

    if (!utils.contains(allowed, "*") && !utils.contains(allowed, protocol)) {
      throw new src_ParseError("Forbidden protocol '" + protocol + "'", res);
    }

    return {
      type: "url",
      mode: this.mode,
      url: url
    };
  }
  /**
   * If `optional` is false or absent, this parses an ordinary group,
   * which is either a single nucleus (like "x") or an expression
   * in braces (like "{x+y}") or an implicit group, a group that starts
   * at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   * If `optional` is true, it parses either a bracket-delimited expression
   * (like "[x+y]") or returns null to indicate the absence of a
   * bracket-enclosed group.
   * If `mode` is present, switches to that mode while parsing the group,
   * and switches back after.
   */
  ;

  _proto.parseGroup = function parseGroup(name, // For error reporting.
  optional, greediness, breakOnTokenText, mode) {
    var outerMode = this.mode;
    var firstToken = this.nextToken;
    var text = firstToken.text; // Switch to specified mode

    if (mode) {
      this.switchMode(mode);
    }

    var groupEnd;
    var result; // Try to parse an open brace or \begingroup

    if (optional ? text === "[" : text === "{" || text === "\\begingroup") {
      groupEnd = Parser.endOfGroup[text]; // Start a new group namespace

      this.gullet.beginGroup(); // If we get a brace, parse an expression

      this.consume();
      var expression = this.parseExpression(false, groupEnd);
      var lastToken = this.nextToken; // End group namespace before consuming symbol after close brace

      this.gullet.endGroup();
      result = {
        type: "ordgroup",
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: text === "\\begingroup" || undefined
      };
    } else if (optional) {
      // Return nothing for an optional group
      result = null;
    } else {
      // If there exists a function with this name, parse the function.
      // Otherwise, just return a nucleus
      result = this.parseFunction(breakOnTokenText, name, greediness) || this.parseSymbol();

      if (result == null && text[0] === "\\" && !implicitCommands.hasOwnProperty(text)) {
        if (this.settings.throwOnError) {
          throw new src_ParseError("Undefined control sequence: " + text, firstToken);
        }

        result = this.handleUnsupportedCmd();
      }
    } // Switch mode back


    if (mode) {
      this.switchMode(outerMode);
    } // Make sure we got a close brace


    if (groupEnd) {
      this.expect(groupEnd);
    }

    return result;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  ;

  _proto.formLigatures = function formLigatures(group) {
    var n = group.length - 1;

    for (var i = 0; i < n; ++i) {
      var a = group[i]; // $FlowFixMe: Not every node type has a `text` property.

      var v = a.text;

      if (v === "-" && group[i + 1].text === "-") {
        if (i + 1 < n && group[i + 2].text === "-") {
          group.splice(i, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 2]),
            text: "---"
          });
          n -= 2;
        } else {
          group.splice(i, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 1]),
            text: "--"
          });
          n -= 1;
        }
      }

      if ((v === "'" || v === "`") && group[i + 1].text === v) {
        group.splice(i, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a, group[i + 1]),
          text: v + v
        });
        n -= 1;
      }
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like verbatim
   */
  ;

  _proto.parseSymbol = function parseSymbol() {
    var nucleus = this.nextToken;
    var text = nucleus.text;

    if (/^\\verb[^a-zA-Z]/.test(text)) {
      this.consume();
      var arg = text.slice(5);
      var star = arg.charAt(0) === "*";

      if (star) {
        arg = arg.slice(1);
      } // Lexer's tokenRegex is constructed to always have matching
      // first/last characters.


      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
      }

      arg = arg.slice(1, -1); // remove first and last char

      return {
        type: "verb",
        mode: "text",
        body: arg,
        star: star
      };
    } // At this point, we should have a symbol, possibly with accents.
    // First expand any accented base symbol according to unicodeSymbols.


    if (unicodeSymbols.hasOwnProperty(text[0]) && !src_symbols[this.mode][text[0]]) {
      // This behavior is not strict (XeTeX-compatible) in math mode.
      if (this.settings.strict && this.mode === "math") {
        this.settings.reportNonstrict("unicodeTextInMathMode", "Accented Unicode text character \"" + text[0] + "\" used in " + "math mode", nucleus);
      }

      text = unicodeSymbols[text[0]] + text.substr(1);
    } // Strip off any combining characters


    var match = combiningDiacriticalMarksEndRegex.exec(text);

    if (match) {
      text = text.substring(0, match.index);

      if (text === 'i') {
        text = "\u0131"; // dotless i, in math and text mode
      } else if (text === 'j') {
        text = "\u0237"; // dotless j, in math and text mode
      }
    } // Recognize base symbol


    var symbol;

    if (src_symbols[this.mode][text]) {
      if (this.settings.strict && this.mode === 'math' && extraLatin.indexOf(text) >= 0) {
        this.settings.reportNonstrict("unicodeTextInMathMode", "Latin-1/Unicode text character \"" + text[0] + "\" used in " + "math mode", nucleus);
      }

      var group = src_symbols[this.mode][text].group;
      var loc = SourceLocation.range(nucleus);
      var s;

      if (ATOMS.hasOwnProperty(group)) {
        // $FlowFixMe
        var family = group;
        s = {
          type: "atom",
          mode: this.mode,
          family: family,
          loc: loc,
          text: text
        };
      } else {
        // $FlowFixMe
        s = {
          type: group,
          mode: this.mode,
          loc: loc,
          text: text
        };
      }

      symbol = s;
    } else if (text.charCodeAt(0) >= 0x80) {
      // no symbol for e.g. ^
      if (this.settings.strict) {
        if (!supportedCodepoint(text.charCodeAt(0))) {
          this.settings.reportNonstrict("unknownSymbol", "Unrecognized Unicode character \"" + text[0] + "\"" + (" (" + text.charCodeAt(0) + ")"), nucleus);
        } else if (this.mode === "math") {
          this.settings.reportNonstrict("unicodeTextInMathMode", "Unicode text character \"" + text[0] + "\" used in math mode", nucleus);
        }
      }

      symbol = {
        type: "textord",
        mode: this.mode,
        loc: SourceLocation.range(nucleus),
        text: text
      };
    } else {
      return null; // EOF, ^, _, {, }, etc.
    }

    this.consume(); // Transform combining characters into accents

    if (match) {
      for (var i = 0; i < match[0].length; i++) {
        var accent = match[0][i];

        if (!unicodeAccents[accent]) {
          throw new src_ParseError("Unknown accent ' " + accent + "'", nucleus);
        }

        var command = unicodeAccents[accent][this.mode];

        if (!command) {
          throw new src_ParseError("Accent " + accent + " unsupported in " + this.mode + " mode", nucleus);
        }

        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          isShifty: true,
          base: symbol
        };
      }
    }

    return symbol;
  };

  return Parser;
}();

Parser_Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
Parser_Parser.endOfGroup = {
  "[": "]",
  "{": "}",
  "\\begingroup": "\\endgroup"
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precendence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */

};
Parser_Parser.SUPSUB_GREEDINESS = 1;

// CONCATENATED MODULE: ./src/parseTree.js
/**
 * Provides a single function for parsing an expression using a Parser
 * TODO(emily): Remove this
 */



/**
 * Parses an expression using a Parser, then returns the parsed result.
 */
var parseTree_parseTree = function parseTree(toParse, settings) {
  if (!(typeof toParse === 'string' || toParse instanceof String)) {
    throw new TypeError('KaTeX can only parse string typed expression');
  }

  var parser = new Parser_Parser(toParse, settings); // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors

  delete parser.gullet.macros.current["\\df@tag"];
  var tree = parser.parse(); // If the input used \tag, it will set the \df@tag macro to the tag.
  // In this case, we separately parse the tag and wrap the tree.

  if (parser.gullet.macros.get("\\df@tag")) {
    if (!settings.displayMode) {
      throw new src_ParseError("\\tag works only in display equations");
    }

    parser.gullet.feed("\\df@tag");
    tree = [{
      type: "tag",
      mode: "text",
      body: tree,
      tag: parser.parse()
    }];
  }

  return tree;
};

/* harmony default export */ var src_parseTree = (parseTree_parseTree);
// CONCATENATED MODULE: ./katex.js
/* eslint no-console:0 */

/**
 * This is the main entry point for KaTeX. Here, we expose functions for
 * rendering expressions either to DOM nodes or to markup strings.
 *
 * We also expose the ParseError class to check if errors thrown from KaTeX are
 * errors in the expression, or errors in javascript handling.
 */










/**
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */
var katex_render = function render(expression, baseNode, options) {
  baseNode.textContent = "";
  var node = katex_renderToDomTree(expression, options).toNode();
  baseNode.appendChild(node);
}; // KaTeX's styles don't work properly in quirks mode. Print out an error, and
// disable rendering.


if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your " + "website has a suitable doctype.");

    katex_render = function render() {
      throw new src_ParseError("KaTeX doesn't work in quirks mode.");
    };
  }
}
/**
 * Parse and build an expression, and return the markup for that.
 */


var renderToString = function renderToString(expression, options) {
  var markup = katex_renderToDomTree(expression, options).toMarkup();
  return markup;
};
/**
 * Parse an expression and return the parse tree.
 */


var katex_generateParseTree = function generateParseTree(expression, options) {
  var settings = new src_Settings(options);
  return src_parseTree(expression, settings);
};
/**
 * If the given error is a KaTeX ParseError and options.throwOnError is false,
 * renders the invalid LaTeX as a span with hover title giving the KaTeX
 * error message.  Otherwise, simply throws the error.
 */


var katex_renderError = function renderError(error, expression, options) {
  if (options.throwOnError || !(error instanceof src_ParseError)) {
    throw error;
  }

  var node = buildCommon.makeSpan(["katex-error"], [new domTree_SymbolNode(expression)]);
  node.setAttribute("title", error.toString());
  node.setAttribute("style", "color:" + options.errorColor);
  return node;
};
/**
 * Generates and returns the katex build tree. This is used for advanced
 * use cases (like rendering to custom output).
 */


var katex_renderToDomTree = function renderToDomTree(expression, options) {
  var settings = new src_Settings(options);

  try {
    var tree = src_parseTree(expression, settings);
    return buildTree_buildTree(tree, expression, settings);
  } catch (error) {
    return katex_renderError(error, expression, settings);
  }
};
/**
 * Generates and returns the katex build tree, with just HTML (no MathML).
 * This is used for advanced use cases (like rendering to custom output).
 */


var katex_renderToHTMLTree = function renderToHTMLTree(expression, options) {
  var settings = new src_Settings(options);

  try {
    var tree = src_parseTree(expression, settings);
    return buildTree_buildHTMLTree(tree, expression, settings);
  } catch (error) {
    return katex_renderError(error, expression, settings);
  }
};

/* harmony default export */ var katex_0 = ({
  /**
   * Current KaTeX version
   */
  version: "0.10.2",

  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: katex_render,

  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: renderToString,

  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: src_ParseError,

  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: katex_generateParseTree,

  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: katex_renderToDomTree,

  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: katex_renderToHTMLTree,

  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: setFontMetrics,

  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,

  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro,

  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: {
    Span: domTree_Span,
    Anchor: domTree_Anchor,
    SymbolNode: domTree_SymbolNode,
    SvgNode: SvgNode,
    PathNode: domTree_PathNode,
    LineNode: LineNode
  }
});
// CONCATENATED MODULE: ./katex.webpack.js
/**
 * This is the webpack entry point for KaTeX. As ECMAScript, flow[1] and jest[2]
 * doesn't support CSS modules natively, a separate entry point is used and
 * it is not flowtyped.
 *
 * [1] https://gist.github.com/lambdahands/d19e0da96285b749f0ef
 * [2] https://facebook.github.io/jest/docs/en/webpack.html
 */


/* harmony default export */ var katex_webpack = __webpack_exports__["default"] = (katex_0);

/***/ })
/******/ ])["default"];
});
},{}],18:[function(require,module,exports){
/*global define:false */
/**
 * Copyright 2012-2017 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.6.5
 * @url craig.is/killing/mice
 */
(function(window, document, undefined) {

    // Check if mousetrap is used inside browser, if not, return
    if (!window) {
        return;
    }

    /**
     * mapping of special keycodes to their corresponding keys
     *
     * everything in this dictionary cannot use keypress events
     * so it has to be here to map to the correct keycodes for
     * keyup/keydown events
     *
     * @type {Object}
     */
    var _MAP = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        20: 'capslock',
        27: 'esc',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        45: 'ins',
        46: 'del',
        91: 'meta',
        93: 'meta',
        224: 'meta'
    };

    /**
     * mapping for special characters so they can support
     *
     * this dictionary is only used incase you want to bind a
     * keyup or keydown event to one of these keys
     *
     * @type {Object}
     */
    var _KEYCODE_MAP = {
        106: '*',
        107: '+',
        109: '-',
        110: '.',
        111 : '/',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: '\''
    };

    /**
     * this is a mapping of keys that require shift on a US keypad
     * back to the non shift equivelents
     *
     * this is so you can use keyup events with these keys
     *
     * note that this will only work reliably on US keyboards
     *
     * @type {Object}
     */
    var _SHIFT_MAP = {
        '~': '`',
        '!': '1',
        '@': '2',
        '#': '3',
        '$': '4',
        '%': '5',
        '^': '6',
        '&': '7',
        '*': '8',
        '(': '9',
        ')': '0',
        '_': '-',
        '+': '=',
        ':': ';',
        '\"': '\'',
        '<': ',',
        '>': '.',
        '?': '/',
        '|': '\\'
    };

    /**
     * this is a list of special strings you can use to map
     * to modifier keys when you specify your keyboard shortcuts
     *
     * @type {Object}
     */
    var _SPECIAL_ALIASES = {
        'option': 'alt',
        'command': 'meta',
        'return': 'enter',
        'escape': 'esc',
        'plus': '+',
        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
    };

    /**
     * variable to store the flipped version of _MAP from above
     * needed to check if we should use keypress or not when no action
     * is specified
     *
     * @type {Object|undefined}
     */
    var _REVERSE_MAP;

    /**
     * loop through the f keys, f1 to f19 and add them to the map
     * programatically
     */
    for (var i = 1; i < 20; ++i) {
        _MAP[111 + i] = 'f' + i;
    }

    /**
     * loop through to map numbers on the numeric keypad
     */
    for (i = 0; i <= 9; ++i) {

        // This needs to use a string cause otherwise since 0 is falsey
        // mousetrap will never fire for numpad 0 pressed as part of a keydown
        // event.
        //
        // @see https://github.com/ccampbell/mousetrap/pull/258
        _MAP[i + 96] = i.toString();
    }

    /**
     * cross browser add event method
     *
     * @param {Element|HTMLDocument} object
     * @param {string} type
     * @param {Function} callback
     * @returns void
     */
    function _addEvent(object, type, callback) {
        if (object.addEventListener) {
            object.addEventListener(type, callback, false);
            return;
        }

        object.attachEvent('on' + type, callback);
    }

    /**
     * takes the event and returns the key character
     *
     * @param {Event} e
     * @return {string}
     */
    function _characterFromEvent(e) {

        // for keypress events we should return the character as is
        if (e.type == 'keypress') {
            var character = String.fromCharCode(e.which);

            // if the shift key is not pressed then it is safe to assume
            // that we want the character to be lowercase.  this means if
            // you accidentally have caps lock on then your key bindings
            // will continue to work
            //
            // the only side effect that might not be desired is if you
            // bind something like 'A' cause you want to trigger an
            // event when capital A is pressed caps lock will no longer
            // trigger the event.  shift+a will though.
            if (!e.shiftKey) {
                character = character.toLowerCase();
            }

            return character;
        }

        // for non keypress events the special maps are needed
        if (_MAP[e.which]) {
            return _MAP[e.which];
        }

        if (_KEYCODE_MAP[e.which]) {
            return _KEYCODE_MAP[e.which];
        }

        // if it is not in the special map

        // with keydown and keyup events the character seems to always
        // come in as an uppercase character whether you are pressing shift
        // or not.  we should make sure it is always lowercase for comparisons
        return String.fromCharCode(e.which).toLowerCase();
    }

    /**
     * checks if two arrays are equal
     *
     * @param {Array} modifiers1
     * @param {Array} modifiers2
     * @returns {boolean}
     */
    function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
    }

    /**
     * takes a key event and figures out what the modifiers are
     *
     * @param {Event} e
     * @returns {Array}
     */
    function _eventModifiers(e) {
        var modifiers = [];

        if (e.shiftKey) {
            modifiers.push('shift');
        }

        if (e.altKey) {
            modifiers.push('alt');
        }

        if (e.ctrlKey) {
            modifiers.push('ctrl');
        }

        if (e.metaKey) {
            modifiers.push('meta');
        }

        return modifiers;
    }

    /**
     * prevents default for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _preventDefault(e) {
        if (e.preventDefault) {
            e.preventDefault();
            return;
        }

        e.returnValue = false;
    }

    /**
     * stops propogation for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _stopPropagation(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
            return;
        }

        e.cancelBubble = true;
    }

    /**
     * determines if the keycode specified is a modifier key or not
     *
     * @param {string} key
     * @returns {boolean}
     */
    function _isModifier(key) {
        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
    }

    /**
     * reverses the map lookup so that we can look for specific keys
     * to see what can and can't use keypress
     *
     * @return {Object}
     */
    function _getReverseMap() {
        if (!_REVERSE_MAP) {
            _REVERSE_MAP = {};
            for (var key in _MAP) {

                // pull out the numeric keypad from here cause keypress should
                // be able to detect the keys from the character
                if (key > 95 && key < 112) {
                    continue;
                }

                if (_MAP.hasOwnProperty(key)) {
                    _REVERSE_MAP[_MAP[key]] = key;
                }
            }
        }
        return _REVERSE_MAP;
    }

    /**
     * picks the best action based on the key combination
     *
     * @param {string} key - character for key
     * @param {Array} modifiers
     * @param {string=} action passed in
     */
    function _pickBestAction(key, modifiers, action) {

        // if no action was picked in we should try to pick the one
        // that we think would work best for this key
        if (!action) {
            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
        }

        // modifier keys don't work as expected with keypress,
        // switch to keydown
        if (action == 'keypress' && modifiers.length) {
            action = 'keydown';
        }

        return action;
    }

    /**
     * Converts from a string key combination to an array
     *
     * @param  {string} combination like "command+shift+l"
     * @return {Array}
     */
    function _keysFromString(combination) {
        if (combination === '+') {
            return ['+'];
        }

        combination = combination.replace(/\+{2}/g, '+plus');
        return combination.split('+');
    }

    /**
     * Gets info for a specific key combination
     *
     * @param  {string} combination key combination ("command+s" or "a" or "*")
     * @param  {string=} action
     * @returns {Object}
     */
    function _getKeyInfo(combination, action) {
        var keys;
        var key;
        var i;
        var modifiers = [];

        // take the keys from this pattern and figure out what the actual
        // pattern is all about
        keys = _keysFromString(combination);

        for (i = 0; i < keys.length; ++i) {
            key = keys[i];

            // normalize key names
            if (_SPECIAL_ALIASES[key]) {
                key = _SPECIAL_ALIASES[key];
            }

            // if this is not a keypress event then we should
            // be smart about using shift keys
            // this will only work for US keyboards however
            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
                key = _SHIFT_MAP[key];
                modifiers.push('shift');
            }

            // if this key is a modifier then add it to the list of modifiers
            if (_isModifier(key)) {
                modifiers.push(key);
            }
        }

        // depending on what the key combination is
        // we will try to pick the best event for it
        action = _pickBestAction(key, modifiers, action);

        return {
            key: key,
            modifiers: modifiers,
            action: action
        };
    }

    function _belongsTo(element, ancestor) {
        if (element === null || element === document) {
            return false;
        }

        if (element === ancestor) {
            return true;
        }

        return _belongsTo(element.parentNode, ancestor);
    }

    function Mousetrap(targetElement) {
        var self = this;

        targetElement = targetElement || document;

        if (!(self instanceof Mousetrap)) {
            return new Mousetrap(targetElement);
        }

        /**
         * element to attach key events to
         *
         * @type {Element}
         */
        self.target = targetElement;

        /**
         * a list of all the callbacks setup via Mousetrap.bind()
         *
         * @type {Object}
         */
        self._callbacks = {};

        /**
         * direct map of string combinations to callbacks used for trigger()
         *
         * @type {Object}
         */
        self._directMap = {};

        /**
         * keeps track of what level each sequence is at since multiple
         * sequences can start out with the same sequence
         *
         * @type {Object}
         */
        var _sequenceLevels = {};

        /**
         * variable to store the setTimeout call
         *
         * @type {null|number}
         */
        var _resetTimer;

        /**
         * temporary state where we will ignore the next keyup
         *
         * @type {boolean|string}
         */
        var _ignoreNextKeyup = false;

        /**
         * temporary state where we will ignore the next keypress
         *
         * @type {boolean}
         */
        var _ignoreNextKeypress = false;

        /**
         * are we currently inside of a sequence?
         * type of action ("keyup" or "keydown" or "keypress") or false
         *
         * @type {boolean|string}
         */
        var _nextExpectedAction = false;

        /**
         * resets all sequence counters except for the ones passed in
         *
         * @param {Object} doNotReset
         * @returns void
         */
        function _resetSequences(doNotReset) {
            doNotReset = doNotReset || {};

            var activeSequences = false,
                key;

            for (key in _sequenceLevels) {
                if (doNotReset[key]) {
                    activeSequences = true;
                    continue;
                }
                _sequenceLevels[key] = 0;
            }

            if (!activeSequences) {
                _nextExpectedAction = false;
            }
        }

        /**
         * finds all callbacks that match based on the keycode, modifiers,
         * and action
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event|Object} e
         * @param {string=} sequenceName - name of the sequence we are looking for
         * @param {string=} combination
         * @param {number=} level
         * @returns {Array}
         */
        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
            var i;
            var callback;
            var matches = [];
            var action = e.type;

            // if there are no events related to this keycode
            if (!self._callbacks[character]) {
                return [];
            }

            // if a modifier key is coming up on its own we should allow it
            if (action == 'keyup' && _isModifier(character)) {
                modifiers = [character];
            }

            // loop through all callbacks for the key that was pressed
            // and see if any of them match
            for (i = 0; i < self._callbacks[character].length; ++i) {
                callback = self._callbacks[character][i];

                // if a sequence name is not specified, but this is a sequence at
                // the wrong level then move onto the next match
                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
                    continue;
                }

                // if the action we are looking for doesn't match the action we got
                // then we should keep going
                if (action != callback.action) {
                    continue;
                }

                // if this is a keypress event and the meta key and control key
                // are not pressed that means that we need to only look at the
                // character, otherwise check the modifiers as well
                //
                // chrome will not fire a keypress if meta or control is down
                // safari will fire a keypress if meta or meta+shift is down
                // firefox will fire a keypress if meta or control is down
                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

                    // when you bind a combination or sequence a second time it
                    // should overwrite the first one.  if a sequenceName or
                    // combination is specified in this call it does just that
                    //
                    // @todo make deleting its own method?
                    var deleteCombo = !sequenceName && callback.combo == combination;
                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
                    if (deleteCombo || deleteSequence) {
                        self._callbacks[character].splice(i, 1);
                    }

                    matches.push(callback);
                }
            }

            return matches;
        }

        /**
         * actually calls the callback function
         *
         * if your callback function returns false this will use the jquery
         * convention - prevent default and stop propogation on the event
         *
         * @param {Function} callback
         * @param {Event} e
         * @returns void
         */
        function _fireCallback(callback, e, combo, sequence) {

            // if this event should not happen stop here
            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
                return;
            }

            if (callback(e, combo) === false) {
                _preventDefault(e);
                _stopPropagation(e);
            }
        }

        /**
         * handles a character key event
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event} e
         * @returns void
         */
        self._handleKey = function(character, modifiers, e) {
            var callbacks = _getMatches(character, modifiers, e);
            var i;
            var doNotReset = {};
            var maxLevel = 0;
            var processedSequenceCallback = false;

            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
            for (i = 0; i < callbacks.length; ++i) {
                if (callbacks[i].seq) {
                    maxLevel = Math.max(maxLevel, callbacks[i].level);
                }
            }

            // loop through matching callbacks for this key event
            for (i = 0; i < callbacks.length; ++i) {

                // fire for all sequence callbacks
                // this is because if for example you have multiple sequences
                // bound such as "g i" and "g t" they both need to fire the
                // callback for matching g cause otherwise you can only ever
                // match the first one
                if (callbacks[i].seq) {

                    // only fire callbacks for the maxLevel to prevent
                    // subsequences from also firing
                    //
                    // for example 'a option b' should not cause 'option b' to fire
                    // even though 'option b' is part of the other sequence
                    //
                    // any sequences that do not match here will be discarded
                    // below by the _resetSequences call
                    if (callbacks[i].level != maxLevel) {
                        continue;
                    }

                    processedSequenceCallback = true;

                    // keep a list of which sequences were matches for later
                    doNotReset[callbacks[i].seq] = 1;
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
                    continue;
                }

                // if there were no sequence matches but we are still here
                // that means this is a regular match so we should fire that
                if (!processedSequenceCallback) {
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
                }
            }

            // if the key you pressed matches the type of sequence without
            // being a modifier (ie "keyup" or "keypress") then we should
            // reset all sequences that were not matched by this event
            //
            // this is so, for example, if you have the sequence "h a t" and you
            // type "h e a r t" it does not match.  in this case the "e" will
            // cause the sequence to reset
            //
            // modifier keys are ignored because you can have a sequence
            // that contains modifiers such as "enter ctrl+space" and in most
            // cases the modifier key will be pressed before the next key
            //
            // also if you have a sequence such as "ctrl+b a" then pressing the
            // "b" key will trigger a "keypress" and a "keydown"
            //
            // the "keydown" is expected when there is a modifier, but the
            // "keypress" ends up matching the _nextExpectedAction since it occurs
            // after and that causes the sequence to reset
            //
            // we ignore keypresses in a sequence that directly follow a keydown
            // for the same character
            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
                _resetSequences(doNotReset);
            }

            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
        };

        /**
         * handles a keydown event
         *
         * @param {Event} e
         * @returns void
         */
        function _handleKeyEvent(e) {

            // normalize e.which for key events
            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
            if (typeof e.which !== 'number') {
                e.which = e.keyCode;
            }

            var character = _characterFromEvent(e);

            // no character found then stop
            if (!character) {
                return;
            }

            // need to use === for the character check because the character can be 0
            if (e.type == 'keyup' && _ignoreNextKeyup === character) {
                _ignoreNextKeyup = false;
                return;
            }

            self.handleKey(character, _eventModifiers(e), e);
        }

        /**
         * called to set a 1 second timeout on the specified sequence
         *
         * this is so after each key press in the sequence you have 1 second
         * to press the next key before you have to start over
         *
         * @returns void
         */
        function _resetSequenceTimer() {
            clearTimeout(_resetTimer);
            _resetTimer = setTimeout(_resetSequences, 1000);
        }

        /**
         * binds a key sequence to an event
         *
         * @param {string} combo - combo specified in bind call
         * @param {Array} keys
         * @param {Function} callback
         * @param {string=} action
         * @returns void
         */
        function _bindSequence(combo, keys, callback, action) {

            // start off by adding a sequence level record for this combination
            // and setting the level to 0
            _sequenceLevels[combo] = 0;

            /**
             * callback to increase the sequence level for this sequence and reset
             * all other sequences that were active
             *
             * @param {string} nextAction
             * @returns {Function}
             */
            function _increaseSequence(nextAction) {
                return function() {
                    _nextExpectedAction = nextAction;
                    ++_sequenceLevels[combo];
                    _resetSequenceTimer();
                };
            }

            /**
             * wraps the specified callback inside of another function in order
             * to reset all sequence counters as soon as this sequence is done
             *
             * @param {Event} e
             * @returns void
             */
            function _callbackAndReset(e) {
                _fireCallback(callback, e, combo);

                // we should ignore the next key up if the action is key down
                // or keypress.  this is so if you finish a sequence and
                // release the key the final key will not trigger a keyup
                if (action !== 'keyup') {
                    _ignoreNextKeyup = _characterFromEvent(e);
                }

                // weird race condition if a sequence ends with the key
                // another sequence begins with
                setTimeout(_resetSequences, 10);
            }

            // loop through keys one at a time and bind the appropriate callback
            // function.  for any key leading up to the final one it should
            // increase the sequence. after the final, it should reset all sequences
            //
            // if an action is specified in the original bind call then that will
            // be used throughout.  otherwise we will pass the action that the
            // next key in the sequence should match.  this allows a sequence
            // to mix and match keypress and keydown events depending on which
            // ones are better suited to the key provided
            for (var i = 0; i < keys.length; ++i) {
                var isFinal = i + 1 === keys.length;
                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
                _bindSingle(keys[i], wrappedCallback, action, combo, i);
            }
        }

        /**
         * binds a single keyboard combination
         *
         * @param {string} combination
         * @param {Function} callback
         * @param {string=} action
         * @param {string=} sequenceName - name of sequence if part of sequence
         * @param {number=} level - what part of the sequence the command is
         * @returns void
         */
        function _bindSingle(combination, callback, action, sequenceName, level) {

            // store a direct mapped reference for use with Mousetrap.trigger
            self._directMap[combination + ':' + action] = callback;

            // make sure multiple spaces in a row become a single space
            combination = combination.replace(/\s+/g, ' ');

            var sequence = combination.split(' ');
            var info;

            // if this pattern is a sequence of keys then run through this method
            // to reprocess each pattern one key at a time
            if (sequence.length > 1) {
                _bindSequence(combination, sequence, callback, action);
                return;
            }

            info = _getKeyInfo(combination, action);

            // make sure to initialize array if this is the first time
            // a callback is added for this key
            self._callbacks[info.key] = self._callbacks[info.key] || [];

            // remove an existing match if there is one
            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);

            // add this call back to the array
            // if it is a sequence put it at the beginning
            // if not put it at the end
            //
            // this is important because the way these are processed expects
            // the sequence ones to come first
            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
                callback: callback,
                modifiers: info.modifiers,
                action: info.action,
                seq: sequenceName,
                level: level,
                combo: combination
            });
        }

        /**
         * binds multiple combinations to the same callback
         *
         * @param {Array} combinations
         * @param {Function} callback
         * @param {string|undefined} action
         * @returns void
         */
        self._bindMultiple = function(combinations, callback, action) {
            for (var i = 0; i < combinations.length; ++i) {
                _bindSingle(combinations[i], callback, action);
            }
        };

        // start!
        _addEvent(targetElement, 'keypress', _handleKeyEvent);
        _addEvent(targetElement, 'keydown', _handleKeyEvent);
        _addEvent(targetElement, 'keyup', _handleKeyEvent);
    }

    /**
     * binds an event to mousetrap
     *
     * can be a single key, a combination of keys separated with +,
     * an array of keys, or a sequence of keys separated by spaces
     *
     * be sure to list the modifier keys first to make sure that the
     * correct key ends up getting bound (the last key in the pattern)
     *
     * @param {string|Array} keys
     * @param {Function} callback
     * @param {string=} action - 'keypress', 'keydown', or 'keyup'
     * @returns void
     */
    Mousetrap.prototype.bind = function(keys, callback, action) {
        var self = this;
        keys = keys instanceof Array ? keys : [keys];
        self._bindMultiple.call(self, keys, callback, action);
        return self;
    };

    /**
     * unbinds an event to mousetrap
     *
     * the unbinding sets the callback function of the specified key combo
     * to an empty function and deletes the corresponding key in the
     * _directMap dict.
     *
     * TODO: actually remove this from the _callbacks dictionary instead
     * of binding an empty function
     *
     * the keycombo+action has to be exactly the same as
     * it was defined in the bind method
     *
     * @param {string|Array} keys
     * @param {string} action
     * @returns void
     */
    Mousetrap.prototype.unbind = function(keys, action) {
        var self = this;
        return self.bind.call(self, keys, function() {}, action);
    };

    /**
     * triggers an event that has already been bound
     *
     * @param {string} keys
     * @param {string=} action
     * @returns void
     */
    Mousetrap.prototype.trigger = function(keys, action) {
        var self = this;
        if (self._directMap[keys + ':' + action]) {
            self._directMap[keys + ':' + action]({}, keys);
        }
        return self;
    };

    /**
     * resets the library back to its initial state.  this is useful
     * if you want to clear out the current keyboard shortcuts and bind
     * new ones - for example if you switch to another page
     *
     * @returns void
     */
    Mousetrap.prototype.reset = function() {
        var self = this;
        self._callbacks = {};
        self._directMap = {};
        return self;
    };

    /**
     * should we stop this event before firing off callbacks
     *
     * @param {Event} e
     * @param {Element} element
     * @return {boolean}
     */
    Mousetrap.prototype.stopCallback = function(e, element) {
        var self = this;

        // if the element has the class "mousetrap" then no need to stop
        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
            return false;
        }

        if (_belongsTo(element, self.target)) {
            return false;
        }

        // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,
        // not the initial event target in the shadow tree. Note that not all events cross the
        // shadow boundary.
        // For shadow trees with `mode: 'open'`, the initial event target is the first element in
        // the events composed path. For shadow trees with `mode: 'closed'`, the initial event
        // target cannot be obtained.
        if ('composedPath' in e && typeof e.composedPath === 'function') {
            // For open shadow trees, update `element` so that the following check works.
            var initialEventTarget = e.composedPath()[0];
            if (initialEventTarget !== e.target) {
                element = initialEventTarget;
            }
        }

        // stop for input, select, and textarea
        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
    };

    /**
     * exposes _handleKey publicly so it can be overwritten by extensions
     */
    Mousetrap.prototype.handleKey = function() {
        var self = this;
        return self._handleKey.apply(self, arguments);
    };

    /**
     * allow custom key mappings
     */
    Mousetrap.addKeycodes = function(object) {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                _MAP[key] = object[key];
            }
        }
        _REVERSE_MAP = null;
    };

    /**
     * Init the global mousetrap functions
     *
     * This method is needed to allow the global mousetrap functions to work
     * now that mousetrap is a constructor function.
     */
    Mousetrap.init = function() {
        var documentMousetrap = Mousetrap(document);
        for (var method in documentMousetrap) {
            if (method.charAt(0) !== '_') {
                Mousetrap[method] = (function(method) {
                    return function() {
                        return documentMousetrap[method].apply(documentMousetrap, arguments);
                    };
                } (method));
            }
        }
    };

    Mousetrap.init();

    // expose mousetrap to the global object
    window.Mousetrap = Mousetrap;

    // expose as a common js module
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = Mousetrap;
    }

    // expose mousetrap as an AMD module
    if (typeof define === 'function' && define.amd) {
        define(function() {
            return Mousetrap;
        });
    }
}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);

},{}],19:[function(require,module,exports){
"use strict";

function stdCatToString(x){
    if(x === undefined){
        return undefined;
    }
    if(x.getStringifyingMapKey !== undefined){
        return x.getStringifyingMapKey();
    } else {
        return x.toString();
    }
}

var StringifyingMap = (function () {
    function StringifyingMap(catToString) {
        if(catToString === undefined){
            catToString = stdCatToString
        }
        this.catToString = catToString;
        this.m = new Map();
        this.key_string_to_key_object = new Map();
    }
    StringifyingMap.prototype.set = function (k, v) {
        let key_string = this.catToString(k);
        if(key_string === undefined){
            throw new Error("Key encoding undefined.");
        }
        this.key_string_to_key_object.set(key_string, k);
        let s = this.m.set(key_string, v);
        return s;
    };
    StringifyingMap.prototype.get = function (k) {
        let key_string = this.catToString(k);
        if(key_string === undefined){
            return undefined;
        }
        return this.m.get(this.catToString(k));
    };
    StringifyingMap.prototype.delete = function (k) {
        this.key_string_to_key_object.delete(this.catToString(k));
        return this.m.delete(this.catToString(k));
    };
    StringifyingMap.prototype.has = function (k) {
        if(k === undefined){
            return false;
        }
        return this.m.has(this.catToString(k));
    };    

    StringifyingMap.prototype.getOrElse = function(key, value) {
      return this.has(key) ? this.get(key) : value;
    };
    
    StringifyingMap.prototype[Symbol.iterator] = function*(){
        for(let k of this.m){
            yield [this.key_string_to_key_object.get(k[0]),k[1]];
        }
    };

    StringifyingMap.prototype.keys = function(){
        return this.key_string_to_key_object.values();
    };

    StringifyingMap.prototype.toJSON = function(){
        return [...this];
    }
    
    Object.defineProperty(StringifyingMap.prototype, "size", {
        get: function () {
            return this.m.size;
        },
        enumerable: true,
        configurable: true
    });
    return StringifyingMap;
}());


module.exports = StringifyingMap;

},{}],20:[function(require,module,exports){
exports.INFINITY = 65535;
},{}],21:[function(require,module,exports){
"use strict"

let Display = require("./Display.js").Display;
let Tooltip = require("./Tooltip.js").Tooltip;
let Interface = require("./Interface.js");
let Mousetrap = require("mousetrap");

class BasicDisplay extends Display {
    constructor(container, sseq, kwargs) {
        super(container, sseq);
        document.body.style.overflow = "hidden";
        this.page_indicator_div = this.container.append("div")
            .attr("id", "page_indicator")
            .style("position", "absolute")
            .style("left", "20px")
            .style("top","10px")
            .style("font-family","Arial")
            .style("font-size","15px");

        this.tooltip = new Tooltip(this);
        this.on("mouseover", (node) => {
            this.tooltip.setHTML(this.getClassTooltipHTML(node, this.page));
            this.tooltip.show(node._canvas_x, node._canvas_y);
        });
        this.on("mouseout", () => this.tooltip.hide());

        Mousetrap.bind('left',  this.previousPage);
        Mousetrap.bind('right', this.nextPage);
        Mousetrap.bind('x',
            () => {
                if(this.mouseover_node){
                    console.log(this.mouseover_node.c);
                }
            }
        );

        this.on("page-change", r => this.page_indicator_div.html(this.getPageDescriptor(r)));

        // Trigger page-change to set initial page_indicator_div
        this.setPage();

        this.status_div = this.container.append("div")
            .attr("id", "status")
            .style("position", "absolute")
            .style("left", `20px`)
            .style("bottom",`20px`)
            .style("z-index", 1000);
    }

    setStatus(html){
        if(this.status_div_timer){
            clearTimeout(this.status_div_timer);
        }
        this.status_div.html(html);
    }

    delayedSetStatus(html, delay){
        this.status_div_timer = setTimeout(() => setStatus(html), delay);
    }

    /**
     * Gets the tooltip for the current class on the given page (currently ignores the page).
     * @param c
     * @param page
     * @returns {string}
     */
    getClassTooltip(c, page) {
        let tooltip = c.getNameCoord();
        let extra_info = BasicDisplay.toTooltipString(c.extra_info, page);

        if (extra_info)
            tooltip += extra_info;

        return tooltip;
    }

    getClassTooltipHTML(c, page) {
        return Interface.renderLatex(this.getClassTooltip(c,page));
    }    

    static toTooltipString(obj, page) {
        if (!obj) {
            return false;
        }

        if(obj.constructor === String){
            return obj;
        }

        if(obj.constructor === Array) {
            return obj.map((x) => Tooltip.toTooltipString(x, page)).filter((x) => x).join("\n");
        }

        if(obj.constructor === Map){
            let lastkey;
            for (let k of obj.keys()) {
                if (k > page) {
                    break;
                }
                lastkey = k;
            }
            return BasicDisplay.toTooltipString(obj.get(lastkey));
        }

        return false;
    }
}

exports.BasicDisplay = BasicDisplay;

},{"./Display.js":22,"./Interface.js":24,"./Tooltip.js":28,"mousetrap":18}],22:[function(require,module,exports){
"use strict";

let EventEmitter = require("events");
let d3 = Object.assign({}, 
    require("d3-selection"), 
    require("d3-zoom"), 
    require("d3-scale"), 
    require("d3-timer")
);

let INFINITY = require("../infinity.js").INFINITY

const gridGo = "go";
const gridChess = "chess";

class Display extends EventEmitter {
    // container is either an id (e.g. "#main") or a DOM object
    constructor(container, sseq) {
        super();

        this.leftMargin = 40;
        this.rightMargin = 5;
        this.topMargin = 45;
        this.bottomMargin = 50;
        this.domainOffset = 1 / 2;

        this.gridStyle = gridGo;
        this.gridColor = "#c6c6c6";
        this.background_color = "#FFFFFF";
        this.gridStrokeWidth = 0.3;
        this.TICK_STEP_LOG_BASE = 1.1; // Used for deciding when to change tick step.

        this.hiddenStructlines = new Set();
        this.updateQueue = 0;

        this.container = d3.select(container);
        this.container_DOM = this.container.node();

        this.container.selectAll().remove();

        this.xScaleInit = d3.scaleLinear();
        this.yScaleInit = d3.scaleLinear();

        this.canvas = document.createElement("canvas");
        this.canvas.style.padding = "0px";
        this.canvas.style.position = "absolute";
        this.canvas.style.top = "0";
        this.canvas.style.left = "0";

        this.container_DOM.appendChild(this.canvas);

        this.context = this.canvas.getContext("2d");

        this.updateBatch = this.updateBatch.bind(this);
        this.nextPage = this.nextPage.bind(this);
        this.previousPage = this.previousPage.bind(this);
        this._onMousemove = this._onMousemove.bind(this);
        this._onClick = this._onClick.bind(this);

        this.zoom = d3.zoom().scaleExtent([0, 4]);
        this.zoom.on("zoom", this.updateBatch);
        this.zoomD3Element = d3.select(this.canvas);
        this.zoomD3Element.call(this.zoom).on("dblclick.zoom", null);

        this.canvas.addEventListener("mousemove", this._onMousemove);
        this.canvas.addEventListener("click", this._onClick);

        // TODO: improve window resize handling. Currently the way that the domain changes is suboptimal.
        // I think the best would be to maintain the x and y range by scaling.
        window.addEventListener("resize",  () => this.resize());

        if(sseq) {
            this.setSseq(sseq);
        }
    }

    setBackgroundColor(color) {
        this.background_color = color;
        this.container_DOM.style["background"] = color;
        this.update();
    }

    /**
     *
     * @param width Optional width. Default to 97% of width of bounding element.
     * @param height Optional height. Default to 97% of height of bounding element.
     */
    resize(width, height){
        if(!this.sseq) {
            return;
        }

        let oldxmin = this.xminFloat;
        let oldymin = this.yminFloat;
        // This fixes the scale, but leaves a
        this._initializeCanvas(width, height);
        this._updateScale();
        let dx = this.xminFloat - oldxmin;
        let dy = this.yminFloat - oldymin;
        this.zoom.on("zoom", null);
        this.zoom.translateBy(this.zoomD3Element, this.dxScale(dx), this.dyScale(dy));
        this.zoom.on("zoom", this.updateBatch);
        this.updateBatch();
    }

    /**
     * Initialization method called in constructor.
     * @private
     */
    _initializeCanvas(width, height){
        const boundingRectangle = this.container_DOM.getBoundingClientRect();
        const canvasWidth = width || 0.99*boundingRectangle.width;
        const canvasHeight = height || 0.97*boundingRectangle.height;

        this.canvasWidth = canvasWidth;
        this.canvasHeight = canvasHeight;

        this.canvas.width = canvasWidth;
        this.canvas.height = canvasHeight;

        this.clipWidth = this.canvasWidth - this.rightMargin;
        this.clipHeight = this.canvasHeight - this.bottomMargin;

        this.plotWidth = this.canvasWidth - this.leftMargin - this.rightMargin;
        this.plotHeight = this.canvasHeight - this.bottomMargin - this.topMargin;

        this.xScaleInit = this.xScaleInit.range([this.leftMargin, this.clipWidth]);
        this.yScaleInit = this.yScaleInit.range([this.clipHeight, this.topMargin]);
    }


    /**
     * Set the spectral sequence to display.
     * @param ss
     */
    setSseq(sseq){
        if(this.sseq) {
            this.sseq.removeListener("update", this.updateBatch);
        }
        this.sseq = sseq;
        // The sseq object contains the list of valid pages. Always includes at least 0 and infinity.
        if(this.sseq.initial_page_idx){
            this.page_idx = this.sseq.initial_page_idx;
        } else {
            this.page_idx = this.sseq.min_page_idx;
        }
        if(this.page_idx >= this.sseq.page_list.length){
            console.log(`Warning: min_page_idx ${this.sseq.min_page_idx} greater than page list length ${this.sseq.page_list.length}. Using 0 for min_page_idx instead.`);
            this.page_idx = 0;
            this.min_page_idx = 0;
        }
        this.setPage();

        this._initializeScale();
        this._initializeCanvas();

        if(sseq.gridStyle){
            this.gridStyle = sseq.gridStyle;
        }

        this.sseq.on('update',this.updateBatch);
        this.update();
    }

    _initializeScale(){
        this.xScaleInit.domain([this.sseq.initial_x_range[0] - this.domainOffset, this.sseq.initial_x_range[1] + this.domainOffset]);
        this.yScaleInit.domain([this.sseq.initial_y_range[0] - this.domainOffset, this.sseq.initial_y_range[1] + this.domainOffset]);
    }

    nextPage(){
        if (this.page_idx < this.sseq.page_list.length - 1) {
            this.setPage(this.page_idx + 1);
            this.update();
        }
    }

    previousPage(){
        if (this.page_idx > this.sseq.min_page_idx) {
            this.setPage(this.page_idx - 1);
            this.update();
        }
    }

    /**
     * Update this.page and this.pageRange to reflect the value of page_idx.
     * Eventually I should make a display that indicates the current page again, then this can also say what that is.
     */
    setPage(idx){
        if (!this.sseq) return;

        if(idx !== undefined){
            this.page_idx = idx;
        }
        this.pageRange = this.sseq.page_list[this.page_idx];

        if(Array.isArray(this.pageRange)){
            this.page = this.pageRange[0];
        } else {
            this.page = this.pageRange;
        }
        this.emit("page-change", this.pageRange, this.page_idx);
    }

    /**
     * The main updateAll routine.
     */
    updateBatch(){
        this.update(true);
    }

    update(batch = false) {
        if (!this.sseq) return;

        this.updateQueue ++;

        let drawFunc = () => {
            this.updateQueue --;
            if (this.updateQueue != 0) return;

            this._drawSseq(this.context);
            if (d3.event) {
                // d3 zoom doesn't allow the events it handles to bubble, so we
                // fails to track pointer position.
                this._onMousemove(d3.event);
            } else {
                this._onMousemove();
            }
        };
        if(batch){
            requestAnimationFrame(drawFunc);
        } else {
            drawFunc();
        }
    }

    clipContext(ctx) {
        ctx.beginPath();
        let y_clip_offset = this.y_clip_offset || 0;
        console.log("y_clip_offset:", y_clip_offset);
        ctx.globalAlpha = 0; // C2S does not correctly clip unless the clip is stroked.
        ctx.rect(this.leftMargin, this.topMargin + y_clip_offset, this.plotWidth, this.plotHeight - y_clip_offset);
        ctx.stroke();
        ctx.clip();
        ctx.globalAlpha = 1;
    }

    _drawSseq(ctx = this.context) {
        if (!this.sseq) return;

        this._updateScale();
        this._updateGridAndTickStep();

        ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

        this._drawTicks(ctx);
        this._drawAxes(ctx);

        ctx.save();

        this.clipContext(ctx);

        let [nodes, edges] = this.sseq.getElementsToDraw(
            this.pageRange, 
            this.xmin - 1, this.xmax + 1, this.ymin - 1, this.ymax + 1
        );

        this._drawGrid(ctx);
        this.emit("draw_background");
        this._updateNodes(nodes);
        this._drawEdges(ctx, edges);
        this._drawNodes(ctx);

        if (this.sseq.edgeLayerSVG)
            this.drawSVG(ctx, this.sseq.edgeLayerSVG);

        if(this.svg) {
            if(this.svg_unclipped){
                ctx.restore();
                ctx.save();
            }
            let x_scale = this.svg_x_scale || this.svg_scale || 1;
            let y_scale = this.svg_y_scale || this.svg_scale || 1;
            let x_offset = this.svg_x_offset || 0;
            let y_offset = this.svg_y_offset || 0;
            let default_width = 
                this.canvasWidth / (this.xmaxFloat - this.xminFloat) * (this.sseq.x_range[1] - this.sseq.x_range[0] + 1);
            let default_height = 
                this.canvasHeight / (this.ymaxFloat - this.yminFloat) * (this.sseq.y_range[1] - this.sseq.y_range[0] + 1);
            let width = default_width * x_scale;
            let height = default_height * y_scale;
            // console.log("width:",width, "height:",  height)
            this.context.drawImage(this.svg,
                this.xScale(this.sseq.x_range[0] + x_offset), //- display.xMinOffset,
                this.yScale(this.sseq.y_range[1] + 1 + y_offset) ,
                width, height
            );
        }
        ctx.restore();


        this.emit("draw");
    }

    /**
     * @private
     */
    _updateScale(){
        let zoomD3Element = this.zoomD3Element;
        let transform = d3.zoomTransform(zoomD3Element.node());
        let scale = transform.k;
        let xScale = transform.rescaleX(this.xScaleInit);
        let yScale = transform.rescaleY(this.yScaleInit);

        // We have to call zoom.translateBy when the user hits the boundary of the pan region
        // to adjust the zoom transform. However, this causes the zoom handler (this function) to be called a second time,
        // which is less intuitive program flow than just continuing on in the current function.
        // In order to prevent this, temporarily unset the zoom handler.
        // TODO: See if we can make the behaviour here less jank.
        this.zoom.on("zoom", null);

        let xScaleMaxed = false, yScaleMaxed = false;
        // Prevent user from panning off the side.
        if (this.sseq.x_range) {
            if (xScale(this.sseq.x_range[1] - this.sseq.x_range[0] + 2 * this.domainOffset) - xScale(0) < this.plotWidth) {
                // We simply record the scale was maxed and handle this later
                // by modifying xScale directly.
                xScaleMaxed = true;
            } else if (xScale(this.sseq.x_range[0] - this.domainOffset) > this.leftMargin) {
                this.zoom.translateBy(zoomD3Element, (this.leftMargin - xScale(this.sseq.x_range[0] - this.domainOffset)) / scale, 0);
            } else if (xScale(this.sseq.x_range[1] + this.domainOffset) < this.clipWidth) {
                this.zoom.translateBy(zoomD3Element, (this.clipWidth - xScale(this.sseq.x_range[1] + this.domainOffset)) / scale, 0);
            }
        }

        if (this.sseq.y_range) {
            if (yScale(0) -yScale(this.sseq.y_range[1] - this.sseq.y_range[0] + 2 * this.domainOffset) < this.plotHeight) {
                yScaleMaxed = true;
            } else if (yScale(this.sseq.y_range[0] - this.domainOffset) < this.clipHeight) {
                this.zoom.translateBy(zoomD3Element, 0, (this.clipHeight - yScale(this.sseq.y_range[0] - this.domainOffset)) / scale);
            } else if (yScale(this.sseq.y_range[1] + this.domainOffset) > this.topMargin) {
                this.zoom.translateBy(zoomD3Element, 0, this.topMargin - yScale(this.sseq.y_range[1] + this.domainOffset) / scale);
            }
        }

        // If both scales are maxed, and the user attempts to zoom out further,
        // d3 registers a zoom, but nothing in the interface changes since we
        // manually override xScale and yScale instead of doing something at
        // the level of the transform (see below). We do *not* want to keep
        // zooming out, or else when the user wants to zoom back in, they will
        // have to zoom in for a while before the interface actually zooms in.
        // Thus, We restore the previous zoom state.
        if (xScaleMaxed && yScaleMaxed) {
            if (this.oldScalesMaxed && scale < this.scale) {
                this.zoom.transform(zoomD3Element, this.transform);
                this.zoom.on("zoom", this.updateBatch);
                return;
            } else {
                this.oldScalesMaxed = true;
            }
        } else {
            this.oldScalesMaxed = false;
        }

        // Get new transform and scale objects after possible translation above
        this.transform = d3.zoomTransform(zoomD3Element.node());
        this.scale = this.transform.k;
        this.xScale = this.transform.rescaleX(this.xScaleInit);
        this.yScale = this.transform.rescaleY(this.yScaleInit);

        // If x or y scale is maxed, we directly override xScale/yScale instead
        // of messing with zoom, since we want to continue allow zooming in the
        // other direction
        if (xScaleMaxed) {
            this.xScale.domain([
                this.sseq.x_range[0] - this.domainOffset,
                this.sseq.x_range[1] + this.domainOffset
            ]);
        }
        if (yScaleMaxed) {
            this.yScale.domain([
                this.sseq.y_range[0] - this.domainOffset,
                this.sseq.y_range[1] + this.domainOffset
            ]);
        }

        this.xminFloat = this.xScale.invert(this.leftMargin);
        this.xmaxFloat = this.xScale.invert(this.clipWidth);
        this.yminFloat = this.yScale.invert(this.clipHeight);
        this.ymaxFloat = this.yScale.invert(this.topMargin);
        this.xmin = Math.ceil(this.xminFloat);
        this.xmax = Math.floor(this.xmaxFloat);
        this.ymin = Math.ceil(this.yminFloat);
        this.ymax = Math.floor(this.ymaxFloat);

        this.zoom.on("zoom", this.updateBatch);
    }

    dxScale(x){
        return this.xScale(x) - this.xScale(0);
    }

    dyScale(x){
        return this.yScale(x) - this.yScale(0);
    }

    _updateGridAndTickStep(){
        // TODO: This 70 is a magic number. Maybe I should give it a name?
        this.xTicks = this.xScale.ticks(this.canvasWidth / 70);
        this.yTicks = this.yScale.ticks(this.canvasHeight / 70);

        this.xTickStep = Math.ceil(this.xTicks[1] - this.xTicks[0]);
        this.yTickStep = Math.ceil(this.yTicks[1] - this.yTicks[0]);
        this.xTicks[0] -= this.xTickStep;
        this.yTicks[0] -= this.yTickStep;
        this.xTicks.push(this.xTicks[this.xTicks.length - 1] + this.xTickStep);
        this.yTicks.push(this.yTicks[this.yTicks.length - 1] + this.yTickStep);

        if(this.manualxGridStep){
            this.xGridStep = this.manualxGridStep;
        } else {
            this.xGridStep = (Math.floor(this.xTickStep / 5) === 0) ? 1 : Math.floor(this.xTickStep / 5);
        }
        if(this.manualyGridStep){
            this.yGridStep = this.manualxGridStep;
        } else {
            this.yGridStep = (Math.floor(this.yTickStep / 5) === 0) ? 1 : Math.floor(this.yTickStep / 5);
        }
        // TODO: This is an ad-hoc modification requested by Danny to ensure that the grid boxes are square.
        // Probably it's a useful thing to be able to have square grid boxes, how do we want to deal with this?
        if(this.sseq.squareAspectRatio){
            this.xGridStep = 1;
            this.yGridStep = this.xGridStep;
        }
    }

    _drawTicks(context) {
        context.save();

        context.textBaseline = "middle";
        context.font = "15px Arial";
        context.textAlign = "center";
        for (let i = Math.floor(this.xTicks[0]); i <= this.xTicks[this.xTicks.length - 1]; i += this.xTickStep) {
            context.fillText(i, this.xScale(i), this.clipHeight + 20);
        }

        context.textAlign = "right";
        for (let i = Math.floor(this.yTicks[0]); i <= this.yTicks[this.yTicks.length - 1]; i += this.yTickStep) {
            context.fillText(i, this.leftMargin - 10, this.yScale(i));
        }
        context.restore();
    }

    _drawGrid(context){
        context.save();

        context.strokeStyle = this.gridColor;
        context.lineWidth = this.gridStrokeWidth;

        switch(this.gridStyle){
            case gridGo:
                this._drawGoGrid(context);
                break;
            case gridChess:
                this._drawChessGrid(context);
                break;
            default:
                // TODO: an error here?
                break;
        }

        context.restore();
    }

    _drawGoGrid(context) {
        this._drawGridWithOffset(context, 0, 0);
    }

    _drawChessGrid(context) {
        this._drawGridWithOffset(context, 0.5, 0.5);
    }

    _drawGridWithOffset(context, xoffset, yoffset){
        context.beginPath();
        for (let col = Math.floor(this.xmin / this.xGridStep) * this.xGridStep - xoffset; col <= this.xmax; col += this.xGridStep) {
            context.moveTo(this.xScale(col), 0);
            context.lineTo(this.xScale(col), this.clipHeight);
        }
        context.stroke();

        context.beginPath();
        for (let row = Math.floor(this.ymin / this.yGridStep) * this.yGridStep - yoffset; row <= this.ymax; row += this.yGridStep) {
            context.moveTo(this.leftMargin, this.yScale(row));
            context.lineTo(this.canvasWidth - this.rightMargin, this.yScale(row));
        }
        context.stroke();
    }

    _drawAxes(context){
        context.save();

        // This makes the white square in the bottom left and top right corners which prevents axes labels from appearing to the left
        // or below the axes intercept.
        context.fillStyle = this.background_color;
        context.rect(0, this.clipHeight, this.leftMargin, this.bottomMargin);
        context.rect(0, 0, this.leftMargin, this.topMargin);
        context.fill();
        context.fillStyle = "#000";

        // Draw the axes.
        context.beginPath();
        context.moveTo(this.leftMargin, this.topMargin);
        context.lineTo(this.leftMargin, this.clipHeight);
        context.lineTo(this.canvasWidth - this.rightMargin, this.clipHeight);
        context.stroke();

        context.restore();
    }

    _updateNodes(classes){
        let size = Math.max(Math.min(this.dxScale(1), -this.dyScale(1), this.sseq.max_class_size), this.sseq.min_class_size) * this.sseq.class_scale;
        this.classes_to_draw = classes;
        for(let c of classes) {
            c.setPosition( 
                this.xScale(c.x) + c.getXOffset(), 
                this.yScale(c.y) + c.getYOffset(), 
                size
            );
        }
    }

    _drawNodes(context) {
        for (let c of this.classes_to_draw) {
            c.draw(context);
        }
    }

    _drawEdges(context, edges){        
        for (let e of edges) {
            if(!e) {
                throw ValueError("Undefined edge.");
            }
            if(e.invalid || !e.visible){
                continue;
            }
            if (e.type === "Structline" && this.hiddenStructlines.has(e.mult)) {
                continue;
            }

            let source_node = e._source;
            let target_node = e._target;
            if(!source_node || ! target_node){
                throw ValueError(`Edge ${e} has undefined source or target node`);
            }

            e._sourceOffset = e.sourceOffset || {x: 0, y: 0};
            e._targetOffset = e.targetOffset || {x: 0, y: 0};

            context.save();
            context.strokeStyle = e.color;
            if(e.lineWidth){
                context.lineWidth = e.lineWidth;
            }
            if(e.opacity){
                context.globalAlpha = e.opacity;
            }
            if(e.dash){
                context.setLineDash(e.dash);
            }

            let sourceX = source_node._canvas_x + e._sourceOffset.x;
            let sourceY = source_node._canvas_y + e._sourceOffset.y;
            let targetX = target_node._canvas_x + e._targetOffset.x;
            let targetY = target_node._canvas_y + e._targetOffset.y;

            context.beginPath();
            if(e.bend ){//&& e.bend !== 0
                let distance = Math.sqrt((targetX - sourceX)*(targetX - sourceX) + (targetY - sourceY)*(targetY - sourceY));
                let looseness = 0.4;
                if(e.looseness){
                    looseness = e.looseness;
                }
                let angle = Math.atan((targetY - sourceY)/(targetX - sourceX));
                let bendAngle = - e.bend * Math.PI/180;
                let control1X = sourceX + Math.cos(angle + bendAngle) * looseness * distance;
                let control1Y = sourceY + Math.sin(angle + bendAngle) * looseness * distance;
                let control2X = targetX - Math.cos(angle - bendAngle) * looseness * distance;
                let control2Y = targetY - Math.sin(angle - bendAngle) * looseness * distance;
                context.moveTo(sourceX, sourceY);
                context.bezierCurveTo(control1X, control1Y, control2X, control2Y, targetX, targetY);
            } else {
                context.moveTo(sourceX, sourceY);
                context.lineTo(targetX, targetY);
            }
            context.stroke();
            context.restore();
        }
    }

    _onClick(e) {
        let x = this.xScale.invert(e.layerX);
        let y = this.yScale.invert(e.layerY);
        this.emit("click", this.mouseover_node, x, y, e);
    }

    _onMousemove(e) {
        // If not yet set up 
        if (!this.classes_to_draw) return;

        let redraw = false;

        // We cannot query for mouse position. We must remember it from
        // previous events. If update() is called, we call _onMousemove without
        // an event.
        let rect = this.canvas.getBoundingClientRect();
        if (e) {
            this.x = e.clientX - rect.x;
            this.y = e.clientY - rect.y;
        }

        if (this.mouseover_node) {
            if (this.classes_to_draw.includes(this.mouseover_class) && this.context.isPointInPath(this.mouseover_class._path, this.x, this.y)) {
                return;
            } else {
                this.mouseover_node.highlight = false;
                this.mouseover_node = null;
                this.mouseover_class = null;
                redraw = true;
                this.emit("mouseout");
            }
        }
        let node = this.classes_to_draw.find(n => this.context.isPointInPath(n._path, this.x, this.y));
        if (node) {
            redraw = true;
            node.highlight = true;
            this.mouseover_node = node;
            this.mouseover_class = node.c;
            this.emit("mouseover", node);
        }

        if (redraw) this._drawSseq(this.context);
    }

    /**
     * Draw an svg onto the canvas.
     * @param context html5 canvas context
     * @param xml An svg string
     */
    drawSVG(context, xml){
        // make it base64
        let svg64 = btoa(xml);
        let b64Start = 'data:image/svg+xml;base64,';

        // prepend a "header"
        let image64 = b64Start + svg64;

        // set it as the source of the img element
        let img = new Image();
        img.src = image64;

        context.drawImage(img,
            this.xScale(this.sseq.x_range[0]),// - this.xMinOffset,
            this.yScale(this.sseq.y_range[1] + 1),
            this.canvasWidth  / (this.xmaxFloat - this.xminFloat) * (this.sseq.x_range[1] - this.sseq.x_range[0] + 1),
            this.canvasHeight / (this.ymaxFloat - this.yminFloat) * (this.sseq.y_range[1] - this.sseq.y_range[0] + 1)
        );
    }

    toSVG(){
        let ctx = new C2S(this.canvasWidth, this.canvasHeight);
        this._drawSseq(ctx);

        return ctx.getSerializedSvg(true);
    }

    downloadSVG(filename) {
        if(filename === undefined){
            filename = `${this.sseq.name}_x-${this.xmin}-${this.xmax}_y-${this.ymin}-${this.ymax}.svg`
        }
        IO.download(filename, this.toSVG(), "image/svg+xml")
    }

    /**
     * Move the canvas to contain (x,y)
     * TODO: control speed, control acceptable range of target positions, maybe zoom out if display is super zoomed in?
     * @param x
     * @param y
     */
    seek(x, y){
        return new Promise((resolve) => {
            let dx = 0;
            let dy = 0;
            if (x > this.xmaxFloat - 1) {
                dx = this.xmaxFloat - 1 - x;
            } else if (x < this.xminFloat + 1) {
                dx = this.xminFloat + 1 - x;
            }
            if (y > this.ymaxFloat - 1) {
                dy = this.ymaxFloat - 1 - y;
            } else if (y < this.xminFloat + 1) {
                dy = this.yminFloat + 1 - y;
            }
            if (dx === 0 && dy === 0) {
                return;
            }

            let dxActual = this.dxScale(dx);
            let dyActual = this.dyScale(dy);
            let dist = Math.sqrt(dxActual * dxActual + dyActual * dyActual);
            // steps controls the speed -- doubling steps halves the speed.
            // Of course we could maybe set up some fancy algorithm that zooms and pans.
            let steps = Math.ceil(dist / 10);
            let xstep = dxActual / steps;
            let ystep = dyActual / steps;

            let i = 0;
            let t = d3.interval(() => {
                i++;
                this.translateBy(xstep, ystep);
                if (i >= steps) {
                    t.stop();
                    resolve();
                }
            }, 5);
        });
    }

    translateBy(xstep, ystep){
        this.zoom.on("zoom", null);
        this.zoom.translateBy(this.zoomD3Element, xstep / this.scale, ystep / this.scale );
        this.update();
        this.zoom.on("zoom", this.updateBatch);
    }

    getPageDescriptor(pageRange) {
        if (!this.sseq) return;

        let basePage = 2;
        if(this.sseq.page_list.includes(1)){
            basePage = 1;
        }
        if (pageRange[0] === INFINITY) {
            return "Page ";
        }
        if (pageRange === 0) {
            return `Page ${basePage} with all differentials`;
        }
        if (pageRange === 1 && basePage === 2) {
            return `Page ${basePage} with no differentials`;
        }
        if (pageRange.length) {
            if(pageRange[1] === INFINITY){
                return `Page ${pageRange[0]} with all differentials`;
            }
            if(pageRange[1] === -1){
                return `Page ${pageRange[0]} with no differentials`;
            }

            if(pageRange[0] === pageRange[1]){
                return `Page ${pageRange[0]}`;
            }

            return `Pages ${pageRange[0]}  ${pageRange[1]}`.replace(INFINITY, "");
        }
        return `Page ${pageRange}`;
    }

    // TODO: Fix the selection
    //    /**
    //     * This is a click event handler to update the selected cell when the user clicks.
    //     * @param event A click event.
    //     */
    //    updateSelection(event){
    //        event.mouseover_class = this.mouseover_class;
    //        this.selectedX = Math.floor(display.xScale.invert(event.layerX) + 0.5);
    //        this.selectedY = Math.floor(display.yScale.invert(event.layerY) + 0.5);
    //        this.update();
    //    }
    //
    //    /**
    //     * Enable selection. This changes the grid style to a chess grid and attaches event handlers for clicking
    //     * @param arrowNavigate
    //     */
    //    enableSelection(arrowNavigate){
    //        this.gridStyle = gridChess;
    //        this.addEventHandler("onclick",this.updateSelection.bind(this));
    //        if(arrowNavigate){
    //            this.addEventHandler('left',  () => {
    //                if(this.selectedX !== undefined){
    //                    this.selectedX --;
    //                    this.update();
    //                }
    //            });
    //            this.addEventHandler('right', () => {
    //                if(this.selectedX !== undefined){
    //                    this.selectedX ++;
    //                    this.update();
    //                }
    //            });
    //            this.addEventHandler('down',  () => {
    //                if(this.selectedY !== undefined){
    //                    this.selectedY --;
    //                    this.update();
    //                }
    //            });
    //            this.addEventHandler('up', () => {
    //                if(this.selectedY !== undefined){
    //                    this.selectedY ++;
    //                    this.update();
    //                }
    //            });
    //        }
    //        this.update();
    //    }
    //
    //    disableSelection(){
    //        this.selectedX = undefined;
    //        this.gridStyle = gridGo;
    //        Mousetrap.bind('left',  this.previousPage);
    //        Mousetrap.bind('right', this.nextPage);
    //        this.eventHandlerLayer["onclick"] = (event) => {};
    //        this.update();
    //    }
    //
    //    _drawSelection(context){
    //        let x = this.selectedX;
    //        let y = this.selectedY;
    //        if(x !== undefined && y !== undefined){
    //            context.fillStyle = this.gridColor;
    //            context.rect(
    //                display.xScale(x - 0.5),
    //                display.yScale(y - 0.5),
    //                display.dxScale(1),
    //                display.dyScale(1)
    //            );
    //            context.fill();
    //        }
    //    }

}

exports.Display = Display;

},{"../infinity.js":20,"d3-scale":9,"d3-selection":10,"d3-timer":13,"d3-zoom":15,"events":16}],23:[function(require,module,exports){
"use strict"

let SidebarDisplay = require("./SidebarDisplay.js").SidebarDisplay;
let Panel = require("./Panel.js");
let Tooltip = require("./Tooltip.js").Tooltip;
let Interface = require("./Interface.js");
let Mousetrap = require("mousetrap");

const STATE_ADD_DIFFERENTIAL = 1;
const STATE_RM_DIFFERENTIAL = 2;
const STATE_ADD_STRUCTLINE = 3;
const STATE_RM_STRUCTLINE = 4;
const STATE_RM_EDGE = 5;
const STATE_ADD_CLASS = 6;

class EditorDisplay extends SidebarDisplay {
    constructor(container, sseq) {
        super(container);

        this.differentialColors = {};

        // Footer
        this.sidebar.footer.newGroup();
        this.sidebar.footer.addButtonRow([
            ["Undo", () => this.sseq.undo.undo()],
            ["Redo", () => this.sseq.undo.redo()]
        ]);

        this.sidebar.footer.addButton("Download SVG", () => this.downloadSVG("sseq.svg"));
        this.sidebar.footer.addButton("Save", () => this.sseq.download("sseq.json"));

        // General Panel
        this.generalPanel = new Panel.Panel(this.sidebar.main_div, this);
        this.generalPanel.newGroup();
        this.pageLabel = document.createElement("span");
        this.on("page-change", (r) => {
            this.pageLabel.innerHTML = this.getPageDescriptor(r);
            this._unselect();
        });
        this.generalPanel.addObject(this.pageLabel);

        this.generalPanel.newGroup();
        this.generalPanel.addButton("Add class", () => this.state = STATE_ADD_CLASS, { shortcuts: ["n"] });

        this.generalPanel.newGroup();
        this.generalPanel.addLinkedInput("Min X", "sseq.minX", "number");
        this.generalPanel.addLinkedInput("Max X", "sseq.maxX", "number");
        this.generalPanel.addLinkedInput("Min Y", "sseq.minY", "number");
        this.generalPanel.addLinkedInput("Max Y", "sseq.maxY", "number");
        this.sidebar.addPanel(this.generalPanel);

        // Class panel
        this.classPanel = new Panel.TabbedPanel(this.sidebar.main_div, this);
        this.sidebar.addPanel(this.classPanel);

        // Node tab
        this.nodeTab = new Panel.Panel(this.classPanel.container, this);
        this.nodeTab.newGroup();

        this.title_text = document.createElement("span");
        this.nodeTab.addObject(this.title_text);

        this.title_edit_link = document.createElement("a");
        this.title_edit_link.className = "card-link-body";
        this.title_edit_link.href = "#";
        this.title_edit_link.style.float = "right";
        this.title_edit_link.innerHTML = "Edit";
        this.title_edit_link.addEventListener("click", () => {
            let c = this.selected.c;
            if (this.title_edit_link.innerHTML == "OK") {
                let old_name = c.name;
                c.name = this.title_edit_input.value;
                this.sseq.undo.addValueChange(c, "name", old_name, c.name, () => this.sidebar.showPanel());
                this.sseq.emit("update");
                this.nodeTab.show();
            } else {
                this.title_edit_link.innerHTML = "OK";
                if (c.name) this.title_edit_input.value = c.name;
                this.title_edit_input.style.removeProperty("display");
            }
        });
        this.nodeTab.addObject(this.title_edit_link);

        this.title_edit_input = document.createElement("input");
        this.title_edit_input.className = "form-control mt-2";
        this.title_edit_input.type = "text";
        this.title_edit_input.placeholder = "Enter class name";
        this.nodeTab.addObject(this.title_edit_input);

        this.nodeTab.on("show", () => {
            this.title_edit_input.style.display = "none";
            this.title_edit_input.value = "";
            this.title_edit_link.innerHTML = "Edit";
            let c = this.selected.c;
            if (c.name) {
                this.title_text.innerHTML = Interface.renderLaTeX(Interface.ensureMath(c.name)) + ` - (${c.x}, ${c.y})`;
            } else {
                this.title_text.innerHTML = `<span style='color: gray'>unnamed</span> - (${c.x}, ${c.y})`;
            }
        });

        this.nodeTab.newGroup();
        this.nodeTab.addLinkedInput("Color", "selected.color", "text", "selected.c");
        this.nodeTab.addLinkedInput("Size", "selected.size", "number", "selected.c");
        this.nodeTab.addButton("Delete class", () => {
            this.sseq.startMutationTracking();
            this.sseq.deleteClass(this.selected.c);
            this.sseq.addMutationsToUndoStack();
            this.sidebar.showPanel(this.generalPanel)
        }, { style: "danger" });
        this.classPanel.addTab("Node", this.nodeTab);

        // Differentials tab
        this.differentialTab = new Panel.DifferentialPanel(this.classPanel.container, this);
        Mousetrap.bind('d', () => this.state = STATE_ADD_DIFFERENTIAL);
        Mousetrap.bind('r', () => this.state = STATE_RM_EDGE);
        this.classPanel.addTab("Diff", this.differentialTab);

        // Structline tab
        this.structlineTab = new Panel.StructlinePanel(this.classPanel.container, this);
        Mousetrap.bind('s', () => this.state = STATE_ADD_STRUCTLINE);
        this.classPanel.addTab("Struct", this.structlineTab);

        this.sidebar.showPanel(this.generalPanel);

        this.tooltip = new Tooltip(this);
        this.on("mouseover", (node) => {
            this.tooltip.setHTML(`(${node.c.x}, ${node.c.y})`);
            this.tooltip.show(node.canvas_x, node.canvas_y);
        });
        this.on("mouseout", this._onMouseout.bind(this));
        this.on("click", this.__onClick.bind(this)); // Display already has an _onClick

        this._onDifferentialAdded = this._onDifferentialAdded.bind(this);

        Mousetrap.bind('left',  this.previousPage);
        Mousetrap.bind('right', this.nextPage);
        Mousetrap.bind('x', () => { if(this.selected){ console.log(this.selected.c); } });

        if (sseq) this.setSseq(sseq);
    }

    setDifferentialColor(page, color) {
        this.differentialColors[page] = color;
    }

    setSseq(sseq) {
        if (this.sseq)
            this.sseq.removeListener("differential-added", this._onDifferentialAdded);

        super.setSseq(sseq)

        this.sidebar.showPanel(this.generalPanel);

        this.sseq.on("differential-added", this._onDifferentialAdded);
    }

    _onMouseout() {
        if (this.selected) this.selected.highlight = true;
        this.tooltip.hide();
    }

    _unselect() {
        if (!this.selected) return;

        this.selected.highlight = false;
        this.selected = null;
        this.state = null;

        this.sidebar.showPanel(this.generalPanel);

        this._drawSseq(this.context);
    }

    __onClick(node, e) {
        if (this.state == STATE_ADD_CLASS) {
            let x = Math.round(this.xScale.invert(e.clientX));
            let y = Math.round(this.yScale.invert(e.clientY));
            this.sseq.undo.startMutationTracking();
            this.sseq.addClass(x, y);
            this.sseq.undo.addMutationsToUndoStack();
            this.state = null;
            return;
        }

        if (!node) {
            this._unselect();
            return;
        }

        if (!this.selected) {
            this._unselect();
            this.selected = node;
            this.sidebar.showPanel(this.classPanel);
            this.state = null;
            return;
        }

        let s = this.selected.c;
        let t = node.c;
        switch (this.state) {
            case STATE_ADD_DIFFERENTIAL:
                if(s.x !== t.x + 1){
                    this._unselect();
                    break;
                }
                let length = t.y - s.y;
                this.sseq.undo.startMutationTracking();
                this.sseq.addDifferential(s, t, length);
                this.sseq.undo.addMutationsToUndoStack();
                this.sidebar.showPanel();
                break;
            case STATE_RM_DIFFERENTIAL:
                this.sseq.undo.startMutationTracking();
                for (let e of s.edges)
                    if (e.type === "Differential" && e.target == t)
                        sseq.deleteEdge(e);
                this.sseq.undo.addMutationsToUndoStack();
                this.sidebar.showPanel();
                break;
            case STATE_ADD_STRUCTLINE:
                this.sseq.undo.startMutationTracking();
                this.sseq.addStructline(s, t);
                this.sseq.undo.addMutationsToUndoStack();
                this.sidebar.showPanel();
                break;
            case STATE_RM_STRUCTLINE:
                this.sseq.undo.startMutationTracking();
                for (let e of s.edges)
                    if (e.type === "Structline" && e.target == t)
                        sseq.deleteEdge(e);
                this.sseq.undo.addMutationsToUndoStack();
                this.sidebar.showPanel();
                break;
            case STATE_RM_EDGE:
                this.sseq.undo.startMutationTracking();
                for (let e of s.edges)
                    if (e.target == t)
                        sseq.deleteEdge(e);
                this.sseq.undo.addMutationsToUndoStack();
                this.sidebar.showPanel();
                break;
            default:
                this._unselect();
                this.selected = node;
                this.sidebar.showPanel(this.classPanel);
                break;
        }
        this.state = null;
    }

    _onDifferentialAdded(d) {
        if (this.differentialColors[d.page])
            d.color = this.differentialColors[d.page];
    }
}
exports.EditorDisplay = EditorDisplay;

},{"./Interface.js":24,"./Panel.js":25,"./SidebarDisplay.js":27,"./Tooltip.js":28,"mousetrap":18}],24:[function(require,module,exports){
let katex = require("katex");

applyAttributesToElement = function applyAttributesToElement(element, attributes){
    if(!element || !attributes){
        return;
    }
    for(let kv of Object.entries(attributes)){
        element.setAttribute(kv[0], kv[1]);
    }
};

function ensureMath(str){
    if(str.startsWith("\\(") || str.startsWith("$")){
        return str;
    }
    if(!str){
        return "";
    }
    return "$" + str + "$";
}

function renderLatex(html) {
    html = html.replace(/\n/g, "\n<hr>\n")
    let html_list = html.split(/(?:\\\[)|(?:\\\()|(?:\\\))|(?:\\\])|(?:\$)/);
    for(let i = 1; i < html_list.length; i+=2){
        html_list[i] = katex.renderToString(html_list[i]);
    }
    return html_list.join("\n")
}
exports.renderLatex = renderLatex;
exports.renderLaTeX = renderLatex;
exports.ensureMath = ensureMath;
exports.renderMath = x => renderLatex(ensureMath(x));

fixFormHTML = {};
fixFormHTML.radio = function(doc, field){
    let elts = doc.getElementsByName(field.name);
    let items = field.options.items;
    for(let i = 0; i < elts.length; i++){
        applyAttributesToElement(elts[i], items[i].attributes);
    }
};

class PopupForm {
    // This copies form.record into form.save_record to avoid a race condition between:
    //    the onClose writes over form.record with form.original
    //    the success code writes over form.original with form.record.
    static backupRecord(form){
        form.save_record = {};
        Object.assign(form.save_record,form.record);
    }

    // Write over form.original and form.record with form.save_record. Better have called backupRecord first!
    static saveRecord(form){
        Object.assign(form.original, form.save_record);
        Object.assign(form.record,   form.save_record);
    }

    // Write over form.record with form.original. Goes in the onClose handler.
    static restoreRecord(form){
        Object.assign(form.record, form.original);
    }

    constructor(form_options, popup_options){
        let form_obj = Object.assign({}, PopupForm.default_form_obj, form_options);
        this.form_obj = form_obj;
        let name = form_obj.name;
        form_obj.actions = {};
        form_obj.actions[this.form_obj.accept_button_name] = function() {
            // This call to ".save()" produces a logged error but seems to have the desired effect
            // of moving the current set of form fields into ".record". save is supposed to send the form data
            // to a server. There doesn't seem to be an API call to save current fields into .record, and
            // I couldn't figure out another way to access them.
            w2ui[name].save();
            PopupForm.backupRecord(w2ui[name]);
            let errs = w2ui[name].validate();
            if (errs.length > 0) {
                return;
            }
            PopupForm.saveRecord(w2ui[name]);
            w2ui[name].onSuccess();
            w2popup.close();
        };
        form_obj.actions["Cancel"] = function cancel() {
            // No special handling if the user clicks the cancel button as opposed to escape or close or click outside the box.
            w2popup.close();
        };

        $().w2form(this.form_obj);
        let form = w2ui[name];
        this.form = form;
        this.fixFormHTML(form);
        Object.assign(form.original, form_obj.record);

        this.popup_obj = Object.assign({}, PopupForm.default_popup_obj, popup_options);
        // No idea what this is for I just copied it from http://w2ui.com/web/demos/#!forms/forms-8
        this.popup_obj.onToggle = function (event) {
            $(form.box).hide();
            event.onComplete = function () {
                $(form.box).show();
                form.resize();
            }
        };
        // Pressing "Enter" is the same as clicking "open"
        this.popup_obj.onKeydown = function(event){
            if(event.originalEvent.key === "Enter"){
                if(document.getElementsByClassName("w2ui-error").length > 0){
                    return;
                }
                form.actions[form_obj.accept_button_name]();
            }
        };

        this.popup_obj.onClose = function(event){
            PopupForm.restoreRecord(form);
        };

        this.userOnOpen = this.popup_obj.onOpen;
        this.popup_obj.onOpen = (event) => {
            // There's a delay between when the popup opens and when the form is rendered into the popup.
            // It looks ugly if we let these two events happen sequentially, so we temporarily add a style
            // element to override the opacity with 0. Once the document is rendered, we remove this style element
            // to allow the form to display.
            // TODO: refactor this a bit.
            let hide_popup = document.createElement("style");
            hide_popup.innerText = '#w2ui-popup, #w2ui-lock { opacity :  0 !important }';
            document.body.appendChild(hide_popup);
            event.onComplete = () => {
                $('#w2ui-popup #form').w2render(form); // Render the form
                if(this.userOnOpen){
                    this.userOnOpen(event);
                }
                document.body.removeChild(hide_popup); // Once everything is done, remove the element.
            }
        };

        this.open = this.open.bind(this);
//        w2ui.open_sseq_form.record['sseq-file-name'] = '';
    }

    open(){
        if($('#w2ui-popup').length > 0){
            return;
        }
        $().w2popup(this.popup_obj);
    }

    fixFormHTML(){
        let doc = new DOMParser().parseFromString(this.form.formHTML, "text/html");
        for(let f of this.form.fields){
            if(f.attributes){
                applyAttributesToElement(doc.getElementsByName(f.name)[0], f.attributes);
            }
            if(fixFormHTML[f.type]){
                fixFormHTML[f.type](doc, f);
            }
        }
        this.form.formHTML = new XMLSerializer().serializeToString(doc);
    };


}

PopupForm.default_form_obj = {style: 'border: 0px; background-color: transparent;'};
PopupForm.default_popup_obj = {
    body    : '<div id="form" style="width: 100%; height: 100%;"></div>',
    style   : 'padding: 15px 0px 0px 0px opacity: 0',
    width   : 500,
    height  : 220
};

exports.PopupForm = PopupForm;


class Undo {
    constructor(sseq){
        this.sseq = sseq;
        this.undoStack = [];
        this.undoObjStack = [];
        this.redoStack = [];
        this.redoObjStack = [];
        this.undo = this.undo.bind(this);
        this.redo = this.redo.bind(this);
    };

    startMutationTracking(){
        this.mutationMap = new Map();
    }

    addMutationsToUndoStack(event_obj){
        this.add(this.mutationMap, event_obj);
        this.mutationMap = undefined;
    }

    addMutation(obj, pre, post){
        if(!this.mutationMap){
            return;
        }
        if(this.mutationMap.get(obj)){
            pre = this.mutationMap.get(obj).before;
        }
        this.mutationMap.set(obj, {obj: obj, before: pre, after : post});
    }

    add(mutations, event_obj) {
        this.undoStack.push({type:"normal",  mutations: mutations});
        this.undoObjStack.push(event_obj);
        this.redoStack = [];
        this.redoObjStack = [];
    }

    addValueChange(target, prop, before, after, callback) {
        let e = {type:"value", target: target, prop: prop, before: before, after: after, callback: callback};
        this.undoStack.push(e);
        this.undoObjStack.push(e);
        this.redoStack = [];
        this.redoObjStack = [];
    }
    addManual(e, e_obj) {
        this.undoStack.push(e);
        this.undoObjStack.push(e_obj);
        this.redoStack = [];
        this.redoObjStack = [];
    }

    clear(){
        this.undoStack = [];
        this.redoStack = [];
    };

    undo() {
        if (this.undoStack.length === 0) {
            return;
        }
        let e = this.undoStack.pop();
        this.redoStack.push(e);
        let obj = this.undoObjStack.pop();
        this.redoObjStack.push(obj);
        switch (e.type) {
            case "normal":
                this.undoNormal(e);
                break;
            case "value":
                e.target[e.prop] = e.before;
                if (e.callback) e.callback();
                break;
        }
        this.sseq.emit("update");
    };

    undoNormal(obj){
        let mutations = obj.mutations;
        for(let m of mutations.values()){
            if(m.obj.undoFromMemento){
                m.obj.undoFromMemento(m.before);
            } else {
                m.obj.restoreFromMemento(m.before);
            }
        }
    }

    redo() {
        if (this.redoStack.length === 0) {
            return;
        }
        let e = this.redoStack.pop();
        this.undoStack.push(e);
        let obj = this.redoObjStack.pop();
        this.undoObjStack.push(obj);
        switch (e.type) {
            case "normal":
                this.redoNormal(e);
                break;
            case "value":
                e.target[e.prop] = e.after;
                if (e.callback) e.callback();
                break;
        }
        this.sseq.emit("update");
    };

    redoNormal(obj){
        let mutations = obj.mutations;
        for(let m of mutations.values()){
            if(m.obj.redoFromMemento){
                m.obj.redoFromMemento(m.after);
            } else {
                m.obj.restoreFromMemento(m.after);
            }
        }
    }

    addLock(msg){
        let d = new Date();
        if(msg === undefined){
            msg = `Undo events before save at ${d.getFullYear()}-${d.getMonth()}-${d.getDay()} ${d.getHours()}:${d.getMinutes().toString().padStart(2,"0")}?`;
        }
        this.undoStack.push({
            type : "lock",
            msg : msg,
            date : d,
            undoFunction : lockFunction.bind(this)
        })
    }

    getEventObjects() {
        return this.undoObjStack;
    }

    toJSON(){
        return this.undoStack.map(function(e) {
            if(e.type === "normal"){
                return {
                    "type" : "normal",
                    "mutations" : Array.from(e.mutations.entries()).map(([k,v]) => [k.recid, v.before])
                };
            } else {
                return e;
            }
        });
    }
}

Undo.undoFunctions = {};
Undo.redoFunctions = {};
Undo.undoFunctions["lock"] = lockFunction;
Undo.redoFunctions["lock"] = function() {};


function lockFunction(obj){
    w2confirm(obj.msg)
        .yes(() => {
            this.redoStack.pop();
        })
        .no(() => {
            let e = this.redoStack.pop();
            this.undoStack.push(e);
        });
}

Undo.defaultLockMessage = "Undo events before loaded page?";

exports.Undo = Undo;

},{"katex":17}],25:[function(require,module,exports){
"use strict"

let EventEmitter = require("events");
let Mousetrap = require("mousetrap");
let Interface = require("./Interface.js");

const STATE_ADD_DIFFERENTIAL = 1;
const STATE_RM_DIFFERENTIAL = 2;
const STATE_ADD_STRUCTLINE = 3;
const STATE_RM_STRUCTLINE = 4;
const STATE_RM_EDGE = 5;

/**
 * A panel is a collection of objects (button etc.) to be displayed in a
 * sidepanel. The main function to implement is show(), which is called
 * whenever the panel is to be displayed.
 *
 * The standard way to deal with panels is that all children of the panel are
 * created when the panel is initialized, and all callbacks are appropriately
 * set up. When show() is called, we decide which elements to display by
 * setting the display property, and then initialize the values of the elements
 * accordingly.
 *
 * Panels and its children are expected to properly track mutations and write
 * them to this.display.sseq.undo upon each change.
 *
 * There are a few helper functions that add elements to the panel, such as
 * addButton.
 *
 * @property {Node} container - Top node of the panel, to which we add all
 * children. This is a plain div element that is not styled. All styling should
 * be applied to children of this container.
 * @property {Node} currentGroup - This is the DOM element that the helper
 * functions will add the buttons/fields to. This defaults to this.container
 * but is modified by newGroup() and endGroup(). It can also be manually
 * modified as desired.
 *
 * @fires Panel#show
 * @extends EventEmitter
 */
class Panel extends EventEmitter {
    /**
     * Constructs a panel.
     *
     * @param {Node} parentContainer - The node to add the panel to
     * @param {Display:Display} - The Display object the panel is about.
     * This is used by the helper functions to know where to track mutations,
     * update the display when properties change, etc.
     */
    constructor (parentContainer, display) {
        super();

        this.display = display;
        this.container = document.createElement("div");
        parentContainer.appendChild(this.container);
        this.links = [];

        this.currentGroup = this.container;
    }

    /**
     * This hides the panel. It does nothing but set the display property to
     * none.
     */
    hide() {
        this.container.style.display = "none";
    }

    /**
     * This clears everything in the panel. This currently does not unbind the
     * shortcuts.
     */
    clear() {
        while (this.container.firstChild)
            this.container.removeChild(this.container.firstChild);

        this.links = [];
    }

    /**
     * This shows the panel, and populates the values of the children.  This
     * correctly populates the children added by the helper functions, and no
     * extra work has to be done for them. If custom children are added, one
     * will want to customize the show() function to ensure the children are
     * correctly displayed. This can be done by overwriting the show() function
     * or by listening to the Panel#show event.
     *
     * This function may be called when the panel is already shown. In this
     * case, the correct behaviour is to refresh the display (e.g. update the
     * values of the fields)
     */
    show() {
        this.container.style.removeProperty("display");

        for (let link of this.links) {
            let t = this.display;
            for (let attr of link[0].split(".")) {
                t = t[attr];
                if (t === undefined || t === null) {
                    return;
                }
            }
            link[1].value = t;
        }
        /**
         * Show event. This is emitted when show() is called. One may opt to
         * listen and respond to the show event instead of overwriting show()
         * when designing custom panels, c.f. DifferentialPanel.
         *
         * @event Panel#show
         */
        this.emit("show");
    }

    /**
     * This creates a new div and adds it to the container. This new div is
     * then set as currentGroup and has class card-body.
     *
     * This should be used if one wishes to add a collection of children that
     * are to be grouped together. The procedure for using this is as follows:
     * (1) Run Panel#addGroup
     * (2) Add the children using the helper functions (addButton, addObject, etc.)
     * (3) Run Panel#endGroup to set currentGroup back to this.container.
     */
    newGroup() {
        this.currentGroup = document.createElement("div");
        this.currentGroup.className = "card-body";
        this.container.appendChild(this.currentGroup);
    }
    /**
     * See newGroup().
     */
    endGroup() {
        this.currentGroup = this.container;
    }

    /**
     * Does nothing but this.currentGroup.appendChild(obj);
     *
     * @param {Node} obj - The object to be added.
     */
    addObject(obj) {
        this.currentGroup.appendChild(obj);
    }

    /**
     * This adds a button to currentGroup.
     *
     * @param {string} text - Text to appear on the button.
     * @param {function} callback - Function to call when button is clicked.
     * @param {Object} extra - Extra (optional) properties to supply.
     * @param {string} extra.tooltip - Tooltip text to display
     * @param {string[]} shortcuts - A list of shortcuts that will be bound to callback
     */
    addButton(text, callback, extra = {}) {
        let o = document.createElement("button");
        if (extra.style)
            o.className = `btn btn-${extra.style} mb-2`;
        else
            o.className = "btn btn-primary mb-2";

        o.style.width = "100%";
        o.innerHTML = text;
        o.addEventListener("click", callback);

        if (extra.tooltip)
            o.setAttribute("title", extra.tooltip);
        if (extra.shortcuts)
            for (let k of extra.shortcuts)
                Mousetrap.bind(k, callback);

        this.currentGroup.appendChild(o);
    }

    /**
     * This adds several buttons placed side-by-side on a row.
     *
     * @param {Array[]} buttons - An array of arguments specifying the buttons
     * to be added. Each entry in the array should itself be an array, which
     * consists of the arguments to Panel#addButton for the corresponding
     * button.
     */
    addButtonRow(buttons){
        let group = this.currentGroup;
        let o = document.createElement("div");
        o.className = "form-row";
        for (let button of buttons) {
            let c = document.createElement("div");
            c.className = "col";
            this.currentGroup = c;
            this.addButton(...button);
            o.appendChild(c);
        }
        this.currentGroup = group;
        this.currentGroup.appendChild(o);
    }

    /**
     * This adds a header.
     * @param {String} header - The header text.
     */
    addHeader(header) {
        let node = document.createElement("h5");
        node.className = "card-title";
        node.innerHTML = header;
        this.addObject(node);
    }

    /**
     * This adds a linked input. A linked input is an entry that looks like
     *
     *       +-----+
     * Label |     |
     *       +-----+
     *
     * The input field is linked to a certain property of display. When the
     * panel is shown, the initial value of the input field is set to the value
     * of the corresponding property, and when the input field is changed, the
     * property is changed accordingly.
     *
     * @param {string} label - The label displayed next to the input field
     * @param {string} target - The property the input field is linked to.
     * This is specified by a string of the from "foo.bar.xyz", which says the
     * field is linked to this.display.foo.bar.xyz.
     * @param {string} type - The type of the input field. This is "text" or
     * "number" would usually be sensible choices.
     * @param {Object=} mementoObject - By default, the undo/redo functions
     * will simply set the value of target to what it was. Here the target
     * is remembered as an *object*, not as a property of this.display via
     * target (for example, if the input is about the currently active node
     * (this.display.selected), the undo function should undo the change on the
     * node that was affected, not the node that is active when the undo button
     * is pressed). It turns out this is problematic when dealing with nodes of
     * classes, since when classes are restored via undo/redo, the set of nodes
     * is copied and all references are lost.
     *
     * If mementoObject is defined, then instead of tracking individual changes
     * of the properties, the mutation tracker remembers the previous and after
     * states of mementoObject and writes that into the undo stack instead.
     * c.f. the node color/size inputs in EditorDisplay.
     */
    addLinkedInput(label, target, type, mementoObject) {
        let o = document.createElement("div");
        o.className = "form-row mb-2";
        o.style.width = "100%";
        this.currentGroup.appendChild(o);

        let l = document.createElement("label");
        l.className = "col-form-label mr-sm-2";
        l.innerHTML = label;
        o.appendChild(l);

        let i = document.createElement("input");
        i.style["flex-grow"] = 1;
        i.setAttribute("type", type);
        o.appendChild(i);

        switch (type) {
            case "text":
                i.setAttribute("size", "1");
                break;
            default:
                i.style.width = "1px";
                break;
        }

        this.links.push([target, i]);

        i.addEventListener("change", (e) => {
            let target_pre;
            if (mementoObject) {
                mementoObject = Panel.unwrapProperty(this.display, mementoObject.split("."))
                target_pre = mementoObject.getMemento();
            }

            let l = target.split(".");
            let prop = l.pop();
            let t = Panel.unwrapProperty(this.display, l);

            let old_val = t[prop];
            let new_val = e.target.value;
            t[prop] = new_val;

            if (this.display.sseq.undo) {
                if (mementoObject) {
                    this.display.sseq.undo.startMutationTracking()
                    this.display.sseq.undo.addMutation(mementoObject, target_pre, mementoObject.getMemento())
                    this.display.sseq.undo.addMutationsToUndoStack();
                } else {
                    this.display.sseq.undo.addValueChange(t, prop, old_val, new_val, () => this.display.sidebar.showPanel());
                }
            }

            this.display.sseq.emit("update");
        });
    }

    static unwrapProperty(start, list) {
        let t = start;
        for (let i of list)
            t = t[i];
        return t;
    }
}

/**
 * This is a panel whose some purpose is to contain further panels arranged in
 * tabs. This is used, for example, in EditorDisplay for configuring different
 * properties of a class.
 *
 * @property {Panel} currentTab - The current tab that is displayed.
 */
class TabbedPanel extends Panel {
    constructor (parentContainer, display) {
        super(parentContainer, display);

        let head = document.createElement("div");
        head.className = "card-header";
        this.container.appendChild(head);

        this.header = document.createElement("ul");
        this.header.className = "nav nav-tabs card-header-tabs";
        head.appendChild(this.header);

        this.tabs = [];
        this.currentTab = null;
    }

    /**
     * This adds a tab to TabbedPanel.
     *
     * @param {string} name - The name of the tab, to be displayed in the
     * header. Avoid making this too long.
     * @param {Panel} tab - The tab to be added.
     */
    addTab(name, tab) {
        let li = document.createElement("li");
        li.className = "nav-item";
        this.header.appendChild(li);

        let a = document.createElement("a");
        a.className = "nav-link";
        a.href = "#";
        a.innerHTML = name;
        li.appendChild(a);

        a.addEventListener("click", () => this.showTab(tab));
        this.tabs[this.tabs.length] = [tab, a];

        if (!this.currentTab) this.currentTab = tab;
    }

    show() {
        super.show();
        this.showTab(this.currentTab);
    }

    /**
     * Sets the corresponding tab to be the active tab and shows it (of course,
     * the tab will not be actually shown if the panel itself is hidden).
     *
     * @param {Panel} tab - Tab to be shown.
     */
    showTab(tab) {
        this.currentTab = tab;
        for (let t of this.tabs) {
            if (t[0] == tab) {
                t[1].className = "nav-link active";
                t[0].show();
            } else {
                t[1].className = "nav-link";
                t[0].hide();
            }
        }
    }
}

class DifferentialPanel extends Panel {
    constructor(parentContainer, display) {
        super(parentContainer, display);

        this.differential_list = document.createElement("ul");
        this.differential_list.className = "list-group list-group-flush";
        this.differential_list.style["text-align"] = "center";
        this.addObject(this.differential_list);

        this.on("show", () => {
            while(this.differential_list.firstChild)
                this.differential_list.removeChild(this.differential_list.firstChild);

            let edges = this.display.selected.c.edges.filter(e => e.type === "Differential").sort((a, b) => a.page - b.page);

            let sname, tname;
            for (let e of edges) {
                sname = e.source.name ? e.source.name : "?"
                tname = e.target.name ? e.target.name : "?"
                if (e.source == this.display.selected.c)
                    this.addLI(Interface.renderMath(`d_${e.page}({\\color{blue}${sname}}) = ${tname}`));
                else
                    this.addLI(Interface.renderMath(`d_${e.page}(${sname}) = {\\color{blue}${tname}}`));
            }

            this.addLI("<a href='#'>Add differential</a>", () => this.display.state = STATE_ADD_DIFFERENTIAL );
            this.addLI("<a href='#'>Remove differential</a>", () => this.display.state = STATE_RM_DIFFERENTIAL );
        });
    }

    addLI(html, callback) {
        let node = document.createElement("li");
        node.className = "list-group-item";
        node.style = "padding: 0.75rem 0";
        node.innerHTML = html;
        if (callback)
            node.addEventListener("click", callback);
        this.differential_list.appendChild(node);
    }
}

class StructlinePanel extends Panel {
    constructor(parentContainer, display) {
        super(parentContainer, display);

        this.structline_list = document.createElement("ul");
        this.structline_list.className = "list-group list-group-flush";
        this.structline_list.style["text-align"] = "center";
        this.addObject(this.structline_list);

        this.on("show", () => {
            while(this.structline_list.firstChild)
                this.structline_list.removeChild(this.structline_list.firstChild);

            let edges = this.display.selected.c.edges.filter(e => e.type === "Structline").sort((a, b) => a.page - b.page);

            let sname, tname;
            for (let e of edges) {
                sname = e.source.name ? e.source.name : "?"
                tname = e.target.name ? e.target.name : "?"
                if (e.source == this.display.selected.c)
                    this.addLI(Interface.renderMath(`{\\color{blue}${sname}} \\text{---} ${tname}`));
                else
                    this.addLI(Interface.renderMath(`${sname} \\text{---} {\\color{blue}${tname}}`));
            }

            this.addLI("<a href='#'>Add structline</a>", () => this.display.state = STATE_ADD_STRUCTLINE );
            this.addLI("<a href='#'>Remove structline</a>", () => this.display.state = STATE_RM_STRUCTLINE );
        });

    }

    addLI(html, callback) {
        let node = document.createElement("li");
        node.className = "list-group-item";
        node.style = "padding: 0.75rem 0";
        node.innerHTML = html;
        if (callback)
            node.addEventListener("click", callback);
        this.structline_list.appendChild(node);
    }
}

exports.Panel = Panel;
exports.TabbedPanel = TabbedPanel;
exports.DifferentialPanel = DifferentialPanel;
exports.StructlinePanel = StructlinePanel;

},{"./Interface.js":24,"events":16,"mousetrap":18}],26:[function(require,module,exports){
exports.download = function(filename, text, mime="text/plain") {
    if(text.constructor !== String){
        text = JSON.stringify(text);
    }
    let element = document.createElement('a');

    element.setAttribute('href', `data:${mime};charset=utf-8,` + encodeURIComponent(text));
    element.setAttribute('download', filename);

    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
};


//function

exports.upload = function() {
    return new Promise((resolve,reject) => {
        let element = document.createElement('input');
        element.setAttribute('type', 'file');
        element.setAttribute('multiple', '');

        element.style.display = 'none';
        let reader = new FileReader();
        let i = 0;
        let fileList = [];
        element.onchange = function () {
            for(let f of element.files){
                fileList.push({ name : f.name });
            }
            reader.readAsText(element.files[0]);
        };
        reader.onloadend = function() {
            fileList[i].content = reader.result;
            i++;
            if(i < element.files.length){
                reader.readAsText(element.files[i]);
            } else {
                resolve(fileList);
                document.body.removeChild(element);
            }
        };
        document.body.appendChild(element);
        element.click();
    });
};



exports.saveToLocalStore = function(key, value, collection){
    if(value.constructor !== String){
        value = JSON.stringify(value);
    }
    return sseqDatabase.open().catch((err) => console.log(err))
        .then(() => sseqDatabase.createKey(key, value, collection))
        .then(() => console.log("Successfully saved."));
};

function nextString(str){
    if(str.length === 0 ){
        return ""; // Last printable ascii character -- it's in code point 254.
    }
    return str.substring(0,str.length-1)+String.fromCharCode(str.charCodeAt(str.length-1)+1);
}

exports.loadKeysFromLocalStoreWithPrefix = async function(prefix){
    let endStr = nextString(prefix);
    await sseqDatabase.open();
    return await sseqDatabase.fetchKeyRange(prefix, endStr);
};

exports.loadFromLocalStore = async function(key){
    await sseqDatabase.open();
    let response = await sseqDatabase.fetchKey(key);
    if(!response || !response.value){
        return undefined;
    }
    let obj = JSON.parse(response.value);
    obj.name = response.key;
    return obj;
};

exports.deleteFromLocalStore = async function(key){
    await sseqDatabase.open();
    await sseqDatabase.deleteKey(key);
    return;
};

exports.loadFromServer = async function(path){
    let response = await fetch(path);
    return await response.json();
};


const sseqDatabase = {};
let datastore = null;

sseqDatabase.open = function() {
    return new Promise(function(resolve,reject) {
        if(datastore){
            resolve();
            return;
        }
        // Database version.
        const version = 6;

        // Open a connection to the datastore.
        const request = indexedDB.open('sseq', version);

        // Handle datastore upgrades.
        request.onupgradeneeded = function (e) {
            const db = e.target.result;

            e.target.transaction.onerror = sseqDatabase.onerror;

            // Delete the old datastore.
            if (db.objectStoreNames.contains('sseq')) {
                db.deleteObjectStore('sseq');
            }

            // Create a new datastore.
            const store = db.createObjectStore('sseq', {
                keyPath: 'key'
            });

            store.createIndex("key", "key",  { unique: true });
            store.createIndex("collection", "collection", { unique: false });
        };

        // Handle successful datastore access.
        request.onsuccess = function (e) {
            // Get a reference to the DB.
            datastore = e.target.result;
            // Execute the callback.
            resolve();
        };

        // Handle errors when opening the datastore.
        request.onerror = reject;
    });
};


sseqDatabase.fetchAllKeys = function() {
    return new Promise(function(resolve, reject) {
        const transaction = datastore.transaction(['sseq'], 'readwrite');
        const objStore = transaction.objectStore('sseq');

        const keyRange = IDBKeyRange.lowerBound(0);
        const cursorRequest = objStore.openCursor(keyRange);

        const todos = [];

        transaction.oncomplete = function (e) {
            // Execute the callback function.
            resolve(todos);
        };

        cursorRequest.onsuccess = function (e) {
            let result = e.target.result;

            if (!!result === false) {
                return;
            }

            todos.push(result.value);

            result.continue();
        };

        cursorRequest.onerror = reject;
    });
};

sseqDatabase.fetchKey = function(key) {
    return new Promise(function(resolve, reject) {
        const transaction = datastore.transaction(['sseq'], 'readwrite');
        const objStore = transaction.objectStore('sseq');

        const keyRange = IDBKeyRange.lowerBound(0);
        const objectStoreRequest = objStore.index("key").get(key);

        objectStoreRequest.onsuccess = function (e) {
            resolve(objectStoreRequest.result);
        };

        objectStoreRequest.onerror = reject;
    });
};


sseqDatabase.fetchKeyRange = function(min,max) {
    return new Promise(function(resolve, reject) {
        const transaction = datastore.transaction(['sseq'], 'readwrite');
        const objStore = transaction.objectStore('sseq');

        const keyRange = IDBKeyRange.bound(min, max, true, false);
        const cursorRequest = objStore.openCursor(keyRange);

        const todos = [];

        transaction.oncomplete = function (e) {
            // Execute the callback function.
            resolve(todos);
        };

        cursorRequest.onsuccess = function (e) {
            let result = e.target.result;

            if (!!result === false) {
                return;
            }

            todos.push(result.value);

            result.continue();
        };

        cursorRequest.onerror = reject;
    });
};

sseqDatabase.fetchCollection = function(collection) {
    return new Promise(function(resolve, reject) {
        const transaction = datastore.transaction(['sseq'], 'readwrite');
        const objStore = transaction.objectStore('sseq');

        console.log(collection);
        const cursorRequest = objStore.index("collection").openCursor(collection);

        const todos = [];

        transaction.oncomplete = function (e) {
            // Execute the callback function.
            resolve(todos);
        };

        cursorRequest.onsuccess = function (e) {
            let result = e.target.result;

            if (!!result == false) {
                return;
            }

            todos.push(result.value);

            result.continue();
        };

        cursorRequest.onerror = reject;
    });
};

sseqDatabase.createKey = function(key, value, collection) {
    return new Promise(function(resolve, reject) {
        // Get a reference to the db.
        const db = datastore;

        // Initiate a new transaction.
        const transaction = db.transaction(['sseq'], 'readwrite');
        // Get the datastore.
        const objStore = transaction.objectStore('sseq');
        // Create a timestamp for the item.
        const timestamp = new Date().getTime();
        // Create an object for the item.
        const item = {
            'key' : key,
            'value': value,
            'collection' : collection,
            'timestamp': timestamp
        };
        // Create the datastore request.
        const request = objStore.put(item);
        // Handle a successful datastore put.
        request.onsuccess = function (e) {
            // Execute the callback function.
            resolve(item);
        };

        // Handle errors.
        request.onerror = reject;
    });
};


sseqDatabase.deleteKey = function(id) {
    return new Promise(function(resolve, reject) {
        const db = datastore;
        const transaction = db.transaction(['sseq'], 'readwrite');
        const objStore = transaction.objectStore('sseq');

        const request = objStore.delete(id);

        request.onsuccess = function (e) {
            resolve();
        };

        request.onerror = reject;
    });
};

exports.sseqDatabase = sseqDatabase;

},{}],27:[function(require,module,exports){
"use strict"

let Display = require("./Display.js").Display;
let Panel = require("./Panel.js");

class Sidebar {
    constructor(parentContainer) {
        this.adjuster = document.createElement("div");
        this.adjuster.style.backgroundColor = "rgba(0,0,0,0.125)";
        this.adjuster.style.height = "100%";
        this.adjuster.style.cursor = "ew-resize";
        this.adjuster.style.width = "2px";

        parentContainer.appendChild(this.adjuster);

        this.resize = this.resize.bind(this);
        this.stopResize = this.stopResize.bind(this);

        this.adjuster.addEventListener("mousedown", (function(e) {
            e.preventDefault();
            window.addEventListener('mousemove', this.resize);
            window.addEventListener('mouseup', this.stopResize);
        }).bind(this));

        this.sidebar = document.createElement("div");
        this.sidebar.style.height = "100%";
        this.sidebar.style.width = "240px";
        this.sidebar.style.border = "none";
        this.sidebar.style.display = "flex";
        this.sidebar.style.flexDirection = "column";
        this.sidebar.className = "card";

        parentContainer.appendChild(this.sidebar);

        this.main_div = document.createElement("div");
        this.main_div.style.overflow = "auto";
        this.sidebar.appendChild(this.main_div);

        let filler = document.createElement("div");
        filler.style.flexGrow = "1";
        this.sidebar.appendChild(filler);

        this.footer_div = document.createElement("div");
        this.sidebar.appendChild(this.footer_div);

        this.panels = [];
        this.currentPanel = null;
    }

    addPanel(panel) {
        this.panels.push(panel);
        return this.panels.length;
    }

    init(display) {
        this.display = display;
        this.footer = new Panel.Panel(this.footer_div, display);
    }

    resize(e) {
        let width = this.sidebar.getBoundingClientRect().right - e.pageX;
        this.sidebar.style.width = `${width}px`;
    }

    stopResize() {
        window.removeEventListener('mousemove', this.resize);
        window.removeEventListener('mouseup', this.stopResize);
        this.display.resize();
    }

    showPanel(panel) {
        if (!panel) panel = this.currentPanel;
        this.currentPanel = panel;

        for (let x of this.panels) {
            if (x == panel)
                x.show();
            else
                x.hide();
        }
    }
}

class SidebarDisplay extends Display {
    constructor(container, sseq) {
        if (typeof container == "string")
            container = document.querySelector(container);

        container.style.display = "flex";
        container.style.displayDirection = "row";

        let child = document.createElement("div");
        child.style.height = "100%";
        child.style.minHeight = "100%";
        child.style.overflow = "hidden";
        child.style.position = "relative";
        child.style.flexGrow = "1";

        container.appendChild(child);

        let sidebar = new Sidebar(container)

        super(child, sseq);

        this.sidebar = sidebar;
        this.sidebar.init(this);
    }
}

exports.SidebarDisplay = SidebarDisplay;

},{"./Display.js":22,"./Panel.js":25}],28:[function(require,module,exports){
"use strict"

const MARGIN = 10;

class Tooltip {
    constructor(display) {
        this.display = display;

        this.div = document.createElement("div");
        this.div.style.opacity = 0;
        this.div.style.position = "absolute";
        this.div.style["z-index"] = 999999;
        this.div.className = "tooltip";

        document.body.appendChild(this.div);
    }

    setHTML(html) {
        this.div.innerHTML = html;
    }

    show(x, y) {
        /**
         * Reset the tooltip position. This prevents a bug that occurs when the
         * previously displayed tooltip is positioned near the edge (but still
         * positioned to the right of the node), and the new tooltip text is
         * longer than the previous tooltip text. This may cause the new
         * (undisplayed) tooltip text to wrap, which gives an incorrect value
         * of rect.width and rect.height. The bug also occurs after resizing,
         * where the location of the previous tooltip is now outside of the
         * window.
         */
        this.div.style.left = "0px";
        this.div.style.top = "0px";

        let rect = this.div.getBoundingClientRect();
        let canvasRect = this.display.canvas.getBoundingClientRect();

        x = x + canvasRect.x;
        y = y + canvasRect.y;

        /**
         * By default, show the tooltip to the top and right of (x, y), offset
         * by MARGIN. If this cuases the tooltip to leave the window, position
         * it to the bottom/left accordingly.
         */
        if (x + MARGIN + rect.width < window.innerWidth)
            x = x + MARGIN;
        else
            x = x - rect.width - MARGIN;

        if (y - rect.height - MARGIN > 0)
            y = y - rect.height - MARGIN;
        else
            y = y + MARGIN;

        this.div.style.left = `${x}px`;
        this.div.style.top = `${y}px`;

        this.div.style.transition = "opacity 200ms";
        this.div.style.opacity = 0.9;
    }

    hide () {
        this.div.style.transition = "opacity 500ms";
        this.div.style.opacity = 0;
    }
}

exports.Tooltip = Tooltip;

},{}],29:[function(require,module,exports){
exports.BasicDisplay = require("./BasicDisplay.js").BasicDisplay;
exports.Display = require("./Display.js").Display;
exports.EditorDisplay = require("./EditorDisplay.js").EditorDisplay;
exports.Interface = require("./Interface");
exports.IO = require("./SaveLoad");
    exports.sseqDatabase = exports.IO.sseqDatabase;
exports.SidebarDisplay = require("./SidebarDisplay.js").SidebarDisplay;
exports.Tooltip = require("./Tooltip.js").Tooltip;
exports.Panel = require("./Panel.js");
// exports.EditMode = require("./EditMode.js").EditMode;
},{"./BasicDisplay.js":21,"./Display.js":22,"./EditorDisplay.js":23,"./Interface":24,"./Panel.js":25,"./SaveLoad":26,"./SidebarDisplay.js":27,"./Tooltip.js":28}],30:[function(require,module,exports){
exports.INFINITY = require("./infinity.js").INFINITY;

exports.mod = function(n,d){
    return (n % d + d)%d;
};

// window.Util = require("./sseq/Util.js");

exports.C2S = require("canvas2svg");
exports.EventEmitter = require("events");


exports.interface = require("./interface/mod.js");
exports.spectralsequences = require("./sseq/mod.js");
exports.SpectralSequenceSocketListener = require("./spectralsequence_socket_listener.js").SpectralSequenceSocketListener;


exports.d3 = require("d3-selection");
exports.Mousetrap = require("mousetrap");

},{"./infinity.js":20,"./interface/mod.js":29,"./spectralsequence_socket_listener.js":32,"./sseq/mod.js":38,"canvas2svg":1,"d3-selection":10,"events":16,"mousetrap":18}],31:[function(require,module,exports){
let webclient = require("./lib.js")

window.infinity = webclient.infinity;
window.mod = function(n,d){
    return (n % d + d)%d;
};

// window.Util = require("./sseq/Util.js");

window.C2S = require("canvas2svg");
window.EventEmitter = require("events");


window.Interface = webclient.interface;
window.IO = webclient.interface.IO;
window.BasicDisplay = webclient.interface.BasicDisplay;

window.spectralsequences = webclient.spectralsequences;
window.SpectralSequenceChart = webclient.spectralsequences.SpectralSequenceChart;
window.ChartShape = webclient.spectralsequences.ChartShape;
window.ChartNode = webclient.spectralsequences.ChartNode;
window.ChartClass = webclient.spectralsequences.ChartClass;
window.ChartEdge = webclient.spectralsequences.ChartEdge;
window.ChartStructline = webclient.spectralsequences.ChartStructline;
window.ChartDifferential = webclient.spectralsequences.ChartDifferential;
window.ChartExtension = webclient.spectralsequences.ChartExtension;

window.SpectralSequenceSocketListener = webclient.SpectralSequenceSocketListener;


window.d3 = webclient.d3;
window.Mousetrap = webclient.Mousetrap;

},{"./lib.js":30,"canvas2svg":1,"events":16}],32:[function(require,module,exports){
class BadMessageError extends TypeError {
    constructor(...args) {
        super(...args)
        this.name = this.constructor.name;
        this.stack = this.stack.split("\n").slice(1).join("\n")
    }
}

class UnknownCommandError extends BadMessageError {
    constructor(...args) {
        super(...args)
        this.name = this.constructor.name;
        this.stack = this.stack.split("\n").slice(1).join("\n")
    }
}

class InvalidCommandError extends BadMessageError {
    constructor(...args) {
        super(...args)
        this.name = this.constructor.name;
        this.stack = this.stack.split("\n").slice(1).join("\n")
    }
}


class UnknownDisplayCommandError extends UnknownCommandError {
    constructor(...args) {
        super(...args)
        this.name = this.constructor.name;
        this.stack = this.stack.split("\n").slice(1).join("\n")
    }
}

class SpectralSequenceSocketListener {
    constructor(websocket, make_display) {
        this.websocket = websocket;
        this.websocket.onmessage = this.onmessage.bind(this);
        this.websocket.onopen = this.onopen.bind(this);
        this.make_display = make_display;
        this.display = undefined;
        this.sseq = undefined;
        this.message_dispatch = {};
        this.add_message_handlers_from_object(default_message_handlers);
        this.debug_mode = false;
    }

    add_message_handlers_from_object(handlers) {
        for(let [cmd_filter, handler] of Object.entries(handlers)) {
            this.add_message_handler(cmd_filter, handler);
        }
    }

    add_message_handler(cmd_filter, handler) {
        this.message_dispatch[cmd_filter] = handler.bind(this);
    }

    start() {
        console.log("client ready");
        this.client_ready = true;
        if(this.socket_ready) {
            this.send_introduction_message();
        }
    }

    onopen(event) {
        console.log("socket opened");
        this.socket_ready = true;
        if(this.client_ready){
            this.send_introduction_message();
        }
    }

    send_introduction_message(){
        console.log("send_introduction_message");
        this.send("new_user", {});
    }

    onmessage(event) {
        let msg = JSON.parse(event.data);
        this.handle_message_dispatch(msg);
    }


    display_click_handler(cls, x, y) { 
        this.send("click", { "chart_class" : cls, "x" : x, "y" : y });
    }
    

    send(cmd, kwargs) { // args parameter?
        let args = []
        console.log("send message", cmd, kwargs);
        // if(args === undefined || kwargs === undefined) {
        //     throw TypeError(`Send with missing arguments.`);
        // }
        // if(args.constructor !== Array){
        //     throw TypeError(`Argument "args" expected to have type "Array" not "${args.constructor.name}"`);
        // }
        if(kwargs.constructor !== Object){
            throw TypeError(`Argument "kwargs" expected to have type "Array" not "${kwargs.constructor.name}"`);
        }            
        if("cmd" in kwargs) {
            throw ValueError(`Tried to send message with top level "cmd" key`);
        }
        let obj = { "cmd" : cmd, "args" : args, "kwargs" : kwargs };
        let json_str = JSON.stringify(obj);
        this.websocket.send(json_str);
    }

    console_log_if_debug(msg) {
        if(this.debug_mode) {
            console.log(msg);
        }
    }
    
    debug(type, text, orig_msg) {
        let cmd = "debug";
        if(type !== ""){
            cmd += `.${type}`
        }            
        this.send("debug", {
            "type" : type,
            "text" : text, 
            "orig_msg" : orig_msg
        });
    }

    info(type, text, orig_msg) {
        let cmd = "info";
        if(type !== ""){
            cmd += `.${type}`
        }
        this.send(cmd, {
            "type" : type,
            "text" : text, 
            "orig_msg" : orig_msg
        });
    }

    warning(type, text, orig_msg, stack_trace) {
        let cmd = "warning";
        if(type !== ""){
            cmd += `.${type}`
        }
        this.send(cmd, {
            "type" : type,
            "text" : text, 
            "orig_msg" : orig_msg,
            "stack_trace" : stack_trace
        });
    }

    error(type, msg) {
        let cmd = "error.client";
        if(type !== ""){
            cmd += `.${type}`
        }
        this.send(cmd, msg);
    }

    log_exception(error, orig_msg) {
        // For some reason JSON.stringify(error) drops the "message" field by default.
        // We move it to "msg" to avoid that.
        error.msg = error.message; 
        this.error(error.name, 
            {
                "exception" : error,
                "orig_msg" : orig_msg,
            }
        );
        console.error(error);
    }


    set_display_state(kwargs) {
        if("background_color" in kwargs){
            this.display.setBackgroundColor(kwargs.background_color);
        }
    }

    handle_message_dispatch(msg) {
        this.console_log_if_debug(msg);
        let succeeded = true;
        let error;
        try {
            if(msg.cmd === undefined) {
                throw new UnknownCommandError(`Console sent message missing "cmd" field.`);
            }
    
            if(msg.cmd.constructor != Array){
                throw new InvalidCommandError(
                    `"msg.cmd" should have type "Array" not "${msg.cmd.constructor.name}."`
                );
            }
    
            if(msg.args === undefined) {
                throw new InvalidCommandError(
                    `Message is missing the "args" field.`
                );
            }
            
            if(msg.kwargs === undefined) {
                throw new InvalidCommandError(
                    `Message is missing the "kwargs" field.`
                );
            }
    
            let key = undefined;
            for(let partial_cmd of msg.cmd) {
                if(this.message_dispatch[partial_cmd] !== undefined){
                    key = partial_cmd; 
                    break;
                }
            }
            this.console_log_if_debug("cmd", msg.cmd, "key", key);
            this.console_log_if_debug("received message","cmd", msg.cmd, "key", key);
            if(key === undefined) {
                throw new UnknownCommandError(`Console sent unknown command "${msg.cmd[0]}".`);
            }
            this.message_dispatch[key](msg.cmd, msg.args, msg.kwargs);
        } catch(err) {
            succeeded = false;
            error = err;
        }
    
        if(!succeeded) {
            this.console_log_if_debug(error);
            this.log_exception(error, msg);
        }
    }    
}


let default_message_handlers = {
    "initialize.chart.state" : function(cmd, args, kwargs) {
        this.console_log_if_debug("accepted user:", kwargs.state);
        this.sseq = SpectralSequenceChart.from_JSON(kwargs.state);
        this.display = this.make_display(this.sseq);
        this.display.y_clip_offset = this.sseq.y_clip_offset;
        this.set_display_state(kwargs.display_state)
        this.display.on("click", this.display_click_handler.bind(this));
        this.send("initialize.complete", {});
        // if(kwargs.display_state) {
        //     set_display_settings(kwargs.display_state);
        // }
        // let sseq = new SpectralSequenceChart();
        // Object.assign(sseq, msg.state)
    },

    "chart.batched" : function(cmd, args, kwargs) {
        for(msg of kwargs.messages) {
            this.handle_message_dispatch(msg);
        }
        this.display.update()
    },
    
    "chart.state.reset" : function(cmd, args, kwargs) {
        this.console_log_if_debug("accepted user:", kwargs.state);
        this.sseq = SpectralSequenceChart.from_JSON(kwargs.state);
        if(kwargs.display_state !== undefined){
            this.set_display_state(kwargs.display_state);
        }
        this.display.y_clip_offset = this.sseq.y_clip_offset;
        this.display.setSseq(this.sseq);
        // this.display.on("click", this.display_click_handler.bind(this));
        // this.send("initialize.complete", {});
        // if(kwargs.display_state) {
        //     set_display_settings(kwargs.display_state);
        // }
        // let sseq = new SpectralSequenceChart();
        // Object.assign(sseq, msg.state)
    },

    "chart.set_x_range" : function(cmd, args, kwargs){
        this.sseq.x_range = [kwargs.x_min, kwargs.x_max];
    },
    "chart.set_y_range" : function(cmd, args, kwargs){
        this.sseq.y_range = [kwargs.y_min, kwargs.y_max];
    },
    "chart.set_initial_x_range" : function(cmd, args, kwargs){
        this.sseq.initial_x_range = [kwargs.x_min, kwargs.x_max];
    },
    "chart.set_initial_y_range" : function(cmd, args, kwargs){
        this.sseq.initial_y_range = [kwargs.y_min, kwargs.y_max];
    },    
    "chart.insert_page_range" : function(cmd, args, kwargs) {
        this.sseq.page_list.splice(kwargs.idx, 0, kwargs.page_range);
    },

    "chart.node.add" : function(cmd, args, kwargs) {
        this.console_log_if_debug("add node", cmd, kwargs)
        // this.info(msg);
    },

    "chart.class.add" : function(cmd, args, kwargs) {
        let c = this.sseq.add_class(kwargs.new_class);
        this.display.update();
    },

    "chart.class.update" : function(cmd, args, kwargs) {
        let c = kwargs.class_to_update;
        Object.assign(this.sseq.classes[c.uuid], c);
        // this.display.update();
    },

    "chart.class.set_name" : function(cmd, args, kwargs) {
        let [x,y,idx] = load_args({
            "x" : Number.isInteger, 
            "y" : Number.isInteger, 
            "idx" : Number.isInteger
        });
        this.sseq.classes_by_degree.get([kwargs.x, msg.arguments.y])[msg.arguments.idx].name = msg.arguments.name;
    },

    "chart.edge.add" : function(cmd, args, kwargs) {
        this.console_log_if_debug(kwargs);
        this.sseq.add_edge(kwargs);
        // this.display.update();
    },

    "chart.edge.update" : function(cmd, args, kwargs) {
        this.console_log_if_debug(kwargs);
        let e = kwargs.edge_to_update;
        Object.assign(this.sseq.edges[e.uuid], e);
        // this.display.update();
    },

    "display.set_background_color" : function(cmd, args, kwargs) {
        this.display.setBackgroundColor(kwargs.color);
    },

    "interact.alert" : function(cmd, args, kwargs) {
        alert(kwargs.msg);
    },
    "interact.prompt" : function(cmd, args, kwargs) {
        let result = prompt(kwargs.msg, kwargs.default);
        this.send("interact.result", {"result" : result});
    }
};

exports.SpectralSequenceSocketListener = SpectralSequenceSocketListener;
},{}],33:[function(require,module,exports){
let utils = require("./utils.js");
let ChartShape = require("./ChartShape.js").ChartShape;

class ChartClass {
    constructor(sseq, kwargs) {
        this._sseq = sseq;
        this._valid = true;
        this._x_offset = 0;
        this._y_offset = 0;
        
        // utils.assign_fields(this, kwargs, [
        //     { "type" : "mandatory", "field" : "x" },
        //     { "type" : "mandatory", "field" : "y" },
        //     { "type" : "optional", "field" : "idx" },
        //     { "type" : "default",   "field" : "name",             "default" : "" },
        //     { "type" : "default",   "field" : "transition_pages", "default" : [] },
        //     { "type" : "mandatory", "field" : "node_list" },
        //     { "type" : "default",   "field" : "transition_pages", "default" : [] },
        //     { "type" : "default",   "field" : "visible",          "default" : true },
        //     { "type" : "optional",  "field" : "xoffset" },
        //     { "type" : "optional",  "field" : "yoffset" },
        //     { "type" : "optional",  "field" : "tooltip" },
        //     { "type" : "optional",  "field" : "uuid" },
        // ]);
        
        // TODO: new utils function that ensures no "_" fields present, raises error "bad serialized class".
        Object.assign(this, kwargs);
    }

    setPosition(x, y, size) {
        if(isNaN(x) || isNaN(y) || isNaN(size)){
            console.error(this, x, y, size);
            throw "class.setPosition called with bad argument.";
        }
        this._canvas_x = x;
        this._canvas_y = y;
        this._size = size;
    }

    draw(context) {
        let node = this._node;
        context.save();

        if(node.opacity) {
            context.opacity = node.opacity;
        }

        if(node.color) {
            context.fillStyle = node.color;
            context.strokeStyle = node.color;
        }

        if(node.stroke && node.stroke !== true) {
            context.strokeStyle = node.stroke;
        }

        if(node.fill && node.fill !== true) {
            context.fillStyle = node.fill;
        }

        if(node.highlight) {
            if(node.hcolor) {
                context.fillStyle = node.hcolor;
                context.strokeStyle = node.hcolor;
            }

            if(node.hstroke) {
                context.strokeStyle = node.hstroke;
            }

            if(node.hfill) {
                context.fillStyle = node.hfill;
            }
        }
        context.lineWidth = Math.min(3, node.size * node.scale / 20); // Magic number
        this._path = ChartShape.draw(node.shape, context, this._canvas_x, this._canvas_y, this._size * node.scale, node);
        context.restore();
    }

    _drawOnPageQ(page){
        let idx = this._getPageIndex(page);
        return this.node_list[idx] != null && this.visible;
    }

    _inRangeQ(xmin, xmax, ymin, ymax){
        return xmin <= this.x && this.x <= xmax && ymin <= this.y && this.y <= ymax;
    }

    _getPageIndex(page){
        if( page === undefined ) {
            return this.node_list.length - 1;
        } else if( page === this._last_page ) {
            return this._last_page_idx;
        }
        let page_idx = this.transition_pages.length;
        for(let i = 0; i < this.transition_pages.length; i++){
            if(this.transition_pages[i] >= page){
                page_idx = i;
                break;
            }
        }
        this._last_page = page;
        this._last_page_idx = page_idx;
        return page_idx;
    }

    getNameCoord(){
        let tooltip = "";
        if (this.name !== "") {
            tooltip = `\\(\\large ${this.name}\\)&nbsp;&mdash;&nbsp;`;
        }
        tooltip += `(${this.x}, ${this.y})`;
        return tooltip;
    }

    getXOffset() {
        let x_offset;
        let classes = this._sseq.classes_by_degree.get([this.x, this.y]);
        let num_classes = classes.length;
        let idx = this.idx;
        let out = (idx - (num_classes - 1) / 2) * this._sseq.offset_size;
        if (isNaN(out)) {
            console.error("Invalid offset for class:", this);
            x_offset = 0;
        } else {
            x_offset = out; 
        }

        let x_nudge = this.x_nudge ? this.x_nudge : 0;
        return x_offset + x_nudge;
    }

    getYOffset() {
        let y_offset = 0;
        let y_nudge = this.y_nudge ? this.y_nudge : 0;
        return y_offset + y_nudge;
    }

    toJSON() {
        return utils.public_fields(this);
    }
}

exports.ChartClass = ChartClass;
},{"./ChartShape.js":36,"./utils.js":39}],34:[function(require,module,exports){
let utils = require("./utils.js");
let INFINITY = require("../infinity.js").INFINITY;

class ChartEdge {
    constructor(type, kwargs) {
        this.type = type;
        if(!"source" in kwargs){
            throw Error(`Edge is missing argument "source".`);
        }
        if(!"target" in kwargs){
            throw Error(`Edge is missing argument "target".`);
        }
        if(!"visible" in kwargs) {
            this.visible = true;
        }
        Object.assign(this, kwargs);
        // utils.assign_fields(this, kwargs, [
        //     { "type" : "mandatory", "field" : "source"},
        //     { "type" : "mandatory", "field" : "target"},
        //     { "type" : "default", "field" : "visible", "default" : true},
        //     { "type" : "optional", "field" : "color"},
        //     { "type" : "optional", "field" : "opacity"},
        //     { "type" : "optional", "field" : "bend"},
        //     { "type" : "optional", "field" : "control_points"},
        //     { "type" : "optional", "field" : "arrow_type"},
        // ])
    }

    _drawOnPageQ(pageRange){
        let max_page = this.max_page || INFINITY;
        let min_page = this.min_page || 0;
        return pageRange[0] <= max_page && min_page <= pageRange[0];
    }

    toJSON() {
        return utils.public_fields(this);
    }
}

class ChartDifferential extends ChartEdge {
    constructor(kwargs){
        super("differential", kwargs);
        utils.assign_kwarg_mandatory(this, kwargs, "page");
    }

    _drawOnPageQ(pageRange){
        return pageRange[0] === 0 || (pageRange[0] <= this.page && this.page <= pageRange[1]);
    }    
}

class ChartStructline extends ChartEdge {
    constructor(kwargs){
        super("structline", kwargs);
        if(this.max_page === undefined) {
            this.max_page = INFINITY;
        }
        if(this.min_page === undefined) {
            this.min_page = 0;
        }        
    }

    _drawOnPageQ(pageRange){
        return pageRange[0] <= this.max_page && this.min_page <= pageRange[0];
    }
}

class ChartExtension extends ChartEdge {
    constructor(kwargs){
        super("extension", kwargs);
    }

    _drawOnPageQ(pageRange){
        return pageRange[0] === INFINITY;
    }

}

exports.ChartEdge = ChartEdge;
exports.ChartDifferential = ChartDifferential;
exports.ChartStructline = ChartStructline;
exports.ChartExtension = ChartExtension;
},{"../infinity.js":20,"./utils.js":39}],35:[function(require,module,exports){
let utils = require("./utils.js");

class ChartNode {
    constructor(kwargs) {
        utils.assign_fields(this, kwargs, [
            { "type" : "mandatory", "field" : "shape"},
            { "type" : "default", "field" : "scale", "default" : 1},
            { "type" : "optional", "field" : "fill"},
            { "type" : "optional", "field" : "stroke"},
            { "type" : "optional", "field" : "color"},
            { "type" : "optional", "field" : "opacity"},            
        ]);
    }

    toJSON() {
        return utils.public_fields(this);
    }
}

exports.ChartNode = ChartNode;
},{"./utils.js":39}],36:[function(require,module,exports){
"use strict";

class ChartShape {
    static draw(shape, ...rest) {
        return Shapes[shape].draw(...rest);
    }
}

exports.ChartShape = ChartShape;

let Shapes = {};

Shapes.circle = {
    draw: function(context, x, y, size, path2d=true) {
        context.beginPath();
        context.arc(x, y, size * 0.1, 0, 2*Math.PI);
        context.fill();
        context.stroke();

        let path = new Path2D();
        path.arc(x, y, size * 0.2, 0, 2 * Math.PI);
        return path;
    }
}


Shapes.circlen = {
    draw: function(context, x, y, size, node) {
        context.beginPath();
        context.arc(x, y, size * 0.1, 0, 2*Math.PI);
        context.fill();
        context.stroke();

        context.textAlign = "center";
        context.fillStyle = "black";
        let fontsize = 0.15*size | 0;
        context.font = `${fontsize}px Arial`;
        context.fillText(node.order, x, y + size*0.06);

        let path = new Path2D();
        path.arc(x, y, size * 0.2, 0, 2 * Math.PI);

        return path;
    }
};

Shapes.square = {
    draw: function(context, x, y, size) {
        let hwidth = 0.1 * size;

        context.beginPath();
        context.rect(x - hwidth, y - hwidth, 2*hwidth, 2*hwidth);
        context.fill();
        context.stroke();

        let path = new Path2D();
        path.rect(x - 2*hwidth, y - 2*hwidth, 4*hwidth, 4*hwidth);

        return path;
    }
}

for(let k of Object.getOwnPropertyNames(Shapes)){
    Shapes[k].name = k;
    exports[k] = Shapes[k];
}

},{}],37:[function(require,module,exports){
let StringifyingMap = require("../StringifyingMap.js");
let ChartNode = require("./ChartNode.js").ChartNode;
let ChartClass = require("./ChartClass.js").ChartClass;
let ChartEdgeJS = require("./ChartEdge.js");
let ChartEdge = ChartEdgeJS.ChartEdge;
let ChartDifferential = ChartEdgeJS.ChartDifferential;
let ChartStructline = ChartEdgeJS.ChartStructline;
let ChartExtension = ChartEdgeJS.ChartExtension;
let EventEmitter = require('events');

function check_argument_is_integer(name, value){
    if(!Number.isInteger(value)) {
        throw TypeError(`Argument "${name}" is ${x} which is not an integer. "${name}" is expected to be an integer.`);
    }
}

/**
 * Adds an entry to a map keys ==> lists.
 * If the current key isn't present in the map, add an empty list first.
 * @param dictionary The dictionary of lists to add the entry to
 * @param key
 * @param value
 */
function add_to_dictionary_of_lists(dictionary, key,value){
    if(!dictionary.has(key)){
        dictionary.set(key, []);
    }
    dictionary.get(key).push(value);
}

function filter_dictionary_of_lists(dictionary, key,callback){
    if(!dictionary.has(key)){
        dictionary.set(key, []);
    }
    dictionary.set(dictionary.get(key).filter(callback));
}

class SpectralSequenceChart extends EventEmitter {
    constructor() {
        super();
        this.offset_size = 8;
        this.min_class_size = 1;
        this.max_class_size = 3;
        this.class_scale = 10;
        this.classes_by_degree = new StringifyingMap();
        this.classes = [];
        this.edges = [];
        this.nodes = [];

        this.page_list = [2];
        this.min_page_idx = 0;

        this.x_range = [0, 10];
        this.y_range = [0, 10];
        this.initial_x_range = [0, 10];
        this.initial_y_range = [0, 10];
        this.next_uuid = 0;
    }

    static from_JSON(json) {
        let chart = new SpectralSequenceChart();

        if(json.nodes === undefined) {
            throw ReferenceError("json.nodes is undefined.");
        }

        if(json.classes === undefined) {
            throw ReferenceError("json.classes is undefined.");
        }

        if(json.edges === undefined) {
            throw ReferenceError("json.edges is undefined.");
        }
        
        // Make sure to assign fields to chart first in case they are used in process of add_class, add_edge.
        Object.assign(chart, json);

        chart.nodes = chart.nodes.map(n => new ChartNode(n));
        let json_classes = chart.classes;
        let json_edges = chart.edges;
        chart.classes = {};
        chart.edges = {};
        

        for(let [id, c] of Object.entries(json_classes)){ // in iterates over object keys.
            chart.classes[id] = chart.add_class(c);
        }
        for(let [id, e] of Object.entries(json_edges)){
            chart.edges[id] = chart.add_edge(e)
        }
        

        return chart;
    }

    class_by_degree_and_index(x, y, idx){
        check_argument_is_integer("x", x);
        check_argument_is_integer("y", y);
        check_argument_is_integer("idx", idx);
        if(!this.classes_by_degree.has([x,y])){
            throw Error(`No classes exist in bidegree (${x}, ${y}).`);
        }
        let classes = this.classes_by_degree.get([x, y]);
        if(idx >= classes.length) {
            throw Error(`Fewer than ${idx} classes exist in bidegree (${x}, ${y}).`);
        }
        return classes[idx];
    }

    add_class(kwargs) {
        let c = new ChartClass(this, kwargs);
        if("uuid" in kwargs){
            c.uuid = kwargs["uuid"]
        } else {
            c.uuid = this.next_uuid;
            this.next_uuid++;
        }
        let degree = [c.x, c.y];
        this.classes[c.uuid] = c;
        filter_dictionary_of_lists(this.classes_by_degree, degree, c => c._valid);
        if(c.idx === undefined){
            c.idx = this.classes_by_degree.get(degree).length;
        }
        add_to_dictionary_of_lists(this.classes_by_degree, degree, c);
        this.emit("class-added", c);
        this.emit("update");
        return c;
    }

    add_edge(kwargs) {
        let edge_type = kwargs["type"];
        switch(edge_type) {
            case ChartDifferential.name:
                return this.add_differential(kwargs);
            case ChartStructline.name:
                return this.add_structline(kwargs);
            case ChartExtension.name:
                return this.add_extension(kwargs);
            default:
                throw TypeError(`Argument "type" expected to contain one of "${ChartDifferential.name}" \
                                 "${ChartStructline.name}", or "${ChartExtension.name}", not "${edge_type}".`);
        }
    }

    add_differential(kwargs) {
        let e = new ChartDifferential(kwargs);
        if("uuid" in kwargs){
            e.uuid = kwargs["uuid"];
        } else {
            e.uuid = this.next_uuid;
            this.next_uuid++;
        }
        this.edges[e["uuid"]] = e;
        this.emit("differential-added", e);
        this.emit("edge-added", e);
        this.emit("update");
        return e;
    }

    add_structline(kwargs) {
        let e = new ChartStructline(kwargs);
        if("uuid" in kwargs){
            e.uuid = kwargs["uuid"];
        } else {
            e.uuid = this.next_uuid;
            this.next_uuid++;
        }
        this.edges[e.uuid] = e;
        this.emit("structline-added", e);
        this.emit("edge-added", e);
        this.emit("update");
        return e;
    }

    add_extension(kwargs) {
        let e = new ChartExtension(kwargs);
        if("uuid" in kwargs){
            e.uuid = kwargs["uuid"];
        } else {
            e.uuid = this.next_uuid;
            this.next_uuid++;
        }
        this.edges[e.uuid] = e;
        this.emit("extension-added", e);
        this.emit("edge-added", e);
        this.emit("update");
        return e;    
    }

    /**
     * Gets the node to be drawn for the class on the given page. Used primarily by display.
     * @param c
     * @param page
     * @returns {*}
     */
    getClassNode(c, page) {
        let node_or_idx = c.node_list[c._getPageIndex(page)];
        if(node_or_idx.constructor === Number) {
            node_or_idx = this.nodes[node_or_idx];
        }
        return node_or_idx;
    }

    getElementsToDraw(page, xmin, xmax, ymin, ymax) {
        // Util.checkArgumentsDefined(SpectralSequenceChart.prototype.getDrawnElements, arguments);
        let pageRange;
        // TODO: clean up pageRange. Probably we should always pass pages as pairs?
        if(Array.isArray(page)) {
            pageRange = page;
            page = page[0];
        } else {
            pageRange = [page, page];
        }
        let display_classes = Object.values(this.classes).filter(c => {
            if (!c || c.invalid) {
                return false;
            }
            return c._inRangeQ(xmin, xmax, ymin, ymax) && c._drawOnPageQ(page);
        });

        // Maybe move this elsewhere...
        for (let e of Object.values(this.edges)) {
            e._source = this.classes[e.source];
            e._target = this.classes[e.target];
        }

        // Display edges such that
        // 1) e is a valid edge
        // 2) e is supposed to be drawn on the current pageRange.
        // 3) e.source and e.target are supposed to be drawn on the current pageRange
        // 4) At least one of the source or target is in bounds.
        let display_edges = Object.values(this.edges).filter(e =>
            e && !e.invalid && 
            e._drawOnPageQ(pageRange)
            && e._source._drawOnPageQ(page) 
            && e._target._drawOnPageQ(page)
            && (e._source._inRangeQ(xmin, xmax, ymin, ymax) || e._target._inRangeQ(xmin, xmax, ymin, ymax))
        );

        // We need to go back and make sure that for every edge we are planning to  draw, we draw both its source and
        // target even if one of them is out of bounds. Check for out of bounds sources / targets and add them to the
        // list of edges to draw.
        for (let e of display_edges) {
            if (!e._source.in_range) {
                display_classes.push(e._source);
                e._source._in_range = true;
            }
            if (!e._target.in_range) {
                e._target._in_range = true;
                display_classes.push(e._target);
            }
        }

        for(let c of display_classes) {
            let node = this.getClassNode(c, page);
            if(node === undefined) {
                console.error("Undefined node for:", c);
                throw ReferenceError(`Undefined node on page ${page} for class: ${c}`);
            }
            c._node = node;
        }

        // for (let e of display_edges) {
        //     e.source_node = e.source.node;
        //     e.target_node = e.target.node;
        // }
        return [display_classes, display_edges];
    }
}

exports.SpectralSequenceChart = SpectralSequenceChart;
},{"../StringifyingMap.js":19,"./ChartClass.js":33,"./ChartEdge.js":34,"./ChartNode.js":35,"events":16}],38:[function(require,module,exports){
exports.Shapes = require("./ChartShape.js");
exports.ChartNode = require("./ChartNode.js").ChartNode;
exports.ChartClass = require("./ChartClass.js").ChartClass;
let ChartEdgejs = require("./ChartEdge.js")
exports.ChartEdge = ChartEdgejs.ChartEdge;
exports.ChartDifferential = ChartEdgejs.ChartDifferential;
exports.ChartStructline = ChartEdgejs.ChartStructline;
exports.ChartExtension = ChartEdgejs.ChartExtension;
exports.SpectralSequenceChart = require("./SpectralSequenceChart.js").SpectralSequenceChart;

},{"./ChartClass.js":33,"./ChartEdge.js":34,"./ChartNode.js":35,"./ChartShape.js":36,"./SpectralSequenceChart.js":37}],39:[function(require,module,exports){
function KeyError(message) {
    this.message = message;
    this.name = 'KeyError';
    console.error(message);
}

exports.assign_fields = function assign_fields(obj, kwargs, fields) {
    for(let field of fields) {
        switch(field["type"]) {
            case "mandatory":
                exports.assign_kwarg_mandatory(obj, kwargs, field["field"]);
                break;
            case "optional":
                exports.assign_kwarg_optional(obj, kwargs, field["field"]);
                break;
            case "default":
                exports.assign_kwarg_default(obj, kwargs, field["field"], field["default"]);
                break;
            default:
                throw new KeyError(`Unknown field type ${field["type"]}`);
        }
    }
}

exports.assign_kwarg_mandatory = function assign_kwarg_mandatory(obj, kwargs, field) {
    if(field === undefined) {
        throw new TypeError("field is undefined.")
    }
    if(kwargs === undefined){
        throw new TypeError("kwargs is undefined.");
    }
    if(kwargs[field] === undefined) {
        throw new KeyError(`Argument kwargs is missing mandatory field ${field}. kwargs is : ${JSON.stringify(kwargs)}`);
    } else {
        obj[field] = kwargs[field];
    }
}

exports.assign_kwarg_optional = function assign_kwarg_optional(obj, kwargs, field) {
    if(field === undefined) {
        throw new TypeError("field is undefined.")
    }    
    if(kwargs === undefined){
        throw new KeyError("kwargs is undefined!");
    }
    if(kwargs[field] === undefined) {

    } else {
        obj[field] = kwargs[field]
    }
}


exports.assign_kwarg_default = function assign_kwarg_default(obj, kwargs, field, default_value) {
    if(field === undefined) {
        throw new TypeError("field is undefined.")
    }    
    if(kwargs === undefined) {
        throw new KeyError("kwargs is undefined!");
    }
    if(kwargs[field] === undefined) {
        obj[field] = default_value
    } else {
        obj[field] = kwargs[field]
    }
}

exports.public_fields = function public_fields(obj){
    result = {};
    for(let [key, value] of Object.entries(obj)) {
        if(!key.startsWith("_")){
            result[key] = value;
        }
    }
    return result;
}
},{}]},{},[31])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY2FudmFzMnN2Zy9jYW52YXMyc3ZnLmpzIiwibm9kZV9tb2R1bGVzL2QzLWFycmF5L2Rpc3QvZDMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvZDMtY29sb3IvZGlzdC9kMy1jb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9kaXN0L2QzLWRpc3BhdGNoLmpzIiwibm9kZV9tb2R1bGVzL2QzLWRyYWcvZGlzdC9kMy1kcmFnLmpzIiwibm9kZV9tb2R1bGVzL2QzLWVhc2UvZGlzdC9kMy1lYXNlLmpzIiwibm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9kaXN0L2QzLWZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9kaXN0L2QzLWludGVycG9sYXRlLmpzIiwibm9kZV9tb2R1bGVzL2QzLXNjYWxlL2Rpc3QvZDMtc2NhbGUuanMiLCJub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL2Rpc3QvZDMtc2VsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2QzLXRpbWUtZm9ybWF0L2Rpc3QvZDMtdGltZS1mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZDMtdGltZS9kaXN0L2QzLXRpbWUuanMiLCJub2RlX21vZHVsZXMvZDMtdGltZXIvZGlzdC9kMy10aW1lci5qcyIsIm5vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL2Rpc3QvZDMtdHJhbnNpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9kMy16b29tL2Rpc3QvZDMtem9vbS5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L2Rpc3Qva2F0ZXguanMiLCJub2RlX21vZHVsZXMvbW91c2V0cmFwL21vdXNldHJhcC5qcyIsInNyYy9TdHJpbmdpZnlpbmdNYXAuanMiLCJzcmMvaW5maW5pdHkuanMiLCJzcmMvaW50ZXJmYWNlL0Jhc2ljRGlzcGxheS5qcyIsInNyYy9pbnRlcmZhY2UvRGlzcGxheS5qcyIsInNyYy9pbnRlcmZhY2UvRWRpdG9yRGlzcGxheS5qcyIsInNyYy9pbnRlcmZhY2UvSW50ZXJmYWNlLmpzIiwic3JjL2ludGVyZmFjZS9QYW5lbC5qcyIsInNyYy9pbnRlcmZhY2UvU2F2ZUxvYWQuanMiLCJzcmMvaW50ZXJmYWNlL1NpZGViYXJEaXNwbGF5LmpzIiwic3JjL2ludGVyZmFjZS9Ub29sdGlwLmpzIiwic3JjL2ludGVyZmFjZS9tb2QuanMiLCJzcmMvbGliLmpzIiwic3JjL21haW4uanMiLCJzcmMvc3BlY3RyYWxzZXF1ZW5jZV9zb2NrZXRfbGlzdGVuZXIuanMiLCJzcmMvc3NlcS9DaGFydENsYXNzLmpzIiwic3JjL3NzZXEvQ2hhcnRFZGdlLmpzIiwic3JjL3NzZXEvQ2hhcnROb2RlLmpzIiwic3JjL3NzZXEvQ2hhcnRTaGFwZS5qcyIsInNyYy9zc2VxL1NwZWN0cmFsU2VxdWVuY2VDaGFydC5qcyIsInNyYy9zc2VxL21vZC5qcyIsInNyYy9zc2VxL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbG1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNydkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3OUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4NmdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3owQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvKiEhXG4gKiAgQ2FudmFzIDIgU3ZnIHYxLjAuMTVcbiAqICBBIGxvdyBsZXZlbCBjYW52YXMgdG8gU1ZHIGNvbnZlcnRlci4gVXNlcyBhIG1vY2sgY2FudmFzIGNvbnRleHQgdG8gYnVpbGQgYW4gU1ZHIGRvY3VtZW50LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXG4gKiAgQXV0aG9yOlxuICogIEtlcnJ5IExpdVxuICpcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTQgR2xpZmZ5IEluYy5cbiAqL1xuXG47KGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIFNUWUxFUywgY3R4LCBDYW52YXNHcmFkaWVudCwgQ2FudmFzUGF0dGVybiwgbmFtZWRFbnRpdGllcztcblxuICAgIC8vaGVscGVyIGZ1bmN0aW9uIHRvIGZvcm1hdCBhIHN0cmluZ1xuICAgIGZ1bmN0aW9uIGZvcm1hdChzdHIsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhcmdzKSwgaTtcbiAgICAgICAgZm9yIChpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFx7XCIgKyBrZXlzW2ldICsgXCJcXFxcfVwiLCBcImdpXCIpLCBhcmdzW2tleXNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8vaGVscGVyIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIGEgcmFuZG9tIHN0cmluZ1xuICAgIGZ1bmN0aW9uIHJhbmRvbVN0cmluZyhob2xkZXIpIHtcbiAgICAgICAgdmFyIGNoYXJzLCByYW5kb21zdHJpbmcsIGk7XG4gICAgICAgIGlmICghaG9sZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY3JlYXRlIGEgcmFuZG9tIGF0dHJpYnV0ZSBuYW1lIGZvciBhbiB1bmRlZmluZWQgb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hUWmFiY2RlZmdoaWtsbW5vcHFyc3R1dnd4eXpcIjtcbiAgICAgICAgcmFuZG9tc3RyaW5nID0gXCJcIjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmFuZG9tc3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmFuZG9tc3RyaW5nICs9IGNoYXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChob2xkZXJbcmFuZG9tc3RyaW5nXSk7XG4gICAgICAgIHJldHVybiByYW5kb21zdHJpbmc7XG4gICAgfVxuXG4gICAgLy9oZWxwZXIgZnVuY3Rpb24gdG8gbWFwIG5hbWVkIHRvIG51bWJlcmVkIGVudGl0aWVzXG4gICAgZnVuY3Rpb24gY3JlYXRlTmFtZWRUb051bWJlcmVkTG9va3VwKGl0ZW1zLCByYWRpeCkge1xuICAgICAgICB2YXIgaSwgZW50aXR5LCBsb29rdXAgPSB7fSwgYmFzZTEwLCBiYXNlMTY7XG4gICAgICAgIGl0ZW1zID0gaXRlbXMuc3BsaXQoJywnKTtcbiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgICAgICAgLy8gTWFwIGZyb20gbmFtZWQgdG8gbnVtYmVyZWQgZW50aXRpZXMuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgZW50aXR5ID0gJyYnICsgaXRlbXNbaSArIDFdICsgJzsnO1xuICAgICAgICAgICAgYmFzZTEwID0gcGFyc2VJbnQoaXRlbXNbaV0sIHJhZGl4KTtcbiAgICAgICAgICAgIGxvb2t1cFtlbnRpdHldID0gJyYjJytiYXNlMTArJzsnO1xuICAgICAgICB9XG4gICAgICAgIC8vRkYgYW5kIElFIG5lZWQgdG8gY3JlYXRlIGEgcmVnZXggZnJvbSBoZXggdmFsdWVzIGllICZuYnNwOyA9PSBcXHhhMFxuICAgICAgICBsb29rdXBbXCJcXFxceGEwXCJdID0gJyYjMTYwOyc7XG4gICAgICAgIHJldHVybiBsb29rdXA7XG4gICAgfVxuXG4gICAgLy9oZWxwZXIgZnVuY3Rpb24gdG8gbWFwIGNhbnZhcy10ZXh0QWxpZ24gdG8gc3ZnLXRleHRBbmNob3JcbiAgICBmdW5jdGlvbiBnZXRUZXh0QW5jaG9yKHRleHRBbGlnbikge1xuICAgICAgICAvL1RPRE86IHN1cHBvcnQgcnRsIGxhbmd1YWdlc1xuICAgICAgICB2YXIgbWFwcGluZyA9IHtcImxlZnRcIjpcInN0YXJ0XCIsIFwicmlnaHRcIjpcImVuZFwiLCBcImNlbnRlclwiOlwibWlkZGxlXCIsIFwic3RhcnRcIjpcInN0YXJ0XCIsIFwiZW5kXCI6XCJlbmRcIn07XG4gICAgICAgIHJldHVybiBtYXBwaW5nW3RleHRBbGlnbl0gfHwgbWFwcGluZy5zdGFydDtcbiAgICB9XG5cbiAgICAvL2hlbHBlciBmdW5jdGlvbiB0byBtYXAgY2FudmFzLXRleHRCYXNlbGluZSB0byBzdmctZG9taW5hbnRCYXNlbGluZVxuICAgIGZ1bmN0aW9uIGdldERvbWluYW50QmFzZWxpbmUodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIC8vSU5GTzogbm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnNcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB7XCJhbHBoYWJldGljXCI6IFwiYWxwaGFiZXRpY1wiLCBcImhhbmdpbmdcIjogXCJoYW5naW5nXCIsIFwidG9wXCI6XCJ0ZXh0LWJlZm9yZS1lZGdlXCIsIFwiYm90dG9tXCI6XCJ0ZXh0LWFmdGVyLWVkZ2VcIiwgXCJtaWRkbGVcIjpcImNlbnRyYWxcIn07XG4gICAgICAgIHJldHVybiBtYXBwaW5nW3RleHRCYXNlbGluZV0gfHwgbWFwcGluZy5hbHBoYWJldGljO1xuICAgIH1cblxuICAgIC8vIFVucGFjayBlbnRpdGllcyBsb29rdXAgd2hlcmUgdGhlIG51bWJlcnMgYXJlIGluIHJhZGl4IDMyIHRvIHJlZHVjZSB0aGUgc2l6ZVxuICAgIC8vIGVudGl0eSBtYXBwaW5nIGNvdXJ0ZXN5IG9mIHRpbnltY2VcbiAgICBuYW1lZEVudGl0aWVzID0gY3JlYXRlTmFtZWRUb051bWJlcmVkTG9va3VwKFxuICAgICAgICAnNTAsbmJzcCw1MSxpZXhjbCw1MixjZW50LDUzLHBvdW5kLDU0LGN1cnJlbiw1NSx5ZW4sNTYsYnJ2YmFyLDU3LHNlY3QsNTgsdW1sLDU5LGNvcHksJyArXG4gICAgICAgICAgICAnNWEsb3JkZiw1YixsYXF1byw1Yyxub3QsNWQsc2h5LDVlLHJlZyw1ZixtYWNyLDVnLGRlZyw1aCxwbHVzbW4sNWksc3VwMiw1aixzdXAzLDVrLGFjdXRlLCcgK1xuICAgICAgICAgICAgJzVsLG1pY3JvLDVtLHBhcmEsNW4sbWlkZG90LDVvLGNlZGlsLDVwLHN1cDEsNXEsb3JkbSw1cixyYXF1byw1cyxmcmFjMTQsNXQsZnJhYzEyLDV1LGZyYWMzNCwnICtcbiAgICAgICAgICAgICc1dixpcXVlc3QsNjAsQWdyYXZlLDYxLEFhY3V0ZSw2MixBY2lyYyw2MyxBdGlsZGUsNjQsQXVtbCw2NSxBcmluZyw2NixBRWxpZyw2NyxDY2VkaWwsJyArXG4gICAgICAgICAgICAnNjgsRWdyYXZlLDY5LEVhY3V0ZSw2YSxFY2lyYyw2YixFdW1sLDZjLElncmF2ZSw2ZCxJYWN1dGUsNmUsSWNpcmMsNmYsSXVtbCw2ZyxFVEgsNmgsTnRpbGRlLCcgK1xuICAgICAgICAgICAgJzZpLE9ncmF2ZSw2aixPYWN1dGUsNmssT2NpcmMsNmwsT3RpbGRlLDZtLE91bWwsNm4sdGltZXMsNm8sT3NsYXNoLDZwLFVncmF2ZSw2cSxVYWN1dGUsJyArXG4gICAgICAgICAgICAnNnIsVWNpcmMsNnMsVXVtbCw2dCxZYWN1dGUsNnUsVEhPUk4sNnYsc3psaWcsNzAsYWdyYXZlLDcxLGFhY3V0ZSw3MixhY2lyYyw3MyxhdGlsZGUsNzQsYXVtbCwnICtcbiAgICAgICAgICAgICc3NSxhcmluZyw3NixhZWxpZyw3NyxjY2VkaWwsNzgsZWdyYXZlLDc5LGVhY3V0ZSw3YSxlY2lyYyw3YixldW1sLDdjLGlncmF2ZSw3ZCxpYWN1dGUsN2UsaWNpcmMsJyArXG4gICAgICAgICAgICAnN2YsaXVtbCw3ZyxldGgsN2gsbnRpbGRlLDdpLG9ncmF2ZSw3aixvYWN1dGUsN2ssb2NpcmMsN2wsb3RpbGRlLDdtLG91bWwsN24sZGl2aWRlLDdvLG9zbGFzaCwnICtcbiAgICAgICAgICAgICc3cCx1Z3JhdmUsN3EsdWFjdXRlLDdyLHVjaXJjLDdzLHV1bWwsN3QseWFjdXRlLDd1LHRob3JuLDd2LHl1bWwsY2ksZm5vZixzaCxBbHBoYSxzaSxCZXRhLCcgK1xuICAgICAgICAgICAgJ3NqLEdhbW1hLHNrLERlbHRhLHNsLEVwc2lsb24sc20sWmV0YSxzbixFdGEsc28sVGhldGEsc3AsSW90YSxzcSxLYXBwYSxzcixMYW1iZGEsc3MsTXUsJyArXG4gICAgICAgICAgICAnc3QsTnUsc3UsWGksc3YsT21pY3Jvbix0MCxQaSx0MSxSaG8sdDMsU2lnbWEsdDQsVGF1LHQ1LFVwc2lsb24sdDYsUGhpLHQ3LENoaSx0OCxQc2ksJyArXG4gICAgICAgICAgICAndDksT21lZ2EsdGgsYWxwaGEsdGksYmV0YSx0aixnYW1tYSx0ayxkZWx0YSx0bCxlcHNpbG9uLHRtLHpldGEsdG4sZXRhLHRvLHRoZXRhLHRwLGlvdGEsJyArXG4gICAgICAgICAgICAndHEsa2FwcGEsdHIsbGFtYmRhLHRzLG11LHR0LG51LHR1LHhpLHR2LG9taWNyb24sdTAscGksdTEscmhvLHUyLHNpZ21hZix1MyxzaWdtYSx1NCx0YXUsJyArXG4gICAgICAgICAgICAndTUsdXBzaWxvbix1NixwaGksdTcsY2hpLHU4LHBzaSx1OSxvbWVnYSx1aCx0aGV0YXN5bSx1aSx1cHNpaCx1bSxwaXYsODEyLGJ1bGwsODE2LGhlbGxpcCwnICtcbiAgICAgICAgICAgICc4MWkscHJpbWUsODFqLFByaW1lLDgxdSxvbGluZSw4MjQsZnJhc2wsODhvLHdlaWVycCw4OGgsaW1hZ2UsODhzLHJlYWwsODkyLHRyYWRlLDg5bCxhbGVmc3ltLCcgK1xuICAgICAgICAgICAgJzhjZyxsYXJyLDhjaCx1YXJyLDhjaSxyYXJyLDhjaixkYXJyLDhjayxoYXJyLDhkbCxjcmFyciw4ZWcsbEFyciw4ZWgsdUFyciw4ZWksckFyciw4ZWosZEFyciwnICtcbiAgICAgICAgICAgICc4ZWssaEFyciw4ZzAsZm9yYWxsLDhnMixwYXJ0LDhnMyxleGlzdCw4ZzUsZW1wdHksOGc3LG5hYmxhLDhnOCxpc2luLDhnOSxub3Rpbiw4Z2IsbmksOGdmLHByb2QsJyArXG4gICAgICAgICAgICAnOGdoLHN1bSw4Z2ksbWludXMsOGduLGxvd2FzdCw4Z3EscmFkaWMsOGd0LHByb3AsOGd1LGluZmluLDhoMCxhbmcsOGg3LGFuZCw4aDgsb3IsOGg5LGNhcCw4aGEsY3VwLCcgK1xuICAgICAgICAgICAgJzhoYixpbnQsOGhrLHRoZXJlNCw4aHMsc2ltLDhpNSxjb25nLDhpOCxhc3ltcCw4ajAsbmUsOGoxLGVxdWl2LDhqNCxsZSw4ajUsZ2UsOGsyLHN1Yiw4azMsc3VwLDhrNCwnICtcbiAgICAgICAgICAgICduc3ViLDhrNixzdWJlLDhrNyxzdXBlLDhrbCxvcGx1cyw4a24sb3RpbWVzLDhsNSxwZXJwLDhtNSxzZG90LDhvOCxsY2VpbCw4bzkscmNlaWwsOG9hLGxmbG9vciw4b2IsJyArXG4gICAgICAgICAgICAncmZsb29yLDhwOSxsYW5nLDhwYSxyYW5nLDllYSxsb3osOWowLHNwYWRlcyw5ajMsY2x1YnMsOWo1LGhlYXJ0cyw5ajYsZGlhbXMsYWksT0VsaWcsYWosb2VsaWcsYjAsJyArXG4gICAgICAgICAgICAnU2Nhcm9uLGIxLHNjYXJvbixibyxZdW1sLG02LGNpcmMsbXMsdGlsZGUsODAyLGVuc3AsODAzLGVtc3AsODA5LHRoaW5zcCw4MGMsenduaiw4MGQsendqLDgwZSxscm0sJyArXG4gICAgICAgICAgICAnODBmLHJsbSw4MGosbmRhc2gsODBrLG1kYXNoLDgwbyxsc3F1byw4MHAscnNxdW8sODBxLHNicXVvLDgwcyxsZHF1byw4MHQscmRxdW8sODB1LGJkcXVvLDgxMCxkYWdnZXIsJyArXG4gICAgICAgICAgICAnODExLERhZ2dlciw4MWcscGVybWlsLDgxcCxsc2FxdW8sODFxLHJzYXF1byw4NWMsZXVybycsIDMyKTtcblxuXG4gICAgLy9Tb21lIGJhc2ljIG1hcHBpbmdzIGZvciBhdHRyaWJ1dGVzIGFuZCBkZWZhdWx0IHZhbHVlcy5cbiAgICBTVFlMRVMgPSB7XG4gICAgICAgIFwic3Ryb2tlU3R5bGVcIjp7XG4gICAgICAgICAgICBzdmdBdHRyIDogXCJzdHJva2VcIiwgLy9jb3JyZXNwb25kaW5nIHN2ZyBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGNhbnZhcyA6IFwiIzAwMDAwMFwiLCAvL2NhbnZhcyBkZWZhdWx0XG4gICAgICAgICAgICBzdmcgOiBcIm5vbmVcIiwgICAgICAgLy9zdmcgZGVmYXVsdFxuICAgICAgICAgICAgYXBwbHkgOiBcInN0cm9rZVwiICAgIC8vYXBwbHkgb24gc3Ryb2tlKCkgb3IgZmlsbCgpXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmlsbFN0eWxlXCI6e1xuICAgICAgICAgICAgc3ZnQXR0ciA6IFwiZmlsbFwiLFxuICAgICAgICAgICAgY2FudmFzIDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICBzdmcgOiBudWxsLCAvL3N2ZyBkZWZhdWx0IGlzIGJsYWNrLCBidXQgd2UgbmVlZCB0byBzcGVjaWFsIGNhc2UgdGhpcyB0byBoYW5kbGUgY2FudmFzIHN0cm9rZSB3aXRob3V0IGZpbGxcbiAgICAgICAgICAgIGFwcGx5IDogXCJmaWxsXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lQ2FwXCI6e1xuICAgICAgICAgICAgc3ZnQXR0ciA6IFwic3Ryb2tlLWxpbmVjYXBcIixcbiAgICAgICAgICAgIGNhbnZhcyA6IFwiYnV0dFwiLFxuICAgICAgICAgICAgc3ZnIDogXCJidXR0XCIsXG4gICAgICAgICAgICBhcHBseSA6IFwic3Ryb2tlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lSm9pblwiOntcbiAgICAgICAgICAgIHN2Z0F0dHIgOiBcInN0cm9rZS1saW5lam9pblwiLFxuICAgICAgICAgICAgY2FudmFzIDogXCJtaXRlclwiLFxuICAgICAgICAgICAgc3ZnIDogXCJtaXRlclwiLFxuICAgICAgICAgICAgYXBwbHkgOiBcInN0cm9rZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWl0ZXJMaW1pdFwiOntcbiAgICAgICAgICAgIHN2Z0F0dHIgOiBcInN0cm9rZS1taXRlcmxpbWl0XCIsXG4gICAgICAgICAgICBjYW52YXMgOiAxMCxcbiAgICAgICAgICAgIHN2ZyA6IDQsXG4gICAgICAgICAgICBhcHBseSA6IFwic3Ryb2tlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lV2lkdGhcIjp7XG4gICAgICAgICAgICBzdmdBdHRyIDogXCJzdHJva2Utd2lkdGhcIixcbiAgICAgICAgICAgIGNhbnZhcyA6IDEsXG4gICAgICAgICAgICBzdmcgOiAxLFxuICAgICAgICAgICAgYXBwbHkgOiBcInN0cm9rZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2xvYmFsQWxwaGFcIjoge1xuICAgICAgICAgICAgc3ZnQXR0ciA6IFwib3BhY2l0eVwiLFxuICAgICAgICAgICAgY2FudmFzIDogMSxcbiAgICAgICAgICAgIHN2ZyA6IDEsXG4gICAgICAgICAgICBhcHBseSA6IFwiZmlsbCBzdHJva2VcIlxuICAgICAgICB9LFxuICAgICAgICBcImZvbnRcIjp7XG4gICAgICAgICAgICAvL2ZvbnQgY29udmVydHMgdG8gbXVsdGlwbGUgc3ZnIGF0dHJpYnV0ZXMsIHRoZXJlIGlzIGN1c3RvbSBsb2dpYyBmb3IgdGhpc1xuICAgICAgICAgICAgY2FudmFzIDogXCIxMHB4IHNhbnMtc2VyaWZcIlxuICAgICAgICB9LFxuICAgICAgICBcInNoYWRvd0NvbG9yXCI6e1xuICAgICAgICAgICAgY2FudmFzIDogXCIjMDAwMDAwXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzaGFkb3dPZmZzZXRYXCI6e1xuICAgICAgICAgICAgY2FudmFzIDogMFxuICAgICAgICB9LFxuICAgICAgICBcInNoYWRvd09mZnNldFlcIjp7XG4gICAgICAgICAgICBjYW52YXMgOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwic2hhZG93Qmx1clwiOntcbiAgICAgICAgICAgIGNhbnZhcyA6IDBcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0QWxpZ25cIjp7XG4gICAgICAgICAgICBjYW52YXMgOiBcInN0YXJ0XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0QmFzZWxpbmVcIjp7XG4gICAgICAgICAgICBjYW52YXMgOiBcImFscGhhYmV0aWNcIlxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyYWRpZW50Tm9kZSAtIHJlZmVyZW5jZSB0byB0aGUgZ3JhZGllbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBDYW52YXNHcmFkaWVudCA9IGZ1bmN0aW9uKGdyYWRpZW50Tm9kZSwgY3R4KSB7XG4gICAgICAgIHRoaXMuX19yb290ID0gZ3JhZGllbnROb2RlO1xuICAgICAgICB0aGlzLl9fY3R4ID0gY3R4O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29sb3Igc3RvcCB0byB0aGUgZ3JhZGllbnQgcm9vdFxuICAgICAqL1xuICAgIENhbnZhc0dyYWRpZW50LnByb3RvdHlwZS5hZGRDb2xvclN0b3AgPSBmdW5jdGlvbihvZmZzZXQsIGNvbG9yKSB7XG4gICAgICAgIHZhciBzdG9wID0gdGhpcy5fX2N0eC5fX2NyZWF0ZUVsZW1lbnQoXCJzdG9wXCIpLCByZWdleCwgbWF0Y2hlcztcbiAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoXCJvZmZzZXRcIiwgb2Zmc2V0KTtcbiAgICAgICAgaWYoY29sb3IuaW5kZXhPZihcInJnYmFcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAvL3NlcGFyYXRlIGFscGhhIHZhbHVlLCBzaW5jZSB3ZWJraXQgY2FuJ3QgaGFuZGxlIGl0XG4gICAgICAgICAgICByZWdleCA9IC9yZ2JhXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQ/XFwuP1xcZCopXFxzKlxcKS9naTtcbiAgICAgICAgICAgIG1hdGNoZXMgPSByZWdleC5leGVjKGNvbG9yKTtcbiAgICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKFwic3RvcC1jb2xvclwiLCBmb3JtYXQoXCJyZ2Ioe3J9LHtnfSx7Yn0pXCIsIHtyOm1hdGNoZXNbMV0sIGc6bWF0Y2hlc1syXSwgYjptYXRjaGVzWzNdfSkpO1xuICAgICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoXCJzdG9wLW9wYWNpdHlcIiwgbWF0Y2hlc1s0XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZShcInN0b3AtY29sb3JcIiwgY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19yb290LmFwcGVuZENoaWxkKHN0b3ApO1xuICAgIH07XG5cbiAgICBDYW52YXNQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybiwgY3R4KSB7XG4gICAgICAgIHRoaXMuX19yb290ID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5fX2N0eCA9IGN0eDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vY2sgY2FudmFzIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gbyAtIG9wdGlvbnMgaW5jbHVkZTpcbiAgICAgKiB3aWR0aCAtIHdpZHRoIG9mIHlvdXIgY2FudmFzIChkZWZhdWx0cyB0byA1MDApXG4gICAgICogaGVpZ2h0IC0gaGVpZ2h0IG9mIHlvdXIgY2FudmFzIChkZWZhdWx0cyB0byA1MDApXG4gICAgICogZW5hYmxlTWlycm9yaW5nIC0gZW5hYmxlcyBjYW52YXMgbWlycm9yaW5nIChnZXQgaW1hZ2UgZGF0YSkgKGRlZmF1bHRzIHRvIGZhbHNlKVxuICAgICAqIGRvY3VtZW50IC0gdGhlIGRvY3VtZW50IG9iamVjdCAoZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQpXG4gICAgICovXG4gICAgY3R4ID0gZnVuY3Rpb24obykge1xuXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHsgd2lkdGg6NTAwLCBoZWlnaHQ6NTAwLCBlbmFibGVNaXJyb3JpbmcgOiBmYWxzZX0sIG9wdGlvbnM7XG5cbiAgICAgICAgLy9rZWVwIHN1cHBvcnQgZm9yIHRoaXMgd2F5IG9mIGNhbGxpbmcgQzJTOiBuZXcgQzJTKHdpZHRoLGhlaWdodClcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMud2lkdGggPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBvcHRpb25zLmhlaWdodCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfSBlbHNlIGlmKCAhbyApIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoISh0aGlzIGluc3RhbmNlb2YgY3R4KSkge1xuICAgICAgICAgICAgLy9kaWQgc29tZW9uZSBjYWxsIHRoaXMgd2l0aG91dCBuZXc/XG4gICAgICAgICAgICByZXR1cm4gbmV3IGN0eChvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2V0dXAgb3B0aW9uc1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCB8fCBkZWZhdWx0T3B0aW9ucy53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBkZWZhdWx0T3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuZW5hYmxlTWlycm9yaW5nID0gb3B0aW9ucy5lbmFibGVNaXJyb3JpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZW5hYmxlTWlycm9yaW5nIDogZGVmYXVsdE9wdGlvbnMuZW5hYmxlTWlycm9yaW5nO1xuXG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpczsgICAvLy9wb2ludCBiYWNrIHRvIHRoaXMgaW5zdGFuY2UhXG4gICAgICAgIHRoaXMuX19kb2N1bWVudCA9IG9wdGlvbnMuZG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuX19jYW52YXMgPSB0aGlzLl9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgdGhpcy5fX2N0eCA9IHRoaXMuX19jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIHRoaXMuX19zZXREZWZhdWx0U3R5bGVzKCk7XG4gICAgICAgIHRoaXMuX19zdGFjayA9IFt0aGlzLl9fZ2V0U3R5bGVTdGF0ZSgpXTtcbiAgICAgICAgdGhpcy5fX2dyb3VwU3RhY2sgPSBbXTtcblxuICAgICAgICAvL3RoZSByb290IHN2ZyBlbGVtZW50XG4gICAgICAgIHRoaXMuX19yb290ID0gdGhpcy5fX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICAgICAgICB0aGlzLl9fcm9vdC5zZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIsIDEuMSk7XG4gICAgICAgIHRoaXMuX19yb290LnNldEF0dHJpYnV0ZShcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XG4gICAgICAgIHRoaXMuX19yb290LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIiwgXCJ4bWxuczp4bGlua1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIik7XG4gICAgICAgIHRoaXMuX19yb290LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHRoaXMud2lkdGgpO1xuICAgICAgICB0aGlzLl9fcm9vdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgIC8vbWFrZSBzdXJlIHdlIGRvbid0IGdlbmVyYXRlIHRoZSBzYW1lIGlkcyBpbiBkZWZzXG4gICAgICAgIHRoaXMuX19pZHMgPSB7fTtcblxuICAgICAgICAvL2RlZnMgdGFnXG4gICAgICAgIHRoaXMuX19kZWZzID0gdGhpcy5fX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZGVmc1wiKTtcbiAgICAgICAgdGhpcy5fX3Jvb3QuYXBwZW5kQ2hpbGQodGhpcy5fX2RlZnMpO1xuXG4gICAgICAgIC8vYWxzbyBhZGQgYSBncm91cCBjaGlsZC4gdGhlIHN2ZyBlbGVtZW50IGNhbid0IHVzZSB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZVxuICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQgPSB0aGlzLl9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICAgICAgICB0aGlzLl9fcm9vdC5hcHBlbmRDaGlsZCh0aGlzLl9fY3VycmVudEVsZW1lbnQpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHNwZWNpZmllZCBzdmcgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5fX2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIHByb3BlcnRpZXMsIHJlc2V0RmlsbCkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIGVsZW1lbnROYW1lKSxcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSwga2V5O1xuICAgICAgICBpZihyZXNldEZpbGwpIHtcbiAgICAgICAgICAgIC8vaWYgZmlsbCBvciBzdHJva2UgaXMgbm90IHNwZWNpZmllZCwgdGhlIHN2ZyBlbGVtZW50IHNob3VsZCBub3QgZGlzcGxheS4gQnkgZGVmYXVsdCBTVkcncyBmaWxsIGlzIGJsYWNrLlxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaT0wOyBpPGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHByb3BlcnRpZXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZGVmYXVsdCBjYW52YXMgc3R5bGVzIHRvIHRoZSBjb250ZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLl9fc2V0RGVmYXVsdFN0eWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2RlZmF1bHQgMmQgY2FudmFzIGNvbnRleHQgcHJvcGVydGllcyBzZWU6aHR0cDovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0L1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKFNUWUxFUyksIGksIGtleTtcbiAgICAgICAgZm9yKGk9MDsgaTxrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdGhpc1trZXldID0gU1RZTEVTW2tleV0uY2FudmFzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgc3R5bGVzIG9uIHJlc3RvcmVcbiAgICAgKiBAcGFyYW0gc3R5bGVTdGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5fX2FwcGx5U3R5bGVTdGF0ZSA9IGZ1bmN0aW9uKHN0eWxlU3RhdGUpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdHlsZVN0YXRlKSwgaSwga2V5O1xuICAgICAgICBmb3IoaT0wOyBpPGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBzdHlsZVN0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBzdHlsZSBzdGF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19nZXRTdHlsZVN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpLCBzdHlsZVN0YXRlID0ge30sIGtleXMgPSBPYmplY3Qua2V5cyhTVFlMRVMpLCBrZXk7XG4gICAgICAgIGZvcihpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHN0eWxlU3RhdGVba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGVTdGF0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbGVzIHRoZSBjdXJyZW50IHN0eWxlcyB0byB0aGUgY3VycmVudCBTVkcgZWxlbWVudC4gT24gXCJjdHguZmlsbFwiIG9yIFwiY3R4LnN0cm9rZVwiXG4gICAgICogQHBhcmFtIHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19hcHBseVN0eWxlVG9DdXJyZW50RWxlbWVudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhTVFlMRVMpLCBpLCBzdHlsZSwgdmFsdWUsIGlkLCByZWdleCwgbWF0Y2hlcztcbiAgICAgICAgZm9yKGk9MDsgaTxrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHlsZSA9IFNUWUxFU1trZXlzW2ldXTtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpc1trZXlzW2ldXTtcbiAgICAgICAgICAgIGlmKHN0eWxlLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgLy9pcyB0aGlzIGEgZ3JhZGllbnQgb3IgcGF0dGVybj9cbiAgICAgICAgICAgICAgICBpZihzdHlsZS5hcHBseS5pbmRleE9mKFwiZmlsbFwiKSE9PS0xICYmIHZhbHVlIGluc3RhbmNlb2YgQ2FudmFzUGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICAvL3BhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgaWYodmFsdWUuX19jdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29weSBvdmVyIGRlZnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHZhbHVlLl9fY3R4Ll9fZGVmcy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gdmFsdWUuX19jdHguX19kZWZzLmNoaWxkTm9kZXNbMF0uZ2V0QXR0cmlidXRlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lkc1tpZF0gPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGVmcy5hcHBlbmRDaGlsZCh2YWx1ZS5fX2N0eC5fX2RlZnMuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50LnNldEF0dHJpYnV0ZShcImZpbGxcIiwgZm9ybWF0KFwidXJsKCN7aWR9KVwiLCB7aWQ6dmFsdWUuX19yb290LmdldEF0dHJpYnV0ZShcImlkXCIpfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHN0eWxlLmFwcGx5LmluZGV4T2YoXCJmaWxsXCIpIT09LTEgJiYgdmFsdWUgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvL2dyYWRpZW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19jdXJyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIGZvcm1hdChcInVybCgje2lkfSlcIiwge2lkOnZhbHVlLl9fcm9vdC5nZXRBdHRyaWJ1dGUoXCJpZFwiKX0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoc3R5bGUuYXBwbHkuaW5kZXhPZih0eXBlKSE9PS0xICYmIHN0eWxlLnN2ZyAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoKHN0eWxlLnN2Z0F0dHIgPT09IFwic3Ryb2tlXCIgfHwgc3R5bGUuc3ZnQXR0ciA9PT0gXCJmaWxsXCIpICYmIHZhbHVlLmluZGV4T2YoXCJyZ2JhXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZXBhcmF0ZSBhbHBoYSB2YWx1ZSwgc2luY2UgaWxsdXN0cmF0b3IgY2FuJ3QgaGFuZGxlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleCA9IC9yZ2JhXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQ/XFwuP1xcZCopXFxzKlxcKS9naTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSByZWdleC5leGVjKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19jdXJyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoc3R5bGUuc3ZnQXR0ciwgZm9ybWF0KFwicmdiKHtyfSx7Z30se2J9KVwiLCB7cjptYXRjaGVzWzFdLCBnOm1hdGNoZXNbMl0sIGI6bWF0Y2hlc1szXX0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19jdXJyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoc3R5bGUuc3ZnQXR0citcIi1vcGFjaXR5XCIsIG1hdGNoZXNbNF0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9vdGhlcndpc2Ugb25seSB1cGRhdGUgYXR0cmlidXRlIGlmIHJpZ2h0IHR5cGUsIGFuZCBub3Qgc3ZnIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19jdXJyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoc3R5bGUuc3ZnQXR0ciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgZ3JvdXAgb3Igc3ZnIG5vZGUuIE1heSByZXR1cm4gdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19jbG9zZXN0R3JvdXBPclN2ZyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUgfHwgdGhpcy5fX2N1cnJlbnRFbGVtZW50O1xuICAgICAgICBpZihub2RlLm5vZGVOYW1lID09PSBcImdcIiB8fCBub2RlLm5vZGVOYW1lID09PSBcInN2Z1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fY2xvc2VzdEdyb3VwT3JTdmcobm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXJpYWxpemVkIHZhbHVlIG9mIHRoZSBzdmcgc28gZmFyXG4gICAgICogQHBhcmFtIGZpeE5hbWVkRW50aXRpZXMgLSBTdGFuZGFsb25lIFNWRyBkb2Vzbid0IHN1cHBvcnQgbmFtZWQgZW50aXRpZXMsIHdoaWNoIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlIGVuY29kZXMuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlLCB3ZSBhdHRlbXB0IHRvIGZpbmQgYWxsIG5hbWVkIGVudGl0aWVzIGFuZCBlbmNvZGUgaXQgYXMgYSBudW1lcmljIGVudGl0eS5cbiAgICAgKiBAcmV0dXJuIHNlcmlhbGl6ZWQgc3ZnXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5nZXRTZXJpYWxpemVkU3ZnID0gZnVuY3Rpb24oZml4TmFtZWRFbnRpdGllcykge1xuICAgICAgICB2YXIgc2VyaWFsaXplZCA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcodGhpcy5fX3Jvb3QpLFxuICAgICAgICAgICAga2V5cywgaSwga2V5LCB2YWx1ZSwgcmVnZXhwLCB4bWxucztcblxuICAgICAgICAvL0lFIHNlYXJjaCBmb3IgYSBkdXBsaWNhdGUgeG1ubHMgYmVjYXVzZSB0aGV5IGRpZG4ndCBpbXBsZW1lbnQgc2V0QXR0cmlidXRlTlMgY29ycmVjdGx5XG4gICAgICAgIHhtbG5zID0gL3htbG5zPVwiaHR0cDpcXC9cXC93d3dcXC53M1xcLm9yZ1xcLzIwMDBcXC9zdmdcIi4reG1sbnM9XCJodHRwOlxcL1xcL3d3d1xcLnczXFwub3JnXFwvMjAwMFxcL3N2Zy9naTtcbiAgICAgICAgaWYoeG1sbnMudGVzdChzZXJpYWxpemVkKSkge1xuICAgICAgICAgICAgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZWQucmVwbGFjZSgneG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZml4TmFtZWRFbnRpdGllcykge1xuICAgICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG5hbWVkRW50aXRpZXMpO1xuICAgICAgICAgICAgLy9sb29wIG92ZXIgZWFjaCBuYW1lZCBlbnRpdHkgYW5kIHJlcGxhY2Ugd2l0aCB0aGUgcHJvcGVyIGVxdWl2YWxlbnQuXG4gICAgICAgICAgICBmb3IoaT0wOyBpPGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmFtZWRFbnRpdGllc1trZXldO1xuICAgICAgICAgICAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoa2V5LCBcImdpXCIpO1xuICAgICAgICAgICAgICAgIGlmKHJlZ2V4cC50ZXN0KHNlcmlhbGl6ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVkLnJlcGxhY2UocmVnZXhwLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm9vdCBzdmdcbiAgICAgKiBAcmV0dXJuXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5nZXRTdmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19yb290O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2lsbCBnZW5lcmF0ZSBhIGdyb3VwIHRhZy5cbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5fX2NyZWF0ZUVsZW1lbnQoXCJnXCIpLCBwYXJlbnQgPSB0aGlzLl9fY2xvc2VzdEdyb3VwT3JTdmcoKTtcbiAgICAgICAgdGhpcy5fX2dyb3VwU3RhY2sucHVzaChwYXJlbnQpO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQgPSBncm91cDtcbiAgICAgICAgdGhpcy5fX3N0YWNrLnB1c2godGhpcy5fX2dldFN0eWxlU3RhdGUoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGN1cnJlbnQgZWxlbWVudCB0byBwYXJlbnQsIG9yIGp1c3Qgcm9vdCBpZiBhbHJlYWR5IHJvb3RcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQgPSB0aGlzLl9fZ3JvdXBTdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fX3N0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLl9fYXBwbHlTdHlsZVN0YXRlKHN0YXRlKTtcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFkZCB0cmFuc2Zvcm1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19hZGRUcmFuc2Zvcm0gPSBmdW5jdGlvbih0KSB7XG5cbiAgICAgICAgLy9pZiB0aGUgY3VycmVudCBlbGVtZW50IGhhcyBzaWJsaW5ncywgYWRkIGFub3RoZXIgZ3JvdXBcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX19jbG9zZXN0R3JvdXBPclN2ZygpO1xuICAgICAgICBpZihwYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLl9fY3JlYXRlRWxlbWVudChcImdcIik7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICAgICAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50ID0gZ3JvdXA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5fX2N1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgaWYodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gXCIgXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zZm9ybSArPSB0O1xuICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBzY2FsZXMgdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGlmKHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2FkZFRyYW5zZm9ybShmb3JtYXQoXCJzY2FsZSh7eH0se3l9KVwiLCB7eDp4LCB5Onl9KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJvdGF0ZXMgdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24oYW5nbGUpe1xuICAgICAgICB2YXIgZGVncmVlcyA9IChhbmdsZSAqIDE4MCAvIE1hdGguUEkpO1xuICAgICAgICB0aGlzLl9fYWRkVHJhbnNmb3JtKGZvcm1hdChcInJvdGF0ZSh7YW5nbGV9LHtjeH0se2N5fSlcIiwge2FuZ2xlOmRlZ3JlZXMsIGN4OjAsIGN5OjB9KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRyYW5zbGF0ZXMgdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24oeCwgeSl7XG4gICAgICAgIHRoaXMuX19hZGRUcmFuc2Zvcm0oZm9ybWF0KFwidHJhbnNsYXRlKHt4fSx7eX0pXCIsIHt4OngseTp5fSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhcHBsaWVzIGEgdHJhbnNmb3JtIHRvIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpe1xuICAgICAgICB0aGlzLl9fYWRkVHJhbnNmb3JtKGZvcm1hdChcIm1hdHJpeCh7YX0se2J9LHtjfSx7ZH0se2V9LHtmfSlcIiwge2E6YSwgYjpiLCBjOmMsIGQ6ZCwgZTplLCBmOmZ9KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBQYXRoIEVsZW1lbnRcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLmJlZ2luUGF0aCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBwYXRoLCBwYXJlbnQ7XG5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIGN1cnJlbnQgZGVmYXVsdCBwYXRoLCBpdCBpcyBub3QgcGFydCBvZiB0aGUgZHJhd2luZyBzdGF0ZS5cbiAgICAgICAgLy8gU2VlIGFsc286IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI2N1cnJlbnQtZGVmYXVsdC1wYXRoXG4gICAgICAgIHRoaXMuX19jdXJyZW50RGVmYXVsdFBhdGggPSBcIlwiO1xuICAgICAgICB0aGlzLl9fY3VycmVudFBvc2l0aW9uID0ge307XG5cbiAgICAgICAgcGF0aCA9IHRoaXMuX19jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7fSwgdHJ1ZSk7XG4gICAgICAgIHBhcmVudCA9IHRoaXMuX19jbG9zZXN0R3JvdXBPclN2ZygpO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgICAgIHRoaXMuX19jdXJyZW50RWxlbWVudCA9IHBhdGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBhcHBseSBjdXJyZW50RGVmYXVsdFBhdGggdG8gY3VycmVudCBwYXRoIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19hcHBseUN1cnJlbnREZWZhdWx0UGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLl9fY3VycmVudEVsZW1lbnQubm9kZU5hbWUgPT09IFwicGF0aFwiKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuX19jdXJyZW50RGVmYXVsdFBhdGg7XG4gICAgICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZFwiLCBkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBhcHBseSBwYXRoIGNvbW1hbmQgdG8gbm9kZSBcIiArIHRoaXMuX19jdXJyZW50RWxlbWVudC5ub2RlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGFkZCBwYXRoIGNvbW1hbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuX19hZGRQYXRoQ29tbWFuZCA9IGZ1bmN0aW9uKGNvbW1hbmQpe1xuICAgICAgICB0aGlzLl9fY3VycmVudERlZmF1bHRQYXRoICs9IFwiIFwiO1xuICAgICAgICB0aGlzLl9fY3VycmVudERlZmF1bHRQYXRoICs9IGNvbW1hbmQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIG1vdmUgY29tbWFuZCB0byB0aGUgY3VycmVudCBwYXRoIGVsZW1lbnQsXG4gICAgICogaWYgdGhlIGN1cnJlbnRQYXRoRWxlbWVudCBpcyBub3QgZW1wdHkgY3JlYXRlIGEgbmV3IHBhdGggZWxlbWVudFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCx5KXtcbiAgICAgICAgaWYodGhpcy5fX2N1cnJlbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcInBhdGhcIikge1xuICAgICAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZXMgYSBuZXcgc3VicGF0aCB3aXRoIHRoZSBnaXZlbiBwb2ludFxuICAgICAgICB0aGlzLl9fY3VycmVudFBvc2l0aW9uID0ge3g6IHgsIHk6IHl9O1xuICAgICAgICB0aGlzLl9fYWRkUGF0aENvbW1hbmQoZm9ybWF0KFwiTSB7eH0ge3l9XCIsIHt4OngsIHk6eX0pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGhcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX19hZGRQYXRoQ29tbWFuZChcIlpcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaW5lIHRvIGNvbW1hbmRcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uKHgsIHkpe1xuICAgICAgICB0aGlzLl9fY3VycmVudFBvc2l0aW9uID0ge3g6IHgsIHk6IHl9O1xuICAgICAgICBpZiAodGhpcy5fX2N1cnJlbnREZWZhdWx0UGF0aC5pbmRleE9mKCdNJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fX2FkZFBhdGhDb21tYW5kKGZvcm1hdChcIkwge3h9IHt5fVwiLCB7eDp4LCB5Onl9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fYWRkUGF0aENvbW1hbmQoZm9ybWF0KFwiTSB7eH0ge3l9XCIsIHt4OngsIHk6eX0pKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBiZXppZXIgY29tbWFuZFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRQb3NpdGlvbiA9IHt4OiB4LCB5OiB5fTtcbiAgICAgICAgdGhpcy5fX2FkZFBhdGhDb21tYW5kKGZvcm1hdChcIkMge2NwMXh9IHtjcDF5fSB7Y3AyeH0ge2NwMnl9IHt4fSB7eX1cIixcbiAgICAgICAgICAgIHtjcDF4OmNwMXgsIGNwMXk6Y3AxeSwgY3AyeDpjcDJ4LCBjcDJ5OmNwMnksIHg6eCwgeTp5fSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcXVhZHJhdGljIGN1cnZlIHRvIGNvbW1hbmRcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbihjcHgsIGNweSwgeCwgeSl7XG4gICAgICAgIHRoaXMuX19jdXJyZW50UG9zaXRpb24gPSB7eDogeCwgeTogeX07XG4gICAgICAgIHRoaXMuX19hZGRQYXRoQ29tbWFuZChmb3JtYXQoXCJRIHtjcHh9IHtjcHl9IHt4fSB7eX1cIiwge2NweDpjcHgsIGNweTpjcHksIHg6eCwgeTp5fSkpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBub3JtYWxpemVkIHZlY3RvciBvZiBnaXZlbiB2ZWN0b3JcbiAgICAgKi9cbiAgICB2YXIgbm9ybWFsaXplID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLnNxcnQodmVjdG9yWzBdICogdmVjdG9yWzBdICsgdmVjdG9yWzFdICogdmVjdG9yWzFdKTtcbiAgICAgICAgcmV0dXJuIFt2ZWN0b3JbMF0gLyBsZW4sIHZlY3RvclsxXSAvIGxlbl07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGFyY1RvIHRvIHRoZSBjdXJyZW50IHBhdGhcbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxNS9XRC0yZGNvbnRleHQtMjAxNTA1MTQvI2RvbS1jb250ZXh0LTJkLWFyY3RvXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5hcmNUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICAgICAgLy8gTGV0IHRoZSBwb2ludCAoeDAsIHkwKSBiZSB0aGUgbGFzdCBwb2ludCBpbiB0aGUgc3VicGF0aC5cbiAgICAgICAgdmFyIHgwID0gdGhpcy5fX2N1cnJlbnRQb3NpdGlvbiAmJiB0aGlzLl9fY3VycmVudFBvc2l0aW9uLng7XG4gICAgICAgIHZhciB5MCA9IHRoaXMuX19jdXJyZW50UG9zaXRpb24gJiYgdGhpcy5fX2N1cnJlbnRQb3NpdGlvbi55O1xuXG4gICAgICAgIC8vIEZpcnN0IGVuc3VyZSB0aGVyZSBpcyBhIHN1YnBhdGggZm9yICh4MSwgeTEpLlxuICAgICAgICBpZiAodHlwZW9mIHgwID09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHkwID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5lZ2F0aXZlIHZhbHVlcyBmb3IgcmFkaXVzIG11c3QgY2F1c2UgdGhlIGltcGxlbWVudGF0aW9uIHRvIHRocm93IGFuIEluZGV4U2l6ZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKHJhZGl1cyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluZGV4U2l6ZUVycm9yOiBUaGUgcmFkaXVzIHByb3ZpZGVkIChcIiArIHJhZGl1cyArIFwiKSBpcyBuZWdhdGl2ZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgcG9pbnQgKHgwLCB5MCkgaXMgZXF1YWwgdG8gdGhlIHBvaW50ICh4MSwgeTEpLFxuICAgICAgICAvLyBvciBpZiB0aGUgcG9pbnQgKHgxLCB5MSkgaXMgZXF1YWwgdG8gdGhlIHBvaW50ICh4MiwgeTIpLFxuICAgICAgICAvLyBvciBpZiB0aGUgcmFkaXVzIHJhZGl1cyBpcyB6ZXJvLFxuICAgICAgICAvLyB0aGVuIHRoZSBtZXRob2QgbXVzdCBhZGQgdGhlIHBvaW50ICh4MSwgeTEpIHRvIHRoZSBzdWJwYXRoLFxuICAgICAgICAvLyBhbmQgY29ubmVjdCB0aGF0IHBvaW50IHRvIHRoZSBwcmV2aW91cyBwb2ludCAoeDAsIHkwKSBieSBhIHN0cmFpZ2h0IGxpbmUuXG4gICAgICAgIGlmICgoKHgwID09PSB4MSkgJiYgKHkwID09PSB5MSkpXG4gICAgICAgICAgICB8fCAoKHgxID09PSB4MikgJiYgKHkxID09PSB5MikpXG4gICAgICAgICAgICB8fCAocmFkaXVzID09PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5saW5lVG8oeDEsIHkxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIHBvaW50cyAoeDAsIHkwKSwgKHgxLCB5MSksIGFuZCAoeDIsIHkyKSBhbGwgbGllIG9uIGEgc2luZ2xlIHN0cmFpZ2h0IGxpbmUsXG4gICAgICAgIC8vIHRoZW4gdGhlIG1ldGhvZCBtdXN0IGFkZCB0aGUgcG9pbnQgKHgxLCB5MSkgdG8gdGhlIHN1YnBhdGgsXG4gICAgICAgIC8vIGFuZCBjb25uZWN0IHRoYXQgcG9pbnQgdG8gdGhlIHByZXZpb3VzIHBvaW50ICh4MCwgeTApIGJ5IGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgdmFyIHVuaXRfdmVjX3AxX3AwID0gbm9ybWFsaXplKFt4MCAtIHgxLCB5MCAtIHkxXSk7XG4gICAgICAgIHZhciB1bml0X3ZlY19wMV9wMiA9IG5vcm1hbGl6ZShbeDIgLSB4MSwgeTIgLSB5MV0pO1xuICAgICAgICBpZiAodW5pdF92ZWNfcDFfcDBbMF0gKiB1bml0X3ZlY19wMV9wMlsxXSA9PT0gdW5pdF92ZWNfcDFfcDBbMV0gKiB1bml0X3ZlY19wMV9wMlswXSkge1xuICAgICAgICAgICAgdGhpcy5saW5lVG8oeDEsIHkxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgbGV0IFRoZSBBcmMgYmUgdGhlIHNob3J0ZXN0IGFyYyBnaXZlbiBieSBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjaXJjbGUgdGhhdCBoYXMgcmFkaXVzIHJhZGl1cyxcbiAgICAgICAgLy8gYW5kIHRoYXQgaGFzIG9uZSBwb2ludCB0YW5nZW50IHRvIHRoZSBoYWxmLWluZmluaXRlIGxpbmUgdGhhdCBjcm9zc2VzIHRoZSBwb2ludCAoeDAsIHkwKSBhbmQgZW5kcyBhdCB0aGUgcG9pbnQgKHgxLCB5MSksXG4gICAgICAgIC8vIGFuZCB0aGF0IGhhcyBhIGRpZmZlcmVudCBwb2ludCB0YW5nZW50IHRvIHRoZSBoYWxmLWluZmluaXRlIGxpbmUgdGhhdCBlbmRzIGF0IHRoZSBwb2ludCAoeDEsIHkxKSwgYW5kIGNyb3NzZXMgdGhlIHBvaW50ICh4MiwgeTIpLlxuICAgICAgICAvLyBUaGUgcG9pbnRzIGF0IHdoaWNoIHRoaXMgY2lyY2xlIHRvdWNoZXMgdGhlc2UgdHdvIGxpbmVzIGFyZSBjYWxsZWQgdGhlIHN0YXJ0IGFuZCBlbmQgdGFuZ2VudCBwb2ludHMgcmVzcGVjdGl2ZWx5LlxuXG4gICAgICAgIC8vIG5vdGUgdGhhdCBib3RoIHZlY3RvcnMgYXJlIHVuaXQgdmVjdG9ycywgc28gdGhlIGxlbmd0aCBpcyAxXG4gICAgICAgIHZhciBjb3MgPSAodW5pdF92ZWNfcDFfcDBbMF0gKiB1bml0X3ZlY19wMV9wMlswXSArIHVuaXRfdmVjX3AxX3AwWzFdICogdW5pdF92ZWNfcDFfcDJbMV0pO1xuICAgICAgICB2YXIgdGhldGEgPSBNYXRoLmFjb3MoTWF0aC5hYnMoY29zKSk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG9yaWdpblxuICAgICAgICB2YXIgdW5pdF92ZWNfcDFfb3JpZ2luID0gbm9ybWFsaXplKFtcbiAgICAgICAgICAgIHVuaXRfdmVjX3AxX3AwWzBdICsgdW5pdF92ZWNfcDFfcDJbMF0sXG4gICAgICAgICAgICB1bml0X3ZlY19wMV9wMFsxXSArIHVuaXRfdmVjX3AxX3AyWzFdXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgbGVuX3AxX29yaWdpbiA9IHJhZGl1cyAvIE1hdGguc2luKHRoZXRhIC8gMik7XG4gICAgICAgIHZhciB4ID0geDEgKyBsZW5fcDFfb3JpZ2luICogdW5pdF92ZWNfcDFfb3JpZ2luWzBdO1xuICAgICAgICB2YXIgeSA9IHkxICsgbGVuX3AxX29yaWdpbiAqIHVuaXRfdmVjX3AxX29yaWdpblsxXTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgc3RhcnQgYW5nbGUgYW5kIGVuZCBhbmdsZVxuICAgICAgICAvLyByb3RhdGUgOTBkZWcgY2xvY2t3aXNlIChub3RlIHRoYXQgeSBheGlzIHBvaW50cyB0byBpdHMgZG93bilcbiAgICAgICAgdmFyIHVuaXRfdmVjX29yaWdpbl9zdGFydF90YW5nZW50ID0gW1xuICAgICAgICAgICAgLXVuaXRfdmVjX3AxX3AwWzFdLFxuICAgICAgICAgICAgdW5pdF92ZWNfcDFfcDBbMF1cbiAgICAgICAgXTtcbiAgICAgICAgLy8gcm90YXRlIDkwZGVnIGNvdW50ZXIgY2xvY2t3aXNlIChub3RlIHRoYXQgeSBheGlzIHBvaW50cyB0byBpdHMgZG93bilcbiAgICAgICAgdmFyIHVuaXRfdmVjX29yaWdpbl9lbmRfdGFuZ2VudCA9IFtcbiAgICAgICAgICAgIHVuaXRfdmVjX3AxX3AyWzFdLFxuICAgICAgICAgICAgLXVuaXRfdmVjX3AxX3AyWzBdXG4gICAgICAgIF07XG4gICAgICAgIHZhciBnZXRBbmdsZSA9IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgICAgICAgLy8gZ2V0IGFuZ2xlIChjbG9ja3dpc2UpIGJldHdlZW4gdmVjdG9yIGFuZCAoMSwgMClcbiAgICAgICAgICAgIHZhciB4ID0gdmVjdG9yWzBdO1xuICAgICAgICAgICAgdmFyIHkgPSB2ZWN0b3JbMV07XG4gICAgICAgICAgICBpZiAoeSA+PSAwKSB7IC8vIG5vdGUgdGhhdCB5IGF4aXMgcG9pbnRzIHRvIGl0cyBkb3duXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWNvcyh4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC1NYXRoLmFjb3MoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gZ2V0QW5nbGUodW5pdF92ZWNfb3JpZ2luX3N0YXJ0X3RhbmdlbnQpO1xuICAgICAgICB2YXIgZW5kQW5nbGUgPSBnZXRBbmdsZSh1bml0X3ZlY19vcmlnaW5fZW5kX3RhbmdlbnQpO1xuXG4gICAgICAgIC8vIENvbm5lY3QgdGhlIHBvaW50ICh4MCwgeTApIHRvIHRoZSBzdGFydCB0YW5nZW50IHBvaW50IGJ5IGEgc3RyYWlnaHQgbGluZVxuICAgICAgICB0aGlzLmxpbmVUbyh4ICsgdW5pdF92ZWNfb3JpZ2luX3N0YXJ0X3RhbmdlbnRbMF0gKiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIHkgKyB1bml0X3ZlY19vcmlnaW5fc3RhcnRfdGFuZ2VudFsxXSAqIHJhZGl1cyk7XG5cbiAgICAgICAgLy8gQ29ubmVjdCB0aGUgc3RhcnQgdGFuZ2VudCBwb2ludCB0byB0aGUgZW5kIHRhbmdlbnQgcG9pbnQgYnkgYXJjXG4gICAgICAgIC8vIGFuZCBhZGRpbmcgdGhlIGVuZCB0YW5nZW50IHBvaW50IHRvIHRoZSBzdWJwYXRoLlxuICAgICAgICB0aGlzLmFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3Ryb2tlIHByb3BlcnR5IG9uIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLnN0cm9rZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKHRoaXMuX19jdXJyZW50RWxlbWVudC5ub2RlTmFtZSA9PT0gXCJwYXRoXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX19jdXJyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwYWludC1vcmRlclwiLCBcImZpbGwgc3Ryb2tlIG1hcmtlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2FwcGx5Q3VycmVudERlZmF1bHRQYXRoKCk7XG4gICAgICAgIHRoaXMuX19hcHBseVN0eWxlVG9DdXJyZW50RWxlbWVudChcInN0cm9rZVwiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBmaWxsIHByb3BlcnRpZXMgb24gdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKHRoaXMuX19jdXJyZW50RWxlbWVudC5ub2RlTmFtZSA9PT0gXCJwYXRoXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX19jdXJyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwYWludC1vcmRlclwiLCBcInN0cm9rZSBmaWxsIG1hcmtlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2FwcGx5Q3VycmVudERlZmF1bHRQYXRoKCk7XG4gICAgICAgIHRoaXMuX19hcHBseVN0eWxlVG9DdXJyZW50RWxlbWVudChcImZpbGxcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBBZGRzIGEgcmVjdGFuZ2xlIHRvIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpe1xuICAgICAgICBpZih0aGlzLl9fY3VycmVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwicGF0aFwiKSB7XG4gICAgICAgICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmxpbmVUbyh4K3dpZHRoLCB5KTtcbiAgICAgICAgdGhpcy5saW5lVG8oeCt3aWR0aCwgeStoZWlnaHQpO1xuICAgICAgICB0aGlzLmxpbmVUbyh4LCB5K2hlaWdodCk7XG4gICAgICAgIHRoaXMubGluZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIGFkZHMgYSByZWN0YW5nbGUgZWxlbWVudFxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuZmlsbFJlY3QgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KXtcbiAgICAgICAgdmFyIHJlY3QsIHBhcmVudDtcbiAgICAgICAgcmVjdCA9IHRoaXMuX19jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICAgICAgICB4IDogeCxcbiAgICAgICAgICAgIHkgOiB5LFxuICAgICAgICAgICAgd2lkdGggOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA6IGhlaWdodFxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgcGFyZW50ID0gdGhpcy5fX2Nsb3Nlc3RHcm91cE9yU3ZnKCk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZWN0KTtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50ID0gcmVjdDtcbiAgICAgICAgdGhpcy5fX2FwcGx5U3R5bGVUb0N1cnJlbnRFbGVtZW50KFwiZmlsbFwiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSByZWN0YW5nbGUgd2l0aCBubyBmaWxsXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwYXJhbSB3aWR0aFxuICAgICAqIEBwYXJhbSBoZWlnaHRcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLnN0cm9rZVJlY3QgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KXtcbiAgICAgICAgdmFyIHJlY3QsIHBhcmVudDtcbiAgICAgICAgcmVjdCA9IHRoaXMuX19jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICAgICAgICB4IDogeCxcbiAgICAgICAgICAgIHkgOiB5LFxuICAgICAgICAgICAgd2lkdGggOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA6IGhlaWdodFxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgcGFyZW50ID0gdGhpcy5fX2Nsb3Nlc3RHcm91cE9yU3ZnKCk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZWN0KTtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50ID0gcmVjdDtcbiAgICAgICAgdGhpcy5fX2FwcGx5U3R5bGVUb0N1cnJlbnRFbGVtZW50KFwic3Ryb2tlXCIpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFwiQ2xlYXJzXCIgYSBjYW52YXMgYnkganVzdCBkcmF3aW5nIGEgd2hpdGUgcmVjdGFuZ2xlIGluIHRoZSBjdXJyZW50IGdyb3VwLlxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuY2xlYXJSZWN0ID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcmVjdCwgcGFyZW50ID0gdGhpcy5fX2Nsb3Nlc3RHcm91cE9yU3ZnKCk7XG4gICAgICAgIHJlY3QgPSB0aGlzLl9fY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgICAgICAgeCA6IHgsXG4gICAgICAgICAgICB5IDogeSxcbiAgICAgICAgICAgIHdpZHRoIDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgOiBoZWlnaHQsXG4gICAgICAgICAgICBmaWxsIDogXCIjRkZGRkZGXCJcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpbmVhciBncmFkaWVudCB0byBhIGRlZnMgdGFnLlxuICAgICAqIFJldHVybnMgYSBjYW52YXMgZ3JhZGllbnQgb2JqZWN0IHRoYXQgaGFzIGEgcmVmZXJlbmNlIHRvIGl0J3MgcGFyZW50IGRlZlxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuY3JlYXRlTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mil7XG4gICAgICAgIHZhciBncmFkID0gdGhpcy5fX2NyZWF0ZUVsZW1lbnQoXCJsaW5lYXJHcmFkaWVudFwiLCB7XG4gICAgICAgICAgICBpZCA6IHJhbmRvbVN0cmluZyh0aGlzLl9faWRzKSxcbiAgICAgICAgICAgIHgxIDogeDErXCJweFwiLFxuICAgICAgICAgICAgeDIgOiB4MitcInB4XCIsXG4gICAgICAgICAgICB5MSA6IHkxK1wicHhcIixcbiAgICAgICAgICAgIHkyIDogeTIrXCJweFwiLFxuICAgICAgICAgICAgXCJncmFkaWVudFVuaXRzXCIgOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9fZGVmcy5hcHBlbmRDaGlsZChncmFkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYW52YXNHcmFkaWVudChncmFkLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHJhZGlhbCBncmFkaWVudCB0byBhIGRlZnMgdGFnLlxuICAgICAqIFJldHVybnMgYSBjYW52YXMgZ3JhZGllbnQgb2JqZWN0IHRoYXQgaGFzIGEgcmVmZXJlbmNlIHRvIGl0J3MgcGFyZW50IGRlZlxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuY3JlYXRlUmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbih4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKXtcbiAgICAgICAgdmFyIGdyYWQgPSB0aGlzLl9fY3JlYXRlRWxlbWVudChcInJhZGlhbEdyYWRpZW50XCIsIHtcbiAgICAgICAgICAgIGlkIDogcmFuZG9tU3RyaW5nKHRoaXMuX19pZHMpLFxuICAgICAgICAgICAgY3ggOiB4MStcInB4XCIsXG4gICAgICAgICAgICBjeSA6IHkxK1wicHhcIixcbiAgICAgICAgICAgIHIgIDogcjErXCJweFwiLFxuICAgICAgICAgICAgZnggOiB4MCtcInB4XCIsXG4gICAgICAgICAgICBmeSA6IHkwK1wicHhcIixcbiAgICAgICAgICAgIFwiZ3JhZGllbnRVbml0c1wiIDogXCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fX2RlZnMuYXBwZW5kQ2hpbGQoZ3JhZCk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FudmFzR3JhZGllbnQoZ3JhZCwgdGhpcyk7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBmb250IHN0cmluZyBhbmQgcmV0dXJucyBzdmcgbWFwcGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5fX3BhcnNlRm9udCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVnZXggPSAvXlxccyooPz0oPzooPzpbLWEtel0rXFxzKil7MCwyfShpdGFsaWN8b2JsaXF1ZSkpPykoPz0oPzooPzpbLWEtel0rXFxzKil7MCwyfShzbWFsbC1jYXBzKSk/KSg/PSg/Oig/OlstYS16XStcXHMqKXswLDJ9KGJvbGQoPzplcik/fGxpZ2h0ZXJ8WzEtOV0wMCkpPykoPzooPzpub3JtYWx8XFwxfFxcMnxcXDMpXFxzKil7MCwzfSgoPzp4eD8tKT8oPzpzbWFsbHxsYXJnZSl8bWVkaXVtfHNtYWxsZXJ8bGFyZ2VyfFsuXFxkXSsoPzpcXCV8aW58W2NlbV1tfGV4fHBbY3R4XSkpKD86XFxzKlxcL1xccyoobm9ybWFsfFsuXFxkXSsoPzpcXCV8aW58W2NlbV1tfGV4fHBbY3R4XSkpKT9cXHMqKFstLFxcXCJcXHNhLXpdKz8pXFxzKiQvaTtcbiAgICAgICAgdmFyIGZvbnRQYXJ0ID0gcmVnZXguZXhlYyggdGhpcy5mb250ICk7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgc3R5bGUgOiBmb250UGFydFsxXSB8fCAnbm9ybWFsJyxcbiAgICAgICAgICAgIHNpemUgOiBmb250UGFydFs0XSB8fCAnMTBweCcsXG4gICAgICAgICAgICBmYW1pbHkgOiBmb250UGFydFs2XSB8fCAnc2Fucy1zZXJpZicsXG4gICAgICAgICAgICB3ZWlnaHQ6IGZvbnRQYXJ0WzNdIHx8ICdub3JtYWwnLFxuICAgICAgICAgICAgZGVjb3JhdGlvbiA6IGZvbnRQYXJ0WzJdIHx8ICdub3JtYWwnLFxuICAgICAgICAgICAgaHJlZiA6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICAvL2NhbnZhcyBkb2Vzbid0IHN1cHBvcnQgdW5kZXJsaW5lIG5hdGl2ZWx5LCBidXQgd2UgY2FuIHBhc3MgdGhpcyBhdHRyaWJ1dGVcbiAgICAgICAgaWYodGhpcy5fX2ZvbnRVbmRlcmxpbmUgPT09IFwidW5kZXJsaW5lXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZGVjb3JhdGlvbiA9IFwidW5kZXJsaW5lXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NhbnZhcyBhbHNvIGRvZXNuJ3Qgc3VwcG9ydCBsaW5raW5nLCBidXQgd2UgY2FuIHBhc3MgdGhpcyBhcyB3ZWxsXG4gICAgICAgIGlmKHRoaXMuX19mb250SHJlZikge1xuICAgICAgICAgICAgZGF0YS5ocmVmID0gdGhpcy5fX2ZvbnRIcmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0byBsaW5rIHRleHQgZnJhZ21lbnRzXG4gICAgICogQHBhcmFtIGZvbnRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjdHgucHJvdG90eXBlLl9fd3JhcFRleHRMaW5rID0gZnVuY3Rpb24oZm9udCwgZWxlbWVudCkge1xuICAgICAgICBpZihmb250LmhyZWYpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5fX2NyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgYS5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwgXCJ4bGluazpocmVmXCIsIGZvbnQuaHJlZik7XG4gICAgICAgICAgICBhLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbGxzIG9yIHN0cm9rZXMgdGV4dFxuICAgICAqIEBwYXJhbSB0ZXh0XG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBzdHJva2Ugb3IgZmlsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5fX2FwcGx5VGV4dCA9IGZ1bmN0aW9uKHRleHQsIHgsIHksIGFjdGlvbikge1xuICAgICAgICB2YXIgZm9udCA9IHRoaXMuX19wYXJzZUZvbnQoKSxcbiAgICAgICAgICAgIHBhcmVudCA9IHRoaXMuX19jbG9zZXN0R3JvdXBPclN2ZygpLFxuICAgICAgICAgICAgdGV4dEVsZW1lbnQgPSB0aGlzLl9fY3JlYXRlRWxlbWVudChcInRleHRcIiwge1xuICAgICAgICAgICAgICAgIFwiZm9udC1mYW1pbHlcIiA6IGZvbnQuZmFtaWx5LFxuICAgICAgICAgICAgICAgIFwiZm9udC1zaXplXCIgOiBmb250LnNpemUsXG4gICAgICAgICAgICAgICAgXCJmb250LXN0eWxlXCIgOiBmb250LnN0eWxlLFxuICAgICAgICAgICAgICAgIFwiZm9udC13ZWlnaHRcIiA6IGZvbnQud2VpZ2h0LFxuICAgICAgICAgICAgICAgIFwidGV4dC1kZWNvcmF0aW9uXCIgOiBmb250LmRlY29yYXRpb24sXG4gICAgICAgICAgICAgICAgXCJ4XCIgOiB4LFxuICAgICAgICAgICAgICAgIFwieVwiIDogeSxcbiAgICAgICAgICAgICAgICBcInRleHQtYW5jaG9yXCI6IGdldFRleHRBbmNob3IodGhpcy50ZXh0QWxpZ24pLFxuICAgICAgICAgICAgICAgIFwiZG9taW5hbnQtYmFzZWxpbmVcIjogZ2V0RG9taW5hbnRCYXNlbGluZSh0aGlzLnRleHRCYXNlbGluZSlcbiAgICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHRleHRFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgICAgIHRoaXMuX19jdXJyZW50RWxlbWVudCA9IHRleHRFbGVtZW50O1xuICAgICAgICB0aGlzLl9fYXBwbHlTdHlsZVRvQ3VycmVudEVsZW1lbnQoYWN0aW9uKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuX193cmFwVGV4dExpbmsoZm9udCx0ZXh0RWxlbWVudCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGV4dCBlbGVtZW50XG4gICAgICogQHBhcmFtIHRleHRcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5maWxsVGV4dCA9IGZ1bmN0aW9uKHRleHQsIHgsIHkpe1xuICAgICAgICB0aGlzLl9fYXBwbHlUZXh0KHRleHQsIHgsIHksIFwiZmlsbFwiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3Ryb2tlcyB0ZXh0XG4gICAgICogQHBhcmFtIHRleHRcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5zdHJva2VUZXh0ID0gZnVuY3Rpb24odGV4dCwgeCwgeSl7XG4gICAgICAgIHRoaXMuX19hcHBseVRleHQodGV4dCwgeCwgeSwgXCJzdHJva2VcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vIG5lZWQgdG8gaW1wbGVtZW50IHRoaXMgZm9yIHN2Zy5cbiAgICAgKiBAcGFyYW0gdGV4dFxuICAgICAqIEByZXR1cm4ge1RleHRNZXRyaWNzfVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUubWVhc3VyZVRleHQgPSBmdW5jdGlvbih0ZXh0KXtcbiAgICAgICAgdGhpcy5fX2N0eC5mb250ID0gdGhpcy5mb250O1xuICAgICAgICByZXR1cm4gdGhpcy5fX2N0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIEFyYyBjb21tYW5kIVxuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlckNsb2Nrd2lzZSkge1xuICAgICAgICAvLyBpbiBjYW52YXMgbm8gY2lyY2xlIGlzIGRyYXduIGlmIG5vIGFuZ2xlIGlzIHByb3ZpZGVkLlxuICAgICAgICBpZiAoc3RhcnRBbmdsZSA9PT0gZW5kQW5nbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSAlICgyKk1hdGguUEkpO1xuICAgICAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlICUgKDIqTWF0aC5QSSk7XG4gICAgICAgIGlmKHN0YXJ0QW5nbGUgPT09IGVuZEFuZ2xlKSB7XG4gICAgICAgICAgICAvL2NpcmNsZSB0aW1lISBzdWJ0cmFjdCBzb21lIG9mIHRoZSBhbmdsZSBzbyBzdmcgaXMgaGFwcHkgKHN2ZyBlbGxpcHRpY2FsIGFyYyBjYW4ndCBkcmF3IGEgZnVsbCBjaXJjbGUpXG4gICAgICAgICAgICBlbmRBbmdsZSA9ICgoZW5kQW5nbGUgKyAoMipNYXRoLlBJKSkgLSAwLjAwMSAqIChjb3VudGVyQ2xvY2t3aXNlID8gLTEgOiAxKSkgJSAoMipNYXRoLlBJKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kWCA9IHgrcmFkaXVzKk1hdGguY29zKGVuZEFuZ2xlKSxcbiAgICAgICAgICAgIGVuZFkgPSB5K3JhZGl1cypNYXRoLnNpbihlbmRBbmdsZSksXG4gICAgICAgICAgICBzdGFydFggPSB4K3JhZGl1cypNYXRoLmNvcyhzdGFydEFuZ2xlKSxcbiAgICAgICAgICAgIHN0YXJ0WSA9IHkrcmFkaXVzKk1hdGguc2luKHN0YXJ0QW5nbGUpLFxuICAgICAgICAgICAgc3dlZXBGbGFnID0gY291bnRlckNsb2Nrd2lzZSA/IDAgOiAxLFxuICAgICAgICAgICAgbGFyZ2VBcmNGbGFnID0gMCxcbiAgICAgICAgICAgIGRpZmYgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dsaWZmeS9jYW52YXMyc3ZnL2lzc3Vlcy80XG4gICAgICAgIGlmKGRpZmYgPCAwKSB7XG4gICAgICAgICAgICBkaWZmICs9IDIqTWF0aC5QSTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGNvdW50ZXJDbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIGxhcmdlQXJjRmxhZyA9IGRpZmYgPiBNYXRoLlBJID8gMCA6IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXJnZUFyY0ZsYWcgPSBkaWZmID4gTWF0aC5QSSA/IDEgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5saW5lVG8oc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICB0aGlzLl9fYWRkUGF0aENvbW1hbmQoZm9ybWF0KFwiQSB7cnh9IHtyeX0ge3hBeGlzUm90YXRpb259IHtsYXJnZUFyY0ZsYWd9IHtzd2VlcEZsYWd9IHtlbmRYfSB7ZW5kWX1cIixcbiAgICAgICAgICAgIHtyeDpyYWRpdXMsIHJ5OnJhZGl1cywgeEF4aXNSb3RhdGlvbjowLCBsYXJnZUFyY0ZsYWc6bGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWc6c3dlZXBGbGFnLCBlbmRYOmVuZFgsIGVuZFk6ZW5kWX0pKTtcblxuICAgICAgICB0aGlzLl9fY3VycmVudFBvc2l0aW9uID0ge3g6IGVuZFgsIHk6IGVuZFl9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBDbGlwUGF0aCBmcm9tIHRoZSBjbGlwIGNvbW1hbmQuXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5fX2Nsb3Nlc3RHcm91cE9yU3ZnKCksXG4gICAgICAgICAgICBjbGlwUGF0aCA9IHRoaXMuX19jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiksXG4gICAgICAgICAgICBpZCA9ICByYW5kb21TdHJpbmcodGhpcy5fX2lkcyksXG4gICAgICAgICAgICBuZXdHcm91cCA9IHRoaXMuX19jcmVhdGVFbGVtZW50KFwiZ1wiKTtcblxuICAgICAgICBncm91cC5yZW1vdmVDaGlsZCh0aGlzLl9fY3VycmVudEVsZW1lbnQpO1xuICAgICAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgICAgIGNsaXBQYXRoLmFwcGVuZENoaWxkKHRoaXMuX19jdXJyZW50RWxlbWVudCk7XG5cbiAgICAgICAgdGhpcy5fX2RlZnMuYXBwZW5kQ2hpbGQoY2xpcFBhdGgpO1xuXG4gICAgICAgIC8vc2V0IHRoZSBjbGlwIHBhdGggdG8gdGhpcyBncm91cFxuICAgICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIiwgZm9ybWF0KFwidXJsKCN7aWR9KVwiLCB7aWQ6aWR9KSk7XG5cbiAgICAgICAgLy9jbGlwIHBhdGhzIGNhbiBiZSBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkLCB3ZSBuZWVkIHRvIGFkZCBhbm90aGVyIHdyYXBwZXIgZ3JvdXAgdG8gYXZvaWQgbGF0ZXIgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgIC8vIHRvIHRoaXMgcGF0aFxuICAgICAgICBncm91cC5hcHBlbmRDaGlsZChuZXdHcm91cCk7XG5cbiAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50ID0gbmV3R3JvdXA7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBjYW52YXMsIGltYWdlIG9yIG1vY2sgY29udGV4dCB0byB0aGlzIGNhbnZhcy5cbiAgICAgKiBOb3RlIHRoYXQgYWxsIHN2ZyBkb20gbWFuaXB1bGF0aW9uIHVzZXMgbm9kZS5jaGlsZE5vZGVzIHJhdGhlciB0aGFuIG5vZGUuY2hpbGRyZW4gZm9yIElFIHN1cHBvcnQuXG4gICAgICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtZHJhd2ltYWdlXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5kcmF3SW1hZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgICAvL2NvbnZlcnQgYXJndW1lbnRzIHRvIGEgcmVhbCBhcnJheVxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBpbWFnZT1hcmdzWzBdLFxuICAgICAgICAgICAgZHgsIGR5LCBkdywgZGgsIHN4PTAsIHN5PTAsIHN3LCBzaCwgcGFyZW50LCBzdmcsIGRlZnMsIGdyb3VwLFxuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQsIHN2Z0ltYWdlLCBjYW52YXMsIGNvbnRleHQsIGlkO1xuXG4gICAgICAgIGlmKGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICBkeCA9IGFyZ3NbMV07XG4gICAgICAgICAgICBkeSA9IGFyZ3NbMl07XG4gICAgICAgICAgICBzdyA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgc2ggPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICBkdyA9IHN3O1xuICAgICAgICAgICAgZGggPSBzaDtcbiAgICAgICAgfSBlbHNlIGlmKGFyZ3MubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICBkeCA9IGFyZ3NbMV07XG4gICAgICAgICAgICBkeSA9IGFyZ3NbMl07XG4gICAgICAgICAgICBkdyA9IGFyZ3NbM107XG4gICAgICAgICAgICBkaCA9IGFyZ3NbNF07XG4gICAgICAgICAgICBzdyA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgc2ggPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZihhcmdzLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAgICAgc3ggPSBhcmdzWzFdO1xuICAgICAgICAgICAgc3kgPSBhcmdzWzJdO1xuICAgICAgICAgICAgc3cgPSBhcmdzWzNdO1xuICAgICAgICAgICAgc2ggPSBhcmdzWzRdO1xuICAgICAgICAgICAgZHggPSBhcmdzWzVdO1xuICAgICAgICAgICAgZHkgPSBhcmdzWzZdO1xuICAgICAgICAgICAgZHcgPSBhcmdzWzddO1xuICAgICAgICAgICAgZGggPSBhcmdzWzhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5hdmxpZCBudW1iZXIgb2YgYXJndW1lbnRzIHBhc3NlZCB0byBkcmF3SW1hZ2U6IFwiICsgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQgPSB0aGlzLl9fY2xvc2VzdEdyb3VwT3JTdmcoKTtcbiAgICAgICAgY3VycmVudEVsZW1lbnQgPSB0aGlzLl9fY3VycmVudEVsZW1lbnQ7XG5cbiAgICAgICAgaWYoaW1hZ2UgaW5zdGFuY2VvZiBjdHgpIHtcbiAgICAgICAgICAgIC8vY2FudmFzMnN2ZyBtb2NrIGNhbnZhcyBjb250ZXh0LiBJbiB0aGUgZnV0dXJlIHdlIG1heSB3YW50IHRvIGNsb25lIG5vZGVzIGluc3RlYWQuXG4gICAgICAgICAgICAvL2Fsc28gSSdtIGN1cnJlbnRseSBpZ25vcmluZyBkdywgZGgsIHN3LCBzaCwgc3gsIHN5IGZvciBhIG1vY2sgY29udGV4dC5cbiAgICAgICAgICAgIHN2ZyA9IGltYWdlLmdldFN2ZygpO1xuICAgICAgICAgICAgZGVmcyA9IHN2Zy5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgd2hpbGUoZGVmcy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlkID0gZGVmcy5jaGlsZE5vZGVzWzBdLmdldEF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19pZHNbaWRdID0gaWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2RlZnMuYXBwZW5kQ2hpbGQoZGVmcy5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyb3VwID0gc3ZnLmNoaWxkTm9kZXNbMV07XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICAgICAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50ID0gZ3JvdXA7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShkeCwgZHkpO1xuICAgICAgICAgICAgdGhpcy5fX2N1cnJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSBpZihpbWFnZS5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIiB8fCBpbWFnZS5ub2RlTmFtZSA9PT0gXCJJTUdcIikge1xuICAgICAgICAgICAgLy9jYW52YXMgb3IgaW1hZ2VcbiAgICAgICAgICAgIHN2Z0ltYWdlID0gdGhpcy5fX2NyZWF0ZUVsZW1lbnQoXCJpbWFnZVwiKTtcbiAgICAgICAgICAgIHN2Z0ltYWdlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGR3KTtcbiAgICAgICAgICAgIHN2Z0ltYWdlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBkaCk7XG4gICAgICAgICAgICBzdmdJbWFnZS5zZXRBdHRyaWJ1dGUoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwibm9uZVwiKTtcblxuICAgICAgICAgICAgaWYoc3ggfHwgc3kgfHwgc3cgIT09IGltYWdlLndpZHRoIHx8IHNoICE9PSBpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvL2Nyb3AgdGhlIGltYWdlIHVzaW5nIGEgdGVtcG9yYXJ5IGNhbnZhc1xuICAgICAgICAgICAgICAgIGNhbnZhcyA9IHRoaXMuX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGR3O1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaDtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzdywgc2gsIDAsIDAsIGR3LCBkaCk7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBjYW52YXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN2Z0ltYWdlLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBcInhsaW5rOmhyZWZcIixcbiAgICAgICAgICAgICAgICBpbWFnZS5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIiA/IGltYWdlLnRvRGF0YVVSTCgpIDogaW1hZ2UuZ2V0QXR0cmlidXRlKFwic3JjXCIpKTtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChzdmdJbWFnZSk7XG4gICAgICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQgPSBzdmdJbWFnZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKGR4LCBkeSk7XG4gICAgICAgICAgICB0aGlzLl9fY3VycmVudEVsZW1lbnQgPSBjdXJyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBwYXR0ZXJuIHRhZ1xuICAgICAqL1xuICAgIGN0eC5wcm90b3R5cGUuY3JlYXRlUGF0dGVybiA9IGZ1bmN0aW9uKGltYWdlLCByZXBldGl0aW9uKXtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLl9fZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXR0ZXJuXCIpLCBpZCA9IHJhbmRvbVN0cmluZyh0aGlzLl9faWRzKSxcbiAgICAgICAgICAgIGltZztcbiAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgICAgIHBhdHRlcm4uc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgaW1hZ2Uud2lkdGgpO1xuICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICBpZihpbWFnZS5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIiB8fCBpbWFnZS5ub2RlTmFtZSA9PT0gXCJJTUdcIikge1xuICAgICAgICAgICAgaW1nID0gdGhpcy5fX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiaW1hZ2VcIik7XG4gICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgaW1hZ2Uud2lkdGgpO1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBcInhsaW5rOmhyZWZcIixcbiAgICAgICAgICAgICAgICBpbWFnZS5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIiA/IGltYWdlLnRvRGF0YVVSTCgpIDogaW1hZ2UuZ2V0QXR0cmlidXRlKFwic3JjXCIpKTtcbiAgICAgICAgICAgIHBhdHRlcm4uYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgICAgIHRoaXMuX19kZWZzLmFwcGVuZENoaWxkKHBhdHRlcm4pO1xuICAgICAgICB9IGVsc2UgaWYoaW1hZ2UgaW5zdGFuY2VvZiBjdHgpIHtcbiAgICAgICAgICAgIHBhdHRlcm4uYXBwZW5kQ2hpbGQoaW1hZ2UuX19yb290LmNoaWxkTm9kZXNbMV0pO1xuICAgICAgICAgICAgdGhpcy5fX2RlZnMuYXBwZW5kQ2hpbGQocGF0dGVybik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDYW52YXNQYXR0ZXJuKHBhdHRlcm4sIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOb3QgeWV0IGltcGxlbWVudGVkXG4gICAgICovXG4gICAgY3R4LnByb3RvdHlwZS5kcmF3Rm9jdXNSaW5nID0gZnVuY3Rpb24oKXt9O1xuICAgIGN0eC5wcm90b3R5cGUuY3JlYXRlSW1hZ2VEYXRhID0gZnVuY3Rpb24oKXt9O1xuICAgIGN0eC5wcm90b3R5cGUuZ2V0SW1hZ2VEYXRhID0gZnVuY3Rpb24oKXt9O1xuICAgIGN0eC5wcm90b3R5cGUucHV0SW1hZ2VEYXRhID0gZnVuY3Rpb24oKXt9O1xuICAgIGN0eC5wcm90b3R5cGUuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZnVuY3Rpb24oKXt9O1xuICAgIGN0eC5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24oKXt9O1xuXG4gICAgLy9hZGQgb3B0aW9ucyBmb3IgYWx0ZXJuYXRpdmUgbmFtZXNwYWNlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgd2luZG93LkMyUyA9IGN0eDtcbiAgICB9XG5cbiAgICAvLyBDb21tb25KUy9Ccm93c2VyaWZ5XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gY3R4O1xuICAgIH1cblxufSgpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtYXJyYXkvIHYyLjQuMCBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn1cblxuZnVuY3Rpb24gYmlzZWN0b3IoY29tcGFyZSkge1xuICBpZiAoY29tcGFyZS5sZW5ndGggPT09IDEpIGNvbXBhcmUgPSBhc2NlbmRpbmdDb21wYXJhdG9yKGNvbXBhcmUpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7XG4gICAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG87XG4gICAgfSxcbiAgICByaWdodDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApIGhpID0gbWlkO1xuICAgICAgICBlbHNlIGxvID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsbztcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZ0NvbXBhcmF0b3IoZikge1xuICByZXR1cm4gZnVuY3Rpb24oZCwgeCkge1xuICAgIHJldHVybiBhc2NlbmRpbmcoZihkKSwgeCk7XG4gIH07XG59XG5cbnZhciBhc2NlbmRpbmdCaXNlY3QgPSBiaXNlY3Rvcihhc2NlbmRpbmcpO1xudmFyIGJpc2VjdFJpZ2h0ID0gYXNjZW5kaW5nQmlzZWN0LnJpZ2h0O1xudmFyIGJpc2VjdExlZnQgPSBhc2NlbmRpbmdCaXNlY3QubGVmdDtcblxuZnVuY3Rpb24gY291bnQodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoKGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5sZW5ndGggfCAwO1xufVxuXG5mdW5jdGlvbiBlbXB0eShsZW5ndGgpIHtcbiAgcmV0dXJuICEobGVuZ3RoID4gMCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5aWZ5KHZhbHVlcykge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlcyAhPT0gXCJvYmplY3RcIiB8fCBcImxlbmd0aFwiIGluIHZhbHVlcyA/IHZhbHVlcyA6IEFycmF5LmZyb20odmFsdWVzKTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlcihyZWR1Y2UpIHtcbiAgcmV0dXJuIHZhbHVlcyA9PiByZWR1Y2UoLi4udmFsdWVzKTtcbn1cblxuZnVuY3Rpb24gY3Jvc3MoLi4udmFsdWVzKSB7XG4gIGNvbnN0IHJlZHVjZSA9IHR5cGVvZiB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCIgJiYgcmVkdWNlcih2YWx1ZXMucG9wKCkpO1xuICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGFycmF5aWZ5KTtcbiAgY29uc3QgbGVuZ3RocyA9IHZhbHVlcy5tYXAobGVuZ3RoKTtcbiAgY29uc3QgaiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICBjb25zdCBpbmRleCA9IG5ldyBBcnJheShqICsgMSkuZmlsbCgwKTtcbiAgY29uc3QgcHJvZHVjdCA9IFtdO1xuICBpZiAoaiA8IDAgfHwgbGVuZ3Rocy5zb21lKGVtcHR5KSkgcmV0dXJuIHByb2R1Y3Q7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgcHJvZHVjdC5wdXNoKGluZGV4Lm1hcCgoaiwgaSkgPT4gdmFsdWVzW2ldW2pdKSk7XG4gICAgbGV0IGkgPSBqO1xuICAgIHdoaWxlICgrK2luZGV4W2ldID09PSBsZW5ndGhzW2ldKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgcmV0dXJuIHJlZHVjZSA/IHByb2R1Y3QubWFwKHJlZHVjZSkgOiBwcm9kdWN0O1xuICAgICAgaW5kZXhbaS0tXSA9IDA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGN1bXN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIHN1bSA9IDAsIGluZGV4ID0gMDtcbiAgcmV0dXJuIEZsb2F0NjRBcnJheS5mcm9tKHZhbHVlcywgdmFsdWVvZiA9PT0gdW5kZWZpbmVkXG4gICAgPyB2ID0+IChzdW0gKz0gK3YgfHwgMClcbiAgICA6IHYgPT4gKHN1bSArPSArdmFsdWVvZih2LCBpbmRleCsrLCB2YWx1ZXMpIHx8IDApKTtcbn1cblxuZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBiIDwgYSA/IC0xIDogYiA+IGEgPyAxIDogYiA+PSBhID8gMCA6IE5hTjtcbn1cblxuZnVuY3Rpb24gdmFyaWFuY2UodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBkZWx0YTtcbiAgbGV0IG1lYW4gPSAwO1xuICBsZXQgc3VtID0gMDtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICBkZWx0YSA9IHZhbHVlIC0gbWVhbjtcbiAgICAgICAgbWVhbiArPSBkZWx0YSAvICsrY291bnQ7XG4gICAgICAgIHN1bSArPSBkZWx0YSAqICh2YWx1ZSAtIG1lYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK2NvdW50O1xuICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNvdW50ID4gMSkgcmV0dXJuIHN1bSAvIChjb3VudCAtIDEpO1xufVxuXG5mdW5jdGlvbiBkZXZpYXRpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGNvbnN0IHYgPSB2YXJpYW5jZSh2YWx1ZXMsIHZhbHVlb2YpO1xuICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG59XG5cbmZ1bmN0aW9uIGV4dGVudCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IG1pbjtcbiAgbGV0IG1heDtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPj0gdmFsdWUpIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh2YWx1ZSA+PSB2YWx1ZSkgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbbWluLCBtYXhdO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBncm91cCh2YWx1ZXMsIC4uLmtleXMpIHtcbiAgcmV0dXJuIG5lc3QodmFsdWVzLCBpZGVudGl0eSwgaWRlbnRpdHksIGtleXMpO1xufVxuXG5mdW5jdGlvbiBncm91cHModmFsdWVzLCAuLi5rZXlzKSB7XG4gIHJldHVybiBuZXN0KHZhbHVlcywgQXJyYXkuZnJvbSwgaWRlbnRpdHksIGtleXMpO1xufVxuXG5mdW5jdGlvbiByb2xsdXAodmFsdWVzLCByZWR1Y2UsIC4uLmtleXMpIHtcbiAgcmV0dXJuIG5lc3QodmFsdWVzLCBpZGVudGl0eSwgcmVkdWNlLCBrZXlzKTtcbn1cblxuZnVuY3Rpb24gcm9sbHVwcyh2YWx1ZXMsIHJlZHVjZSwgLi4ua2V5cykge1xuICByZXR1cm4gbmVzdCh2YWx1ZXMsIEFycmF5LmZyb20sIHJlZHVjZSwga2V5cyk7XG59XG5cbmZ1bmN0aW9uIG5lc3QodmFsdWVzLCBtYXAsIHJlZHVjZSwga2V5cykge1xuICByZXR1cm4gKGZ1bmN0aW9uIHJlZ3JvdXAodmFsdWVzLCBpKSB7XG4gICAgaWYgKGkgPj0ga2V5cy5sZW5ndGgpIHJldHVybiByZWR1Y2UodmFsdWVzKTtcbiAgICBjb25zdCBncm91cHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qga2V5b2YgPSBrZXlzW2krK107XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpO1xuICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHMuZ2V0KGtleSk7XG4gICAgICBpZiAoZ3JvdXApIGdyb3VwLnB1c2godmFsdWUpO1xuICAgICAgZWxzZSBncm91cHMuc2V0KGtleSwgW3ZhbHVlXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiBncm91cHMpIHtcbiAgICAgIGdyb3Vwcy5zZXQoa2V5LCByZWdyb3VwKHZhbHVlcywgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwKGdyb3Vwcyk7XG4gIH0pKHZhbHVlcywgMCk7XG59XG5cbnZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHNsaWNlID0gYXJyYXkuc2xpY2U7XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICBzdGFydCA9ICtzdGFydCwgc3RvcCA9ICtzdG9wLCBzdGVwID0gKG4gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDIgPyAoc3RvcCA9IHN0YXJ0LCBzdGFydCA9IDAsIDEpIDogbiA8IDMgPyAxIDogK3N0ZXA7XG5cbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSkgfCAwLFxuICAgICAgcmFuZ2UgPSBuZXcgQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByYW5nZVtpXSA9IHN0YXJ0ICsgaSAqIHN0ZXA7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59XG5cbnZhciBlMTAgPSBNYXRoLnNxcnQoNTApLFxuICAgIGU1ID0gTWF0aC5zcXJ0KDEwKSxcbiAgICBlMiA9IE1hdGguc3FydCgyKTtcblxuZnVuY3Rpb24gdGlja3Moc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciByZXZlcnNlLFxuICAgICAgaSA9IC0xLFxuICAgICAgbixcbiAgICAgIHRpY2tzLFxuICAgICAgc3RlcDtcblxuICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgaWYgKHN0YXJ0ID09PSBzdG9wICYmIGNvdW50ID4gMCkgcmV0dXJuIFtzdGFydF07XG4gIGlmIChyZXZlcnNlID0gc3RvcCA8IHN0YXJ0KSBuID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IG47XG4gIGlmICgoc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSkgPT09IDAgfHwgIWlzRmluaXRlKHN0ZXApKSByZXR1cm4gW107XG5cbiAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgLyBzdGVwKTtcbiAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wIC8gc3RlcCk7XG4gICAgdGlja3MgPSBuZXcgQXJyYXkobiA9IE1hdGguY2VpbChzdG9wIC0gc3RhcnQgKyAxKSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRpY2tzW2ldID0gKHN0YXJ0ICsgaSkgKiBzdGVwO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAqIHN0ZXApO1xuICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAqIHN0ZXApO1xuICAgIHRpY2tzID0gbmV3IEFycmF5KG4gPSBNYXRoLmNlaWwoc3RhcnQgLSBzdG9wICsgMSkpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChzdGFydCAtIGkpIC8gc3RlcDtcbiAgfVxuXG4gIGlmIChyZXZlcnNlKSB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5mdW5jdGlvbiB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMCwgY291bnQpLFxuICAgICAgcG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nKHN0ZXApIC8gTWF0aC5MTjEwKSxcbiAgICAgIGVycm9yID0gc3RlcCAvIE1hdGgucG93KDEwLCBwb3dlcik7XG4gIHJldHVybiBwb3dlciA+PSAwXG4gICAgICA/IChlcnJvciA+PSBlMTAgPyAxMCA6IGVycm9yID49IGU1ID8gNSA6IGVycm9yID49IGUyID8gMiA6IDEpICogTWF0aC5wb3coMTAsIHBvd2VyKVxuICAgICAgOiAtTWF0aC5wb3coMTAsIC1wb3dlcikgLyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKTtcbn1cblxuZnVuY3Rpb24gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciBzdGVwMCA9IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICBzdGVwMSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHN0ZXAwKSAvIE1hdGguTE4xMCkpLFxuICAgICAgZXJyb3IgPSBzdGVwMCAvIHN0ZXAxO1xuICBpZiAoZXJyb3IgPj0gZTEwKSBzdGVwMSAqPSAxMDtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTUpIHN0ZXAxICo9IDU7XG4gIGVsc2UgaWYgKGVycm9yID49IGUyKSBzdGVwMSAqPSAyO1xuICByZXR1cm4gc3RvcCA8IHN0YXJ0ID8gLXN0ZXAxIDogc3RlcDE7XG59XG5cbmZ1bmN0aW9uIHN0dXJnZXModmFsdWVzKSB7XG4gIHJldHVybiBNYXRoLmNlaWwoTWF0aC5sb2coY291bnQodmFsdWVzKSkgLyBNYXRoLkxOMikgKyAxO1xufVxuXG5mdW5jdGlvbiBiaW4oKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgZG9tYWluID0gZXh0ZW50LFxuICAgICAgdGhyZXNob2xkID0gc3R1cmdlcztcblxuICBmdW5jdGlvbiBoaXN0b2dyYW0oZGF0YSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkgZGF0YSA9IEFycmF5LmZyb20oZGF0YSk7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICB4LFxuICAgICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkobik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSB2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKTtcbiAgICB9XG5cbiAgICB2YXIgeHogPSBkb21haW4odmFsdWVzKSxcbiAgICAgICAgeDAgPSB4elswXSxcbiAgICAgICAgeDEgPSB4elsxXSxcbiAgICAgICAgdHogPSB0aHJlc2hvbGQodmFsdWVzLCB4MCwgeDEpO1xuXG4gICAgLy8gQ29udmVydCBudW1iZXIgb2YgdGhyZXNob2xkcyBpbnRvIHVuaWZvcm0gdGhyZXNob2xkcy5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHopKSB7XG4gICAgICB0eiA9IHRpY2tTdGVwKHgwLCB4MSwgdHopO1xuICAgICAgdHogPSByYW5nZShNYXRoLmNlaWwoeDAgLyB0eikgKiB0eiwgeDEsIHR6KTsgLy8gZXhjbHVzaXZlXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSB0aHJlc2hvbGRzIG91dHNpZGUgdGhlIGRvbWFpbi5cbiAgICB2YXIgbSA9IHR6Lmxlbmd0aDtcbiAgICB3aGlsZSAodHpbMF0gPD0geDApIHR6LnNoaWZ0KCksIC0tbTtcbiAgICB3aGlsZSAodHpbbSAtIDFdID4geDEpIHR6LnBvcCgpLCAtLW07XG5cbiAgICB2YXIgYmlucyA9IG5ldyBBcnJheShtICsgMSksXG4gICAgICAgIGJpbjtcblxuICAgIC8vIEluaXRpYWxpemUgYmlucy5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG07ICsraSkge1xuICAgICAgYmluID0gYmluc1tpXSA9IFtdO1xuICAgICAgYmluLngwID0gaSA+IDAgPyB0eltpIC0gMV0gOiB4MDtcbiAgICAgIGJpbi54MSA9IGkgPCBtID8gdHpbaV0gOiB4MTtcbiAgICB9XG5cbiAgICAvLyBBc3NpZ24gZGF0YSB0byBiaW5zIGJ5IHZhbHVlLCBpZ25vcmluZyBhbnkgb3V0c2lkZSB0aGUgZG9tYWluLlxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHggPSB2YWx1ZXNbaV07XG4gICAgICBpZiAoeDAgPD0geCAmJiB4IDw9IHgxKSB7XG4gICAgICAgIGJpbnNbYmlzZWN0UmlnaHQodHosIHgsIDAsIG0pXS5wdXNoKGRhdGFbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiaW5zO1xuICB9XG5cbiAgaGlzdG9ncmFtLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHZhbHVlO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbX1swXSwgX1sxXV0pLCBoaXN0b2dyYW0pIDogZG9tYWluO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS50aHJlc2hvbGRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRocmVzaG9sZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogQXJyYXkuaXNBcnJheShfKSA/IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpIDogY29uc3RhbnQoXyksIGhpc3RvZ3JhbSkgOiB0aHJlc2hvbGQ7XG4gIH07XG5cbiAgcmV0dXJuIGhpc3RvZ3JhbTtcbn1cblxuZnVuY3Rpb24gbWF4KHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWF4O1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1heCA8IHZhbHVlIHx8IChtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1heCA8IHZhbHVlIHx8IChtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4O1xufVxuXG5mdW5jdGlvbiBtaW4odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtaW47XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW47XG59XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3F1aWNrc2VsZWN0XG4vLyBJU0MgbGljZW5zZSwgQ29weXJpZ2h0IDIwMTggVmxhZGltaXIgQWdhZm9ua2luLlxuZnVuY3Rpb24gcXVpY2tzZWxlY3QoYXJyYXksIGssIGxlZnQgPSAwLCByaWdodCA9IGFycmF5Lmxlbmd0aCAtIDEsIGNvbXBhcmUgPSBhc2NlbmRpbmcpIHtcbiAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgIGNvbnN0IG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgY29uc3QgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgIGNvbnN0IHogPSBNYXRoLmxvZyhuKTtcbiAgICAgIGNvbnN0IHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgY29uc3Qgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICBjb25zdCBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgIGNvbnN0IG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICBxdWlja3NlbGVjdChhcnJheSwgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGNvbXBhcmUpO1xuICAgIH1cblxuICAgIGNvbnN0IHQgPSBhcnJheVtrXTtcbiAgICBsZXQgaSA9IGxlZnQ7XG4gICAgbGV0IGogPSByaWdodDtcblxuICAgIHN3YXAoYXJyYXksIGxlZnQsIGspO1xuICAgIGlmIChjb21wYXJlKGFycmF5W3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFycmF5LCBsZWZ0LCByaWdodCk7XG5cbiAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgIHN3YXAoYXJyYXksIGksIGopLCArK2ksIC0tajtcbiAgICAgIHdoaWxlIChjb21wYXJlKGFycmF5W2ldLCB0KSA8IDApICsraTtcbiAgICAgIHdoaWxlIChjb21wYXJlKGFycmF5W2pdLCB0KSA+IDApIC0tajtcbiAgICB9XG5cbiAgICBpZiAoY29tcGFyZShhcnJheVtsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyYXksIGxlZnQsIGopO1xuICAgIGVsc2UgKytqLCBzd2FwKGFycmF5LCBqLCByaWdodCk7XG5cbiAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyYXksIGksIGopIHtcbiAgY29uc3QgdCA9IGFycmF5W2ldO1xuICBhcnJheVtpXSA9IGFycmF5W2pdO1xuICBhcnJheVtqXSA9IHQ7XG59XG5cbmZ1bmN0aW9uIG51bWJlcih4KSB7XG4gIHJldHVybiB4ID09PSBudWxsID8gTmFOIDogK3g7XG59XG5cbmZ1bmN0aW9uKiBudW1iZXJzKHZhbHVlcywgdmFsdWVvZikge1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlKHZhbHVlcywgcCwgdmFsdWVvZikge1xuICB2YWx1ZXMgPSBGbG9hdDY0QXJyYXkuZnJvbShudW1iZXJzKHZhbHVlcywgdmFsdWVvZikpO1xuICBpZiAoIShuID0gdmFsdWVzLmxlbmd0aCkpIHJldHVybjtcbiAgaWYgKChwID0gK3ApIDw9IDAgfHwgbiA8IDIpIHJldHVybiBtaW4odmFsdWVzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuIG1heCh2YWx1ZXMpO1xuICB2YXIgbixcbiAgICAgIGkgPSAobiAtIDEpICogcCxcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcbiAgICAgIHZhbHVlMCA9IG1heChxdWlja3NlbGVjdCh2YWx1ZXMsIGkwKS5zdWJhcnJheSgwLCBpMCArIDEpKSxcbiAgICAgIHZhbHVlMSA9IG1pbih2YWx1ZXMuc3ViYXJyYXkoaTAgKyAxKSk7XG4gIHJldHVybiB2YWx1ZTAgKyAodmFsdWUxIC0gdmFsdWUwKSAqIChpIC0gaTApO1xufVxuXG5mdW5jdGlvbiBxdWFudGlsZVNvcnRlZCh2YWx1ZXMsIHAsIHZhbHVlb2YgPSBudW1iZXIpIHtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XG4gIGlmICgocCA9ICtwKSA8PSAwIHx8IG4gPCAyKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzWzBdLCAwLCB2YWx1ZXMpO1xuICBpZiAocCA+PSAxKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzW24gLSAxXSwgbiAtIDEsIHZhbHVlcyk7XG4gIHZhciBuLFxuICAgICAgaSA9IChuIC0gMSkgKiBwLFxuICAgICAgaTAgPSBNYXRoLmZsb29yKGkpLFxuICAgICAgdmFsdWUwID0gK3ZhbHVlb2YodmFsdWVzW2kwXSwgaTAsIHZhbHVlcyksXG4gICAgICB2YWx1ZTEgPSArdmFsdWVvZih2YWx1ZXNbaTAgKyAxXSwgaTAgKyAxLCB2YWx1ZXMpO1xuICByZXR1cm4gdmFsdWUwICsgKHZhbHVlMSAtIHZhbHVlMCkgKiAoaSAtIGkwKTtcbn1cblxuZnVuY3Rpb24gZnJlZWRtYW5EaWFjb25pcyh2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoMiAqIChxdWFudGlsZSh2YWx1ZXMsIDAuNzUpIC0gcXVhbnRpbGUodmFsdWVzLCAwLjI1KSkgKiBNYXRoLnBvdyhjb3VudCh2YWx1ZXMpLCAtMSAvIDMpKSk7XG59XG5cbmZ1bmN0aW9uIHNjb3R0KHZhbHVlcywgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGguY2VpbCgobWF4IC0gbWluKSAvICgzLjUgKiBkZXZpYXRpb24odmFsdWVzKSAqIE1hdGgucG93KGNvdW50KHZhbHVlcyksIC0xIC8gMykpKTtcbn1cblxuZnVuY3Rpb24gbWF4SW5kZXgodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtYXg7XG4gIGxldCBtYXhJbmRleCA9IC0xO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICArK2luZGV4O1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWUsIG1heEluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWUsIG1heEluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXhJbmRleDtcbn1cblxuZnVuY3Rpb24gbWVhbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IHN1bSA9IDA7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgKytjb3VudCwgc3VtICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgKytjb3VudCwgc3VtICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY291bnQpIHJldHVybiBzdW0gLyBjb3VudDtcbn1cblxuZnVuY3Rpb24gbWVkaWFuKHZhbHVlcywgdmFsdWVvZikge1xuICByZXR1cm4gcXVhbnRpbGUodmFsdWVzLCAwLjUsIHZhbHVlb2YpO1xufVxuXG5mdW5jdGlvbiogZmxhdHRlbihhcnJheXMpIHtcbiAgZm9yIChjb25zdCBhcnJheSBvZiBhcnJheXMpIHtcbiAgICB5aWVsZCogYXJyYXk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2UoYXJyYXlzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGZsYXR0ZW4oYXJyYXlzKSk7XG59XG5cbmZ1bmN0aW9uIG1pbkluZGV4KHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWluO1xuICBsZXQgbWluSW5kZXggPSAtMTtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgKytpbmRleDtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlLCBtaW5JbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlLCBtaW5JbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWluSW5kZXg7XG59XG5cbmZ1bmN0aW9uIHBhaXJzKHZhbHVlcywgcGFpcm9mID0gcGFpcikge1xuICBjb25zdCBwYWlycyA9IFtdO1xuICBsZXQgcHJldmlvdXM7XG4gIGxldCBmaXJzdCA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIGlmIChmaXJzdCkgcGFpcnMucHVzaChwYWlyb2YocHJldmlvdXMsIHZhbHVlKSk7XG4gICAgcHJldmlvdXMgPSB2YWx1ZTtcbiAgICBmaXJzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHBhaXJzO1xufVxuXG5mdW5jdGlvbiBwYWlyKGEsIGIpIHtcbiAgcmV0dXJuIFthLCBiXTtcbn1cblxuZnVuY3Rpb24gcGVybXV0ZShzb3VyY2UsIGtleXMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oa2V5cywga2V5ID0+IHNvdXJjZVtrZXldKTtcbn1cblxuZnVuY3Rpb24gbGVhc3QodmFsdWVzLCBjb21wYXJlID0gYXNjZW5kaW5nKSB7XG4gIGxldCBtaW47XG4gIGxldCBkZWZpbmVkID0gZmFsc2U7XG4gIGlmIChjb21wYXJlLmxlbmd0aCA9PT0gMSkge1xuICAgIGxldCBtaW5WYWx1ZTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdmFsdWVzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNvbXBhcmUoZWxlbWVudCk7XG4gICAgICBpZiAoZGVmaW5lZFxuICAgICAgICAgID8gYXNjZW5kaW5nKHZhbHVlLCBtaW5WYWx1ZSkgPCAwXG4gICAgICAgICAgOiBhc2NlbmRpbmcodmFsdWUsIHZhbHVlKSA9PT0gMCkge1xuICAgICAgICBtaW4gPSBlbGVtZW50O1xuICAgICAgICBtaW5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICBkZWZpbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmIChkZWZpbmVkXG4gICAgICAgICAgPyBjb21wYXJlKHZhbHVlLCBtaW4pIDwgMFxuICAgICAgICAgIDogY29tcGFyZSh2YWx1ZSwgdmFsdWUpID09PSAwKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICBkZWZpbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn1cblxuZnVuY3Rpb24gbGVhc3RJbmRleCh2YWx1ZXMsIGNvbXBhcmUgPSBhc2NlbmRpbmcpIHtcbiAgaWYgKGNvbXBhcmUubGVuZ3RoID09PSAxKSByZXR1cm4gbWluSW5kZXgodmFsdWVzLCBjb21wYXJlKTtcbiAgbGV0IG1pblZhbHVlO1xuICBsZXQgbWluID0gLTE7XG4gIGxldCBpbmRleCA9IC0xO1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICsraW5kZXg7XG4gICAgaWYgKG1pbiA8IDBcbiAgICAgICAgPyBjb21wYXJlKHZhbHVlLCB2YWx1ZSkgPT09IDBcbiAgICAgICAgOiBjb21wYXJlKHZhbHVlLCBtaW5WYWx1ZSkgPCAwKSB7XG4gICAgICBtaW5WYWx1ZSA9IHZhbHVlO1xuICAgICAgbWluID0gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW47XG59XG5cbmZ1bmN0aW9uIGdyZWF0ZXN0KHZhbHVlcywgY29tcGFyZSA9IGFzY2VuZGluZykge1xuICBsZXQgbWF4O1xuICBsZXQgZGVmaW5lZCA9IGZhbHNlO1xuICBpZiAoY29tcGFyZS5sZW5ndGggPT09IDEpIHtcbiAgICBsZXQgbWF4VmFsdWU7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHZhbHVlcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBjb21wYXJlKGVsZW1lbnQpO1xuICAgICAgaWYgKGRlZmluZWRcbiAgICAgICAgICA/IGFzY2VuZGluZyh2YWx1ZSwgbWF4VmFsdWUpID4gMFxuICAgICAgICAgIDogYXNjZW5kaW5nKHZhbHVlLCB2YWx1ZSkgPT09IDApIHtcbiAgICAgICAgbWF4ID0gZWxlbWVudDtcbiAgICAgICAgbWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZGVmaW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoZGVmaW5lZFxuICAgICAgICAgID8gY29tcGFyZSh2YWx1ZSwgbWF4KSA+IDBcbiAgICAgICAgICA6IGNvbXBhcmUodmFsdWUsIHZhbHVlKSA9PT0gMCkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgZGVmaW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXg7XG59XG5cbmZ1bmN0aW9uIGdyZWF0ZXN0SW5kZXgodmFsdWVzLCBjb21wYXJlID0gYXNjZW5kaW5nKSB7XG4gIGlmIChjb21wYXJlLmxlbmd0aCA9PT0gMSkgcmV0dXJuIG1heEluZGV4KHZhbHVlcywgY29tcGFyZSk7XG4gIGxldCBtYXhWYWx1ZTtcbiAgbGV0IG1heCA9IC0xO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICArK2luZGV4O1xuICAgIGlmIChtYXggPCAwXG4gICAgICAgID8gY29tcGFyZSh2YWx1ZSwgdmFsdWUpID09PSAwXG4gICAgICAgIDogY29tcGFyZSh2YWx1ZSwgbWF4VmFsdWUpID4gMCkge1xuICAgICAgbWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgIG1heCA9IGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4O1xufVxuXG5mdW5jdGlvbiBzY2FuKHZhbHVlcywgY29tcGFyZSkge1xuICBjb25zdCBpbmRleCA9IGxlYXN0SW5kZXgodmFsdWVzLCBjb21wYXJlKTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGluZGV4O1xufVxuXG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5LCBpMCA9IDAsIGkxID0gYXJyYXkubGVuZ3RoKSB7XG4gIHZhciBtID0gaTEgLSAoaTAgPSAraTApLFxuICAgICAgdCxcbiAgICAgIGk7XG5cbiAgd2hpbGUgKG0pIHtcbiAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgdCA9IGFycmF5W20gKyBpMF07XG4gICAgYXJyYXlbbSArIGkwXSA9IGFycmF5W2kgKyBpMF07XG4gICAgYXJyYXlbaSArIGkwXSA9IHQ7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IHN1bSA9IDA7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZSkge1xuICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpIHtcbiAgICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufVxuXG5mdW5jdGlvbiB0cmFuc3Bvc2UobWF0cml4KSB7XG4gIGlmICghKG4gPSBtYXRyaXgubGVuZ3RoKSkgcmV0dXJuIFtdO1xuICBmb3IgKHZhciBpID0gLTEsIG0gPSBtaW4obWF0cml4LCBsZW5ndGgkMSksIHRyYW5zcG9zZSA9IG5ldyBBcnJheShtKTsgKytpIDwgbTspIHtcbiAgICBmb3IgKHZhciBqID0gLTEsIG4sIHJvdyA9IHRyYW5zcG9zZVtpXSA9IG5ldyBBcnJheShuKTsgKytqIDwgbjspIHtcbiAgICAgIHJvd1tqXSA9IG1hdHJpeFtqXVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYW5zcG9zZTtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoJDEoZCkge1xuICByZXR1cm4gZC5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHppcCgpIHtcbiAgcmV0dXJuIHRyYW5zcG9zZShhcmd1bWVudHMpO1xufVxuXG5leHBvcnRzLmFzY2VuZGluZyA9IGFzY2VuZGluZztcbmV4cG9ydHMuYmluID0gYmluO1xuZXhwb3J0cy5iaXNlY3QgPSBiaXNlY3RSaWdodDtcbmV4cG9ydHMuYmlzZWN0TGVmdCA9IGJpc2VjdExlZnQ7XG5leHBvcnRzLmJpc2VjdFJpZ2h0ID0gYmlzZWN0UmlnaHQ7XG5leHBvcnRzLmJpc2VjdG9yID0gYmlzZWN0b3I7XG5leHBvcnRzLmNvdW50ID0gY291bnQ7XG5leHBvcnRzLmNyb3NzID0gY3Jvc3M7XG5leHBvcnRzLmN1bXN1bSA9IGN1bXN1bTtcbmV4cG9ydHMuZGVzY2VuZGluZyA9IGRlc2NlbmRpbmc7XG5leHBvcnRzLmRldmlhdGlvbiA9IGRldmlhdGlvbjtcbmV4cG9ydHMuZXh0ZW50ID0gZXh0ZW50O1xuZXhwb3J0cy5ncmVhdGVzdCA9IGdyZWF0ZXN0O1xuZXhwb3J0cy5ncmVhdGVzdEluZGV4ID0gZ3JlYXRlc3RJbmRleDtcbmV4cG9ydHMuZ3JvdXAgPSBncm91cDtcbmV4cG9ydHMuZ3JvdXBzID0gZ3JvdXBzO1xuZXhwb3J0cy5oaXN0b2dyYW0gPSBiaW47XG5leHBvcnRzLmxlYXN0ID0gbGVhc3Q7XG5leHBvcnRzLmxlYXN0SW5kZXggPSBsZWFzdEluZGV4O1xuZXhwb3J0cy5tYXggPSBtYXg7XG5leHBvcnRzLm1heEluZGV4ID0gbWF4SW5kZXg7XG5leHBvcnRzLm1lYW4gPSBtZWFuO1xuZXhwb3J0cy5tZWRpYW4gPSBtZWRpYW47XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWluSW5kZXggPSBtaW5JbmRleDtcbmV4cG9ydHMucGFpcnMgPSBwYWlycztcbmV4cG9ydHMucGVybXV0ZSA9IHBlcm11dGU7XG5leHBvcnRzLnF1YW50aWxlID0gcXVhbnRpbGU7XG5leHBvcnRzLnF1YW50aWxlU29ydGVkID0gcXVhbnRpbGVTb3J0ZWQ7XG5leHBvcnRzLnF1aWNrc2VsZWN0ID0gcXVpY2tzZWxlY3Q7XG5leHBvcnRzLnJhbmdlID0gcmFuZ2U7XG5leHBvcnRzLnJvbGx1cCA9IHJvbGx1cDtcbmV4cG9ydHMucm9sbHVwcyA9IHJvbGx1cHM7XG5leHBvcnRzLnNjYW4gPSBzY2FuO1xuZXhwb3J0cy5zaHVmZmxlID0gc2h1ZmZsZTtcbmV4cG9ydHMuc3VtID0gc3VtO1xuZXhwb3J0cy50aHJlc2hvbGRGcmVlZG1hbkRpYWNvbmlzID0gZnJlZWRtYW5EaWFjb25pcztcbmV4cG9ydHMudGhyZXNob2xkU2NvdHQgPSBzY290dDtcbmV4cG9ydHMudGhyZXNob2xkU3R1cmdlcyA9IHN0dXJnZXM7XG5leHBvcnRzLnRpY2tJbmNyZW1lbnQgPSB0aWNrSW5jcmVtZW50O1xuZXhwb3J0cy50aWNrU3RlcCA9IHRpY2tTdGVwO1xuZXhwb3J0cy50aWNrcyA9IHRpY2tzO1xuZXhwb3J0cy50cmFuc3Bvc2UgPSB0cmFuc3Bvc2U7XG5leHBvcnRzLnZhcmlhbmNlID0gdmFyaWFuY2U7XG5leHBvcnRzLnppcCA9IHppcDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1jb2xvci8gdjEuNC4wIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZGVmaW5lKGNvbnN0cnVjdG9yLCBmYWN0b3J5LCBwcm90b3R5cGUpIHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gZmFjdG9yeS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIHByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBleHRlbmQocGFyZW50LCBkZWZpbml0aW9uKSB7XG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xuICBmb3IgKHZhciBrZXkgaW4gZGVmaW5pdGlvbikgcHJvdG90eXBlW2tleV0gPSBkZWZpbml0aW9uW2tleV07XG4gIHJldHVybiBwcm90b3R5cGU7XG59XG5cbmZ1bmN0aW9uIENvbG9yKCkge31cblxudmFyIGRhcmtlciA9IDAuNztcbnZhciBicmlnaHRlciA9IDEgLyBkYXJrZXI7XG5cbnZhciByZUkgPSBcIlxcXFxzKihbKy1dP1xcXFxkKylcXFxccypcIixcbiAgICByZU4gPSBcIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KVxcXFxzKlwiLFxuICAgIHJlUCA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pJVxcXFxzKlwiLFxuICAgIHJlSGV4ID0gL14jKFswLTlhLWZdezMsOH0pJC8sXG4gICAgcmVSZ2JJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiICsgW3JlSSwgcmVJLCByZUldICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiICsgW3JlUCwgcmVQLCByZVBdICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JhSW50ZWdlciA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVJLCByZUksIHJlSSwgcmVOXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYmFcXFxcKFwiICsgW3JlUCwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKSxcbiAgICByZUhzbFBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbFxcXFwoXCIgKyBbcmVOLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKSxcbiAgICByZUhzbGFQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5oc2xhXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQLCByZU5dICsgXCJcXFxcKSRcIik7XG5cbnZhciBuYW1lZCA9IHtcbiAgYWxpY2VibHVlOiAweGYwZjhmZixcbiAgYW50aXF1ZXdoaXRlOiAweGZhZWJkNyxcbiAgYXF1YTogMHgwMGZmZmYsXG4gIGFxdWFtYXJpbmU6IDB4N2ZmZmQ0LFxuICBhenVyZTogMHhmMGZmZmYsXG4gIGJlaWdlOiAweGY1ZjVkYyxcbiAgYmlzcXVlOiAweGZmZTRjNCxcbiAgYmxhY2s6IDB4MDAwMDAwLFxuICBibGFuY2hlZGFsbW9uZDogMHhmZmViY2QsXG4gIGJsdWU6IDB4MDAwMGZmLFxuICBibHVldmlvbGV0OiAweDhhMmJlMixcbiAgYnJvd246IDB4YTUyYTJhLFxuICBidXJseXdvb2Q6IDB4ZGViODg3LFxuICBjYWRldGJsdWU6IDB4NWY5ZWEwLFxuICBjaGFydHJldXNlOiAweDdmZmYwMCxcbiAgY2hvY29sYXRlOiAweGQyNjkxZSxcbiAgY29yYWw6IDB4ZmY3ZjUwLFxuICBjb3JuZmxvd2VyYmx1ZTogMHg2NDk1ZWQsXG4gIGNvcm5zaWxrOiAweGZmZjhkYyxcbiAgY3JpbXNvbjogMHhkYzE0M2MsXG4gIGN5YW46IDB4MDBmZmZmLFxuICBkYXJrYmx1ZTogMHgwMDAwOGIsXG4gIGRhcmtjeWFuOiAweDAwOGI4YixcbiAgZGFya2dvbGRlbnJvZDogMHhiODg2MGIsXG4gIGRhcmtncmF5OiAweGE5YTlhOSxcbiAgZGFya2dyZWVuOiAweDAwNjQwMCxcbiAgZGFya2dyZXk6IDB4YTlhOWE5LFxuICBkYXJra2hha2k6IDB4YmRiNzZiLFxuICBkYXJrbWFnZW50YTogMHg4YjAwOGIsXG4gIGRhcmtvbGl2ZWdyZWVuOiAweDU1NmIyZixcbiAgZGFya29yYW5nZTogMHhmZjhjMDAsXG4gIGRhcmtvcmNoaWQ6IDB4OTkzMmNjLFxuICBkYXJrcmVkOiAweDhiMDAwMCxcbiAgZGFya3NhbG1vbjogMHhlOTk2N2EsXG4gIGRhcmtzZWFncmVlbjogMHg4ZmJjOGYsXG4gIGRhcmtzbGF0ZWJsdWU6IDB4NDgzZDhiLFxuICBkYXJrc2xhdGVncmF5OiAweDJmNGY0ZixcbiAgZGFya3NsYXRlZ3JleTogMHgyZjRmNGYsXG4gIGRhcmt0dXJxdW9pc2U6IDB4MDBjZWQxLFxuICBkYXJrdmlvbGV0OiAweDk0MDBkMyxcbiAgZGVlcHBpbms6IDB4ZmYxNDkzLFxuICBkZWVwc2t5Ymx1ZTogMHgwMGJmZmYsXG4gIGRpbWdyYXk6IDB4Njk2OTY5LFxuICBkaW1ncmV5OiAweDY5Njk2OSxcbiAgZG9kZ2VyYmx1ZTogMHgxZTkwZmYsXG4gIGZpcmVicmljazogMHhiMjIyMjIsXG4gIGZsb3JhbHdoaXRlOiAweGZmZmFmMCxcbiAgZm9yZXN0Z3JlZW46IDB4MjI4YjIyLFxuICBmdWNoc2lhOiAweGZmMDBmZixcbiAgZ2FpbnNib3JvOiAweGRjZGNkYyxcbiAgZ2hvc3R3aGl0ZTogMHhmOGY4ZmYsXG4gIGdvbGQ6IDB4ZmZkNzAwLFxuICBnb2xkZW5yb2Q6IDB4ZGFhNTIwLFxuICBncmF5OiAweDgwODA4MCxcbiAgZ3JlZW46IDB4MDA4MDAwLFxuICBncmVlbnllbGxvdzogMHhhZGZmMmYsXG4gIGdyZXk6IDB4ODA4MDgwLFxuICBob25leWRldzogMHhmMGZmZjAsXG4gIGhvdHBpbms6IDB4ZmY2OWI0LFxuICBpbmRpYW5yZWQ6IDB4Y2Q1YzVjLFxuICBpbmRpZ286IDB4NGIwMDgyLFxuICBpdm9yeTogMHhmZmZmZjAsXG4gIGtoYWtpOiAweGYwZTY4YyxcbiAgbGF2ZW5kZXI6IDB4ZTZlNmZhLFxuICBsYXZlbmRlcmJsdXNoOiAweGZmZjBmNSxcbiAgbGF3bmdyZWVuOiAweDdjZmMwMCxcbiAgbGVtb25jaGlmZm9uOiAweGZmZmFjZCxcbiAgbGlnaHRibHVlOiAweGFkZDhlNixcbiAgbGlnaHRjb3JhbDogMHhmMDgwODAsXG4gIGxpZ2h0Y3lhbjogMHhlMGZmZmYsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiAweGZhZmFkMixcbiAgbGlnaHRncmF5OiAweGQzZDNkMyxcbiAgbGlnaHRncmVlbjogMHg5MGVlOTAsXG4gIGxpZ2h0Z3JleTogMHhkM2QzZDMsXG4gIGxpZ2h0cGluazogMHhmZmI2YzEsXG4gIGxpZ2h0c2FsbW9uOiAweGZmYTA3YSxcbiAgbGlnaHRzZWFncmVlbjogMHgyMGIyYWEsXG4gIGxpZ2h0c2t5Ymx1ZTogMHg4N2NlZmEsXG4gIGxpZ2h0c2xhdGVncmF5OiAweDc3ODg5OSxcbiAgbGlnaHRzbGF0ZWdyZXk6IDB4Nzc4ODk5LFxuICBsaWdodHN0ZWVsYmx1ZTogMHhiMGM0ZGUsXG4gIGxpZ2h0eWVsbG93OiAweGZmZmZlMCxcbiAgbGltZTogMHgwMGZmMDAsXG4gIGxpbWVncmVlbjogMHgzMmNkMzIsXG4gIGxpbmVuOiAweGZhZjBlNixcbiAgbWFnZW50YTogMHhmZjAwZmYsXG4gIG1hcm9vbjogMHg4MDAwMDAsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDB4NjZjZGFhLFxuICBtZWRpdW1ibHVlOiAweDAwMDBjZCxcbiAgbWVkaXVtb3JjaGlkOiAweGJhNTVkMyxcbiAgbWVkaXVtcHVycGxlOiAweDkzNzBkYixcbiAgbWVkaXVtc2VhZ3JlZW46IDB4M2NiMzcxLFxuICBtZWRpdW1zbGF0ZWJsdWU6IDB4N2I2OGVlLFxuICBtZWRpdW1zcHJpbmdncmVlbjogMHgwMGZhOWEsXG4gIG1lZGl1bXR1cnF1b2lzZTogMHg0OGQxY2MsXG4gIG1lZGl1bXZpb2xldHJlZDogMHhjNzE1ODUsXG4gIG1pZG5pZ2h0Ymx1ZTogMHgxOTE5NzAsXG4gIG1pbnRjcmVhbTogMHhmNWZmZmEsXG4gIG1pc3R5cm9zZTogMHhmZmU0ZTEsXG4gIG1vY2Nhc2luOiAweGZmZTRiNSxcbiAgbmF2YWpvd2hpdGU6IDB4ZmZkZWFkLFxuICBuYXZ5OiAweDAwMDA4MCxcbiAgb2xkbGFjZTogMHhmZGY1ZTYsXG4gIG9saXZlOiAweDgwODAwMCxcbiAgb2xpdmVkcmFiOiAweDZiOGUyMyxcbiAgb3JhbmdlOiAweGZmYTUwMCxcbiAgb3JhbmdlcmVkOiAweGZmNDUwMCxcbiAgb3JjaGlkOiAweGRhNzBkNixcbiAgcGFsZWdvbGRlbnJvZDogMHhlZWU4YWEsXG4gIHBhbGVncmVlbjogMHg5OGZiOTgsXG4gIHBhbGV0dXJxdW9pc2U6IDB4YWZlZWVlLFxuICBwYWxldmlvbGV0cmVkOiAweGRiNzA5MyxcbiAgcGFwYXlhd2hpcDogMHhmZmVmZDUsXG4gIHBlYWNocHVmZjogMHhmZmRhYjksXG4gIHBlcnU6IDB4Y2Q4NTNmLFxuICBwaW5rOiAweGZmYzBjYixcbiAgcGx1bTogMHhkZGEwZGQsXG4gIHBvd2RlcmJsdWU6IDB4YjBlMGU2LFxuICBwdXJwbGU6IDB4ODAwMDgwLFxuICByZWJlY2NhcHVycGxlOiAweDY2MzM5OSxcbiAgcmVkOiAweGZmMDAwMCxcbiAgcm9zeWJyb3duOiAweGJjOGY4ZixcbiAgcm95YWxibHVlOiAweDQxNjllMSxcbiAgc2FkZGxlYnJvd246IDB4OGI0NTEzLFxuICBzYWxtb246IDB4ZmE4MDcyLFxuICBzYW5keWJyb3duOiAweGY0YTQ2MCxcbiAgc2VhZ3JlZW46IDB4MmU4YjU3LFxuICBzZWFzaGVsbDogMHhmZmY1ZWUsXG4gIHNpZW5uYTogMHhhMDUyMmQsXG4gIHNpbHZlcjogMHhjMGMwYzAsXG4gIHNreWJsdWU6IDB4ODdjZWViLFxuICBzbGF0ZWJsdWU6IDB4NmE1YWNkLFxuICBzbGF0ZWdyYXk6IDB4NzA4MDkwLFxuICBzbGF0ZWdyZXk6IDB4NzA4MDkwLFxuICBzbm93OiAweGZmZmFmYSxcbiAgc3ByaW5nZ3JlZW46IDB4MDBmZjdmLFxuICBzdGVlbGJsdWU6IDB4NDY4MmI0LFxuICB0YW46IDB4ZDJiNDhjLFxuICB0ZWFsOiAweDAwODA4MCxcbiAgdGhpc3RsZTogMHhkOGJmZDgsXG4gIHRvbWF0bzogMHhmZjYzNDcsXG4gIHR1cnF1b2lzZTogMHg0MGUwZDAsXG4gIHZpb2xldDogMHhlZTgyZWUsXG4gIHdoZWF0OiAweGY1ZGViMyxcbiAgd2hpdGU6IDB4ZmZmZmZmLFxuICB3aGl0ZXNtb2tlOiAweGY1ZjVmNSxcbiAgeWVsbG93OiAweGZmZmYwMCxcbiAgeWVsbG93Z3JlZW46IDB4OWFjZDMyXG59O1xuXG5kZWZpbmUoQ29sb3IsIGNvbG9yLCB7XG4gIGNvcHk6IGZ1bmN0aW9uKGNoYW5uZWxzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IHRoaXMuY29uc3RydWN0b3IsIHRoaXMsIGNoYW5uZWxzKTtcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpLmRpc3BsYXlhYmxlKCk7XG4gIH0sXG4gIGhleDogY29sb3JfZm9ybWF0SGV4LCAvLyBEZXByZWNhdGVkISBVc2UgY29sb3IuZm9ybWF0SGV4LlxuICBmb3JtYXRIZXg6IGNvbG9yX2Zvcm1hdEhleCxcbiAgZm9ybWF0SHNsOiBjb2xvcl9mb3JtYXRIc2wsXG4gIGZvcm1hdFJnYjogY29sb3JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogY29sb3JfZm9ybWF0UmdiXG59KTtcblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRIZXgoKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SHNsKCkge1xuICByZXR1cm4gaHNsQ29udmVydCh0aGlzKS5mb3JtYXRIc2woKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0UmdiKCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRSZ2IoKTtcbn1cblxuZnVuY3Rpb24gY29sb3IoZm9ybWF0KSB7XG4gIHZhciBtLCBsO1xuICBmb3JtYXQgPSAoZm9ybWF0ICsgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAobSA9IHJlSGV4LmV4ZWMoZm9ybWF0KSkgPyAobCA9IG1bMV0ubGVuZ3RoLCBtID0gcGFyc2VJbnQobVsxXSwgMTYpLCBsID09PSA2ID8gcmdibihtKSAvLyAjZmYwMDAwXG4gICAgICA6IGwgPT09IDMgPyBuZXcgUmdiKChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZiksIDEpIC8vICNmMDBcbiAgICAgIDogbCA9PT0gOCA/IG5ldyBSZ2IobSA+PiAyNCAmIDB4ZmYsIG0gPj4gMTYgJiAweGZmLCBtID4+IDggJiAweGZmLCAobSAmIDB4ZmYpIC8gMHhmZikgLy8gI2ZmMDAwMDAwXG4gICAgICA6IGwgPT09IDQgPyBuZXcgUmdiKChtID4+IDEyICYgMHhmKSB8IChtID4+IDggJiAweGYwKSwgKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKCgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZikpIC8gMHhmZikgLy8gI2YwMDBcbiAgICAgIDogbnVsbCkgLy8gaW52YWxpZCBoZXhcbiAgICAgIDogKG0gPSByZVJnYkludGVnZXIuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSwgbVsyXSwgbVszXSwgMSkgLy8gcmdiKDI1NSwgMCwgMClcbiAgICAgIDogKG0gPSByZVJnYlBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgMSkgLy8gcmdiKDEwMCUsIDAlLCAwJSlcbiAgICAgIDogKG0gPSByZVJnYmFJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pIC8vIHJnYmEoMjU1LCAwLCAwLCAxKVxuICAgICAgOiAobSA9IHJlUmdiYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgbVs0XSkgLy8gcmdiKDEwMCUsIDAlLCAwJSwgMSlcbiAgICAgIDogKG0gPSByZUhzbFBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgMSkgLy8gaHNsKDEyMCwgNTAlLCA1MCUpXG4gICAgICA6IChtID0gcmVIc2xhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCBtWzRdKSAvLyBoc2xhKDEyMCwgNTAlLCA1MCUsIDEpXG4gICAgICA6IG5hbWVkLmhhc093blByb3BlcnR5KGZvcm1hdCkgPyByZ2JuKG5hbWVkW2Zvcm1hdF0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICA6IGZvcm1hdCA9PT0gXCJ0cmFuc3BhcmVudFwiID8gbmV3IFJnYihOYU4sIE5hTiwgTmFOLCAwKVxuICAgICAgOiBudWxsO1xufVxuXG5mdW5jdGlvbiByZ2JuKG4pIHtcbiAgcmV0dXJuIG5ldyBSZ2IobiA+PiAxNiAmIDB4ZmYsIG4gPj4gOCAmIDB4ZmYsIG4gJiAweGZmLCAxKTtcbn1cblxuZnVuY3Rpb24gcmdiYShyLCBnLCBiLCBhKSB7XG4gIGlmIChhIDw9IDApIHIgPSBnID0gYiA9IE5hTjtcbiAgcmV0dXJuIG5ldyBSZ2IociwgZywgYiwgYSk7XG59XG5cbmZ1bmN0aW9uIHJnYkNvbnZlcnQobykge1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBSZ2I7XG4gIG8gPSBvLnJnYigpO1xuICByZXR1cm4gbmV3IFJnYihvLnIsIG8uZywgby5iLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiByZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHJnYkNvbnZlcnQocikgOiBuZXcgUmdiKHIsIGcsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gUmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5yID0gK3I7XG4gIHRoaXMuZyA9ICtnO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShSZ2IsIHJnYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKC0wLjUgPD0gdGhpcy5yICYmIHRoaXMuciA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmcgJiYgdGhpcy5nIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuYiAmJiB0aGlzLmIgPCAyNTUuNSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgaGV4OiByZ2JfZm9ybWF0SGV4LCAvLyBEZXByZWNhdGVkISBVc2UgY29sb3IuZm9ybWF0SGV4LlxuICBmb3JtYXRIZXg6IHJnYl9mb3JtYXRIZXgsXG4gIGZvcm1hdFJnYjogcmdiX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IHJnYl9mb3JtYXRSZ2Jcbn0pKTtcblxuZnVuY3Rpb24gcmdiX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIFwiI1wiICsgaGV4KHRoaXMucikgKyBoZXgodGhpcy5nKSArIGhleCh0aGlzLmIpO1xufVxuXG5mdW5jdGlvbiByZ2JfZm9ybWF0UmdiKCkge1xuICB2YXIgYSA9IHRoaXMub3BhY2l0eTsgYSA9IGlzTmFOKGEpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEpKTtcbiAgcmV0dXJuIChhID09PSAxID8gXCJyZ2IoXCIgOiBcInJnYmEoXCIpXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLnIpIHx8IDApKSArIFwiLCBcIlxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5nKSB8fCAwKSkgKyBcIiwgXCJcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuYikgfHwgMCkpXG4gICAgICArIChhID09PSAxID8gXCIpXCIgOiBcIiwgXCIgKyBhICsgXCIpXCIpO1xufVxuXG5mdW5jdGlvbiBoZXgodmFsdWUpIHtcbiAgdmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodmFsdWUpIHx8IDApKTtcbiAgcmV0dXJuICh2YWx1ZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIHZhbHVlLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gaHNsYShoLCBzLCBsLCBhKSB7XG4gIGlmIChhIDw9IDApIGggPSBzID0gbCA9IE5hTjtcbiAgZWxzZSBpZiAobCA8PSAwIHx8IGwgPj0gMSkgaCA9IHMgPSBOYU47XG4gIGVsc2UgaWYgKHMgPD0gMCkgaCA9IE5hTjtcbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgYSk7XG59XG5cbmZ1bmN0aW9uIGhzbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG5ldyBIc2woby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgSHNsO1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG87XG4gIG8gPSBvLnJnYigpO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGggPSBOYU4sXG4gICAgICBzID0gbWF4IC0gbWluLFxuICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKHMpIHtcbiAgICBpZiAociA9PT0gbWF4KSBoID0gKGcgLSBiKSAvIHMgKyAoZyA8IGIpICogNjtcbiAgICBlbHNlIGlmIChnID09PSBtYXgpIGggPSAoYiAtIHIpIC8gcyArIDI7XG4gICAgZWxzZSBoID0gKHIgLSBnKSAvIHMgKyA0O1xuICAgIHMgLz0gbCA8IDAuNSA/IG1heCArIG1pbiA6IDIgLSBtYXggLSBtaW47XG4gICAgaCAqPSA2MDtcbiAgfSBlbHNlIHtcbiAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcbiAgfVxuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBoc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhzbENvbnZlcnQoaCkgOiBuZXcgSHNsKGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gSHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShIc2wsIGhzbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IHRoaXMuaCAlIDM2MCArICh0aGlzLmggPCAwKSAqIDM2MCxcbiAgICAgICAgcyA9IGlzTmFOKGgpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLFxuICAgICAgICBsID0gdGhpcy5sLFxuICAgICAgICBtMiA9IGwgKyAobCA8IDAuNSA/IGwgOiAxIC0gbCkgKiBzLFxuICAgICAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBoc2wycmdiKGggPj0gMjQwID8gaCAtIDI0MCA6IGggKyAxMjAsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGgsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGggPCAxMjAgPyBoICsgMjQwIDogaCAtIDEyMCwgbTEsIG0yKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5zICYmIHRoaXMucyA8PSAxIHx8IGlzTmFOKHRoaXMucykpXG4gICAgICAgICYmICgwIDw9IHRoaXMubCAmJiB0aGlzLmwgPD0gMSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgZm9ybWF0SHNsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IHRoaXMub3BhY2l0eTsgYSA9IGlzTmFOKGEpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEpKTtcbiAgICByZXR1cm4gKGEgPT09IDEgPyBcImhzbChcIiA6IFwiaHNsYShcIilcbiAgICAgICAgKyAodGhpcy5oIHx8IDApICsgXCIsIFwiXG4gICAgICAgICsgKHRoaXMucyB8fCAwKSAqIDEwMCArIFwiJSwgXCJcbiAgICAgICAgKyAodGhpcy5sIHx8IDApICogMTAwICsgXCIlXCJcbiAgICAgICAgKyAoYSA9PT0gMSA/IFwiKVwiIDogXCIsIFwiICsgYSArIFwiKVwiKTtcbiAgfVxufSkpO1xuXG4vKiBGcm9tIEZ2RCAxMy4zNywgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCAzICovXG5mdW5jdGlvbiBoc2wycmdiKGgsIG0xLCBtMikge1xuICByZXR1cm4gKGggPCA2MCA/IG0xICsgKG0yIC0gbTEpICogaCAvIDYwXG4gICAgICA6IGggPCAxODAgPyBtMlxuICAgICAgOiBoIDwgMjQwID8gbTEgKyAobTIgLSBtMSkgKiAoMjQwIC0gaCkgLyA2MFxuICAgICAgOiBtMSkgKiAyNTU7XG59XG5cbnZhciBkZWcycmFkID0gTWF0aC5QSSAvIDE4MDtcbnZhciByYWQyZGVnID0gMTgwIC8gTWF0aC5QSTtcblxuLy8gaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BtYm9zdG9jay9sYWItYW5kLXJnYlxudmFyIEsgPSAxOCxcbiAgICBYbiA9IDAuOTY0MjIsXG4gICAgWW4gPSAxLFxuICAgIFpuID0gMC44MjUyMSxcbiAgICB0MCA9IDQgLyAyOSxcbiAgICB0MSA9IDYgLyAyOSxcbiAgICB0MiA9IDMgKiB0MSAqIHQxLFxuICAgIHQzID0gdDEgKiB0MSAqIHQxO1xuXG5mdW5jdGlvbiBsYWJDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBMYWIpIHJldHVybiBuZXcgTGFiKG8ubCwgby5hLCBvLmIsIG8ub3BhY2l0eSk7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gaGNsMmxhYihvKTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IHJnYjJscmdiKG8uciksXG4gICAgICBnID0gcmdiMmxyZ2Ioby5nKSxcbiAgICAgIGIgPSByZ2IybHJnYihvLmIpLFxuICAgICAgeSA9IHh5ejJsYWIoKDAuMjIyNTA0NSAqIHIgKyAwLjcxNjg3ODYgKiBnICsgMC4wNjA2MTY5ICogYikgLyBZbiksIHgsIHo7XG4gIGlmIChyID09PSBnICYmIGcgPT09IGIpIHggPSB6ID0geTsgZWxzZSB7XG4gICAgeCA9IHh5ejJsYWIoKDAuNDM2MDc0NyAqIHIgKyAwLjM4NTA2NDkgKiBnICsgMC4xNDMwODA0ICogYikgLyBYbik7XG4gICAgeiA9IHh5ejJsYWIoKDAuMDEzOTMyMiAqIHIgKyAwLjA5NzEwNDUgKiBnICsgMC43MTQxNzMzICogYikgLyBabik7XG4gIH1cbiAgcmV0dXJuIG5ldyBMYWIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBncmF5KGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIG5ldyBMYWIobCwgMCwgMCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBsYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGxhYkNvbnZlcnQobCkgOiBuZXcgTGFiKGwsIGEsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gTGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMuYSA9ICthO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShMYWIsIGxhYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHkgPSAodGhpcy5sICsgMTYpIC8gMTE2LFxuICAgICAgICB4ID0gaXNOYU4odGhpcy5hKSA/IHkgOiB5ICsgdGhpcy5hIC8gNTAwLFxuICAgICAgICB6ID0gaXNOYU4odGhpcy5iKSA/IHkgOiB5IC0gdGhpcy5iIC8gMjAwO1xuICAgIHggPSBYbiAqIGxhYjJ4eXooeCk7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgbHJnYjJyZ2IoIDMuMTMzODU2MSAqIHggLSAxLjYxNjg2NjcgKiB5IC0gMC40OTA2MTQ2ICogeiksXG4gICAgICBscmdiMnJnYigtMC45Nzg3Njg0ICogeCArIDEuOTE2MTQxNSAqIHkgKyAwLjAzMzQ1NDAgKiB6KSxcbiAgICAgIGxyZ2IycmdiKCAwLjA3MTk0NTMgKiB4IC0gMC4yMjg5OTE0ICogeSArIDEuNDA1MjQyNyAqIHopLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XG59XG5cbmZ1bmN0aW9uIGxyZ2IycmdiKHgpIHtcbiAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7XG59XG5cbmZ1bmN0aW9uIHJnYjJscmdiKHgpIHtcbiAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbmZ1bmN0aW9uIGhjbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIG5ldyBIY2woby5oLCBvLmMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIExhYikpIG8gPSBsYWJDb252ZXJ0KG8pO1xuICBpZiAoby5hID09PSAwICYmIG8uYiA9PT0gMCkgcmV0dXJuIG5ldyBIY2woTmFOLCAwIDwgby5sICYmIG8ubCA8IDEwMCA/IDAgOiBOYU4sIG8ubCwgby5vcGFjaXR5KTtcbiAgdmFyIGggPSBNYXRoLmF0YW4yKG8uYiwgby5hKSAqIHJhZDJkZWc7XG4gIHJldHVybiBuZXcgSGNsKGggPCAwID8gaCArIDM2MCA6IGgsIE1hdGguc3FydChvLmEgKiBvLmEgKyBvLmIgKiBvLmIpLCBvLmwsIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGxjaChsLCBjLCBoLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChsKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBoY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQoaCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gSGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMuYyA9ICtjO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmZ1bmN0aW9uIGhjbDJsYWIobykge1xuICBpZiAoaXNOYU4oby5oKSkgcmV0dXJuIG5ldyBMYWIoby5sLCAwLCAwLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IG8uaCAqIGRlZzJyYWQ7XG4gIHJldHVybiBuZXcgTGFiKG8ubCwgTWF0aC5jb3MoaCkgKiBvLmMsIE1hdGguc2luKGgpICogby5jLCBvLm9wYWNpdHkpO1xufVxuXG5kZWZpbmUoSGNsLCBoY2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBoY2wybGFiKHRoaXMpLnJnYigpO1xuICB9XG59KSk7XG5cbnZhciBBID0gLTAuMTQ4NjEsXG4gICAgQiA9ICsxLjc4Mjc3LFxuICAgIEMgPSAtMC4yOTIyNyxcbiAgICBEID0gLTAuOTA2NDksXG4gICAgRSA9ICsxLjk3Mjk0LFxuICAgIEVEID0gRSAqIEQsXG4gICAgRUIgPSBFICogQixcbiAgICBCQ19EQSA9IEIgKiBDIC0gRCAqIEE7XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEN1YmVoZWxpeCkgcmV0dXJuIG5ldyBDdWJlaGVsaXgoby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbCA9IChCQ19EQSAqIGIgKyBFRCAqIHIgLSBFQiAqIGcpIC8gKEJDX0RBICsgRUQgLSBFQiksXG4gICAgICBibCA9IGIgLSBsLFxuICAgICAgayA9IChFICogKGcgLSBsKSAtIEMgKiBibCkgLyBELFxuICAgICAgcyA9IE1hdGguc3FydChrICogayArIGJsICogYmwpIC8gKEUgKiBsICogKDEgLSBsKSksIC8vIE5hTiBpZiBsPTAgb3IgbD0xXG4gICAgICBoID0gcyA/IE1hdGguYXRhbjIoaywgYmwpICogcmFkMmRlZyAtIDEyMCA6IE5hTjtcbiAgcmV0dXJuIG5ldyBDdWJlaGVsaXgoaCA8IDAgPyBoICsgMzYwIDogaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gY3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBjdWJlaGVsaXhDb252ZXJ0KGgpIDogbmV3IEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoQ3ViZWhlbGl4LCBjdWJlaGVsaXgsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSBpc05hTih0aGlzLmgpID8gMCA6ICh0aGlzLmggKyAxMjApICogZGVnMnJhZCxcbiAgICAgICAgbCA9ICt0aGlzLmwsXG4gICAgICAgIGEgPSBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyAqIGwgKiAoMSAtIGwpLFxuICAgICAgICBjb3NoID0gTWF0aC5jb3MoaCksXG4gICAgICAgIHNpbmggPSBNYXRoLnNpbihoKTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIDI1NSAqIChsICsgYSAqIChBICogY29zaCArIEIgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoQyAqIGNvc2ggKyBEICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEUgKiBjb3NoKSksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG5cbmV4cG9ydHMuY29sb3IgPSBjb2xvcjtcbmV4cG9ydHMuY3ViZWhlbGl4ID0gY3ViZWhlbGl4O1xuZXhwb3J0cy5ncmF5ID0gZ3JheTtcbmV4cG9ydHMuaGNsID0gaGNsO1xuZXhwb3J0cy5oc2wgPSBoc2w7XG5leHBvcnRzLmxhYiA9IGxhYjtcbmV4cG9ydHMubGNoID0gbGNoO1xuZXhwb3J0cy5yZ2IgPSByZ2I7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZGlzcGF0Y2gvIHYxLjAuNiBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBub29wID0ge3ZhbHVlOiBmdW5jdGlvbigpIHt9fTtcblxuZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IHt9LCB0OyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEodCA9IGFyZ3VtZW50c1tpXSArIFwiXCIpIHx8ICh0IGluIF8pIHx8IC9bXFxzLl0vLnRlc3QodCkpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0KTtcbiAgICBfW3RdID0gW107XG4gIH1cbiAgcmV0dXJuIG5ldyBEaXNwYXRjaChfKTtcbn1cblxuZnVuY3Rpb24gRGlzcGF0Y2goXykge1xuICB0aGlzLl8gPSBfO1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMsIHR5cGVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICBpZiAodCAmJiAhdHlwZXMuaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuRGlzcGF0Y2gucHJvdG90eXBlID0gZGlzcGF0Y2gucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGF0Y2gsXG4gIG9uOiBmdW5jdGlvbih0eXBlbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgXyA9IHRoaXMuXyxcbiAgICAgICAgVCA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiwgXyksXG4gICAgICAgIHQsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IFQubGVuZ3RoO1xuXG4gICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmV0dXJuIHRoZSBjYWxsYmFjayBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSAmJiAodCA9IGdldChfW3RdLCB0eXBlbmFtZS5uYW1lKSkpIHJldHVybiB0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGEgdHlwZSB3YXMgc3BlY2lmaWVkLCBzZXQgdGhlIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICAvLyBPdGhlcndpc2UsIGlmIGEgbnVsbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZW1vdmUgY2FsbGJhY2tzIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIGNhbGxiYWNrKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrID09IG51bGwpIGZvciAodCBpbiBfKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29weSA9IHt9LCBfID0gdGhpcy5fO1xuICAgIGZvciAodmFyIHQgaW4gXykgY29weVt0XSA9IF9bdF0uc2xpY2UoKTtcbiAgICByZXR1cm4gbmV3IERpc3BhdGNoKGNvcHkpO1xuICB9LFxuICBjYWxsOiBmdW5jdGlvbih0eXBlLCB0aGF0KSB7XG4gICAgaWYgKChuID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgYXJncyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIG4sIHQ7IGkgPCBuOyArK2kpIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24odHlwZSwgdGhhdCwgYXJncykge1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh2YXIgdCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0KHR5cGUsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aCwgYzsgaSA8IG47ICsraSkge1xuICAgIGlmICgoYyA9IHR5cGVbaV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQodHlwZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICh0eXBlW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHR5cGVbaV0gPSBub29wLCB0eXBlID0gdHlwZS5zbGljZSgwLCBpKS5jb25jYXQodHlwZS5zbGljZShpICsgMSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB0eXBlLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiBjYWxsYmFja30pO1xuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0cy5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWRyYWcvIHYxLjIuNSBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWRpc3BhdGNoJyksIHJlcXVpcmUoJ2QzLXNlbGVjdGlvbicpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWRpc3BhdGNoJywgJ2QzLXNlbGVjdGlvbiddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9LCBnbG9iYWwuZDMsIGdsb2JhbC5kMykpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNEaXNwYXRjaCwgZDNTZWxlY3Rpb24pIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBub3Byb3BhZ2F0aW9uKCkge1xuICBkM1NlbGVjdGlvbi5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZnVuY3Rpb24gbm9ldmVudCgpIHtcbiAgZDNTZWxlY3Rpb24uZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZDNTZWxlY3Rpb24uZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIG5vZHJhZyh2aWV3KSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBkM1NlbGVjdGlvbi5zZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBub2V2ZW50LCB0cnVlKTtcbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG5vZXZlbnQsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuX19ub3NlbGVjdCA9IHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdDtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiB5ZXNkcmFnKHZpZXcsIG5vY2xpY2spIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IGQzU2VsZWN0aW9uLnNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG51bGwpO1xuICBpZiAobm9jbGljaykge1xuICAgIHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBudWxsKTsgfSwgMCk7XG4gIH1cbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IHJvb3QuX19ub3NlbGVjdDtcbiAgICBkZWxldGUgcm9vdC5fX25vc2VsZWN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBEcmFnRXZlbnQodGFyZ2V0LCB0eXBlLCBzdWJqZWN0LCBpZCwgYWN0aXZlLCB4LCB5LCBkeCwgZHksIGRpc3BhdGNoKSB7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICB0aGlzLmlkZW50aWZpZXIgPSBpZDtcbiAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMuZHggPSBkeDtcbiAgdGhpcy5keSA9IGR5O1xuICB0aGlzLl8gPSBkaXNwYXRjaDtcbn1cblxuRHJhZ0V2ZW50LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSB0aGlzLl8ub24uYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdmFsdWUgPT09IHRoaXMuXyA/IHRoaXMgOiB2YWx1ZTtcbn07XG5cbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxuZnVuY3Rpb24gZGVmYXVsdEZpbHRlcigpIHtcbiAgcmV0dXJuICFkM1NlbGVjdGlvbi5ldmVudC5jdHJsS2V5ICYmICFkM1NlbGVjdGlvbi5ldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb250YWluZXIoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdWJqZWN0KGQpIHtcbiAgcmV0dXJuIGQgPT0gbnVsbCA/IHt4OiBkM1NlbGVjdGlvbi5ldmVudC54LCB5OiBkM1NlbGVjdGlvbi5ldmVudC55fSA6IGQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgKFwib250b3VjaHN0YXJ0XCIgaW4gdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGRyYWcoKSB7XG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgY29udGFpbmVyID0gZGVmYXVsdENvbnRhaW5lcixcbiAgICAgIHN1YmplY3QgPSBkZWZhdWx0U3ViamVjdCxcbiAgICAgIHRvdWNoYWJsZSA9IGRlZmF1bHRUb3VjaGFibGUsXG4gICAgICBnZXN0dXJlcyA9IHt9LFxuICAgICAgbGlzdGVuZXJzID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcInN0YXJ0XCIsIFwiZHJhZ1wiLCBcImVuZFwiKSxcbiAgICAgIGFjdGl2ZSA9IDAsXG4gICAgICBtb3VzZWRvd254LFxuICAgICAgbW91c2Vkb3dueSxcbiAgICAgIG1vdXNlbW92aW5nLFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDA7XG5cbiAgZnVuY3Rpb24gZHJhZyhzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLm9uKFwibW91c2Vkb3duLmRyYWdcIiwgbW91c2Vkb3duZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC5kcmFnXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLmRyYWdcIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuZHJhZyB0b3VjaGNhbmNlbC5kcmFnXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKCkge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZ2VzdHVyZSA9IGJlZm9yZXN0YXJ0KFwibW91c2VcIiwgY29udGFpbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGQzU2VsZWN0aW9uLm1vdXNlLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghZ2VzdHVyZSkgcmV0dXJuO1xuICAgIGQzU2VsZWN0aW9uLnNlbGVjdChkM1NlbGVjdGlvbi5ldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC5kcmFnXCIsIG1vdXNldXBwZWQsIHRydWUpO1xuICAgIG5vZHJhZyhkM1NlbGVjdGlvbi5ldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgbW91c2Vtb3ZpbmcgPSBmYWxzZTtcbiAgICBtb3VzZWRvd254ID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WDtcbiAgICBtb3VzZWRvd255ID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WTtcbiAgICBnZXN0dXJlKFwic3RhcnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZW1vdmVkKCkge1xuICAgIG5vZXZlbnQoKTtcbiAgICBpZiAoIW1vdXNlbW92aW5nKSB7XG4gICAgICB2YXIgZHggPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRYIC0gbW91c2Vkb3dueCwgZHkgPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRZIC0gbW91c2Vkb3dueTtcbiAgICAgIG1vdXNlbW92aW5nID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICB9XG4gICAgZ2VzdHVyZXMubW91c2UoXCJkcmFnXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2V1cHBlZCgpIHtcbiAgICBkM1NlbGVjdGlvbi5zZWxlY3QoZDNTZWxlY3Rpb24uZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuZHJhZyBtb3VzZXVwLmRyYWdcIiwgbnVsbCk7XG4gICAgeWVzZHJhZyhkM1NlbGVjdGlvbi5ldmVudC52aWV3LCBtb3VzZW1vdmluZyk7XG4gICAgbm9ldmVudCgpO1xuICAgIGdlc3R1cmVzLm1vdXNlKFwiZW5kXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGQzU2VsZWN0aW9uLmV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBjID0gY29udGFpbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gYmVmb3Jlc3RhcnQodG91Y2hlc1tpXS5pZGVudGlmaWVyLCBjLCBkM1NlbGVjdGlvbi50b3VjaCwgdGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgICAgIGdlc3R1cmUoXCJzdGFydFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKCkge1xuICAgIHZhciB0b3VjaGVzID0gZDNTZWxlY3Rpb24uZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBub2V2ZW50KCk7XG4gICAgICAgIGdlc3R1cmUoXCJkcmFnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoKSB7XG4gICAgdmFyIHRvdWNoZXMgPSBkM1NlbGVjdGlvbi5ldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCA1MDApOyAvLyBHaG9zdCBjbGlja3MgYXJlIGRlbGF5ZWQhXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICAgICAgZ2VzdHVyZShcImVuZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiZWZvcmVzdGFydChpZCwgY29udGFpbmVyLCBwb2ludCwgdGhhdCwgYXJncykge1xuICAgIHZhciBwID0gcG9pbnQoY29udGFpbmVyLCBpZCksIHMsIGR4LCBkeSxcbiAgICAgICAgc3VibGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvcHkoKTtcblxuICAgIGlmICghZDNTZWxlY3Rpb24uY3VzdG9tRXZlbnQobmV3IERyYWdFdmVudChkcmFnLCBcImJlZm9yZXN0YXJ0XCIsIHMsIGlkLCBhY3RpdmUsIHBbMF0sIHBbMV0sIDAsIDAsIHN1Ymxpc3RlbmVycyksIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKChkM1NlbGVjdGlvbi5ldmVudC5zdWJqZWN0ID0gcyA9IHN1YmplY3QuYXBwbHkodGhhdCwgYXJncykpID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIGR4ID0gcy54IC0gcFswXSB8fCAwO1xuICAgICAgZHkgPSBzLnkgLSBwWzFdIHx8IDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KSkgcmV0dXJuO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdlc3R1cmUodHlwZSkge1xuICAgICAgdmFyIHAwID0gcCwgbjtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RhcnRcIjogZ2VzdHVyZXNbaWRdID0gZ2VzdHVyZSwgbiA9IGFjdGl2ZSsrOyBicmVhaztcbiAgICAgICAgY2FzZSBcImVuZFwiOiBkZWxldGUgZ2VzdHVyZXNbaWRdLCAtLWFjdGl2ZTsgLy8gbm9icmVha1xuICAgICAgICBjYXNlIFwiZHJhZ1wiOiBwID0gcG9pbnQoY29udGFpbmVyLCBpZCksIG4gPSBhY3RpdmU7IGJyZWFrO1xuICAgICAgfVxuICAgICAgZDNTZWxlY3Rpb24uY3VzdG9tRXZlbnQobmV3IERyYWdFdmVudChkcmFnLCB0eXBlLCBzLCBpZCwgbiwgcFswXSArIGR4LCBwWzFdICsgZHksIHBbMF0gLSBwMFswXSwgcFsxXSAtIHAwWzFdLCBzdWJsaXN0ZW5lcnMpLCBzdWJsaXN0ZW5lcnMuYXBwbHksIHN1Ymxpc3RlbmVycywgW3R5cGUsIHRoYXQsIGFyZ3NdKTtcbiAgICB9O1xuICB9XG5cbiAgZHJhZy5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBkcmFnKSA6IGZpbHRlcjtcbiAgfTtcblxuICBkcmFnLmNvbnRhaW5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250YWluZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBkcmFnKSA6IGNvbnRhaW5lcjtcbiAgfTtcblxuICBkcmFnLnN1YmplY3QgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3ViamVjdCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGRyYWcpIDogc3ViamVjdDtcbiAgfTtcblxuICBkcmFnLnRvdWNoYWJsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0b3VjaGFibGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGRyYWcpIDogdG91Y2hhYmxlO1xuICB9O1xuXG4gIGRyYWcub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gZHJhZyA6IHZhbHVlO1xuICB9O1xuXG4gIGRyYWcuY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgZHJhZykgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHJldHVybiBkcmFnO1xufVxuXG5leHBvcnRzLmRyYWcgPSBkcmFnO1xuZXhwb3J0cy5kcmFnRGlzYWJsZSA9IG5vZHJhZztcbmV4cG9ydHMuZHJhZ0VuYWJsZSA9IHllc2RyYWc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZWFzZS8gdjEuMC42IENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgcmV0dXJuICt0O1xufVxuXG5mdW5jdGlvbiBxdWFkSW4odCkge1xuICByZXR1cm4gdCAqIHQ7XG59XG5cbmZ1bmN0aW9uIHF1YWRPdXQodCkge1xuICByZXR1cm4gdCAqICgyIC0gdCk7XG59XG5cbmZ1bmN0aW9uIHF1YWRJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0IDogLS10ICogKDIgLSB0KSArIDEpIC8gMjtcbn1cblxuZnVuY3Rpb24gY3ViaWNJbih0KSB7XG4gIHJldHVybiB0ICogdCAqIHQ7XG59XG5cbmZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn1cblxuZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG59XG5cbnZhciBleHBvbmVudCA9IDM7XG5cbnZhciBwb2x5SW4gPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlJbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQsIGUpO1xuICB9XG5cbiAgcG9seUluLmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5SW47XG59KShleHBvbmVudCk7XG5cbnZhciBwb2x5T3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XG4gIGUgPSArZTtcblxuICBmdW5jdGlvbiBwb2x5T3V0KHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCBlKTtcbiAgfVxuXG4gIHBvbHlPdXQuZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlPdXQ7XG59KShleHBvbmVudCk7XG5cbnZhciBwb2x5SW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gTWF0aC5wb3codCwgZSkgOiAyIC0gTWF0aC5wb3coMiAtIHQsIGUpKSAvIDI7XG4gIH1cblxuICBwb2x5SW5PdXQuZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlJbk91dDtcbn0pKGV4cG9uZW50KTtcblxudmFyIHBpID0gTWF0aC5QSSxcbiAgICBoYWxmUGkgPSBwaSAvIDI7XG5cbmZ1bmN0aW9uIHNpbkluKHQpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogaGFsZlBpKTtcbn1cblxuZnVuY3Rpb24gc2luT3V0KHQpIHtcbiAgcmV0dXJuIE1hdGguc2luKHQgKiBoYWxmUGkpO1xufVxuXG5mdW5jdGlvbiBzaW5Jbk91dCh0KSB7XG4gIHJldHVybiAoMSAtIE1hdGguY29zKHBpICogdCkpIC8gMjtcbn1cblxuZnVuY3Rpb24gZXhwSW4odCkge1xuICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiB0IC0gMTApO1xufVxuXG5mdW5jdGlvbiBleHBPdXQodCkge1xuICByZXR1cm4gMSAtIE1hdGgucG93KDIsIC0xMCAqIHQpO1xufVxuXG5mdW5jdGlvbiBleHBJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IE1hdGgucG93KDIsIDEwICogdCAtIDEwKSA6IDIgLSBNYXRoLnBvdygyLCAxMCAtIDEwICogdCkpIC8gMjtcbn1cblxuZnVuY3Rpb24gY2lyY2xlSW4odCkge1xuICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xufVxuXG5mdW5jdGlvbiBjaXJjbGVPdXQodCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cblxuZnVuY3Rpb24gY2lyY2xlSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCkgOiBNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSAvIDI7XG59XG5cbnZhciBiMSA9IDQgLyAxMSxcbiAgICBiMiA9IDYgLyAxMSxcbiAgICBiMyA9IDggLyAxMSxcbiAgICBiNCA9IDMgLyA0LFxuICAgIGI1ID0gOSAvIDExLFxuICAgIGI2ID0gMTAgLyAxMSxcbiAgICBiNyA9IDE1IC8gMTYsXG4gICAgYjggPSAyMSAvIDIyLFxuICAgIGI5ID0gNjMgLyA2NCxcbiAgICBiMCA9IDEgLyBiMSAvIGIxO1xuXG5mdW5jdGlvbiBib3VuY2VJbih0KSB7XG4gIHJldHVybiAxIC0gYm91bmNlT3V0KDEgLSB0KTtcbn1cblxuZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcbiAgcmV0dXJuICh0ID0gK3QpIDwgYjEgPyBiMCAqIHQgKiB0IDogdCA8IGIzID8gYjAgKiAodCAtPSBiMikgKiB0ICsgYjQgOiB0IDwgYjYgPyBiMCAqICh0IC09IGI1KSAqIHQgKyBiNyA6IGIwICogKHQgLT0gYjgpICogdCArIGI5O1xufVxuXG5mdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IDEgLSBib3VuY2VPdXQoMSAtIHQpIDogYm91bmNlT3V0KHQgLSAxKSArIDEpIC8gMjtcbn1cblxudmFyIG92ZXJzaG9vdCA9IDEuNzAxNTg7XG5cbnZhciBiYWNrSW4gPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH1cblxuICBiYWNrSW4ub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrSW47XG59KShvdmVyc2hvb3QpO1xuXG52YXIgYmFja091dCA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja091dCh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG4gIH1cblxuICBiYWNrT3V0Lm92ZXJzaG9vdCA9IGN1c3RvbTtcblxuICByZXR1cm4gYmFja091dDtcbn0pKG92ZXJzaG9vdCk7XG5cbnZhciBiYWNrSW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCAqPSAyKSA8IDEgPyB0ICogdCAqICgocyArIDEpICogdCAtIHMpIDogKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKSAvIDI7XG4gIH1cblxuICBiYWNrSW5PdXQub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrSW5PdXQ7XG59KShvdmVyc2hvb3QpO1xuXG52YXIgdGF1ID0gMiAqIE1hdGguUEksXG4gICAgYW1wbGl0dWRlID0gMSxcbiAgICBwZXJpb2QgPSAwLjM7XG5cbnZhciBlbGFzdGljSW4gPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcbiAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIDEwICogLS10KSAqIE1hdGguc2luKChzIC0gdCkgLyBwKTtcbiAgfVxuXG4gIGVsYXN0aWNJbi5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNJbi5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XG5cbiAgcmV0dXJuIGVsYXN0aWNJbjtcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcblxudmFyIGVsYXN0aWNPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG4gICAgcmV0dXJuIDEgLSBhICogTWF0aC5wb3coMiwgLTEwICogKHQgPSArdCkpICogTWF0aC5zaW4oKHQgKyBzKSAvIHApO1xuICB9XG5cbiAgZWxhc3RpY091dC5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNPdXQucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljT3V0O1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXG52YXIgZWxhc3RpY0luT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XG4gIHZhciBzID0gTWF0aC5hc2luKDEgLyAoYSA9IE1hdGgubWF4KDEsIGEpKSkgKiAocCAvPSB0YXUpO1xuXG4gIGZ1bmN0aW9uIGVsYXN0aWNJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCA9IHQgKiAyIC0gMSkgPCAwXG4gICAgICAgID8gYSAqIE1hdGgucG93KDIsIDEwICogdCkgKiBNYXRoLnNpbigocyAtIHQpIC8gcClcbiAgICAgICAgOiAyIC0gYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHMgKyB0KSAvIHApKSAvIDI7XG4gIH1cblxuICBlbGFzdGljSW5PdXQuYW1wbGl0dWRlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpOyB9O1xuICBlbGFzdGljSW5PdXQucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljSW5PdXQ7XG59KShhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cbmV4cG9ydHMuZWFzZUJhY2sgPSBiYWNrSW5PdXQ7XG5leHBvcnRzLmVhc2VCYWNrSW4gPSBiYWNrSW47XG5leHBvcnRzLmVhc2VCYWNrSW5PdXQgPSBiYWNrSW5PdXQ7XG5leHBvcnRzLmVhc2VCYWNrT3V0ID0gYmFja091dDtcbmV4cG9ydHMuZWFzZUJvdW5jZSA9IGJvdW5jZU91dDtcbmV4cG9ydHMuZWFzZUJvdW5jZUluID0gYm91bmNlSW47XG5leHBvcnRzLmVhc2VCb3VuY2VJbk91dCA9IGJvdW5jZUluT3V0O1xuZXhwb3J0cy5lYXNlQm91bmNlT3V0ID0gYm91bmNlT3V0O1xuZXhwb3J0cy5lYXNlQ2lyY2xlID0gY2lyY2xlSW5PdXQ7XG5leHBvcnRzLmVhc2VDaXJjbGVJbiA9IGNpcmNsZUluO1xuZXhwb3J0cy5lYXNlQ2lyY2xlSW5PdXQgPSBjaXJjbGVJbk91dDtcbmV4cG9ydHMuZWFzZUNpcmNsZU91dCA9IGNpcmNsZU91dDtcbmV4cG9ydHMuZWFzZUN1YmljID0gY3ViaWNJbk91dDtcbmV4cG9ydHMuZWFzZUN1YmljSW4gPSBjdWJpY0luO1xuZXhwb3J0cy5lYXNlQ3ViaWNJbk91dCA9IGN1YmljSW5PdXQ7XG5leHBvcnRzLmVhc2VDdWJpY091dCA9IGN1YmljT3V0O1xuZXhwb3J0cy5lYXNlRWxhc3RpYyA9IGVsYXN0aWNPdXQ7XG5leHBvcnRzLmVhc2VFbGFzdGljSW4gPSBlbGFzdGljSW47XG5leHBvcnRzLmVhc2VFbGFzdGljSW5PdXQgPSBlbGFzdGljSW5PdXQ7XG5leHBvcnRzLmVhc2VFbGFzdGljT3V0ID0gZWxhc3RpY091dDtcbmV4cG9ydHMuZWFzZUV4cCA9IGV4cEluT3V0O1xuZXhwb3J0cy5lYXNlRXhwSW4gPSBleHBJbjtcbmV4cG9ydHMuZWFzZUV4cEluT3V0ID0gZXhwSW5PdXQ7XG5leHBvcnRzLmVhc2VFeHBPdXQgPSBleHBPdXQ7XG5leHBvcnRzLmVhc2VMaW5lYXIgPSBsaW5lYXI7XG5leHBvcnRzLmVhc2VQb2x5ID0gcG9seUluT3V0O1xuZXhwb3J0cy5lYXNlUG9seUluID0gcG9seUluO1xuZXhwb3J0cy5lYXNlUG9seUluT3V0ID0gcG9seUluT3V0O1xuZXhwb3J0cy5lYXNlUG9seU91dCA9IHBvbHlPdXQ7XG5leHBvcnRzLmVhc2VRdWFkID0gcXVhZEluT3V0O1xuZXhwb3J0cy5lYXNlUXVhZEluID0gcXVhZEluO1xuZXhwb3J0cy5lYXNlUXVhZEluT3V0ID0gcXVhZEluT3V0O1xuZXhwb3J0cy5lYXNlUXVhZE91dCA9IHF1YWRPdXQ7XG5leHBvcnRzLmVhc2VTaW4gPSBzaW5Jbk91dDtcbmV4cG9ydHMuZWFzZVNpbkluID0gc2luSW47XG5leHBvcnRzLmVhc2VTaW5Jbk91dCA9IHNpbkluT3V0O1xuZXhwb3J0cy5lYXNlU2luT3V0ID0gc2luT3V0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWZvcm1hdC8gdjEuNC4zIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gQ29tcHV0ZXMgdGhlIGRlY2ltYWwgY29lZmZpY2llbnQgYW5kIGV4cG9uZW50IG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIHggd2l0aFxuLy8gc2lnbmlmaWNhbnQgZGlnaXRzIHAsIHdoZXJlIHggaXMgcG9zaXRpdmUgYW5kIHAgaXMgaW4gWzEsIDIxXSBvciB1bmRlZmluZWQuXG4vLyBGb3IgZXhhbXBsZSwgZm9ybWF0RGVjaW1hbCgxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cbmZ1bmN0aW9uIGZvcm1hdERlY2ltYWwoeCwgcCkge1xuICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAvLyBUaGUgc3RyaW5nIHJldHVybmVkIGJ5IHRvRXhwb25lbnRpYWwgZWl0aGVyIGhhcyB0aGUgZm9ybSBcXGRcXC5cXGQrZVstK11cXGQrXG4gIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gIHJldHVybiBbXG4gICAgY29lZmZpY2llbnQubGVuZ3RoID4gMSA/IGNvZWZmaWNpZW50WzBdICsgY29lZmZpY2llbnQuc2xpY2UoMikgOiBjb2VmZmljaWVudCxcbiAgICAreC5zbGljZShpICsgMSlcbiAgXTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnQoeCkge1xuICByZXR1cm4geCA9IGZvcm1hdERlY2ltYWwoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0R3JvdXAoZ3JvdXBpbmcsIHRob3VzYW5kcykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgIHQgPSBbXSxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIGcgPSBncm91cGluZ1swXSxcbiAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgaWYgKGxlbmd0aCArIGcgKyAxID4gd2lkdGgpIGcgPSBNYXRoLm1heCgxLCB3aWR0aCAtIGxlbmd0aCk7XG4gICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgIGlmICgobGVuZ3RoICs9IGcgKyAxKSA+IHdpZHRoKSBicmVhaztcbiAgICAgIGcgPSBncm91cGluZ1tqID0gKGogKyAxKSAlIGdyb3VwaW5nLmxlbmd0aF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4odGhvdXNhbmRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TnVtZXJhbHMobnVtZXJhbHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1swLTldL2csIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBudW1lcmFsc1sraV07XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bfl1bdHlwZV1cbnZhciByZSA9IC9eKD86KC4pPyhbPD49Xl0pKT8oWytcXC0oIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KH4pPyhbYS16JV0pPyQvaTtcblxuZnVuY3Rpb24gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICBpZiAoIShtYXRjaCA9IHJlLmV4ZWMoc3BlY2lmaWVyKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIHNwZWNpZmllcik7XG4gIHZhciBtYXRjaDtcbiAgcmV0dXJuIG5ldyBGb3JtYXRTcGVjaWZpZXIoe1xuICAgIGZpbGw6IG1hdGNoWzFdLFxuICAgIGFsaWduOiBtYXRjaFsyXSxcbiAgICBzaWduOiBtYXRjaFszXSxcbiAgICBzeW1ib2w6IG1hdGNoWzRdLFxuICAgIHplcm86IG1hdGNoWzVdLFxuICAgIHdpZHRoOiBtYXRjaFs2XSxcbiAgICBjb21tYTogbWF0Y2hbN10sXG4gICAgcHJlY2lzaW9uOiBtYXRjaFs4XSAmJiBtYXRjaFs4XS5zbGljZSgxKSxcbiAgICB0cmltOiBtYXRjaFs5XSxcbiAgICB0eXBlOiBtYXRjaFsxMF1cbiAgfSk7XG59XG5cbmZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUgPSBGb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlOyAvLyBpbnN0YW5jZW9mXG5cbmZ1bmN0aW9uIEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgdGhpcy5maWxsID0gc3BlY2lmaWVyLmZpbGwgPT09IHVuZGVmaW5lZCA/IFwiIFwiIDogc3BlY2lmaWVyLmZpbGwgKyBcIlwiO1xuICB0aGlzLmFsaWduID0gc3BlY2lmaWVyLmFsaWduID09PSB1bmRlZmluZWQgPyBcIj5cIiA6IHNwZWNpZmllci5hbGlnbiArIFwiXCI7XG4gIHRoaXMuc2lnbiA9IHNwZWNpZmllci5zaWduID09PSB1bmRlZmluZWQgPyBcIi1cIiA6IHNwZWNpZmllci5zaWduICsgXCJcIjtcbiAgdGhpcy5zeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sID09PSB1bmRlZmluZWQgPyBcIlwiIDogc3BlY2lmaWVyLnN5bWJvbCArIFwiXCI7XG4gIHRoaXMuemVybyA9ICEhc3BlY2lmaWVyLnplcm87XG4gIHRoaXMud2lkdGggPSBzcGVjaWZpZXIud2lkdGggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICtzcGVjaWZpZXIud2lkdGg7XG4gIHRoaXMuY29tbWEgPSAhIXNwZWNpZmllci5jb21tYTtcbiAgdGhpcy5wcmVjaXNpb24gPSBzcGVjaWZpZXIucHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiArc3BlY2lmaWVyLnByZWNpc2lvbjtcbiAgdGhpcy50cmltID0gISFzcGVjaWZpZXIudHJpbTtcbiAgdGhpcy50eXBlID0gc3BlY2lmaWVyLnR5cGUgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBzcGVjaWZpZXIudHlwZSArIFwiXCI7XG59XG5cbkZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZmlsbFxuICAgICAgKyB0aGlzLmFsaWduXG4gICAgICArIHRoaXMuc2lnblxuICAgICAgKyB0aGlzLnN5bWJvbFxuICAgICAgKyAodGhpcy56ZXJvID8gXCIwXCIgOiBcIlwiKVxuICAgICAgKyAodGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IE1hdGgubWF4KDEsIHRoaXMud2lkdGggfCAwKSlcbiAgICAgICsgKHRoaXMuY29tbWEgPyBcIixcIiA6IFwiXCIpXG4gICAgICArICh0aGlzLnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IFwiLlwiICsgTWF0aC5tYXgoMCwgdGhpcy5wcmVjaXNpb24gfCAwKSlcbiAgICAgICsgKHRoaXMudHJpbSA/IFwiflwiIDogXCJcIilcbiAgICAgICsgdGhpcy50eXBlO1xufTtcblxuLy8gVHJpbXMgaW5zaWduaWZpY2FudCB6ZXJvcywgZS5nLiwgcmVwbGFjZXMgMS4yMDAwayB3aXRoIDEuMmsuXG5mdW5jdGlvbiBmb3JtYXRUcmltKHMpIHtcbiAgb3V0OiBmb3IgKHZhciBuID0gcy5sZW5ndGgsIGkgPSAxLCBpMCA9IC0xLCBpMTsgaSA8IG47ICsraSkge1xuICAgIHN3aXRjaCAoc1tpXSkge1xuICAgICAgY2FzZSBcIi5cIjogaTAgPSBpMSA9IGk7IGJyZWFrO1xuICAgICAgY2FzZSBcIjBcIjogaWYgKGkwID09PSAwKSBpMCA9IGk7IGkxID0gaTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBpZiAoIStzW2ldKSBicmVhayBvdXQ7IGlmIChpMCA+IDApIGkwID0gMDsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpMCA+IDAgPyBzLnNsaWNlKDAsIGkwKSArIHMuc2xpY2UoaTEgKyAxKSA6IHM7XG59XG5cbnZhciBwcmVmaXhFeHBvbmVudDtcblxuZnVuY3Rpb24gZm9ybWF0UHJlZml4QXV0byh4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICBleHBvbmVudCA9IGRbMV0sXG4gICAgICBpID0gZXhwb25lbnQgLSAocHJlZml4RXhwb25lbnQgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCAvIDMpKSkgKiAzKSArIDEsXG4gICAgICBuID0gY29lZmZpY2llbnQubGVuZ3RoO1xuICByZXR1cm4gaSA9PT0gbiA/IGNvZWZmaWNpZW50XG4gICAgICA6IGkgPiBuID8gY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoaSAtIG4gKyAxKS5qb2luKFwiMFwiKVxuICAgICAgOiBpID4gMCA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGkpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShpKVxuICAgICAgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIGkpLmpvaW4oXCIwXCIpICsgZm9ybWF0RGVjaW1hbCh4LCBNYXRoLm1heCgwLCBwICsgaSAtIDEpKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxufVxuXG5mdW5jdGlvbiBmb3JtYXRSb3VuZGVkKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXTtcbiAgcmV0dXJuIGV4cG9uZW50IDwgMCA/IFwiMC5cIiArIG5ldyBBcnJheSgtZXhwb25lbnQpLmpvaW4oXCIwXCIpICsgY29lZmZpY2llbnRcbiAgICAgIDogY29lZmZpY2llbnQubGVuZ3RoID4gZXhwb25lbnQgKyAxID8gY29lZmZpY2llbnQuc2xpY2UoMCwgZXhwb25lbnQgKyAxKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoZXhwb25lbnQgKyAxKVxuICAgICAgOiBjb2VmZmljaWVudCArIG5ldyBBcnJheShleHBvbmVudCAtIGNvZWZmaWNpZW50Lmxlbmd0aCArIDIpLmpvaW4oXCIwXCIpO1xufVxuXG52YXIgZm9ybWF0VHlwZXMgPSB7XG4gIFwiJVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiAoeCAqIDEwMCkudG9GaXhlZChwKTsgfSxcbiAgXCJiXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMik7IH0sXG4gIFwiY1wiOiBmdW5jdGlvbih4KSB7IHJldHVybiB4ICsgXCJcIjsgfSxcbiAgXCJkXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTApOyB9LFxuICBcImVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0V4cG9uZW50aWFsKHApOyB9LFxuICBcImZcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0ZpeGVkKHApOyB9LFxuICBcImdcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b1ByZWNpc2lvbihwKTsgfSxcbiAgXCJvXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCk7IH0sXG4gIFwicFwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiBmb3JtYXRSb3VuZGVkKHggKiAxMDAsIHApOyB9LFxuICBcInJcIjogZm9ybWF0Um91bmRlZCxcbiAgXCJzXCI6IGZvcm1hdFByZWZpeEF1dG8sXG4gIFwiWFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9LFxuICBcInhcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNik7IH1cbn07XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbnZhciBtYXAgPSBBcnJheS5wcm90b3R5cGUubWFwLFxuICAgIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiwrVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxuZnVuY3Rpb24gZm9ybWF0TG9jYWxlKGxvY2FsZSkge1xuICB2YXIgZ3JvdXAgPSBsb2NhbGUuZ3JvdXBpbmcgPT09IHVuZGVmaW5lZCB8fCBsb2NhbGUudGhvdXNhbmRzID09PSB1bmRlZmluZWQgPyBpZGVudGl0eSA6IGZvcm1hdEdyb3VwKG1hcC5jYWxsKGxvY2FsZS5ncm91cGluZywgTnVtYmVyKSwgbG9jYWxlLnRob3VzYW5kcyArIFwiXCIpLFxuICAgICAgY3VycmVuY3lQcmVmaXggPSBsb2NhbGUuY3VycmVuY3kgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBsb2NhbGUuY3VycmVuY3lbMF0gKyBcIlwiLFxuICAgICAgY3VycmVuY3lTdWZmaXggPSBsb2NhbGUuY3VycmVuY3kgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBsb2NhbGUuY3VycmVuY3lbMV0gKyBcIlwiLFxuICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsID09PSB1bmRlZmluZWQgPyBcIi5cIiA6IGxvY2FsZS5kZWNpbWFsICsgXCJcIixcbiAgICAgIG51bWVyYWxzID0gbG9jYWxlLm51bWVyYWxzID09PSB1bmRlZmluZWQgPyBpZGVudGl0eSA6IGZvcm1hdE51bWVyYWxzKG1hcC5jYWxsKGxvY2FsZS5udW1lcmFscywgU3RyaW5nKSksXG4gICAgICBwZXJjZW50ID0gbG9jYWxlLnBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IFwiJVwiIDogbG9jYWxlLnBlcmNlbnQgKyBcIlwiLFxuICAgICAgbWludXMgPSBsb2NhbGUubWludXMgPT09IHVuZGVmaW5lZCA/IFwiLVwiIDogbG9jYWxlLm1pbnVzICsgXCJcIixcbiAgICAgIG5hbiA9IGxvY2FsZS5uYW4gPT09IHVuZGVmaW5lZCA/IFwiTmFOXCIgOiBsb2NhbGUubmFuICsgXCJcIjtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyKSB7XG4gICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG5cbiAgICB2YXIgZmlsbCA9IHNwZWNpZmllci5maWxsLFxuICAgICAgICBhbGlnbiA9IHNwZWNpZmllci5hbGlnbixcbiAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxuICAgICAgICBzeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sLFxuICAgICAgICB6ZXJvID0gc3BlY2lmaWVyLnplcm8sXG4gICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxuICAgICAgICBjb21tYSA9IHNwZWNpZmllci5jb21tYSxcbiAgICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbixcbiAgICAgICAgdHJpbSA9IHNwZWNpZmllci50cmltLFxuICAgICAgICB0eXBlID0gc3BlY2lmaWVyLnR5cGU7XG5cbiAgICAvLyBUaGUgXCJuXCIgdHlwZSBpcyBhbiBhbGlhcyBmb3IgXCIsZ1wiLlxuICAgIGlmICh0eXBlID09PSBcIm5cIikgY29tbWEgPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBUaGUgXCJcIiB0eXBlLCBhbmQgYW55IGludmFsaWQgdHlwZSwgaXMgYW4gYWxpYXMgZm9yIFwiLjEyfmdcIi5cbiAgICBlbHNlIGlmICghZm9ybWF0VHlwZXNbdHlwZV0pIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkICYmIChwcmVjaXNpb24gPSAxMiksIHRyaW0gPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cbiAgICBpZiAoemVybyB8fCAoZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSkgemVybyA9IHRydWUsIGZpbGwgPSBcIjBcIiwgYWxpZ24gPSBcIj1cIjtcblxuICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgIC8vIEZvciBTSS1wcmVmaXgsIHRoZSBzdWZmaXggaXMgbGF6aWx5IGNvbXB1dGVkLlxuICAgIHZhciBwcmVmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lQcmVmaXggOiBzeW1ib2wgPT09IFwiI1wiICYmIC9bYm94WF0vLnRlc3QodHlwZSkgPyBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKSA6IFwiXCIsXG4gICAgICAgIHN1ZmZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVN1ZmZpeCA6IC9bJXBdLy50ZXN0KHR5cGUpID8gcGVyY2VudCA6IFwiXCI7XG5cbiAgICAvLyBXaGF0IGZvcm1hdCBmdW5jdGlvbiBzaG91bGQgd2UgdXNlP1xuICAgIC8vIElzIHRoaXMgYW4gaW50ZWdlciB0eXBlP1xuICAgIC8vIENhbiB0aGlzIHR5cGUgZ2VuZXJhdGUgZXhwb25lbnRpYWwgbm90YXRpb24/XG4gICAgdmFyIGZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlc1t0eXBlXSxcbiAgICAgICAgbWF5YmVTdWZmaXggPSAvW2RlZmdwcnMlXS8udGVzdCh0eXBlKTtcblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdCBwcmVjaXNpb24gaWYgbm90IHNwZWNpZmllZCxcbiAgICAvLyBvciBjbGFtcCB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiB0byB0aGUgc3VwcG9ydGVkIHJhbmdlLlxuICAgIC8vIEZvciBzaWduaWZpY2FudCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzEsIDIxXS5cbiAgICAvLyBGb3IgZml4ZWQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFswLCAyMF0uXG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2XG4gICAgICAgIDogL1tncHJzXS8udGVzdCh0eXBlKSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKVxuICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgdmFyIHZhbHVlUHJlZml4ID0gcHJlZml4LFxuICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4LFxuICAgICAgICAgIGksIG4sIGM7XG5cbiAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9IGZvcm1hdFR5cGUodmFsdWUpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuXG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgZm9ybWF0dGluZy5cbiAgICAgICAgdmFyIHZhbHVlTmVnYXRpdmUgPSB2YWx1ZSA8IDA7XG4gICAgICAgIHZhbHVlID0gaXNOYU4odmFsdWUpID8gbmFuIDogZm9ybWF0VHlwZShNYXRoLmFicyh2YWx1ZSksIHByZWNpc2lvbik7XG5cbiAgICAgICAgLy8gVHJpbSBpbnNpZ25pZmljYW50IHplcm9zLlxuICAgICAgICBpZiAodHJpbSkgdmFsdWUgPSBmb3JtYXRUcmltKHZhbHVlKTtcblxuICAgICAgICAvLyBJZiBhIG5lZ2F0aXZlIHZhbHVlIHJvdW5kcyB0byB6ZXJvIGR1cmluZyBmb3JtYXR0aW5nLCB0cmVhdCBhcyBwb3NpdGl2ZS5cbiAgICAgICAgaWYgKHZhbHVlTmVnYXRpdmUgJiYgK3ZhbHVlID09PSAwKSB2YWx1ZU5lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAgIHZhbHVlUHJlZml4ID0gKHZhbHVlTmVnYXRpdmUgPyAoc2lnbiA9PT0gXCIoXCIgPyBzaWduIDogbWludXMpIDogc2lnbiA9PT0gXCItXCIgfHwgc2lnbiA9PT0gXCIoXCIgPyBcIlwiIDogc2lnbikgKyB2YWx1ZVByZWZpeDtcblxuICAgICAgICB2YWx1ZVN1ZmZpeCA9ICh0eXBlID09PSBcInNcIiA/IHByZWZpeGVzWzggKyBwcmVmaXhFeHBvbmVudCAvIDNdIDogXCJcIikgKyB2YWx1ZVN1ZmZpeCArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGludGVnZXIg4oCcdmFsdWXigJ0gcGFydCB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBncm91cGVkLCBhbmQgZnJhY3Rpb25hbCBvciBleHBvbmVudGlhbCDigJxzdWZmaXjigJ0gcGFydCB0aGF0IGlzIG5vdC5cbiAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcbiAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmICF6ZXJvKSB2YWx1ZSA9IGdyb3VwKHZhbHVlLCBJbmZpbml0eSk7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWVQcmVmaXgubGVuZ3RoICsgdmFsdWUubGVuZ3RoICsgdmFsdWVTdWZmaXgubGVuZ3RoLFxuICAgICAgICAgIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiB6ZXJvKSB2YWx1ZSA9IGdyb3VwKHBhZGRpbmcgKyB2YWx1ZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIHZhbHVlU3VmZml4Lmxlbmd0aCA6IEluZmluaXR5KSwgcGFkZGluZyA9IFwiXCI7XG5cbiAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBmaW5hbCBvdXRwdXQgYmFzZWQgb24gdGhlIGRlc2lyZWQgYWxpZ25tZW50LlxuICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICBjYXNlIFwiPFwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPVwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgcGFkZGluZyArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiXlwiOiB2YWx1ZSA9IHBhZGRpbmcuc2xpY2UoMCwgbGVuZ3RoID0gcGFkZGluZy5sZW5ndGggPj4gMSkgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nLnNsaWNlKGxlbmd0aCk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB2YWx1ZSA9IHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtZXJhbHModmFsdWUpO1xuICAgIH1cblxuICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNwZWNpZmllciArIFwiXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgIHZhciBmID0gbmV3Rm9ybWF0KChzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSwgc3BlY2lmaWVyLnR5cGUgPSBcImZcIiwgc3BlY2lmaWVyKSksXG4gICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyxcbiAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogbmV3Rm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gIH07XG59XG5cbnZhciBsb2NhbGU7XG5cbmRlZmF1bHRMb2NhbGUoe1xuICBkZWNpbWFsOiBcIi5cIixcbiAgdGhvdXNhbmRzOiBcIixcIixcbiAgZ3JvdXBpbmc6IFszXSxcbiAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl0sXG4gIG1pbnVzOiBcIi1cIlxufSk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGV4cG9ydHMuZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgZXhwb3J0cy5mb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xuICByZXR1cm4gbG9jYWxlO1xufVxuXG5mdW5jdGlvbiBwcmVjaXNpb25GaXhlZChzdGVwKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCAtZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbn1cblxuZnVuY3Rpb24gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyAtIGV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG59XG5cbmZ1bmN0aW9uIHByZWNpc2lvblJvdW5kKHN0ZXAsIG1heCkge1xuICBzdGVwID0gTWF0aC5hYnMoc3RlcCksIG1heCA9IE1hdGguYWJzKG1heCkgLSBzdGVwO1xuICByZXR1cm4gTWF0aC5tYXgoMCwgZXhwb25lbnQobWF4KSAtIGV4cG9uZW50KHN0ZXApKSArIDE7XG59XG5cbmV4cG9ydHMuRm9ybWF0U3BlY2lmaWVyID0gRm9ybWF0U3BlY2lmaWVyO1xuZXhwb3J0cy5mb3JtYXREZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbmV4cG9ydHMuZm9ybWF0TG9jYWxlID0gZm9ybWF0TG9jYWxlO1xuZXhwb3J0cy5mb3JtYXRTcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXI7XG5leHBvcnRzLnByZWNpc2lvbkZpeGVkID0gcHJlY2lzaW9uRml4ZWQ7XG5leHBvcnRzLnByZWNpc2lvblByZWZpeCA9IHByZWNpc2lvblByZWZpeDtcbmV4cG9ydHMucHJlY2lzaW9uUm91bmQgPSBwcmVjaXNpb25Sb3VuZDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1pbnRlcnBvbGF0ZS8gdjEuNC4wIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtY29sb3InKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1jb2xvciddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9LCBnbG9iYWwuZDMpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGQzQ29sb3IpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBiYXNpcyh0MSwgdjAsIHYxLCB2MiwgdjMpIHtcbiAgdmFyIHQyID0gdDEgKiB0MSwgdDMgPSB0MiAqIHQxO1xuICByZXR1cm4gKCgxIC0gMyAqIHQxICsgMyAqIHQyIC0gdDMpICogdjBcbiAgICAgICsgKDQgLSA2ICogdDIgKyAzICogdDMpICogdjFcbiAgICAgICsgKDEgKyAzICogdDEgKyAzICogdDIgLSAzICogdDMpICogdjJcbiAgICAgICsgdDMgKiB2MykgLyA2O1xufVxuXG5mdW5jdGlvbiBiYXNpcyQxKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdCA8PSAwID8gKHQgPSAwKSA6IHQgPj0gMSA/ICh0ID0gMSwgbiAtIDEpIDogTWF0aC5mbG9vcih0ICogbiksXG4gICAgICAgIHYxID0gdmFsdWVzW2ldLFxuICAgICAgICB2MiA9IHZhbHVlc1tpICsgMV0sXG4gICAgICAgIHYwID0gaSA+IDAgPyB2YWx1ZXNbaSAtIDFdIDogMiAqIHYxIC0gdjIsXG4gICAgICAgIHYzID0gaSA8IG4gLSAxID8gdmFsdWVzW2kgKyAyXSA6IDIgKiB2MiAtIHYxO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmFzaXNDbG9zZWQodmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoKCh0ICU9IDEpIDwgMCA/ICsrdCA6IHQpICogbiksXG4gICAgICAgIHYwID0gdmFsdWVzWyhpICsgbiAtIDEpICUgbl0sXG4gICAgICAgIHYxID0gdmFsdWVzW2kgJSBuXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbKGkgKyAxKSAlIG5dLFxuICAgICAgICB2MyA9IHZhbHVlc1soaSArIDIpICUgbl07XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbGluZWFyKGEsIGQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSArIHQgKiBkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHBvbmVudGlhbChhLCBiLCB5KSB7XG4gIHJldHVybiBhID0gTWF0aC5wb3coYSwgeSksIGIgPSBNYXRoLnBvdyhiLCB5KSAtIGEsIHkgPSAxIC8geSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyhhICsgdCAqIGIsIHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodWUoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkID4gMTgwIHx8IGQgPCAtMTgwID8gZCAtIDM2MCAqIE1hdGgucm91bmQoZCAvIDM2MCkgOiBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuXG5mdW5jdGlvbiBnYW1tYSh5KSB7XG4gIHJldHVybiAoeSA9ICt5KSA9PT0gMSA/IG5vZ2FtbWEgOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIgLSBhID8gZXhwb25lbnRpYWwoYSwgYiwgeSkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9nYW1tYShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG5cbnZhciByZ2IgPSAoZnVuY3Rpb24gcmdiR2FtbWEoeSkge1xuICB2YXIgY29sb3IgPSBnYW1tYSh5KTtcblxuICBmdW5jdGlvbiByZ2Ioc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gY29sb3IoKHN0YXJ0ID0gZDNDb2xvci5yZ2Ioc3RhcnQpKS5yLCAoZW5kID0gZDNDb2xvci5yZ2IoZW5kKSkuciksXG4gICAgICAgIGcgPSBjb2xvcihzdGFydC5nLCBlbmQuZyksXG4gICAgICAgIGIgPSBjb2xvcihzdGFydC5iLCBlbmQuYiksXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuciA9IHIodCk7XG4gICAgICBzdGFydC5nID0gZyh0KTtcbiAgICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICByZ2IuZ2FtbWEgPSByZ2JHYW1tYTtcblxuICByZXR1cm4gcmdiO1xufSkoMSk7XG5cbmZ1bmN0aW9uIHJnYlNwbGluZShzcGxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9ycykge1xuICAgIHZhciBuID0gY29sb3JzLmxlbmd0aCxcbiAgICAgICAgciA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgZyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgaSwgY29sb3I7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29sb3IgPSBkM0NvbG9yLnJnYihjb2xvcnNbaV0pO1xuICAgICAgcltpXSA9IGNvbG9yLnIgfHwgMDtcbiAgICAgIGdbaV0gPSBjb2xvci5nIHx8IDA7XG4gICAgICBiW2ldID0gY29sb3IuYiB8fCAwO1xuICAgIH1cbiAgICByID0gc3BsaW5lKHIpO1xuICAgIGcgPSBzcGxpbmUoZyk7XG4gICAgYiA9IHNwbGluZShiKTtcbiAgICBjb2xvci5vcGFjaXR5ID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29sb3IuciA9IHIodCk7XG4gICAgICBjb2xvci5nID0gZyh0KTtcbiAgICAgIGNvbG9yLmIgPSBiKHQpO1xuICAgICAgcmV0dXJuIGNvbG9yICsgXCJcIjtcbiAgICB9O1xuICB9O1xufVxuXG52YXIgcmdiQmFzaXMgPSByZ2JTcGxpbmUoYmFzaXMkMSk7XG52YXIgcmdiQmFzaXNDbG9zZWQgPSByZ2JTcGxpbmUoYmFzaXNDbG9zZWQpO1xuXG5mdW5jdGlvbiBudW1iZXJBcnJheShhLCBiKSB7XG4gIGlmICghYikgYiA9IFtdO1xuICB2YXIgbiA9IGEgPyBNYXRoLm1pbihiLmxlbmd0aCwgYS5sZW5ndGgpIDogMCxcbiAgICAgIGMgPSBiLnNsaWNlKCksXG4gICAgICBpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNbaV0gPSBhW2ldICogKDEgLSB0KSArIGJbaV0gKiB0O1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc051bWJlckFycmF5KHgpIHtcbiAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh4KSAmJiAhKHggaW5zdGFuY2VvZiBEYXRhVmlldyk7XG59XG5cbmZ1bmN0aW9uIGFycmF5KGEsIGIpIHtcbiAgcmV0dXJuIChpc051bWJlckFycmF5KGIpID8gbnVtYmVyQXJyYXkgOiBnZW5lcmljQXJyYXkpKGEsIGIpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmljQXJyYXkoYSwgYikge1xuICB2YXIgbmIgPSBiID8gYi5sZW5ndGggOiAwLFxuICAgICAgbmEgPSBhID8gTWF0aC5taW4obmIsIGEubGVuZ3RoKSA6IDAsXG4gICAgICB4ID0gbmV3IEFycmF5KG5hKSxcbiAgICAgIGMgPSBuZXcgQXJyYXkobmIpLFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgeFtpXSA9IHZhbHVlKGFbaV0sIGJbaV0pO1xuICBmb3IgKDsgaSA8IG5iOyArK2kpIGNbaV0gPSBiW2ldO1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIGNbaV0gPSB4W2ldKHQpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkYXRlKGEsIGIpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZTtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGQuc2V0VGltZShhICogKDEgLSB0KSArIGIgKiB0KSwgZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKiAoMSAtIHQpICsgYiAqIHQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9iamVjdChhLCBiKSB7XG4gIHZhciBpID0ge30sXG4gICAgICBjID0ge30sXG4gICAgICBrO1xuXG4gIGlmIChhID09PSBudWxsIHx8IHR5cGVvZiBhICE9PSBcIm9iamVjdFwiKSBhID0ge307XG4gIGlmIChiID09PSBudWxsIHx8IHR5cGVvZiBiICE9PSBcIm9iamVjdFwiKSBiID0ge307XG5cbiAgZm9yIChrIGluIGIpIHtcbiAgICBpZiAoayBpbiBhKSB7XG4gICAgICBpW2tdID0gdmFsdWUoYVtrXSwgYltrXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNba10gPSBiW2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChrIGluIGkpIGNba10gPSBpW2tdKHQpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG52YXIgcmVBID0gL1stK10/KD86XFxkK1xcLj9cXGQqfFxcLj9cXGQrKSg/OltlRV1bLStdP1xcZCspPy9nLFxuICAgIHJlQiA9IG5ldyBSZWdFeHAocmVBLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiB6ZXJvKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbmUoYikge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBiKHQpICsgXCJcIjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nKGEsIGIpIHtcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLCAvLyBzY2FuIGluZGV4IGZvciBuZXh0IG51bWJlciBpbiBiXG4gICAgICBhbSwgLy8gY3VycmVudCBtYXRjaCBpbiBhXG4gICAgICBibSwgLy8gY3VycmVudCBtYXRjaCBpbiBiXG4gICAgICBicywgLy8gc3RyaW5nIHByZWNlZGluZyBjdXJyZW50IG51bWJlciBpbiBiLCBpZiBhbnlcbiAgICAgIGkgPSAtMSwgLy8gaW5kZXggaW4gc1xuICAgICAgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcblxuICAvLyBDb2VyY2UgaW5wdXRzIHRvIHN0cmluZ3MuXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuXG4gIC8vIEludGVycG9sYXRlIHBhaXJzIG9mIG51bWJlcnMgaW4gYSAmIGIuXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSlcbiAgICAgICYmIChibSA9IHJlQi5leGVjKGIpKSkge1xuICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkgeyAvLyBhIHN0cmluZyBwcmVjZWRlcyB0aGUgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkgeyAvLyBudW1iZXJzIGluIGEgJiBiIG1hdGNoXG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XG4gICAgfSBlbHNlIHsgLy8gaW50ZXJwb2xhdGUgbm9uLW1hdGNoaW5nIG51bWJlcnNcbiAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICBxLnB1c2goe2k6IGksIHg6IG51bWJlcihhbSwgYm0pfSk7XG4gICAgfVxuICAgIGJpID0gcmVCLmxhc3RJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCByZW1haW5zIG9mIGIuXG4gIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICBlbHNlIHNbKytpXSA9IGJzO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBvcHRpbWl6YXRpb24gZm9yIG9ubHkgYSBzaW5nbGUgbWF0Y2guXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXG4gIHJldHVybiBzLmxlbmd0aCA8IDIgPyAocVswXVxuICAgICAgPyBvbmUocVswXS54KVxuICAgICAgOiB6ZXJvKGIpKVxuICAgICAgOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsdWUoYSwgYikge1xuICB2YXIgdCA9IHR5cGVvZiBiLCBjO1xuICByZXR1cm4gYiA9PSBudWxsIHx8IHQgPT09IFwiYm9vbGVhblwiID8gY29uc3RhbnQoYilcbiAgICAgIDogKHQgPT09IFwibnVtYmVyXCIgPyBudW1iZXJcbiAgICAgIDogdCA9PT0gXCJzdHJpbmdcIiA/ICgoYyA9IGQzQ29sb3IuY29sb3IoYikpID8gKGIgPSBjLCByZ2IpIDogc3RyaW5nKVxuICAgICAgOiBiIGluc3RhbmNlb2YgZDNDb2xvci5jb2xvciA/IHJnYlxuICAgICAgOiBiIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGVcbiAgICAgIDogaXNOdW1iZXJBcnJheShiKSA/IG51bWJlckFycmF5XG4gICAgICA6IEFycmF5LmlzQXJyYXkoYikgPyBnZW5lcmljQXJyYXlcbiAgICAgIDogdHlwZW9mIGIudmFsdWVPZiAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBiLnRvU3RyaW5nICE9PSBcImZ1bmN0aW9uXCIgfHwgaXNOYU4oYikgPyBvYmplY3RcbiAgICAgIDogbnVtYmVyKShhLCBiKTtcbn1cblxuZnVuY3Rpb24gZGlzY3JldGUocmFuZ2UpIHtcbiAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKiBuKSkpXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHVlJDEoYSwgYikge1xuICB2YXIgaSA9IGh1ZSgrYSwgK2IpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciB4ID0gaSh0KTtcbiAgICByZXR1cm4geCAtIDM2MCAqIE1hdGguZmxvb3IoeCAvIDM2MCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJvdW5kKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYSAqICgxIC0gdCkgKyBiICogdCk7XG4gIH07XG59XG5cbnZhciBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcblxudmFyIGlkZW50aXR5ID0ge1xuICB0cmFuc2xhdGVYOiAwLFxuICB0cmFuc2xhdGVZOiAwLFxuICByb3RhdGU6IDAsXG4gIHNrZXdYOiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcblxuZnVuY3Rpb24gZGVjb21wb3NlKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufVxuXG52YXIgY3NzTm9kZSxcbiAgICBjc3NSb290LFxuICAgIGNzc1ZpZXcsXG4gICAgc3ZnTm9kZTtcblxuZnVuY3Rpb24gcGFyc2VDc3ModmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBcIm5vbmVcIikgcmV0dXJuIGlkZW50aXR5O1xuICBpZiAoIWNzc05vZGUpIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpLCBjc3NSb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBjc3NWaWV3ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIGNzc05vZGUuc3R5bGUudHJhbnNmb3JtID0gdmFsdWU7XG4gIHZhbHVlID0gY3NzVmlldy5nZXRDb21wdXRlZFN0eWxlKGNzc1Jvb3QuYXBwZW5kQ2hpbGQoY3NzTm9kZSksIG51bGwpLmdldFByb3BlcnR5VmFsdWUoXCJ0cmFuc2Zvcm1cIik7XG4gIGNzc1Jvb3QucmVtb3ZlQ2hpbGQoY3NzTm9kZSk7XG4gIHZhbHVlID0gdmFsdWUuc2xpY2UoNywgLTEpLnNwbGl0KFwiLFwiKTtcbiAgcmV0dXJuIGRlY29tcG9zZSgrdmFsdWVbMF0sICt2YWx1ZVsxXSwgK3ZhbHVlWzJdLCArdmFsdWVbM10sICt2YWx1ZVs0XSwgK3ZhbHVlWzVdKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTdmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFzdmdOb2RlKSBzdmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICBzdmdOb2RlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB2YWx1ZSk7XG4gIGlmICghKHZhbHVlID0gc3ZnTm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpKSkgcmV0dXJuIGlkZW50aXR5O1xuICB2YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgcmV0dXJuIGRlY29tcG9zZSh2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLCB2YWx1ZS5lLCB2YWx1ZS5mKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2UsIHB4Q29tbWEsIHB4UGFyZW4sIGRlZ1BhcmVuKSB7XG5cbiAgZnVuY3Rpb24gcG9wKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIgXCIgOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBweENvbW1hLCBudWxsLCBweFBhcmVuKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgfHwgeWIpIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHhiICsgcHhDb21tYSArIHliICsgcHhQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgLSBiID4gMTgwKSBiICs9IDM2MDsgZWxzZSBpZiAoYiAtIGEgPiAxODApIGEgKz0gMzYwOyAvLyBzaG9ydGVzdCBwYXRoXG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNrZXdYKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgIT09IDEgfHwgeWIgIT09IDEpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiICsgeGIgKyBcIixcIiArIHliICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcbiAgICBhID0gcGFyc2UoYSksIGIgPSBwYXJzZShiKTtcbiAgICB0cmFuc2xhdGUoYS50cmFuc2xhdGVYLCBhLnRyYW5zbGF0ZVksIGIudHJhbnNsYXRlWCwgYi50cmFuc2xhdGVZLCBzLCBxKTtcbiAgICByb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBza2V3WChhLnNrZXdYLCBiLnNrZXdYLCBzLCBxKTtcbiAgICBzY2FsZShhLnNjYWxlWCwgYS5zY2FsZVksIGIuc2NhbGVYLCBiLnNjYWxlWSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsOyAvLyBnY1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9O1xufVxuXG52YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZUNzcywgXCJweCwgXCIsIFwicHgpXCIsIFwiZGVnKVwiKTtcbnZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlU3ZnLCBcIiwgXCIsIFwiKVwiLCBcIilcIik7XG5cbnZhciByaG8gPSBNYXRoLlNRUlQyLFxuICAgIHJobzIgPSAyLFxuICAgIHJobzQgPSA0LFxuICAgIGVwc2lsb24yID0gMWUtMTI7XG5cbmZ1bmN0aW9uIGNvc2goeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpICsgMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgLSAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiB0YW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKDIgKiB4KSkgLSAxKSAvICh4ICsgMSk7XG59XG5cbi8vIHAwID0gW3V4MCwgdXkwLCB3MF1cbi8vIHAxID0gW3V4MSwgdXkxLCB3MV1cbmZ1bmN0aW9uIHpvb20ocDAsIHAxKSB7XG4gIHZhciB1eDAgPSBwMFswXSwgdXkwID0gcDBbMV0sIHcwID0gcDBbMl0sXG4gICAgICB1eDEgPSBwMVswXSwgdXkxID0gcDFbMV0sIHcxID0gcDFbMl0sXG4gICAgICBkeCA9IHV4MSAtIHV4MCxcbiAgICAgIGR5ID0gdXkxIC0gdXkwLFxuICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgIGksXG4gICAgICBTO1xuXG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgdTAg4omFIHUxLlxuICBpZiAoZDIgPCBlcHNpbG9uMikge1xuICAgIFMgPSBNYXRoLmxvZyh3MSAvIHcwKSAvIHJobztcbiAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdXgwICsgdCAqIGR4LFxuICAgICAgICB1eTAgKyB0ICogZHksXG4gICAgICAgIHcwICogTWF0aC5leHAocmhvICogdCAqIFMpXG4gICAgICBdO1xuICAgIH07XG4gIH1cblxuICAvLyBHZW5lcmFsIGNhc2UuXG4gIGVsc2Uge1xuICAgIHZhciBkMSA9IE1hdGguc3FydChkMiksXG4gICAgICAgIGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgcmhvNCAqIGQyKSAvICgyICogdzAgKiByaG8yICogZDEpLFxuICAgICAgICBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzQgKiBkMikgLyAoMiAqIHcxICogcmhvMiAqIGQxKSxcbiAgICAgICAgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApLFxuICAgICAgICByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gICAgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIHMgPSB0ICogUyxcbiAgICAgICAgICBjb3NocjAgPSBjb3NoKHIwKSxcbiAgICAgICAgICB1ID0gdzAgLyAocmhvMiAqIGQxKSAqIChjb3NocjAgKiB0YW5oKHJobyAqIHMgKyByMCkgLSBzaW5oKHIwKSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB1eDAgKyB1ICogZHgsXG4gICAgICAgIHV5MCArIHUgKiBkeSxcbiAgICAgICAgdzAgKiBjb3NocjAgLyBjb3NoKHJobyAqIHMgKyByMClcbiAgICAgIF07XG4gICAgfTtcbiAgfVxuXG4gIGkuZHVyYXRpb24gPSBTICogMTAwMDtcblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gaHNsKGh1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlKChzdGFydCA9IGQzQ29sb3IuaHNsKHN0YXJ0KSkuaCwgKGVuZCA9IGQzQ29sb3IuaHNsKGVuZCkpLmgpLFxuICAgICAgICBzID0gbm9nYW1tYShzdGFydC5zLCBlbmQucyksXG4gICAgICAgIGwgPSBub2dhbW1hKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgIHN0YXJ0LnMgPSBzKHQpO1xuICAgICAgc3RhcnQubCA9IGwodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgaHNsJDEgPSBoc2woaHVlKTtcbnZhciBoc2xMb25nID0gaHNsKG5vZ2FtbWEpO1xuXG5mdW5jdGlvbiBsYWIoc3RhcnQsIGVuZCkge1xuICB2YXIgbCA9IG5vZ2FtbWEoKHN0YXJ0ID0gZDNDb2xvci5sYWIoc3RhcnQpKS5sLCAoZW5kID0gZDNDb2xvci5sYWIoZW5kKSkubCksXG4gICAgICBhID0gbm9nYW1tYShzdGFydC5hLCBlbmQuYSksXG4gICAgICBiID0gbm9nYW1tYShzdGFydC5iLCBlbmQuYiksXG4gICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgc3RhcnQubCA9IGwodCk7XG4gICAgc3RhcnQuYSA9IGEodCk7XG4gICAgc3RhcnQuYiA9IGIodCk7XG4gICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGNsKGh1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlKChzdGFydCA9IGQzQ29sb3IuaGNsKHN0YXJ0KSkuaCwgKGVuZCA9IGQzQ29sb3IuaGNsKGVuZCkpLmgpLFxuICAgICAgICBjID0gbm9nYW1tYShzdGFydC5jLCBlbmQuYyksXG4gICAgICAgIGwgPSBub2dhbW1hKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgIHN0YXJ0LmMgPSBjKHQpO1xuICAgICAgc3RhcnQubCA9IGwodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgaGNsJDEgPSBoY2woaHVlKTtcbnZhciBoY2xMb25nID0gaGNsKG5vZ2FtbWEpO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXgoaHVlKSB7XG4gIHJldHVybiAoZnVuY3Rpb24gY3ViZWhlbGl4R2FtbWEoeSkge1xuICAgIHkgPSAreTtcblxuICAgIGZ1bmN0aW9uIGN1YmVoZWxpeChzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBkM0NvbG9yLmN1YmVoZWxpeChzdGFydCkpLmgsIChlbmQgPSBkM0NvbG9yLmN1YmVoZWxpeChlbmQpKS5oKSxcbiAgICAgICAgICBzID0gbm9nYW1tYShzdGFydC5zLCBlbmQucyksXG4gICAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgICAgc3RhcnQubCA9IGwoTWF0aC5wb3codCwgeSkpO1xuICAgICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY3ViZWhlbGl4LmdhbW1hID0gY3ViZWhlbGl4R2FtbWE7XG5cbiAgICByZXR1cm4gY3ViZWhlbGl4O1xuICB9KSgxKTtcbn1cblxudmFyIGN1YmVoZWxpeCQxID0gY3ViZWhlbGl4KGh1ZSk7XG52YXIgY3ViZWhlbGl4TG9uZyA9IGN1YmVoZWxpeChub2dhbW1hKTtcblxuZnVuY3Rpb24gcGllY2V3aXNlKGludGVycG9sYXRlLCB2YWx1ZXMpIHtcbiAgdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aCAtIDEsIHYgPSB2YWx1ZXNbMF0sIEkgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gIHdoaWxlIChpIDwgbikgSVtpXSA9IGludGVycG9sYXRlKHYsIHYgPSB2YWx1ZXNbKytpXSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICo9IG4pKSk7XG4gICAgcmV0dXJuIElbaV0odCAtIGkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBxdWFudGl6ZShpbnRlcnBvbGF0b3IsIG4pIHtcbiAgdmFyIHNhbXBsZXMgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBzYW1wbGVzW2ldID0gaW50ZXJwb2xhdG9yKGkgLyAobiAtIDEpKTtcbiAgcmV0dXJuIHNhbXBsZXM7XG59XG5cbmV4cG9ydHMuaW50ZXJwb2xhdGUgPSB2YWx1ZTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVBcnJheSA9IGFycmF5O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUJhc2lzID0gYmFzaXMkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVCYXNpc0Nsb3NlZCA9IGJhc2lzQ2xvc2VkO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeCA9IGN1YmVoZWxpeCQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcgPSBjdWJlaGVsaXhMb25nO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZURhdGUgPSBkYXRlO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZURpc2NyZXRlID0gZGlzY3JldGU7XG5leHBvcnRzLmludGVycG9sYXRlSGNsID0gaGNsJDE7XG5leHBvcnRzLmludGVycG9sYXRlSGNsTG9uZyA9IGhjbExvbmc7XG5leHBvcnRzLmludGVycG9sYXRlSHNsID0gaHNsJDE7XG5leHBvcnRzLmludGVycG9sYXRlSHNsTG9uZyA9IGhzbExvbmc7XG5leHBvcnRzLmludGVycG9sYXRlSHVlID0gaHVlJDE7XG5leHBvcnRzLmludGVycG9sYXRlTGFiID0gbGFiO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZU51bWJlciA9IG51bWJlcjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVOdW1iZXJBcnJheSA9IG51bWJlckFycmF5O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZU9iamVjdCA9IG9iamVjdDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZ2IgPSByZ2I7XG5leHBvcnRzLmludGVycG9sYXRlUmdiQmFzaXMgPSByZ2JCYXNpcztcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZ2JCYXNpc0Nsb3NlZCA9IHJnYkJhc2lzQ2xvc2VkO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJvdW5kID0gcm91bmQ7XG5leHBvcnRzLmludGVycG9sYXRlU3RyaW5nID0gc3RyaW5nO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA9IGludGVycG9sYXRlVHJhbnNmb3JtQ3NzO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA9IGludGVycG9sYXRlVHJhbnNmb3JtU3ZnO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVpvb20gPSB6b29tO1xuZXhwb3J0cy5waWVjZXdpc2UgPSBwaWVjZXdpc2U7XG5leHBvcnRzLnF1YW50aXplID0gcXVhbnRpemU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtc2NhbGUvIHYzLjIuMSBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWFycmF5JyksIHJlcXVpcmUoJ2QzLWludGVycG9sYXRlJyksIHJlcXVpcmUoJ2QzLWZvcm1hdCcpLCByZXF1aXJlKCdkMy10aW1lJyksIHJlcXVpcmUoJ2QzLXRpbWUtZm9ybWF0JykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtYXJyYXknLCAnZDMtaW50ZXJwb2xhdGUnLCAnZDMtZm9ybWF0JywgJ2QzLXRpbWUnLCAnZDMtdGltZS1mb3JtYXQnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSwgZ2xvYmFsLmQzLCBnbG9iYWwuZDMsIGdsb2JhbC5kMywgZ2xvYmFsLmQzLCBnbG9iYWwuZDMpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGQzQXJyYXksIGQzSW50ZXJwb2xhdGUsIGQzRm9ybWF0LCBkM1RpbWUsIGQzVGltZUZvcm1hdCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGluaXRSYW5nZShkb21haW4sIHJhbmdlKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB0aGlzLnJhbmdlKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMucmFuZ2UocmFuZ2UpLmRvbWFpbihkb21haW4pOyBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gaW5pdEludGVycG9sYXRvcihkb21haW4sIGludGVycG9sYXRvcikge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IGJyZWFrO1xuICAgIGNhc2UgMToge1xuICAgICAgaWYgKHR5cGVvZiBkb21haW4gPT09IFwiZnVuY3Rpb25cIikgdGhpcy5pbnRlcnBvbGF0b3IoZG9tYWluKTtcbiAgICAgIGVsc2UgdGhpcy5yYW5nZShkb21haW4pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRoaXMuZG9tYWluKGRvbWFpbik7XG4gICAgICBpZiAodHlwZW9mIGludGVycG9sYXRvciA9PT0gXCJmdW5jdGlvblwiKSB0aGlzLmludGVycG9sYXRvcihpbnRlcnBvbGF0b3IpO1xuICAgICAgZWxzZSB0aGlzLnJhbmdlKGludGVycG9sYXRvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmNvbnN0IGltcGxpY2l0ID0gU3ltYm9sKFwiaW1wbGljaXRcIik7XG5cbmZ1bmN0aW9uIG9yZGluYWwoKSB7XG4gIHZhciBpbmRleCA9IG5ldyBNYXAoKSxcbiAgICAgIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHVua25vd24gPSBpbXBsaWNpdDtcblxuICBmdW5jdGlvbiBzY2FsZShkKSB7XG4gICAgdmFyIGtleSA9IGQgKyBcIlwiLCBpID0gaW5kZXguZ2V0KGtleSk7XG4gICAgaWYgKCFpKSB7XG4gICAgICBpZiAodW5rbm93biAhPT0gaW1wbGljaXQpIHJldHVybiB1bmtub3duO1xuICAgICAgaW5kZXguc2V0KGtleSwgaSA9IGRvbWFpbi5wdXNoKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlWyhpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdLCBpbmRleCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIF8pIHtcbiAgICAgIGNvbnN0IGtleSA9IHZhbHVlICsgXCJcIjtcbiAgICAgIGlmIChpbmRleC5oYXMoa2V5KSkgY29udGludWU7XG4gICAgICBpbmRleC5zZXQoa2V5LCBkb21haW4ucHVzaCh2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBBcnJheS5mcm9tKF8pLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvcmRpbmFsKGRvbWFpbiwgcmFuZ2UpLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gYmFuZCgpIHtcbiAgdmFyIHNjYWxlID0gb3JkaW5hbCgpLnVua25vd24odW5kZWZpbmVkKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIG9yZGluYWxSYW5nZSA9IHNjYWxlLnJhbmdlLFxuICAgICAgcjAgPSAwLFxuICAgICAgcjEgPSAxLFxuICAgICAgc3RlcCxcbiAgICAgIGJhbmR3aWR0aCxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBwYWRkaW5nSW5uZXIgPSAwLFxuICAgICAgcGFkZGluZ091dGVyID0gMCxcbiAgICAgIGFsaWduID0gMC41O1xuXG4gIGRlbGV0ZSBzY2FsZS51bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBkb21haW4oKS5sZW5ndGgsXG4gICAgICAgIHJldmVyc2UgPSByMSA8IHIwLFxuICAgICAgICBzdGFydCA9IHJldmVyc2UgPyByMSA6IHIwLFxuICAgICAgICBzdG9wID0gcmV2ZXJzZSA/IHIwIDogcjE7XG4gICAgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMSwgbiAtIHBhZGRpbmdJbm5lciArIHBhZGRpbmdPdXRlciAqIDIpO1xuICAgIGlmIChyb3VuZCkgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgc3RhcnQgKz0gKHN0b3AgLSBzdGFydCAtIHN0ZXAgKiAobiAtIHBhZGRpbmdJbm5lcikpICogYWxpZ247XG4gICAgYmFuZHdpZHRoID0gc3RlcCAqICgxIC0gcGFkZGluZ0lubmVyKTtcbiAgICBpZiAocm91bmQpIHN0YXJ0ID0gTWF0aC5yb3VuZChzdGFydCksIGJhbmR3aWR0aCA9IE1hdGgucm91bmQoYmFuZHdpZHRoKTtcbiAgICB2YXIgdmFsdWVzID0gZDNBcnJheS5yYW5nZShuKS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gc3RhcnQgKyBzdGVwICogaTsgfSk7XG4gICAgcmV0dXJuIG9yZGluYWxSYW5nZShyZXZlcnNlID8gdmFsdWVzLnJldmVyc2UoKSA6IHZhbHVlcyk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3IwLCByMV0gPSBfLCByMCA9ICtyMCwgcjEgPSArcjEsIHJlc2NhbGUoKSkgOiBbcjAsIHIxXTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBbcjAsIHIxXSA9IF8sIHIwID0gK3IwLCByMSA9ICtyMSwgcm91bmQgPSB0cnVlLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuYmFuZHdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmR3aWR0aDtcbiAgfTtcblxuICBzY2FsZS5zdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH07XG5cbiAgc2NhbGUucm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIV8sIHJlc2NhbGUoKSkgOiByb3VuZDtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IE1hdGgubWluKDEsIHBhZGRpbmdPdXRlciA9ICtfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgXyksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ091dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdPdXRlciA9ICtfLCByZXNjYWxlKCkpIDogcGFkZGluZ091dGVyO1xuICB9O1xuXG4gIHNjYWxlLmFsaWduID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFsaWduID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogYWxpZ247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiYW5kKGRvbWFpbigpLCBbcjAsIHIxXSlcbiAgICAgICAgLnJvdW5kKHJvdW5kKVxuICAgICAgICAucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcilcbiAgICAgICAgLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpXG4gICAgICAgIC5hbGlnbihhbGlnbik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShyZXNjYWxlKCksIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBvaW50aXNoKHNjYWxlKSB7XG4gIHZhciBjb3B5ID0gc2NhbGUuY29weTtcblxuICBzY2FsZS5wYWRkaW5nID0gc2NhbGUucGFkZGluZ091dGVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ0lubmVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ091dGVyO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcG9pbnRpc2goY29weSgpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHBvaW50KCkge1xuICByZXR1cm4gcG9pbnRpc2goYmFuZC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhZGRpbmdJbm5lcigxKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBudW1iZXIoeCkge1xuICByZXR1cm4gK3g7XG59XG5cbnZhciB1bml0ID0gWzAsIDFdO1xuXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUoYSwgYikge1xuICByZXR1cm4gKGIgLT0gKGEgPSArYSkpXG4gICAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICh4IC0gYSkgLyBiOyB9XG4gICAgICA6IGNvbnN0YW50KGlzTmFOKGIpID8gTmFOIDogMC41KTtcbn1cblxuZnVuY3Rpb24gY2xhbXBlcihhLCBiKSB7XG4gIHZhciB0O1xuICBpZiAoYSA+IGIpIHQgPSBhLCBhID0gYiwgYiA9IHQ7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLm1heChhLCBNYXRoLm1pbihiLCB4KSk7IH07XG59XG5cbi8vIG5vcm1hbGl6ZShhLCBiKSh4KSB0YWtlcyBhIGRvbWFpbiB2YWx1ZSB4IGluIFthLGJdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBhcmFtZXRlciB0IGluIFswLDFdLlxuLy8gaW50ZXJwb2xhdGUoYSwgYikodCkgdGFrZXMgYSBwYXJhbWV0ZXIgdCBpbiBbMCwxXSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByYW5nZSB2YWx1ZSB4IGluIFthLGJdLlxuZnVuY3Rpb24gYmltYXAoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGQwID0gZG9tYWluWzBdLCBkMSA9IGRvbWFpblsxXSwgcjAgPSByYW5nZVswXSwgcjEgPSByYW5nZVsxXTtcbiAgaWYgKGQxIDwgZDApIGQwID0gbm9ybWFsaXplKGQxLCBkMCksIHIwID0gaW50ZXJwb2xhdGUocjEsIHIwKTtcbiAgZWxzZSBkMCA9IG5vcm1hbGl6ZShkMCwgZDEpLCByMCA9IGludGVycG9sYXRlKHIwLCByMSk7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiByMChkMCh4KSk7IH07XG59XG5cbmZ1bmN0aW9uIHBvbHltYXAoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGogPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpIC0gMSxcbiAgICAgIGQgPSBuZXcgQXJyYXkoaiksXG4gICAgICByID0gbmV3IEFycmF5KGopLFxuICAgICAgaSA9IC0xO1xuXG4gIC8vIFJldmVyc2UgZGVzY2VuZGluZyBkb21haW5zLlxuICBpZiAoZG9tYWluW2pdIDwgZG9tYWluWzBdKSB7XG4gICAgZG9tYWluID0gZG9tYWluLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIHJhbmdlID0gcmFuZ2Uuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIH1cblxuICB3aGlsZSAoKytpIDwgaikge1xuICAgIGRbaV0gPSBub3JtYWxpemUoZG9tYWluW2ldLCBkb21haW5baSArIDFdKTtcbiAgICByW2ldID0gaW50ZXJwb2xhdGUocmFuZ2VbaV0sIHJhbmdlW2kgKyAxXSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHZhciBpID0gZDNBcnJheS5iaXNlY3QoZG9tYWluLCB4LCAxLCBqKSAtIDE7XG4gICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvcHkoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFxuICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXG4gICAgICAucmFuZ2Uoc291cmNlLnJhbmdlKCkpXG4gICAgICAuaW50ZXJwb2xhdGUoc291cmNlLmludGVycG9sYXRlKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpXG4gICAgICAudW5rbm93bihzb3VyY2UudW5rbm93bigpKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIoKSB7XG4gIHZhciBkb21haW4gPSB1bml0LFxuICAgICAgcmFuZ2UgPSB1bml0LFxuICAgICAgaW50ZXJwb2xhdGUgPSBkM0ludGVycG9sYXRlLmludGVycG9sYXRlLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdW50cmFuc2Zvcm0sXG4gICAgICB1bmtub3duLFxuICAgICAgY2xhbXAgPSBpZGVudGl0eSxcbiAgICAgIHBpZWNld2lzZSxcbiAgICAgIG91dHB1dCxcbiAgICAgIGlucHV0O1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpO1xuICAgIGlmIChjbGFtcCAhPT0gaWRlbnRpdHkpIGNsYW1wID0gY2xhbXBlcihkb21haW5bMF0sIGRvbWFpbltuIC0gMV0pO1xuICAgIHBpZWNld2lzZSA9IG4gPiAyID8gcG9seW1hcCA6IGJpbWFwO1xuICAgIG91dHB1dCA9IGlucHV0ID0gbnVsbDtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogKG91dHB1dCB8fCAob3V0cHV0ID0gcGllY2V3aXNlKGRvbWFpbi5tYXAodHJhbnNmb3JtKSwgcmFuZ2UsIGludGVycG9sYXRlKSkpKHRyYW5zZm9ybShjbGFtcCh4KSkpO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBjbGFtcCh1bnRyYW5zZm9ybSgoaW5wdXQgfHwgKGlucHV0ID0gcGllY2V3aXNlKHJhbmdlLCBkb21haW4ubWFwKHRyYW5zZm9ybSksIGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVOdW1iZXIpKSkoeSkpKTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gQXJyYXkuZnJvbShfLCBudW1iZXIpLCByZXNjYWxlKCkpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBBcnJheS5mcm9tKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiByYW5nZSA9IEFycmF5LmZyb20oXyksIGludGVycG9sYXRlID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVJvdW5kLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSBfID8gdHJ1ZSA6IGlkZW50aXR5LCByZXNjYWxlKCkpIDogY2xhbXAgIT09IGlkZW50aXR5O1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgcmVzY2FsZSgpKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQsIHUpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB1bnRyYW5zZm9ybSA9IHU7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGludW91cygpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKCkoaWRlbnRpdHksIGlkZW50aXR5KTtcbn1cblxuZnVuY3Rpb24gdGlja0Zvcm1hdChzdGFydCwgc3RvcCwgY291bnQsIHNwZWNpZmllcikge1xuICB2YXIgc3RlcCA9IGQzQXJyYXkudGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSxcbiAgICAgIHByZWNpc2lvbjtcbiAgc3BlY2lmaWVyID0gZDNGb3JtYXQuZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciA9PSBudWxsID8gXCIsZlwiIDogc3BlY2lmaWVyKTtcbiAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgIGNhc2UgXCJzXCI6IHtcbiAgICAgIHZhciB2YWx1ZSA9IE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpO1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gZDNGb3JtYXQucHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICByZXR1cm4gZDNGb3JtYXQuZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgIH1cbiAgICBjYXNlIFwiXCI6XG4gICAgY2FzZSBcImVcIjpcbiAgICBjYXNlIFwiZ1wiOlxuICAgIGNhc2UgXCJwXCI6XG4gICAgY2FzZSBcInJcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gZDNGb3JtYXQucHJlY2lzaW9uUm91bmQoc3RlcCwgTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSkpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCJlXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmXCI6XG4gICAgY2FzZSBcIiVcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gZDNGb3JtYXQucHJlY2lzaW9uRml4ZWQoc3RlcCkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcIiVcIikgKiAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBkM0Zvcm1hdC5mb3JtYXQoc3BlY2lmaWVyKTtcbn1cblxuZnVuY3Rpb24gbGluZWFyaXNoKHNjYWxlKSB7XG4gIHZhciBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIGQzQXJyYXkudGlja3MoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCk7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiB0aWNrRm9ybWF0KGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQsIHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG5cbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICBpMCA9IDAsXG4gICAgICAgIGkxID0gZC5sZW5ndGggLSAxLFxuICAgICAgICBzdGFydCA9IGRbaTBdLFxuICAgICAgICBzdG9wID0gZFtpMV0sXG4gICAgICAgIHN0ZXA7XG5cbiAgICBpZiAoc3RvcCA8IHN0YXJ0KSB7XG4gICAgICBzdGVwID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IHN0ZXA7XG4gICAgICBzdGVwID0gaTAsIGkwID0gaTEsIGkxID0gc3RlcDtcbiAgICB9XG5cbiAgICBzdGVwID0gZDNBcnJheS50aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG5cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICB9IGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICBzdGFydCA9IE1hdGguY2VpbChzdGFydCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBzdGVwID0gZDNBcnJheS50aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICBkW2kwXSA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBkW2kxXSA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgZG9tYWluKGQpO1xuICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIGRbaTBdID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xuICAgICAgZFtpMV0gPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBkb21haW4oZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gbGluZWFyKCkge1xuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKCk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsaW5lYXIoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eSQxKGRvbWFpbikge1xuICB2YXIgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogeDtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IHNjYWxlO1xuXG4gIHNjYWxlLmRvbWFpbiA9IHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IEFycmF5LmZyb20oXywgbnVtYmVyKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5JDEoZG9tYWluKS51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIGRvbWFpbiA9IGFyZ3VtZW50cy5sZW5ndGggPyBBcnJheS5mcm9tKGRvbWFpbiwgbnVtYmVyKSA6IFswLCAxXTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZnVuY3Rpb24gbmljZShkb21haW4sIGludGVydmFsKSB7XG4gIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpO1xuXG4gIHZhciBpMCA9IDAsXG4gICAgICBpMSA9IGRvbWFpbi5sZW5ndGggLSAxLFxuICAgICAgeDAgPSBkb21haW5baTBdLFxuICAgICAgeDEgPSBkb21haW5baTFdLFxuICAgICAgdDtcblxuICBpZiAoeDEgPCB4MCkge1xuICAgIHQgPSBpMCwgaTAgPSBpMSwgaTEgPSB0O1xuICAgIHQgPSB4MCwgeDAgPSB4MSwgeDEgPSB0O1xuICB9XG5cbiAgZG9tYWluW2kwXSA9IGludGVydmFsLmZsb29yKHgwKTtcbiAgZG9tYWluW2kxXSA9IGludGVydmFsLmNlaWwoeDEpO1xuICByZXR1cm4gZG9tYWluO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Mb2coeCkge1xuICByZXR1cm4gTWF0aC5sb2coeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUV4cCh4KSB7XG4gIHJldHVybiBNYXRoLmV4cCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTG9nbih4KSB7XG4gIHJldHVybiAtTWF0aC5sb2coLXgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FeHBuKHgpIHtcbiAgcmV0dXJuIC1NYXRoLmV4cCgteCk7XG59XG5cbmZ1bmN0aW9uIHBvdzEwKHgpIHtcbiAgcmV0dXJuIGlzRmluaXRlKHgpID8gKyhcIjFlXCIgKyB4KSA6IHggPCAwID8gMCA6IHg7XG59XG5cbmZ1bmN0aW9uIHBvd3AoYmFzZSkge1xuICByZXR1cm4gYmFzZSA9PT0gMTAgPyBwb3cxMFxuICAgICAgOiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmV4cFxuICAgICAgOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnBvdyhiYXNlLCB4KTsgfTtcbn1cblxuZnVuY3Rpb24gbG9ncChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmxvZ1xuICAgICAgOiBiYXNlID09PSAxMCAmJiBNYXRoLmxvZzEwXG4gICAgICB8fCBiYXNlID09PSAyICYmIE1hdGgubG9nMlxuICAgICAgfHwgKGJhc2UgPSBNYXRoLmxvZyhiYXNlKSwgZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCkgLyBiYXNlOyB9KTtcbn1cblxuZnVuY3Rpb24gcmVmbGVjdChmKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIC1mKC14KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbG9nZ2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIHNjYWxlID0gdHJhbnNmb3JtKHRyYW5zZm9ybUxvZywgdHJhbnNmb3JtRXhwKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIGJhc2UgPSAxMCxcbiAgICAgIGxvZ3MsXG4gICAgICBwb3dzO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgbG9ncyA9IGxvZ3AoYmFzZSksIHBvd3MgPSBwb3dwKGJhc2UpO1xuICAgIGlmIChkb21haW4oKVswXSA8IDApIHtcbiAgICAgIGxvZ3MgPSByZWZsZWN0KGxvZ3MpLCBwb3dzID0gcmVmbGVjdChwb3dzKTtcbiAgICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2duLCB0cmFuc2Zvcm1FeHBuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtKHRyYW5zZm9ybUxvZywgdHJhbnNmb3JtRXhwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChiYXNlID0gK18sIHJlc2NhbGUoKSkgOiBiYXNlO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgdSA9IGRbMF0sXG4gICAgICAgIHYgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHI7XG5cbiAgICBpZiAociA9IHYgPCB1KSBpID0gdSwgdSA9IHYsIHYgPSBpO1xuXG4gICAgdmFyIGkgPSBsb2dzKHUpLFxuICAgICAgICBqID0gbG9ncyh2KSxcbiAgICAgICAgcCxcbiAgICAgICAgayxcbiAgICAgICAgdCxcbiAgICAgICAgbiA9IGNvdW50ID09IG51bGwgPyAxMCA6ICtjb3VudCxcbiAgICAgICAgeiA9IFtdO1xuXG4gICAgaWYgKCEoYmFzZSAlIDEpICYmIGogLSBpIDwgbikge1xuICAgICAgaSA9IE1hdGguZmxvb3IoaSksIGogPSBNYXRoLmNlaWwoaik7XG4gICAgICBpZiAodSA+IDApIGZvciAoOyBpIDw9IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSAxLCBwID0gcG93cyhpKTsgayA8IGJhc2U7ICsraykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgZm9yICg7IGkgPD0gajsgKytpKSB7XG4gICAgICAgIGZvciAoayA9IGJhc2UgLSAxLCBwID0gcG93cyhpKTsgayA+PSAxOyAtLWspIHtcbiAgICAgICAgICB0ID0gcCAqIGs7XG4gICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xuICAgICAgICAgIHoucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHoubGVuZ3RoICogMiA8IG4pIHogPSBkM0FycmF5LnRpY2tzKHUsIHYsIG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB6ID0gZDNBcnJheS50aWNrcyhpLCBqLCBNYXRoLm1pbihqIC0gaSwgbikpLm1hcChwb3dzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gciA/IHoucmV2ZXJzZSgpIDogejtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIGlmIChzcGVjaWZpZXIgPT0gbnVsbCkgc3BlY2lmaWVyID0gYmFzZSA9PT0gMTAgPyBcIi4wZVwiIDogXCIsXCI7XG4gICAgaWYgKHR5cGVvZiBzcGVjaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgc3BlY2lmaWVyID0gZDNGb3JtYXQuZm9ybWF0KHNwZWNpZmllcik7XG4gICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkgcmV0dXJuIHNwZWNpZmllcjtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcbiAgICB2YXIgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBjb3VudCAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTsgLy8gVE9ETyBmYXN0IGVzdGltYXRlP1xuICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgaSA9IGQgLyBwb3dzKE1hdGgucm91bmQobG9ncyhkKSkpO1xuICAgICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIDAuNSkgaSAqPSBiYXNlO1xuICAgICAgcmV0dXJuIGkgPD0gayA/IHNwZWNpZmllcihkKSA6IFwiXCI7XG4gICAgfTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbihuaWNlKGRvbWFpbigpLCB7XG4gICAgICBmbG9vcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmZsb29yKGxvZ3MoeCkpKTsgfSxcbiAgICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5jZWlsKGxvZ3MoeCkpKTsgfVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWxvZyhjKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGgubG9nMXAoTWF0aC5hYnMoeCAvIGMpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3ltZXhwKGMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHgpICogTWF0aC5leHBtMShNYXRoLmFicyh4KSkgKiBjO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzeW1sb2dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBjID0gMSwgc2NhbGUgPSB0cmFuc2Zvcm0odHJhbnNmb3JtU3ltbG9nKGMpLCB0cmFuc2Zvcm1TeW1leHAoYykpO1xuXG4gIHNjYWxlLmNvbnN0YW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdHJhbnNmb3JtKHRyYW5zZm9ybVN5bWxvZyhjID0gK18pLCB0cmFuc2Zvcm1TeW1leHAoYykpIDogYztcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZnVuY3Rpb24gc3ltbG9nKCkge1xuICB2YXIgc2NhbGUgPSBzeW1sb2dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzeW1sb2coKSkuY29uc3RhbnQoc2NhbGUuY29uc3RhbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtUG93KGV4cG9uZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggPCAwID8gLU1hdGgucG93KC14LCBleHBvbmVudCkgOiBNYXRoLnBvdyh4LCBleHBvbmVudCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxcnQoeCkge1xuICByZXR1cm4geCA8IDAgPyAtTWF0aC5zcXJ0KC14KSA6IE1hdGguc3FydCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3F1YXJlKHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLXggKiB4IDogeCAqIHg7XG59XG5cbmZ1bmN0aW9uIHBvd2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIHNjYWxlID0gdHJhbnNmb3JtKGlkZW50aXR5LCBpZGVudGl0eSksXG4gICAgICBleHBvbmVudCA9IDE7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICByZXR1cm4gZXhwb25lbnQgPT09IDEgPyB0cmFuc2Zvcm0oaWRlbnRpdHksIGlkZW50aXR5KVxuICAgICAgICA6IGV4cG9uZW50ID09PSAwLjUgPyB0cmFuc2Zvcm0odHJhbnNmb3JtU3FydCwgdHJhbnNmb3JtU3F1YXJlKVxuICAgICAgICA6IHRyYW5zZm9ybSh0cmFuc2Zvcm1Qb3coZXhwb25lbnQpLCB0cmFuc2Zvcm1Qb3coMSAvIGV4cG9uZW50KSk7XG4gIH1cblxuICBzY2FsZS5leHBvbmVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHBvbmVudCA9ICtfLCByZXNjYWxlKCkpIDogZXhwb25lbnQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIHBvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgcG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHNxcnQoKSB7XG4gIHJldHVybiBwb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuXG5mdW5jdGlvbiBzcXVhcmUoeCkge1xuICByZXR1cm4gTWF0aC5zaWduKHgpICogeCAqIHg7XG59XG5cbmZ1bmN0aW9uIHVuc3F1YXJlKHgpIHtcbiAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGguc3FydChNYXRoLmFicyh4KSk7XG59XG5cbmZ1bmN0aW9uIHJhZGlhbCgpIHtcbiAgdmFyIHNxdWFyZWQgPSBjb250aW51b3VzKCksXG4gICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICB2YXIgeSA9IHVuc3F1YXJlKHNxdWFyZWQoeCkpO1xuICAgIHJldHVybiBpc05hTih5KSA/IHVua25vd24gOiByb3VuZCA/IE1hdGgucm91bmQoeSkgOiB5O1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBzcXVhcmVkLmludmVydChzcXVhcmUoeSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzcXVhcmVkLmRvbWFpbihfKSwgc2NhbGUpIDogc3F1YXJlZC5kb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzcXVhcmVkLnJhbmdlKChyYW5nZSA9IEFycmF5LmZyb20oXywgbnVtYmVyKSkubWFwKHNxdWFyZSkpLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlUm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIHNjYWxlLnJhbmdlKF8pLnJvdW5kKHRydWUpO1xuICB9O1xuXG4gIHNjYWxlLnJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISFfLCBzY2FsZSkgOiByb3VuZDtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzcXVhcmVkLmNsYW1wKF8pLCBzY2FsZSkgOiBzcXVhcmVkLmNsYW1wKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHJhZGlhbChzcXVhcmVkLmRvbWFpbigpLCByYW5nZSlcbiAgICAgICAgLnJvdW5kKHJvdW5kKVxuICAgICAgICAuY2xhbXAoc3F1YXJlZC5jbGFtcCgpKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlKCkge1xuICB2YXIgZG9tYWluID0gW10sXG4gICAgICByYW5nZSA9IFtdLFxuICAgICAgdGhyZXNob2xkcyA9IFtdLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gMCwgbiA9IE1hdGgubWF4KDEsIHJhbmdlLmxlbmd0aCk7XG4gICAgdGhyZXNob2xkcyA9IG5ldyBBcnJheShuIC0gMSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRocmVzaG9sZHNbaSAtIDFdID0gZDNBcnJheS5xdWFudGlsZShkb21haW4sIGkgLyBuKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogcmFuZ2VbZDNBcnJheS5iaXNlY3QodGhyZXNob2xkcywgeCldO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gaSA8IDAgPyBbTmFOLCBOYU5dIDogW1xuICAgICAgaSA+IDAgPyB0aHJlc2hvbGRzW2kgLSAxXSA6IGRvbWFpblswXSxcbiAgICAgIGkgPCB0aHJlc2hvbGRzLmxlbmd0aCA/IHRocmVzaG9sZHNbaV0gOiBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdXG4gICAgXTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW107XG4gICAgZm9yIChsZXQgZCBvZiBfKSBpZiAoZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChkM0FycmF5LmFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IEFycmF5LmZyb20oXyksIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUucXVhbnRpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZHMuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHF1YW50aWxlKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcXVhbnRpemUoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICBuID0gMSxcbiAgICAgIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA8PSB4ID8gcmFuZ2VbZDNBcnJheS5iaXNlY3QoZG9tYWluLCB4LCAwLCBuKV0gOiB1bmtub3duO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIGRvbWFpbiA9IG5ldyBBcnJheShuKTtcbiAgICB3aGlsZSAoKytpIDwgbikgZG9tYWluW2ldID0gKChpICsgMSkgKiB4MSAtIChpIC0gbikgKiB4MCkgLyAobiArIDEpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbeDAsIHgxXSA9IF8sIHgwID0gK3gwLCB4MSA9ICt4MSwgcmVzY2FsZSgpKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAocmFuZ2UgPSBBcnJheS5mcm9tKF8pKS5sZW5ndGggLSAxLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl1cbiAgICAgICAgOiBpIDwgMSA/IFt4MCwgZG9tYWluWzBdXVxuICAgICAgICA6IGkgPj0gbiA/IFtkb21haW5bbiAtIDFdLCB4MV1cbiAgICAgICAgOiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS50aHJlc2hvbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpemUoKVxuICAgICAgICAuZG9tYWluKFt4MCwgeDFdKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkobGluZWFyaXNoKHNjYWxlKSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gdGhyZXNob2xkKCkge1xuICB2YXIgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgIHVua25vd24sXG4gICAgICBuID0gMTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPD0geCA/IHJhbmdlW2QzQXJyYXkuYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBBcnJheS5mcm9tKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gQXJyYXkuZnJvbShfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGQoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG52YXIgZHVyYXRpb25TZWNvbmQgPSAxMDAwLFxuICAgIGR1cmF0aW9uTWludXRlID0gZHVyYXRpb25TZWNvbmQgKiA2MCxcbiAgICBkdXJhdGlvbkhvdXIgPSBkdXJhdGlvbk1pbnV0ZSAqIDYwLFxuICAgIGR1cmF0aW9uRGF5ID0gZHVyYXRpb25Ib3VyICogMjQsXG4gICAgZHVyYXRpb25XZWVrID0gZHVyYXRpb25EYXkgKiA3LFxuICAgIGR1cmF0aW9uTW9udGggPSBkdXJhdGlvbkRheSAqIDMwLFxuICAgIGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5ICogMzY1O1xuXG5mdW5jdGlvbiBkYXRlKHQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHQpO1xufVxuXG5mdW5jdGlvbiBudW1iZXIkMSh0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZSA/ICt0IDogK25ldyBEYXRlKCt0KTtcbn1cblxuZnVuY3Rpb24gY2FsZW5kYXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBmb3JtYXQpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cygpLFxuICAgICAgaW52ZXJ0ID0gc2NhbGUuaW52ZXJ0LFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHZhciBmb3JtYXRNaWxsaXNlY29uZCA9IGZvcm1hdChcIi4lTFwiKSxcbiAgICAgIGZvcm1hdFNlY29uZCA9IGZvcm1hdChcIjolU1wiKSxcbiAgICAgIGZvcm1hdE1pbnV0ZSA9IGZvcm1hdChcIiVJOiVNXCIpLFxuICAgICAgZm9ybWF0SG91ciA9IGZvcm1hdChcIiVJICVwXCIpLFxuICAgICAgZm9ybWF0RGF5ID0gZm9ybWF0KFwiJWEgJWRcIiksXG4gICAgICBmb3JtYXRXZWVrID0gZm9ybWF0KFwiJWIgJWRcIiksXG4gICAgICBmb3JtYXRNb250aCA9IGZvcm1hdChcIiVCXCIpLFxuICAgICAgZm9ybWF0WWVhciA9IGZvcm1hdChcIiVZXCIpO1xuXG4gIHZhciB0aWNrSW50ZXJ2YWxzID0gW1xuICAgIFtzZWNvbmQsICAxLCAgICAgIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAgNSwgIDUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgMTUsIDE1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDMwLCAzMCAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbbWludXRlLCAgMSwgICAgICBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgIDUsICA1ICogZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsIDE1LCAxNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAzMCwgMzAgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgWyAgaG91ciwgIDEsICAgICAgZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsICAzLCAgMyAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgNiwgIDYgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgMTIsIDEyICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgICBkYXksICAxLCAgICAgIGR1cmF0aW9uRGF5ICAgXSxcbiAgICBbICAgZGF5LCAgMiwgIDIgKiBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgd2VlaywgIDEsICAgICAgZHVyYXRpb25XZWVrICBdLFxuICAgIFsgbW9udGgsICAxLCAgICAgIGR1cmF0aW9uTW9udGggXSxcbiAgICBbIG1vbnRoLCAgMywgIDMgKiBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyAgeWVhciwgIDEsICAgICAgZHVyYXRpb25ZZWFyICBdXG4gIF07XG5cbiAgZnVuY3Rpb24gdGlja0Zvcm1hdChkYXRlKSB7XG4gICAgcmV0dXJuIChzZWNvbmQoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWlsbGlzZWNvbmRcbiAgICAgICAgOiBtaW51dGUoZGF0ZSkgPCBkYXRlID8gZm9ybWF0U2Vjb25kXG4gICAgICAgIDogaG91cihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkYXkoZGF0ZSkgPCBkYXRlID8gZm9ybWF0SG91clxuICAgICAgICA6IG1vbnRoKGRhdGUpIDwgZGF0ZSA/ICh3ZWVrKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdERheSA6IGZvcm1hdFdlZWspXG4gICAgICAgIDogeWVhcihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNb250aFxuICAgICAgICA6IGZvcm1hdFllYXIpKGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGlja0ludGVydmFsKGludGVydmFsLCBzdGFydCwgc3RvcCkge1xuICAgIGlmIChpbnRlcnZhbCA9PSBudWxsKSBpbnRlcnZhbCA9IDEwO1xuXG4gICAgLy8gSWYgYSBkZXNpcmVkIHRpY2sgY291bnQgaXMgc3BlY2lmaWVkLCBwaWNrIGEgcmVhc29uYWJsZSB0aWNrIGludGVydmFsXG4gICAgLy8gYmFzZWQgb24gdGhlIGV4dGVudCBvZiB0aGUgZG9tYWluIGFuZCBhIHJvdWdoIGVzdGltYXRlIG9mIHRpY2sgc2l6ZS5cbiAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpbnRlcnZhbCBpcyBhbHJlYWR5IGEgdGltZSBpbnRlcnZhbCBhbmQgdXNlIGl0LlxuICAgIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gaW50ZXJ2YWwsXG4gICAgICAgICAgaSA9IGQzQXJyYXkuYmlzZWN0b3IoZnVuY3Rpb24oaSkgeyByZXR1cm4gaVsyXTsgfSkucmlnaHQodGlja0ludGVydmFscywgdGFyZ2V0KSxcbiAgICAgICAgICBzdGVwO1xuICAgICAgaWYgKGkgPT09IHRpY2tJbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tTdGVwKHN0YXJ0IC8gZHVyYXRpb25ZZWFyLCBzdG9wIC8gZHVyYXRpb25ZZWFyLCBpbnRlcnZhbCk7XG4gICAgICAgIGludGVydmFsID0geWVhcjtcbiAgICAgIH0gZWxzZSBpZiAoaSkge1xuICAgICAgICBpID0gdGlja0ludGVydmFsc1t0YXJnZXQgLyB0aWNrSW50ZXJ2YWxzW2kgLSAxXVsyXSA8IHRpY2tJbnRlcnZhbHNbaV1bMl0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgICAgICBzdGVwID0gaVsxXTtcbiAgICAgICAgaW50ZXJ2YWwgPSBpWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcCA9IE1hdGgubWF4KGQzQXJyYXkudGlja1N0ZXAoc3RhcnQsIHN0b3AsIGludGVydmFsKSwgMSk7XG4gICAgICAgIGludGVydmFsID0gbWlsbGlzZWNvbmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW50ZXJ2YWwuZXZlcnkoc3RlcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVydmFsO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShpbnZlcnQoeSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGRvbWFpbihBcnJheS5mcm9tKF8sIG51bWJlciQxKSkgOiBkb21haW4oKS5tYXAoZGF0ZSk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHQwID0gZFswXSxcbiAgICAgICAgdDEgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHIgPSB0MSA8IHQwLFxuICAgICAgICB0O1xuICAgIGlmIChyKSB0ID0gdDAsIHQwID0gdDEsIHQxID0gdDtcbiAgICB0ID0gdGlja0ludGVydmFsKGludGVydmFsLCB0MCwgdDEpO1xuICAgIHQgPSB0ID8gdC5yYW5nZSh0MCwgdDEgKyAxKSA6IFtdOyAvLyBpbmNsdXNpdmUgc3RvcFxuICAgIHJldHVybiByID8gdC5yZXZlcnNlKCkgOiB0O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIHNwZWNpZmllciA9PSBudWxsID8gdGlja0Zvcm1hdCA6IGZvcm1hdChzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIChpbnRlcnZhbCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgZFswXSwgZFtkLmxlbmd0aCAtIDFdKSlcbiAgICAgICAgPyBkb21haW4obmljZShkLCBpbnRlcnZhbCkpXG4gICAgICAgIDogc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBjYWxlbmRhcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIGZvcm1hdCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gdGltZSgpIHtcbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShjYWxlbmRhcihkM1RpbWUudGltZVllYXIsIGQzVGltZS50aW1lTW9udGgsIGQzVGltZS50aW1lV2VlaywgZDNUaW1lLnRpbWVEYXksIGQzVGltZS50aW1lSG91ciwgZDNUaW1lLnRpbWVNaW51dGUsIGQzVGltZS50aW1lU2Vjb25kLCBkM1RpbWUudGltZU1pbGxpc2Vjb25kLCBkM1RpbWVGb3JtYXQudGltZUZvcm1hdCkuZG9tYWluKFtuZXcgRGF0ZSgyMDAwLCAwLCAxKSwgbmV3IERhdGUoMjAwMCwgMCwgMildKSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gdXRjVGltZSgpIHtcbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShjYWxlbmRhcihkM1RpbWUudXRjWWVhciwgZDNUaW1lLnV0Y01vbnRoLCBkM1RpbWUudXRjV2VlaywgZDNUaW1lLnV0Y0RheSwgZDNUaW1lLnV0Y0hvdXIsIGQzVGltZS51dGNNaW51dGUsIGQzVGltZS51dGNTZWNvbmQsIGQzVGltZS51dGNNaWxsaXNlY29uZCwgZDNUaW1lRm9ybWF0LnV0Y0Zvcm1hdCkuZG9tYWluKFtEYXRlLlVUQygyMDAwLCAwLCAxKSwgRGF0ZS5VVEMoMjAwMCwgMCwgMildKSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIkMSgpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIHQwLFxuICAgICAgdDEsXG4gICAgICBrMTAsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eSxcbiAgICAgIGNsYW1wID0gZmFsc2UsXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiBpbnRlcnBvbGF0b3IoazEwID09PSAwID8gMC41IDogKHggPSAodHJhbnNmb3JtKHgpIC0gdDApICogazEwLCBjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKSA6IHgpKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbeDAsIHgxXSA9IF8sIHQwID0gdHJhbnNmb3JtKHgwID0gK3gwKSwgdDEgPSB0cmFuc2Zvcm0oeDEgPSAreDEpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMSAvICh0MSAtIHQwKSwgc2NhbGUpIDogW3gwLCB4MV07XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSAhIV8sIHNjYWxlKSA6IGNsYW1wO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmFuZ2UoaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oXykge1xuICAgICAgdmFyIHIwLCByMTtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKFtyMCwgcjFdID0gXywgaW50ZXJwb2xhdG9yID0gaW50ZXJwb2xhdGUocjAsIHIxKSwgc2NhbGUpIDogW2ludGVycG9sYXRvcigwKSwgaW50ZXJwb2xhdG9yKDEpXTtcbiAgICB9O1xuICB9XG5cbiAgc2NhbGUucmFuZ2UgPSByYW5nZShkM0ludGVycG9sYXRlLmludGVycG9sYXRlKTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gcmFuZ2UoZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVJvdW5kKTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdDAgPSB0KHgwKSwgdDEgPSB0KHgxKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDEgLyAodDEgLSB0MCk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb3B5JDEoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFxuICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXG4gICAgICAuaW50ZXJwb2xhdG9yKHNvdXJjZS5pbnRlcnBvbGF0b3IoKSlcbiAgICAgIC5jbGFtcChzb3VyY2UuY2xhbXAoKSlcbiAgICAgIC51bmtub3duKHNvdXJjZS51bmtub3duKCkpO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW50aWFsKCkge1xuICB2YXIgc2NhbGUgPSBsaW5lYXJpc2godHJhbnNmb3JtZXIkMSgpKGlkZW50aXR5KSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5JDEoc2NhbGUsIHNlcXVlbnRpYWwoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHNlcXVlbnRpYWxMb2coKSB7XG4gIHZhciBzY2FsZSA9IGxvZ2dpc2godHJhbnNmb3JtZXIkMSgpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5JDEoc2NhbGUsIHNlcXVlbnRpYWxMb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW50aWFsU3ltbG9nKCkge1xuICB2YXIgc2NhbGUgPSBzeW1sb2dpc2godHJhbnNmb3JtZXIkMSgpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkkMShzY2FsZSwgc2VxdWVudGlhbFN5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gc2VxdWVudGlhbFBvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyJDEoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5JDEoc2NhbGUsIHNlcXVlbnRpYWxQb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHNlcXVlbnRpYWxTcXJ0KCkge1xuICByZXR1cm4gc2VxdWVudGlhbFBvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG5cbmZ1bmN0aW9uIHNlcXVlbnRpYWxRdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHk7XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIGlmICghaXNOYU4oeCA9ICt4KSkgcmV0dXJuIGludGVycG9sYXRvcigoZDNBcnJheS5iaXNlY3QoZG9tYWluLCB4LCAxKSAtIDEpIC8gKGRvbWFpbi5sZW5ndGggLSAxKSk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW107XG4gICAgZm9yIChsZXQgZCBvZiBfKSBpZiAoZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChkM0FycmF5LmFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9tYWluLm1hcCgoZCwgaSkgPT4gaW50ZXJwb2xhdG9yKGkgLyAoZG9tYWluLmxlbmd0aCAtIDEpKSk7XG4gIH07XG5cbiAgc2NhbGUucXVhbnRpbGVzID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHtsZW5ndGg6IG4gKyAxfSwgKF8sIGkpID0+IGQzQXJyYXkucXVhbnRpbGUoZG9tYWluLCBpIC8gbikpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VxdWVudGlhbFF1YW50aWxlKGludGVycG9sYXRvcikuZG9tYWluKGRvbWFpbik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyJDIoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDAuNSxcbiAgICAgIHgyID0gMSxcbiAgICAgIHMgPSAxLFxuICAgICAgdDAsXG4gICAgICB0MSxcbiAgICAgIHQyLFxuICAgICAgazEwLFxuICAgICAgazIxLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHksXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBjbGFtcCA9IGZhbHNlLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogKHggPSAwLjUgKyAoKHggPSArdHJhbnNmb3JtKHgpKSAtIHQxKSAqIChzICogeCA8IHMgKiB0MSA/IGsxMCA6IGsyMSksIGludGVycG9sYXRvcihjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKSA6IHgpKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbeDAsIHgxLCB4Ml0gPSBfLCB0MCA9IHRyYW5zZm9ybSh4MCA9ICt4MCksIHQxID0gdHJhbnNmb3JtKHgxID0gK3gxKSwgdDIgPSB0cmFuc2Zvcm0oeDIgPSAreDIpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMC41IC8gKHQxIC0gdDApLCBrMjEgPSB0MSA9PT0gdDIgPyAwIDogMC41IC8gKHQyIC0gdDEpLCBzID0gdDEgPCB0MCA/IC0xIDogMSwgc2NhbGUpIDogW3gwLCB4MSwgeDJdO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCBzY2FsZSkgOiBjbGFtcDtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJhbmdlKGludGVycG9sYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8pIHtcbiAgICAgIHZhciByMCwgcjEsIHIyO1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3IwLCByMSwgcjJdID0gXywgaW50ZXJwb2xhdG9yID0gZDNJbnRlcnBvbGF0ZS5waWVjZXdpc2UoaW50ZXJwb2xhdGUsIFtyMCwgcjEsIHIyXSksIHNjYWxlKSA6IFtpbnRlcnBvbGF0b3IoMCksIGludGVycG9sYXRvcigwLjUpLCBpbnRlcnBvbGF0b3IoMSldO1xuICAgIH07XG4gIH1cblxuICBzY2FsZS5yYW5nZSA9IHJhbmdlKGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGUpO1xuXG4gIHNjYWxlLnJhbmdlUm91bmQgPSByYW5nZShkM0ludGVycG9sYXRlLmludGVycG9sYXRlUm91bmQpO1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB0MCA9IHQoeDApLCB0MSA9IHQoeDEpLCB0MiA9IHQoeDIpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMC41IC8gKHQxIC0gdDApLCBrMjEgPSB0MSA9PT0gdDIgPyAwIDogMC41IC8gKHQyIC0gdDEpLCBzID0gdDEgPCB0MCA/IC0xIDogMTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpdmVyZ2luZygpIHtcbiAgdmFyIHNjYWxlID0gbGluZWFyaXNoKHRyYW5zZm9ybWVyJDIoKShpZGVudGl0eSkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weSQxKHNjYWxlLCBkaXZlcmdpbmcoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGRpdmVyZ2luZ0xvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lciQyKCkpLmRvbWFpbihbMC4xLCAxLCAxMF0pO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weSQxKHNjYWxlLCBkaXZlcmdpbmdMb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBkaXZlcmdpbmdTeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lciQyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weSQxKHNjYWxlLCBkaXZlcmdpbmdTeW1sb2coKSkuY29uc3RhbnQoc2NhbGUuY29uc3RhbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGRpdmVyZ2luZ1BvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyJDIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5JDEoc2NhbGUsIGRpdmVyZ2luZ1BvdygpKS5leHBvbmVudChzY2FsZS5leHBvbmVudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZGl2ZXJnaW5nU3FydCgpIHtcbiAgcmV0dXJuIGRpdmVyZ2luZ1Bvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG5cbmV4cG9ydHMuc2NhbGVCYW5kID0gYmFuZDtcbmV4cG9ydHMuc2NhbGVEaXZlcmdpbmcgPSBkaXZlcmdpbmc7XG5leHBvcnRzLnNjYWxlRGl2ZXJnaW5nTG9nID0gZGl2ZXJnaW5nTG9nO1xuZXhwb3J0cy5zY2FsZURpdmVyZ2luZ1BvdyA9IGRpdmVyZ2luZ1BvdztcbmV4cG9ydHMuc2NhbGVEaXZlcmdpbmdTcXJ0ID0gZGl2ZXJnaW5nU3FydDtcbmV4cG9ydHMuc2NhbGVEaXZlcmdpbmdTeW1sb2cgPSBkaXZlcmdpbmdTeW1sb2c7XG5leHBvcnRzLnNjYWxlSWRlbnRpdHkgPSBpZGVudGl0eSQxO1xuZXhwb3J0cy5zY2FsZUltcGxpY2l0ID0gaW1wbGljaXQ7XG5leHBvcnRzLnNjYWxlTGluZWFyID0gbGluZWFyO1xuZXhwb3J0cy5zY2FsZUxvZyA9IGxvZztcbmV4cG9ydHMuc2NhbGVPcmRpbmFsID0gb3JkaW5hbDtcbmV4cG9ydHMuc2NhbGVQb2ludCA9IHBvaW50O1xuZXhwb3J0cy5zY2FsZVBvdyA9IHBvdztcbmV4cG9ydHMuc2NhbGVRdWFudGlsZSA9IHF1YW50aWxlO1xuZXhwb3J0cy5zY2FsZVF1YW50aXplID0gcXVhbnRpemU7XG5leHBvcnRzLnNjYWxlUmFkaWFsID0gcmFkaWFsO1xuZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWwgPSBzZXF1ZW50aWFsO1xuZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWxMb2cgPSBzZXF1ZW50aWFsTG9nO1xuZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWxQb3cgPSBzZXF1ZW50aWFsUG93O1xuZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWxRdWFudGlsZSA9IHNlcXVlbnRpYWxRdWFudGlsZTtcbmV4cG9ydHMuc2NhbGVTZXF1ZW50aWFsU3FydCA9IHNlcXVlbnRpYWxTcXJ0O1xuZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWxTeW1sb2cgPSBzZXF1ZW50aWFsU3ltbG9nO1xuZXhwb3J0cy5zY2FsZVNxcnQgPSBzcXJ0O1xuZXhwb3J0cy5zY2FsZVN5bWxvZyA9IHN5bWxvZztcbmV4cG9ydHMuc2NhbGVUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG5leHBvcnRzLnNjYWxlVGltZSA9IHRpbWU7XG5leHBvcnRzLnNjYWxlVXRjID0gdXRjVGltZTtcbmV4cG9ydHMudGlja0Zvcm1hdCA9IHRpY2tGb3JtYXQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtc2VsZWN0aW9uLyB2MS40LjEgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgeGh0bWwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcblxudmFyIG5hbWVzcGFjZXMgPSB7XG4gIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB4aHRtbDogeGh0bWwsXG4gIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG59O1xuXG5mdW5jdGlvbiBuYW1lc3BhY2UobmFtZSkge1xuICB2YXIgcHJlZml4ID0gbmFtZSArPSBcIlwiLCBpID0gcHJlZml4LmluZGV4T2YoXCI6XCIpO1xuICBpZiAoaSA+PSAwICYmIChwcmVmaXggPSBuYW1lLnNsaWNlKDAsIGkpKSAhPT0gXCJ4bWxuc1wiKSBuYW1lID0gbmFtZS5zbGljZShpICsgMSk7XG4gIHJldHVybiBuYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7c3BhY2U6IG5hbWVzcGFjZXNbcHJlZml4XSwgbG9jYWw6IG5hbWV9IDogbmFtZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvckluaGVyaXQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50LFxuICAgICAgICB1cmkgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbiAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModXJpLCBuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvckZpeGVkKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdG9yKG5hbWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gKGZ1bGxuYW1lLmxvY2FsXG4gICAgICA/IGNyZWF0b3JGaXhlZFxuICAgICAgOiBjcmVhdG9ySW5oZXJpdCkoZnVsbG5hbWUpO1xufVxuXG5mdW5jdGlvbiBub25lKCkge31cblxuZnVuY3Rpb24gc2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBub25lIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zZWxlY3Qoc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG5cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIHNlbGVjdG9yQWxsKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gZW1wdHkgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3NlbGVjdEFsbChzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3JBbGwoc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBbXSwgcGFyZW50cyA9IFtdLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzdWJncm91cHMucHVzaChzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpO1xuICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCBwYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcihzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9maWx0ZXIobWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG5cbmZ1bmN0aW9uIHNwYXJzZSh1cGRhdGUpIHtcbiAgcmV0dXJuIG5ldyBBcnJheSh1cGRhdGUubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2VudGVyKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9lbnRlciB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuXG5mdW5jdGlvbiBFbnRlck5vZGUocGFyZW50LCBkYXR1bSkge1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudDtcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG59XG5cbkVudGVyTm9kZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgdGhpcy5fbmV4dCk7IH0sXG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxuICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9XG59O1xuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxudmFyIGtleVByZWZpeCA9IFwiJFwiOyAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAvLyBQdXQgYW55IHJlbWFpbmluZyBkYXRhIGludG8gZW50ZXIuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgdmFyIGksXG4gICAgICBub2RlLFxuICAgICAgbm9kZUJ5S2V5VmFsdWUgPSB7fSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAga2V5VmFsdWVzID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKSxcbiAgICAgIGtleVZhbHVlO1xuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBub2RlLlxuICAvLyBJZiBtdWx0aXBsZSBub2RlcyBoYXZlIHRoZSBzYW1lIGtleSwgdGhlIGR1cGxpY2F0ZXMgYXJlIGFkZGVkIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgICBpZiAoa2V5VmFsdWUgaW4gbm9kZUJ5S2V5VmFsdWUpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBkYXR1bS5cbiAgLy8gSWYgdGhlcmUgYSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSwgam9pbiBhbmQgYWRkIGl0IHRvIHVwZGF0ZS5cbiAgLy8gSWYgdGhlcmUgaXMgbm90IChvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlKSwgYWRkIGl0IHRvIGVudGVyLlxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChwYXJlbnQsIGRhdGFbaV0sIGksIGRhdGEpO1xuICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdKSB7XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlW2tleVZhbHVlc1tpXV0gPT09IG5vZGUpKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2RhdGEodmFsdWUsIGtleSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgZGF0YSA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGogPSAtMTtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oZCkgeyBkYXRhWysral0gPSBkOyB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzLFxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgZm9yICh2YXIgbSA9IGdyb3Vwcy5sZW5ndGgsIHVwZGF0ZSA9IG5ldyBBcnJheShtKSwgZW50ZXIgPSBuZXcgQXJyYXkobSksIGV4aXQgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgICAgZGF0YSA9IHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSxcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBlbnRlckdyb3VwID0gZW50ZXJbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIHVwZGF0ZUdyb3VwID0gdXBkYXRlW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICBleGl0R3JvdXAgPSBleGl0W2pdID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKTtcblxuICAgIGJpbmQocGFyZW50LCBncm91cCwgZW50ZXJHcm91cCwgdXBkYXRlR3JvdXAsIGV4aXRHcm91cCwgZGF0YSwga2V5KTtcblxuICAgIC8vIE5vdyBjb25uZWN0IHRoZSBlbnRlciBub2RlcyB0byB0aGVpciBmb2xsb3dpbmcgdXBkYXRlIG5vZGUsIHN1Y2ggdGhhdFxuICAgIC8vIGFwcGVuZENoaWxkIGNhbiBpbnNlcnQgdGhlIG1hdGVyaWFsaXplZCBlbnRlciBub2RlIGJlZm9yZSB0aGlzIG5vZGUsXG4gICAgLy8gcmF0aGVyIHRoYW4gYXQgdGhlIGVuZCBvZiB0aGUgcGFyZW50IG5vZGUuXG4gICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDAsIHByZXZpb3VzLCBuZXh0OyBpMCA8IGRhdGFMZW5ndGg7ICsraTApIHtcbiAgICAgIGlmIChwcmV2aW91cyA9IGVudGVyR3JvdXBbaTBdKSB7XG4gICAgICAgIGlmIChpMCA+PSBpMSkgaTEgPSBpMCArIDE7XG4gICAgICAgIHdoaWxlICghKG5leHQgPSB1cGRhdGVHcm91cFtpMV0pICYmICsraTEgPCBkYXRhTGVuZ3RoKTtcbiAgICAgICAgcHJldmlvdXMuX25leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlID0gbmV3IFNlbGVjdGlvbih1cGRhdGUsIHBhcmVudHMpO1xuICB1cGRhdGUuX2VudGVyID0gZW50ZXI7XG4gIHVwZGF0ZS5fZXhpdCA9IGV4aXQ7XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9leGl0KCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9leGl0IHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9qb2luKG9uZW50ZXIsIG9udXBkYXRlLCBvbmV4aXQpIHtcbiAgdmFyIGVudGVyID0gdGhpcy5lbnRlcigpLCB1cGRhdGUgPSB0aGlzLCBleGl0ID0gdGhpcy5leGl0KCk7XG4gIGVudGVyID0gdHlwZW9mIG9uZW50ZXIgPT09IFwiZnVuY3Rpb25cIiA/IG9uZW50ZXIoZW50ZXIpIDogZW50ZXIuYXBwZW5kKG9uZW50ZXIgKyBcIlwiKTtcbiAgaWYgKG9udXBkYXRlICE9IG51bGwpIHVwZGF0ZSA9IG9udXBkYXRlKHVwZGF0ZSk7XG4gIGlmIChvbmV4aXQgPT0gbnVsbCkgZXhpdC5yZW1vdmUoKTsgZWxzZSBvbmV4aXQoZXhpdCk7XG4gIHJldHVybiBlbnRlciAmJiB1cGRhdGUgPyBlbnRlci5tZXJnZSh1cGRhdGUpLm9yZGVyKCkgOiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9tZXJnZShzZWxlY3Rpb24pIHtcblxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gc2VsZWN0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cyk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9vcmRlcigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAtMSwgbSA9IGdyb3Vwcy5sZW5ndGg7ICsraiA8IG07KSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOykge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBpZiAobmV4dCAmJiBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5leHQpIF4gNCkgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgbmV4dCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zb3J0KGNvbXBhcmUpIHtcbiAgaWYgKCFjb21wYXJlKSBjb21wYXJlID0gYXNjZW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVOb2RlKGEsIGIpIHtcbiAgICByZXR1cm4gYSAmJiBiID8gY29tcGFyZShhLl9fZGF0YV9fLCBiLl9fZGF0YV9fKSA6ICFhIC0gIWI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzb3J0Z3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzb3J0Z3JvdXAgPSBzb3J0Z3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzb3J0Z3JvdXBbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3J0Z3JvdXAuc29ydChjb21wYXJlTm9kZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzb3J0Z3JvdXBzLCB0aGlzLl9wYXJlbnRzKS5vcmRlcigpO1xufVxuXG5mdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jYWxsKCkge1xuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gIGFyZ3VtZW50c1swXSA9IHRoaXM7XG4gIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fbm9kZXMoKSB7XG4gIHZhciBub2RlcyA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGkgPSAtMTtcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyBub2Rlc1srK2ldID0gdGhpczsgfSk7XG4gIHJldHVybiBub2Rlcztcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX25vZGUoKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zaXplKCkge1xuICB2YXIgc2l6ZSA9IDA7XG4gIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgKytzaXplOyB9KTtcbiAgcmV0dXJuIHNpemU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9lbXB0eSgpIHtcbiAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2VhY2goY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9hdHRyKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgIHJldHVybiBmdWxsbmFtZS5sb2NhbFxuICAgICAgICA/IG5vZGUuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKVxuICAgICAgICA6IG5vZGUuZ2V0QXR0cmlidXRlKGZ1bGxuYW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KSkpKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Vmlldyhub2RlKSB7XG4gIHJldHVybiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgLy8gbm9kZSBpcyBhIE5vZGVcbiAgICAgIHx8IChub2RlLmRvY3VtZW50ICYmIG5vZGUpIC8vIG5vZGUgaXMgYSBXaW5kb3dcbiAgICAgIHx8IG5vZGUuZGVmYXVsdFZpZXc7IC8vIG5vZGUgaXMgYSBEb2N1bWVudFxufVxuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3N0eWxlKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHN0eWxlUmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gc3R5bGVGdW5jdGlvblxuICAgICAgICAgICAgOiBzdHlsZUNvbnN0YW50KShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpXG4gICAgICA6IHN0eWxlVmFsdWUodGhpcy5ub2RlKCksIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBzdHlsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKVxuICAgICAgfHwgZGVmYXVsdFZpZXcobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgZWxzZSB0aGlzW25hbWVdID0gdjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHByb3BlcnR5UmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHByb3BlcnR5RnVuY3Rpb25cbiAgICAgICAgICA6IHByb3BlcnR5Q29uc3RhbnQpKG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKClbbmFtZV07XG59XG5cbmZ1bmN0aW9uIGNsYXNzQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudHJpbSgpLnNwbGl0KC9efFxccysvKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NMaXN0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0IHx8IG5ldyBDbGFzc0xpc3Qobm9kZSk7XG59XG5cbmZ1bmN0aW9uIENsYXNzTGlzdChub2RlKSB7XG4gIHRoaXMuX25vZGUgPSBub2RlO1xuICB0aGlzLl9uYW1lcyA9IGNsYXNzQXJyYXkobm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcbn1cblxuQ2xhc3NMaXN0LnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgdGhpcy5fbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKSA+PSAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjbGFzc2VkQWRkKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LmFkZChuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRSZW1vdmUobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QucmVtb3ZlKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFRydWUobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRmFsc2UobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRSZW1vdmUodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24obmFtZXMsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAodmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IGNsYXNzZWRBZGQgOiBjbGFzc2VkUmVtb3ZlKSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbGFzc2VkKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBuYW1lcyA9IGNsYXNzQXJyYXkobmFtZSArIFwiXCIpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBsaXN0ID0gY2xhc3NMaXN0KHRoaXMubm9kZSgpKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWxpc3QuY29udGFpbnMobmFtZXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBjbGFzc2VkRnVuY3Rpb24gOiB2YWx1ZVxuICAgICAgPyBjbGFzc2VkVHJ1ZVxuICAgICAgOiBjbGFzc2VkRmFsc2UpKG5hbWVzLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiB0ZXh0UmVtb3ZlKCkge1xuICB0aGlzLnRleHRDb250ZW50ID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3RleHQodmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHRleHRSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHRleHRGdW5jdGlvblxuICAgICAgICAgIDogdGV4dENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xufVxuXG5mdW5jdGlvbiBodG1sUmVtb3ZlKCkge1xuICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGh0bWxDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHRtbEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2h0bWwodmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IGh0bWxSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGh0bWxGdW5jdGlvblxuICAgICAgICAgIDogaHRtbENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gcmFpc2UoKSB7XG4gIGlmICh0aGlzLm5leHRTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9yYWlzZSgpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyYWlzZSk7XG59XG5cbmZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fbG93ZXIoKSB7XG4gIHJldHVybiB0aGlzLmVhY2gobG93ZXIpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fYXBwZW5kKG5hbWUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50TnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9pbnNlcnQobmFtZSwgYmVmb3JlKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSksXG4gICAgICBzZWxlY3QgPSBiZWZvcmUgPT0gbnVsbCA/IGNvbnN0YW50TnVsbCA6IHR5cGVvZiBiZWZvcmUgPT09IFwiZnVuY3Rpb25cIiA/IGJlZm9yZSA6IHNlbGVjdG9yKGJlZm9yZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9yZW1vdmUoKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmVtb3ZlKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lU2hhbGxvdygpIHtcbiAgdmFyIGNsb25lID0gdGhpcy5jbG9uZU5vZGUoZmFsc2UpLCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzLm5leHRTaWJsaW5nKSA6IGNsb25lO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVEZWVwKCkge1xuICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZSh0cnVlKSwgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICByZXR1cm4gcGFyZW50ID8gcGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcy5uZXh0U2libGluZykgOiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lKGRlZXApIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGRlZXAgPyBzZWxlY3Rpb25fY2xvbmVEZWVwIDogc2VsZWN0aW9uX2Nsb25lU2hhbGxvdyk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9kYXR1bSh2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufVxuXG52YXIgZmlsdGVyRXZlbnRzID0ge307XG5cbmV4cG9ydHMuZXZlbnQgPSBudWxsO1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBpZiAoIShcIm9ubW91c2VlbnRlclwiIGluIGVsZW1lbnQpKSB7XG4gICAgZmlsdGVyRXZlbnRzID0ge21vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIn07XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyQ29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApIHtcbiAgbGlzdGVuZXIgPSBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCk7XG4gIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciByZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBpZiAoIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRoaXMgJiYgIShyZWxhdGVkLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMpICYgOCkpKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gIHJldHVybiBmdW5jdGlvbihldmVudDEpIHtcbiAgICB2YXIgZXZlbnQwID0gZXhwb3J0cy5ldmVudDsgLy8gRXZlbnRzIGNhbiBiZSByZWVudHJhbnQgKGUuZy4sIGZvY3VzKS5cbiAgICBleHBvcnRzLmV2ZW50ID0gZXZlbnQxO1xuICAgIHRyeSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIHRoaXMuX19kYXRhX18sIGluZGV4LCBncm91cCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cG9ydHMuZXZlbnQgPSBldmVudDA7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblJlbW92ZSh0eXBlbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uO1xuICAgIGlmICghb24pIHJldHVybjtcbiAgICBmb3IgKHZhciBqID0gMCwgaSA9IC0xLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAobyA9IG9uW2pdLCAoIXR5cGVuYW1lLnR5cGUgfHwgby50eXBlID09PSB0eXBlbmFtZS50eXBlKSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uWysraV0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKytpKSBvbi5sZW5ndGggPSBpO1xuICAgIGVsc2UgZGVsZXRlIHRoaXMuX19vbjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25BZGQodHlwZW5hbWUsIHZhbHVlLCBjYXB0dXJlKSB7XG4gIHZhciB3cmFwID0gZmlsdGVyRXZlbnRzLmhhc093blByb3BlcnR5KHR5cGVuYW1lLnR5cGUpID8gZmlsdGVyQ29udGV4dExpc3RlbmVyIDogY29udGV4dExpc3RlbmVyO1xuICByZXR1cm4gZnVuY3Rpb24oZCwgaSwgZ3JvdXApIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb24sIG8sIGxpc3RlbmVyID0gd3JhcCh2YWx1ZSwgaSwgZ3JvdXApO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgIGlmICgobyA9IG9uW2pdKS50eXBlID09PSB0eXBlbmFtZS50eXBlICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLmNhcHR1cmUpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyID0gbGlzdGVuZXIsIG8uY2FwdHVyZSA9IGNhcHR1cmUpO1xuICAgICAgICBvLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGVuYW1lLnR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICBvID0ge3R5cGU6IHR5cGVuYW1lLnR5cGUsIG5hbWU6IHR5cGVuYW1lLm5hbWUsIHZhbHVlOiB2YWx1ZSwgbGlzdGVuZXI6IGxpc3RlbmVyLCBjYXB0dXJlOiBjYXB0dXJlfTtcbiAgICBpZiAoIW9uKSB0aGlzLl9fb24gPSBbb107XG4gICAgZWxzZSBvbi5wdXNoKG8pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fb24odHlwZW5hbWUsIHZhbHVlLCBjYXB0dXJlKSB7XG4gIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgb24gPSB0aGlzLm5vZGUoKS5fX29uO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICBpZiAoY2FwdHVyZSA9PSBudWxsKSBjYXB0dXJlID0gZmFsc2U7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBjYXB0dXJlKSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBjdXN0b21FdmVudChldmVudDEsIGxpc3RlbmVyLCB0aGF0LCBhcmdzKSB7XG4gIHZhciBldmVudDAgPSBleHBvcnRzLmV2ZW50O1xuICBldmVudDEuc291cmNlRXZlbnQgPSBleHBvcnRzLmV2ZW50O1xuICBleHBvcnRzLmV2ZW50ID0gZXZlbnQxO1xuICB0cnkge1xuICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleHBvcnRzLmV2ZW50ID0gZXZlbnQwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQobm9kZSwgdHlwZSwgcGFyYW1zKSB7XG4gIHZhciB3aW5kb3cgPSBkZWZhdWx0Vmlldyhub2RlKSxcbiAgICAgIGV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGV2ZW50ID0gbmV3IGV2ZW50KHR5cGUsIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBpZiAocGFyYW1zKSBldmVudC5pbml0RXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlKSwgZXZlbnQuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgICBlbHNlIGV2ZW50LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xuICB9XG5cbiAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDb25zdGFudCh0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9kaXNwYXRjaCh0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGRpc3BhdGNoRnVuY3Rpb25cbiAgICAgIDogZGlzcGF0Y2hDb25zdGFudCkodHlwZSwgcGFyYW1zKSk7XG59XG5cbnZhciByb290ID0gW251bGxdO1xuXG5mdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uLFxuICBzZWxlY3Q6IHNlbGVjdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgZmlsdGVyOiBzZWxlY3Rpb25fZmlsdGVyLFxuICBkYXRhOiBzZWxlY3Rpb25fZGF0YSxcbiAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgZXhpdDogc2VsZWN0aW9uX2V4aXQsXG4gIGpvaW46IHNlbGVjdGlvbl9qb2luLFxuICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxuICBvcmRlcjogc2VsZWN0aW9uX29yZGVyLFxuICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fbm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICBzdHlsZTogc2VsZWN0aW9uX3N0eWxlLFxuICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgdGV4dDogc2VsZWN0aW9uX3RleHQsXG4gIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICBsb3dlcjogc2VsZWN0aW9uX2xvd2VyLFxuICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgcmVtb3ZlOiBzZWxlY3Rpb25fcmVtb3ZlLFxuICBjbG9uZTogc2VsZWN0aW9uX2Nsb25lLFxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICBvbjogc2VsZWN0aW9uX29uLFxuICBkaXNwYXRjaDogc2VsZWN0aW9uX2Rpc3BhdGNoXG59O1xuXG5mdW5jdGlvbiBzZWxlY3Qoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcildXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW1tzZWxlY3Rvcl1dLCByb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG5hbWUpIHtcbiAgcmV0dXJuIHNlbGVjdChjcmVhdG9yKG5hbWUpLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSk7XG59XG5cbnZhciBuZXh0SWQgPSAwO1xuXG5mdW5jdGlvbiBsb2NhbCgpIHtcbiAgcmV0dXJuIG5ldyBMb2NhbDtcbn1cblxuZnVuY3Rpb24gTG9jYWwoKSB7XG4gIHRoaXMuXyA9IFwiQFwiICsgKCsrbmV4dElkKS50b1N0cmluZygzNik7XG59XG5cbkxvY2FsLnByb3RvdHlwZSA9IGxvY2FsLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IExvY2FsLFxuICBnZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLl87XG4gICAgd2hpbGUgKCEoaWQgaW4gbm9kZSkpIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm47XG4gICAgcmV0dXJuIG5vZGVbaWRdO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5vZGVbdGhpcy5fXSA9IHZhbHVlO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fIGluIG5vZGUgJiYgZGVsZXRlIG5vZGVbdGhpcy5fXTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNvdXJjZUV2ZW50KCkge1xuICB2YXIgY3VycmVudCA9IGV4cG9ydHMuZXZlbnQsIHNvdXJjZTtcbiAgd2hpbGUgKHNvdXJjZSA9IGN1cnJlbnQuc291cmNlRXZlbnQpIGN1cnJlbnQgPSBzb3VyY2U7XG4gIHJldHVybiBjdXJyZW50O1xufVxuXG5mdW5jdGlvbiBwb2ludChub2RlLCBldmVudCkge1xuICB2YXIgc3ZnID0gbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgbm9kZTtcblxuICBpZiAoc3ZnLmNyZWF0ZVNWR1BvaW50KSB7XG4gICAgdmFyIHBvaW50ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgcG9pbnQueCA9IGV2ZW50LmNsaWVudFgsIHBvaW50LnkgPSBldmVudC5jbGllbnRZO1xuICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKG5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldO1xuICB9XG5cbiAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gW2V2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSBub2RlLmNsaWVudExlZnQsIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIG5vZGUuY2xpZW50VG9wXTtcbn1cblxuZnVuY3Rpb24gbW91c2Uobm9kZSkge1xuICB2YXIgZXZlbnQgPSBzb3VyY2VFdmVudCgpO1xuICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIGV2ZW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gIHJldHVybiBwb2ludChub2RlLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdEFsbChzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW3NlbGVjdG9yID09IG51bGwgPyBbXSA6IHNlbGVjdG9yXSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIHRvdWNoKG5vZGUsIHRvdWNoZXMsIGlkZW50aWZpZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBpZGVudGlmaWVyID0gdG91Y2hlcywgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkuY2hhbmdlZFRvdWNoZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzID8gdG91Y2hlcy5sZW5ndGggOiAwLCB0b3VjaDsgaSA8IG47ICsraSkge1xuICAgIGlmICgodG91Y2ggPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4gcG9pbnQobm9kZSwgdG91Y2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b3VjaGVzKG5vZGUsIHRvdWNoZXMpIHtcbiAgaWYgKHRvdWNoZXMgPT0gbnVsbCkgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkudG91Y2hlcztcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMgPyB0b3VjaGVzLmxlbmd0aCA6IDAsIHBvaW50cyA9IG5ldyBBcnJheShuKTsgaSA8IG47ICsraSkge1xuICAgIHBvaW50c1tpXSA9IHBvaW50KG5vZGUsIHRvdWNoZXNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cblxuZXhwb3J0cy5jbGllbnRQb2ludCA9IHBvaW50O1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNyZWF0b3IgPSBjcmVhdG9yO1xuZXhwb3J0cy5jdXN0b21FdmVudCA9IGN1c3RvbUV2ZW50O1xuZXhwb3J0cy5sb2NhbCA9IGxvY2FsO1xuZXhwb3J0cy5tYXRjaGVyID0gbWF0Y2hlcjtcbmV4cG9ydHMubW91c2UgPSBtb3VzZTtcbmV4cG9ydHMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuZXhwb3J0cy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcbmV4cG9ydHMuc2VsZWN0ID0gc2VsZWN0O1xuZXhwb3J0cy5zZWxlY3RBbGwgPSBzZWxlY3RBbGw7XG5leHBvcnRzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbmV4cG9ydHMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbmV4cG9ydHMuc2VsZWN0b3JBbGwgPSBzZWxlY3RvckFsbDtcbmV4cG9ydHMuc3R5bGUgPSBzdHlsZVZhbHVlO1xuZXhwb3J0cy50b3VjaCA9IHRvdWNoO1xuZXhwb3J0cy50b3VjaGVzID0gdG91Y2hlcztcbmV4cG9ydHMud2luZG93ID0gZGVmYXVsdFZpZXc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtdGltZS1mb3JtYXQvIHYyLjIuMyBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLXRpbWUnKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy10aW1lJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30sIGdsb2JhbC5kMykpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNUaW1lKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbG9jYWxEYXRlKGQpIHtcbiAgaWYgKDAgPD0gZC55ICYmIGQueSA8IDEwMCkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoLTEsIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpO1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZC55KTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbn1cblxuZnVuY3Rpb24gdXRjRGF0ZShkKSB7XG4gIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkLnkpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyhkLnksIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpKTtcbn1cblxuZnVuY3Rpb24gbmV3RGF0ZSh5LCBtLCBkKSB7XG4gIHJldHVybiB7eTogeSwgbTogbSwgZDogZCwgSDogMCwgTTogMCwgUzogMCwgTDogMH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExvY2FsZShsb2NhbGUpIHtcbiAgdmFyIGxvY2FsZV9kYXRlVGltZSA9IGxvY2FsZS5kYXRlVGltZSxcbiAgICAgIGxvY2FsZV9kYXRlID0gbG9jYWxlLmRhdGUsXG4gICAgICBsb2NhbGVfdGltZSA9IGxvY2FsZS50aW1lLFxuICAgICAgbG9jYWxlX3BlcmlvZHMgPSBsb2NhbGUucGVyaW9kcyxcbiAgICAgIGxvY2FsZV93ZWVrZGF5cyA9IGxvY2FsZS5kYXlzLFxuICAgICAgbG9jYWxlX3Nob3J0V2Vla2RheXMgPSBsb2NhbGUuc2hvcnREYXlzLFxuICAgICAgbG9jYWxlX21vbnRocyA9IGxvY2FsZS5tb250aHMsXG4gICAgICBsb2NhbGVfc2hvcnRNb250aHMgPSBsb2NhbGUuc2hvcnRNb250aHM7XG5cbiAgdmFyIHBlcmlvZFJlID0gZm9ybWF0UmUobG9jYWxlX3BlcmlvZHMpLFxuICAgICAgcGVyaW9kTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9wZXJpb2RzKSxcbiAgICAgIHdlZWtkYXlSZSA9IGZvcm1hdFJlKGxvY2FsZV93ZWVrZGF5cyksXG4gICAgICB3ZWVrZGF5TG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV93ZWVrZGF5cyksXG4gICAgICBzaG9ydFdlZWtkYXlSZSA9IGZvcm1hdFJlKGxvY2FsZV9zaG9ydFdlZWtkYXlzKSxcbiAgICAgIHNob3J0V2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICBtb250aFJlID0gZm9ybWF0UmUobG9jYWxlX21vbnRocyksXG4gICAgICBtb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfbW9udGhzKSxcbiAgICAgIHNob3J0TW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9zaG9ydE1vbnRocyksXG4gICAgICBzaG9ydE1vbnRoTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydE1vbnRocyk7XG5cbiAgdmFyIGZvcm1hdHMgPSB7XG4gICAgXCJhXCI6IGZvcm1hdFNob3J0V2Vla2RheSxcbiAgICBcIkFcIjogZm9ybWF0V2Vla2RheSxcbiAgICBcImJcIjogZm9ybWF0U2hvcnRNb250aCxcbiAgICBcIkJcIjogZm9ybWF0TW9udGgsXG4gICAgXCJjXCI6IG51bGwsXG4gICAgXCJkXCI6IGZvcm1hdERheU9mTW9udGgsXG4gICAgXCJlXCI6IGZvcm1hdERheU9mTW9udGgsXG4gICAgXCJmXCI6IGZvcm1hdE1pY3Jvc2Vjb25kcyxcbiAgICBcIkhcIjogZm9ybWF0SG91cjI0LFxuICAgIFwiSVwiOiBmb3JtYXRIb3VyMTIsXG4gICAgXCJqXCI6IGZvcm1hdERheU9mWWVhcixcbiAgICBcIkxcIjogZm9ybWF0TWlsbGlzZWNvbmRzLFxuICAgIFwibVwiOiBmb3JtYXRNb250aE51bWJlcixcbiAgICBcIk1cIjogZm9ybWF0TWludXRlcyxcbiAgICBcInBcIjogZm9ybWF0UGVyaW9kLFxuICAgIFwicVwiOiBmb3JtYXRRdWFydGVyLFxuICAgIFwiUVwiOiBmb3JtYXRVbml4VGltZXN0YW1wLFxuICAgIFwic1wiOiBmb3JtYXRVbml4VGltZXN0YW1wU2Vjb25kcyxcbiAgICBcIlNcIjogZm9ybWF0U2Vjb25kcyxcbiAgICBcInVcIjogZm9ybWF0V2Vla2RheU51bWJlck1vbmRheSxcbiAgICBcIlVcIjogZm9ybWF0V2Vla051bWJlclN1bmRheSxcbiAgICBcIlZcIjogZm9ybWF0V2Vla051bWJlcklTTyxcbiAgICBcIndcIjogZm9ybWF0V2Vla2RheU51bWJlclN1bmRheSxcbiAgICBcIldcIjogZm9ybWF0V2Vla051bWJlck1vbmRheSxcbiAgICBcInhcIjogbnVsbCxcbiAgICBcIlhcIjogbnVsbCxcbiAgICBcInlcIjogZm9ybWF0WWVhcixcbiAgICBcIllcIjogZm9ybWF0RnVsbFllYXIsXG4gICAgXCJaXCI6IGZvcm1hdFpvbmUsXG4gICAgXCIlXCI6IGZvcm1hdExpdGVyYWxQZXJjZW50XG4gIH07XG5cbiAgdmFyIHV0Y0Zvcm1hdHMgPSB7XG4gICAgXCJhXCI6IGZvcm1hdFVUQ1Nob3J0V2Vla2RheSxcbiAgICBcIkFcIjogZm9ybWF0VVRDV2Vla2RheSxcbiAgICBcImJcIjogZm9ybWF0VVRDU2hvcnRNb250aCxcbiAgICBcIkJcIjogZm9ybWF0VVRDTW9udGgsXG4gICAgXCJjXCI6IG51bGwsXG4gICAgXCJkXCI6IGZvcm1hdFVUQ0RheU9mTW9udGgsXG4gICAgXCJlXCI6IGZvcm1hdFVUQ0RheU9mTW9udGgsXG4gICAgXCJmXCI6IGZvcm1hdFVUQ01pY3Jvc2Vjb25kcyxcbiAgICBcIkhcIjogZm9ybWF0VVRDSG91cjI0LFxuICAgIFwiSVwiOiBmb3JtYXRVVENIb3VyMTIsXG4gICAgXCJqXCI6IGZvcm1hdFVUQ0RheU9mWWVhcixcbiAgICBcIkxcIjogZm9ybWF0VVRDTWlsbGlzZWNvbmRzLFxuICAgIFwibVwiOiBmb3JtYXRVVENNb250aE51bWJlcixcbiAgICBcIk1cIjogZm9ybWF0VVRDTWludXRlcyxcbiAgICBcInBcIjogZm9ybWF0VVRDUGVyaW9kLFxuICAgIFwicVwiOiBmb3JtYXRVVENRdWFydGVyLFxuICAgIFwiUVwiOiBmb3JtYXRVbml4VGltZXN0YW1wLFxuICAgIFwic1wiOiBmb3JtYXRVbml4VGltZXN0YW1wU2Vjb25kcyxcbiAgICBcIlNcIjogZm9ybWF0VVRDU2Vjb25kcyxcbiAgICBcInVcIjogZm9ybWF0VVRDV2Vla2RheU51bWJlck1vbmRheSxcbiAgICBcIlVcIjogZm9ybWF0VVRDV2Vla051bWJlclN1bmRheSxcbiAgICBcIlZcIjogZm9ybWF0VVRDV2Vla051bWJlcklTTyxcbiAgICBcIndcIjogZm9ybWF0VVRDV2Vla2RheU51bWJlclN1bmRheSxcbiAgICBcIldcIjogZm9ybWF0VVRDV2Vla051bWJlck1vbmRheSxcbiAgICBcInhcIjogbnVsbCxcbiAgICBcIlhcIjogbnVsbCxcbiAgICBcInlcIjogZm9ybWF0VVRDWWVhcixcbiAgICBcIllcIjogZm9ybWF0VVRDRnVsbFllYXIsXG4gICAgXCJaXCI6IGZvcm1hdFVUQ1pvbmUsXG4gICAgXCIlXCI6IGZvcm1hdExpdGVyYWxQZXJjZW50XG4gIH07XG5cbiAgdmFyIHBhcnNlcyA9IHtcbiAgICBcImFcIjogcGFyc2VTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IHBhcnNlV2Vla2RheSxcbiAgICBcImJcIjogcGFyc2VTaG9ydE1vbnRoLFxuICAgIFwiQlwiOiBwYXJzZU1vbnRoLFxuICAgIFwiY1wiOiBwYXJzZUxvY2FsZURhdGVUaW1lLFxuICAgIFwiZFwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgXCJlXCI6IHBhcnNlRGF5T2ZNb250aCxcbiAgICBcImZcIjogcGFyc2VNaWNyb3NlY29uZHMsXG4gICAgXCJIXCI6IHBhcnNlSG91cjI0LFxuICAgIFwiSVwiOiBwYXJzZUhvdXIyNCxcbiAgICBcImpcIjogcGFyc2VEYXlPZlllYXIsXG4gICAgXCJMXCI6IHBhcnNlTWlsbGlzZWNvbmRzLFxuICAgIFwibVwiOiBwYXJzZU1vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBwYXJzZU1pbnV0ZXMsXG4gICAgXCJwXCI6IHBhcnNlUGVyaW9kLFxuICAgIFwicVwiOiBwYXJzZVF1YXJ0ZXIsXG4gICAgXCJRXCI6IHBhcnNlVW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogcGFyc2VVbml4VGltZXN0YW1wU2Vjb25kcyxcbiAgICBcIlNcIjogcGFyc2VTZWNvbmRzLFxuICAgIFwidVwiOiBwYXJzZVdlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IHBhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICBcIlZcIjogcGFyc2VXZWVrTnVtYmVySVNPLFxuICAgIFwid1wiOiBwYXJzZVdlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IHBhcnNlV2Vla051bWJlck1vbmRheSxcbiAgICBcInhcIjogcGFyc2VMb2NhbGVEYXRlLFxuICAgIFwiWFwiOiBwYXJzZUxvY2FsZVRpbWUsXG4gICAgXCJ5XCI6IHBhcnNlWWVhcixcbiAgICBcIllcIjogcGFyc2VGdWxsWWVhcixcbiAgICBcIlpcIjogcGFyc2Vab25lLFxuICAgIFwiJVwiOiBwYXJzZUxpdGVyYWxQZXJjZW50XG4gIH07XG5cbiAgLy8gVGhlc2UgcmVjdXJzaXZlIGRpcmVjdGl2ZSBkZWZpbml0aW9ucyBtdXN0IGJlIGRlZmVycmVkLlxuICBmb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIGZvcm1hdHMpO1xuICBmb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIGZvcm1hdHMpO1xuICBmb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCBmb3JtYXRzKTtcbiAgdXRjRm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCB1dGNGb3JtYXRzKTtcbiAgdXRjRm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCB1dGNGb3JtYXRzKTtcbiAgdXRjRm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgdXRjRm9ybWF0cyk7XG5cbiAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllciwgZm9ybWF0cykge1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgc3RyaW5nID0gW10sXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIGogPSAwLFxuICAgICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgcGFkLFxuICAgICAgICAgIGZvcm1hdDtcblxuICAgICAgaWYgKCEoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSBkYXRlID0gbmV3IERhdGUoK2RhdGUpO1xuXG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgICAgICBpZiAoKHBhZCA9IHBhZHNbYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKV0pICE9IG51bGwpIGMgPSBzcGVjaWZpZXIuY2hhckF0KCsraSk7XG4gICAgICAgICAgZWxzZSBwYWQgPSBjID09PSBcImVcIiA/IFwiIFwiIDogXCIwXCI7XG4gICAgICAgICAgaWYgKGZvcm1hdCA9IGZvcm1hdHNbY10pIGMgPSBmb3JtYXQoZGF0ZSwgcGFkKTtcbiAgICAgICAgICBzdHJpbmcucHVzaChjKTtcbiAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgIHJldHVybiBzdHJpbmcuam9pbihcIlwiKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3UGFyc2Uoc3BlY2lmaWVyLCBaKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIGQgPSBuZXdEYXRlKDE5MDAsIHVuZGVmaW5lZCwgMSksXG4gICAgICAgICAgaSA9IHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nICs9IFwiXCIsIDApLFxuICAgICAgICAgIHdlZWssIGRheTtcbiAgICAgIGlmIChpICE9IHN0cmluZy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBJZiBhIFVOSVggdGltZXN0YW1wIGlzIHNwZWNpZmllZCwgcmV0dXJuIGl0LlxuICAgICAgaWYgKFwiUVwiIGluIGQpIHJldHVybiBuZXcgRGF0ZShkLlEpO1xuICAgICAgaWYgKFwic1wiIGluIGQpIHJldHVybiBuZXcgRGF0ZShkLnMgKiAxMDAwICsgKFwiTFwiIGluIGQgPyBkLkwgOiAwKSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgdXRjUGFyc2UsIG5ldmVyIHVzZSB0aGUgbG9jYWwgdGltZXpvbmUuXG4gICAgICBpZiAoWiAmJiAhKFwiWlwiIGluIGQpKSBkLlogPSAwO1xuXG4gICAgICAvLyBUaGUgYW0tcG0gZmxhZyBpcyAwIGZvciBBTSwgYW5kIDEgZm9yIFBNLlxuICAgICAgaWYgKFwicFwiIGluIGQpIGQuSCA9IGQuSCAlIDEyICsgZC5wICogMTI7XG5cbiAgICAgIC8vIElmIHRoZSBtb250aCB3YXMgbm90IHNwZWNpZmllZCwgaW5oZXJpdCBmcm9tIHRoZSBxdWFydGVyLlxuICAgICAgaWYgKGQubSA9PT0gdW5kZWZpbmVkKSBkLm0gPSBcInFcIiBpbiBkID8gZC5xIDogMDtcblxuICAgICAgLy8gQ29udmVydCBkYXktb2Ytd2VlayBhbmQgd2Vlay1vZi15ZWFyIHRvIGRheS1vZi15ZWFyLlxuICAgICAgaWYgKFwiVlwiIGluIGQpIHtcbiAgICAgICAgaWYgKGQuViA8IDEgfHwgZC5WID4gNTMpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gMTtcbiAgICAgICAgaWYgKFwiWlwiIGluIGQpIHtcbiAgICAgICAgICB3ZWVrID0gdXRjRGF0ZShuZXdEYXRlKGQueSwgMCwgMSkpLCBkYXkgPSB3ZWVrLmdldFVUQ0RheSgpO1xuICAgICAgICAgIHdlZWsgPSBkYXkgPiA0IHx8IGRheSA9PT0gMCA/IGQzVGltZS51dGNNb25kYXkuY2VpbCh3ZWVrKSA6IGQzVGltZS51dGNNb25kYXkod2Vlayk7XG4gICAgICAgICAgd2VlayA9IGQzVGltZS51dGNEYXkub2Zmc2V0KHdlZWssIChkLlYgLSAxKSAqIDcpO1xuICAgICAgICAgIGQueSA9IHdlZWsuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICBkLm0gPSB3ZWVrLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgZC5kID0gd2Vlay5nZXRVVENEYXRlKCkgKyAoZC53ICsgNikgJSA3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdlZWsgPSBsb2NhbERhdGUobmV3RGF0ZShkLnksIDAsIDEpKSwgZGF5ID0gd2Vlay5nZXREYXkoKTtcbiAgICAgICAgICB3ZWVrID0gZGF5ID4gNCB8fCBkYXkgPT09IDAgPyBkM1RpbWUudGltZU1vbmRheS5jZWlsKHdlZWspIDogZDNUaW1lLnRpbWVNb25kYXkod2Vlayk7XG4gICAgICAgICAgd2VlayA9IGQzVGltZS50aW1lRGF5Lm9mZnNldCh3ZWVrLCAoZC5WIC0gMSkgKiA3KTtcbiAgICAgICAgICBkLnkgPSB3ZWVrLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgZC5tID0gd2Vlay5nZXRNb250aCgpO1xuICAgICAgICAgIGQuZCA9IHdlZWsuZ2V0RGF0ZSgpICsgKGQudyArIDYpICUgNztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpIHtcbiAgICAgICAgaWYgKCEoXCJ3XCIgaW4gZCkpIGQudyA9IFwidVwiIGluIGQgPyBkLnUgJSA3IDogXCJXXCIgaW4gZCA/IDEgOiAwO1xuICAgICAgICBkYXkgPSBcIlpcIiBpbiBkID8gdXRjRGF0ZShuZXdEYXRlKGQueSwgMCwgMSkpLmdldFVUQ0RheSgpIDogbG9jYWxEYXRlKG5ld0RhdGUoZC55LCAwLCAxKSkuZ2V0RGF5KCk7XG4gICAgICAgIGQubSA9IDA7XG4gICAgICAgIGQuZCA9IFwiV1wiIGluIGQgPyAoZC53ICsgNikgJSA3ICsgZC5XICogNyAtIChkYXkgKyA1KSAlIDcgOiBkLncgKyBkLlUgKiA3IC0gKGRheSArIDYpICUgNztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkLCBhbGwgZmllbGRzIGFyZSBpbnRlcnByZXRlZCBhcyBVVEMgYW5kIHRoZW5cbiAgICAgIC8vIG9mZnNldCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCB0aW1lIHpvbmUuXG4gICAgICBpZiAoXCJaXCIgaW4gZCkge1xuICAgICAgICBkLkggKz0gZC5aIC8gMTAwIHwgMDtcbiAgICAgICAgZC5NICs9IGQuWiAlIDEwMDtcbiAgICAgICAgcmV0dXJuIHV0Y0RhdGUoZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgYWxsIGZpZWxkcyBhcmUgaW4gbG9jYWwgdGltZS5cbiAgICAgIHJldHVybiBsb2NhbERhdGUoZCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nLCBqKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgbSA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgIGMsXG4gICAgICAgIHBhcnNlO1xuXG4gICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICBpZiAoaiA+PSBtKSByZXR1cm4gLTE7XG4gICAgICBjID0gc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIGlmIChjID09PSAzNykge1xuICAgICAgICBjID0gc3BlY2lmaWVyLmNoYXJBdChpKyspO1xuICAgICAgICBwYXJzZSA9IHBhcnNlc1tjIGluIHBhZHMgPyBzcGVjaWZpZXIuY2hhckF0KGkrKykgOiBjXTtcbiAgICAgICAgaWYgKCFwYXJzZSB8fCAoKGogPSBwYXJzZShkLCBzdHJpbmcsIGopKSA8IDApKSByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGMgIT0gc3RyaW5nLmNoYXJDb2RlQXQoaisrKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGo7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBlcmlvZChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHBlcmlvZFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLnAgPSBwZXJpb2RMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTaG9ydFdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBzaG9ydFdlZWtkYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC53ID0gc2hvcnRXZWVrZGF5TG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHdlZWtkYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC53ID0gd2Vla2RheUxvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNob3J0TW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBzaG9ydE1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQubSA9IHNob3J0TW9udGhMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQubSA9IG1vbnRoTG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxlRGF0ZVRpbWUoZCwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlVGltZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxlRGF0ZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX2RhdGUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZVRpbWUoZCwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV90aW1lLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0U2hvcnRXZWVrZGF5KGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXREYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRXZWVrZGF5KGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0U2hvcnRNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldE1vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0TW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRQZXJpb2QoZCkge1xuICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0SG91cnMoKSA+PSAxMildO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UXVhcnRlcihkKSB7XG4gICAgcmV0dXJuIDEgKyB+fihkLmdldE1vbnRoKCkgLyAzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1Nob3J0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1Nob3J0TW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDUGVyaW9kKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldFVUQ0hvdXJzKCkgPj0gMTIpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1F1YXJ0ZXIoZCkge1xuICAgIHJldHVybiAxICsgfn4oZC5nZXRVVENNb250aCgpIC8gMyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgZm9ybWF0cyk7XG4gICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gZjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBwID0gbmV3UGFyc2Uoc3BlY2lmaWVyICs9IFwiXCIsIGZhbHNlKTtcbiAgICAgIHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgdXRjRm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCB1dGNGb3JtYXRzKTtcbiAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBmO1xuICAgIH0sXG4gICAgdXRjUGFyc2U6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIHAgPSBuZXdQYXJzZShzcGVjaWZpZXIgKz0gXCJcIiwgdHJ1ZSk7XG4gICAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH07XG59XG5cbnZhciBwYWRzID0ge1wiLVwiOiBcIlwiLCBcIl9cIjogXCIgXCIsIFwiMFwiOiBcIjBcIn0sXG4gICAgbnVtYmVyUmUgPSAvXlxccypcXGQrLywgLy8gbm90ZTogaWdub3JlcyBuZXh0IGRpcmVjdGl2ZVxuICAgIHBlcmNlbnRSZSA9IC9eJS8sXG4gICAgcmVxdW90ZVJlID0gL1tcXFxcXiQqKz98W1xcXSgpLnt9XS9nO1xuXG5mdW5jdGlvbiBwYWQodmFsdWUsIGZpbGwsIHdpZHRoKSB7XG4gIHZhciBzaWduID0gdmFsdWUgPCAwID8gXCItXCIgOiBcIlwiLFxuICAgICAgc3RyaW5nID0gKHNpZ24gPyAtdmFsdWUgOiB2YWx1ZSkgKyBcIlwiLFxuICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgcmV0dXJuIHNpZ24gKyAobGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpICsgc3RyaW5nIDogc3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gcmVxdW90ZShzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UocmVxdW90ZVJlLCBcIlxcXFwkJlwiKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UmUobmFtZXMpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyBuYW1lcy5tYXAocmVxdW90ZSkuam9pbihcInxcIikgKyBcIilcIiwgXCJpXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMb29rdXAobmFtZXMpIHtcbiAgdmFyIG1hcCA9IHt9LCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBtYXBbbmFtZXNbaV0udG9Mb3dlckNhc2UoKV0gPSBpO1xuICByZXR1cm4gbWFwO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXJTdW5kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyAoZC53ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5TnVtYmVyTW9uZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gIHJldHVybiBuID8gKGQudSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlclN1bmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlUgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJJU08oZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5WID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyTW9uZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuVyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnVsbFllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDQpKTtcbiAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VZZWFyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQueSA9ICtuWzBdICsgKCtuWzBdID4gNjggPyAxOTAwIDogMjAwMCksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2Vab25lKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IC9eKFopfChbKy1dXFxkXFxkKSg/Ojo/KFxcZFxcZCkpPy8uZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDYpKTtcbiAgcmV0dXJuIG4gPyAoZC5aID0gblsxXSA/IDAgOiAtKG5bMl0gKyAoblszXSB8fCBcIjAwXCIpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVF1YXJ0ZXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyAoZC5xID0gblswXSAqIDMgLSAzLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9udGhOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXlPZk1vbnRoKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF5T2ZZZWFyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gIHJldHVybiBuID8gKGQubSA9IDAsIGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSG91cjI0KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuSCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWludXRlcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLk0gPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5TID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaWxsaXNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgcmV0dXJuIG4gPyAoZC5MID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaWNyb3NlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDYpKTtcbiAgcmV0dXJuIG4gPyAoZC5MID0gTWF0aC5mbG9vcihuWzBdIC8gMTAwMCksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaXRlcmFsUGVyY2VudChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBwZXJjZW50UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyBpICsgblswXS5sZW5ndGggOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVbml4VGltZXN0YW1wKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgcmV0dXJuIG4gPyAoZC5RID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVbml4VGltZXN0YW1wU2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gIHJldHVybiBuID8gKGQucyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERheU9mTW9udGgoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RGF0ZSgpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SG91cjI0KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRIb3VyMTIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF5T2ZZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZCgxICsgZDNUaW1lLnRpbWVEYXkuY291bnQoZDNUaW1lLnRpbWVZZWFyKGQpLCBkKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbGxpc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pY3Jvc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkgKyBcIjAwMFwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNb250aE51bWJlcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbnV0ZXMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRTZWNvbmRzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyTW9uZGF5KGQpIHtcbiAgdmFyIGRheSA9IGQuZ2V0RGF5KCk7XG4gIHJldHVybiBkYXkgPT09IDAgPyA3IDogZGF5O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudGltZVN1bmRheS5jb3VudChkM1RpbWUudGltZVllYXIoZCkgLSAxLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJJU08oZCwgcCkge1xuICB2YXIgZGF5ID0gZC5nZXREYXkoKTtcbiAgZCA9IChkYXkgPj0gNCB8fCBkYXkgPT09IDApID8gZDNUaW1lLnRpbWVUaHVyc2RheShkKSA6IGQzVGltZS50aW1lVGh1cnNkYXkuY2VpbChkKTtcbiAgcmV0dXJuIHBhZChkM1RpbWUudGltZVRodXJzZGF5LmNvdW50KGQzVGltZS50aW1lWWVhcihkKSwgZCkgKyAoZDNUaW1lLnRpbWVZZWFyKGQpLmdldERheSgpID09PSA0KSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtkYXlOdW1iZXJTdW5kYXkoZCkge1xuICByZXR1cm4gZC5nZXREYXkoKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlck1vbmRheShkLCBwKSB7XG4gIHJldHVybiBwYWQoZDNUaW1lLnRpbWVNb25kYXkuY291bnQoZDNUaW1lLnRpbWVZZWFyKGQpIC0gMSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRGdWxsWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwMDAsIHAsIDQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRab25lKGQpIHtcbiAgdmFyIHogPSBkLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIHJldHVybiAoeiA+IDAgPyBcIi1cIiA6ICh6ICo9IC0xLCBcIitcIikpXG4gICAgICArIHBhZCh6IC8gNjAgfCAwLCBcIjBcIiwgMilcbiAgICAgICsgcGFkKHogJSA2MCwgXCIwXCIsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENEYXlPZk1vbnRoKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0RhdGUoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIyNChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDSG91cjEyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0hvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoMSArIGQzVGltZS51dGNEYXkuY291bnQoZDNUaW1lLnV0Y1llYXIoZCksIGQpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01pbGxpc2Vjb25kcygpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWljcm9zZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSArIFwiMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoTnVtYmVyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWludXRlcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNaW51dGVzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENTZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ1NlY29uZHMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJNb25kYXkoZCkge1xuICB2YXIgZG93ID0gZC5nZXRVVENEYXkoKTtcbiAgcmV0dXJuIGRvdyA9PT0gMCA/IDcgOiBkb3c7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKGQzVGltZS51dGNTdW5kYXkuY291bnQoZDNUaW1lLnV0Y1llYXIoZCkgLSAxLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJJU08oZCwgcCkge1xuICB2YXIgZGF5ID0gZC5nZXRVVENEYXkoKTtcbiAgZCA9IChkYXkgPj0gNCB8fCBkYXkgPT09IDApID8gZDNUaW1lLnV0Y1RodXJzZGF5KGQpIDogZDNUaW1lLnV0Y1RodXJzZGF5LmNlaWwoZCk7XG4gIHJldHVybiBwYWQoZDNUaW1lLnV0Y1RodXJzZGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSArIChkM1RpbWUudXRjWWVhcihkKS5nZXRVVENEYXkoKSA9PT0gNCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyU3VuZGF5KGQpIHtcbiAgcmV0dXJuIGQuZ2V0VVRDRGF5KCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKGQzVGltZS51dGNNb25kYXkuY291bnQoZDNUaW1lLnV0Y1llYXIoZCkgLSAxLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1llYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0Z1bGxZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1pvbmUoKSB7XG4gIHJldHVybiBcIiswMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExpdGVyYWxQZXJjZW50KCkge1xuICByZXR1cm4gXCIlXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuaXhUaW1lc3RhbXAoZCkge1xuICByZXR1cm4gK2Q7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuaXhUaW1lc3RhbXBTZWNvbmRzKGQpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoK2QgLyAxMDAwKTtcbn1cblxudmFyIGxvY2FsZTtcblxuZGVmYXVsdExvY2FsZSh7XG4gIGRhdGVUaW1lOiBcIiV4LCAlWFwiLFxuICBkYXRlOiBcIiUtbS8lLWQvJVlcIixcbiAgdGltZTogXCIlLUk6JU06JVMgJXBcIixcbiAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG59KTtcblxuZnVuY3Rpb24gZGVmYXVsdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIGxvY2FsZSA9IGZvcm1hdExvY2FsZShkZWZpbml0aW9uKTtcbiAgZXhwb3J0cy50aW1lRm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgZXhwb3J0cy50aW1lUGFyc2UgPSBsb2NhbGUucGFyc2U7XG4gIGV4cG9ydHMudXRjRm9ybWF0ID0gbG9jYWxlLnV0Y0Zvcm1hdDtcbiAgZXhwb3J0cy51dGNQYXJzZSA9IGxvY2FsZS51dGNQYXJzZTtcbiAgcmV0dXJuIGxvY2FsZTtcbn1cblxudmFyIGlzb1NwZWNpZmllciA9IFwiJVktJW0tJWRUJUg6JU06JVMuJUxaXCI7XG5cbmZ1bmN0aW9uIGZvcm1hdElzb05hdGl2ZShkYXRlKSB7XG4gIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG59XG5cbnZhciBmb3JtYXRJc28gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZ1xuICAgID8gZm9ybWF0SXNvTmF0aXZlXG4gICAgOiBleHBvcnRzLnV0Y0Zvcm1hdChpc29TcGVjaWZpZXIpO1xuXG5mdW5jdGlvbiBwYXJzZUlzb05hdGl2ZShzdHJpbmcpIHtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZShzdHJpbmcpO1xuICByZXR1cm4gaXNOYU4oZGF0ZSkgPyBudWxsIDogZGF0ZTtcbn1cblxudmFyIHBhcnNlSXNvID0gK25ldyBEYXRlKFwiMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIpXG4gICAgPyBwYXJzZUlzb05hdGl2ZVxuICAgIDogZXhwb3J0cy51dGNQYXJzZShpc29TcGVjaWZpZXIpO1xuXG5leHBvcnRzLmlzb0Zvcm1hdCA9IGZvcm1hdElzbztcbmV4cG9ydHMuaXNvUGFyc2UgPSBwYXJzZUlzbztcbmV4cG9ydHMudGltZUZvcm1hdERlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuZXhwb3J0cy50aW1lRm9ybWF0TG9jYWxlID0gZm9ybWF0TG9jYWxlO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXRpbWUvIHYxLjEuMCBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciB0MCA9IG5ldyBEYXRlLFxuICAgIHQxID0gbmV3IERhdGU7XG5cbmZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQsIGZpZWxkKSB7XG5cbiAgZnVuY3Rpb24gaW50ZXJ2YWwoZGF0ZSkge1xuICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyBuZXcgRGF0ZSA6IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gIH1cblxuICBpbnRlcnZhbC5mbG9vciA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSkpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLmNlaWwgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoZGF0ZSAtIDEpKSwgb2Zmc2V0aShkYXRlLCAxKSwgZmxvb3JpKGRhdGUpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkMCA9IGludGVydmFsKGRhdGUpLFxuICAgICAgICBkMSA9IGludGVydmFsLmNlaWwoZGF0ZSk7XG4gICAgcmV0dXJuIGRhdGUgLSBkMCA8IGQxIC0gZGF0ZSA/IGQwIDogZDE7XG4gIH07XG5cbiAgaW50ZXJ2YWwub2Zmc2V0ID0gZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIHJldHVybiBvZmZzZXRpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSksIHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApKSwgZGF0ZTtcbiAgfTtcblxuICBpbnRlcnZhbC5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgdmFyIHJhbmdlID0gW10sIHByZXZpb3VzO1xuICAgIHN0YXJ0ID0gaW50ZXJ2YWwuY2VpbChzdGFydCk7XG4gICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApO1xuICAgIGlmICghKHN0YXJ0IDwgc3RvcCkgfHwgIShzdGVwID4gMCkpIHJldHVybiByYW5nZTsgLy8gYWxzbyBoYW5kbGVzIEludmFsaWQgRGF0ZVxuICAgIGRvIHJhbmdlLnB1c2gocHJldmlvdXMgPSBuZXcgRGF0ZSgrc3RhcnQpKSwgb2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCk7XG4gICAgd2hpbGUgKHByZXZpb3VzIDwgc3RhcnQgJiYgc3RhcnQgPCBzdG9wKTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB3aGlsZSAoZmxvb3JpKGRhdGUpLCAhdGVzdChkYXRlKSkgZGF0ZS5zZXRUaW1lKGRhdGUgLSAxKTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB7XG4gICAgICAgIGlmIChzdGVwIDwgMCkgd2hpbGUgKCsrc3RlcCA8PSAwKSB7XG4gICAgICAgICAgd2hpbGUgKG9mZnNldGkoZGF0ZSwgLTEpLCAhdGVzdChkYXRlKSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9IGVsc2Ugd2hpbGUgKC0tc3RlcCA+PSAwKSB7XG4gICAgICAgICAgd2hpbGUgKG9mZnNldGkoZGF0ZSwgKzEpLCAhdGVzdChkYXRlKSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKGNvdW50KSB7XG4gICAgaW50ZXJ2YWwuY291bnQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB0MC5zZXRUaW1lKCtzdGFydCksIHQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAsIHQxKSk7XG4gICAgfTtcblxuICAgIGludGVydmFsLmV2ZXJ5ID0gZnVuY3Rpb24oc3RlcCkge1xuICAgICAgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICByZXR1cm4gIWlzRmluaXRlKHN0ZXApIHx8ICEoc3RlcCA+IDApID8gbnVsbFxuICAgICAgICAgIDogIShzdGVwID4gMSkgPyBpbnRlcnZhbFxuICAgICAgICAgIDogaW50ZXJ2YWwuZmlsdGVyKGZpZWxkXG4gICAgICAgICAgICAgID8gZnVuY3Rpb24oZCkgeyByZXR1cm4gZmllbGQoZCkgJSBzdGVwID09PSAwOyB9XG4gICAgICAgICAgICAgIDogZnVuY3Rpb24oZCkgeyByZXR1cm4gaW50ZXJ2YWwuY291bnQoMCwgZCkgJSBzdGVwID09PSAwOyB9KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGludGVydmFsO1xufVxuXG52YXIgbWlsbGlzZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgLy8gbm9vcFxufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbm1pbGxpc2Vjb25kLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICBrID0gTWF0aC5mbG9vcihrKTtcbiAgaWYgKCFpc0Zpbml0ZShrKSB8fCAhKGsgPiAwKSkgcmV0dXJuIG51bGw7XG4gIGlmICghKGsgPiAxKSkgcmV0dXJuIG1pbGxpc2Vjb25kO1xuICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKGRhdGUgLyBrKSAqIGspO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGspO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBrO1xuICB9KTtcbn07XG52YXIgbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmQucmFuZ2U7XG5cbnZhciBkdXJhdGlvblNlY29uZCA9IDFlMztcbnZhciBkdXJhdGlvbk1pbnV0ZSA9IDZlNDtcbnZhciBkdXJhdGlvbkhvdXIgPSAzNmU1O1xudmFyIGR1cmF0aW9uRGF5ID0gODY0ZTU7XG52YXIgZHVyYXRpb25XZWVrID0gNjA0OGU1O1xuXG52YXIgc2Vjb25kID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFRpbWUoZGF0ZSAtIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25TZWNvbmQpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uU2Vjb25kO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XG59KTtcbnZhciBzZWNvbmRzID0gc2Vjb25kLnJhbmdlO1xuXG52YXIgbWludXRlID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFRpbWUoZGF0ZSAtIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgLSBkYXRlLmdldFNlY29uZHMoKSAqIGR1cmF0aW9uU2Vjb25kKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uTWludXRlKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbk1pbnV0ZTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0TWludXRlcygpO1xufSk7XG52YXIgbWludXRlcyA9IG1pbnV0ZS5yYW5nZTtcblxudmFyIGhvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShkYXRlIC0gZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAtIGRhdGUuZ2V0U2Vjb25kcygpICogZHVyYXRpb25TZWNvbmQgLSBkYXRlLmdldE1pbnV0ZXMoKSAqIGR1cmF0aW9uTWludXRlKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uSG91cik7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25Ib3VyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRIb3VycygpO1xufSk7XG52YXIgaG91cnMgPSBob3VyLnJhbmdlO1xuXG52YXIgZGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogZHVyYXRpb25NaW51dGUpIC8gZHVyYXRpb25EYXk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldERhdGUoKSAtIDE7XG59KTtcbnZhciBkYXlzID0gZGF5LnJhbmdlO1xuXG5mdW5jdGlvbiB3ZWVrZGF5KGkpIHtcbiAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAoZGF0ZS5nZXREYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwICogNyk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiBkdXJhdGlvbk1pbnV0ZSkgLyBkdXJhdGlvbldlZWs7XG4gIH0pO1xufVxuXG52YXIgc3VuZGF5ID0gd2Vla2RheSgwKTtcbnZhciBtb25kYXkgPSB3ZWVrZGF5KDEpO1xudmFyIHR1ZXNkYXkgPSB3ZWVrZGF5KDIpO1xudmFyIHdlZG5lc2RheSA9IHdlZWtkYXkoMyk7XG52YXIgdGh1cnNkYXkgPSB3ZWVrZGF5KDQpO1xudmFyIGZyaWRheSA9IHdlZWtkYXkoNSk7XG52YXIgc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xuXG52YXIgc3VuZGF5cyA9IHN1bmRheS5yYW5nZTtcbnZhciBtb25kYXlzID0gbW9uZGF5LnJhbmdlO1xudmFyIHR1ZXNkYXlzID0gdHVlc2RheS5yYW5nZTtcbnZhciB3ZWRuZXNkYXlzID0gd2VkbmVzZGF5LnJhbmdlO1xudmFyIHRodXJzZGF5cyA9IHRodXJzZGF5LnJhbmdlO1xudmFyIGZyaWRheXMgPSBmcmlkYXkucmFuZ2U7XG52YXIgc2F0dXJkYXlzID0gc2F0dXJkYXkucmFuZ2U7XG5cbnZhciBtb250aCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXREYXRlKDEpO1xuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldE1vbnRoKCkgLSBzdGFydC5nZXRNb250aCgpICsgKGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKSkgKiAxMjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcbn0pO1xudmFyIG1vbnRocyA9IG1vbnRoLnJhbmdlO1xuXG52YXIgeWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG55ZWFyLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICByZXR1cm4gIWlzRmluaXRlKGsgPSBNYXRoLmZsb29yKGspKSB8fCAhKGsgPiAwKSA/IG51bGwgOiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihNYXRoLmZsb29yKGRhdGUuZ2V0RnVsbFllYXIoKSAvIGspICogayk7XG4gICAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBzdGVwICogayk7XG4gIH0pO1xufTtcbnZhciB5ZWFycyA9IHllYXIucmFuZ2U7XG5cbnZhciB1dGNNaW51dGUgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDU2Vjb25kcygwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uTWludXRlKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbk1pbnV0ZTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDTWludXRlcygpO1xufSk7XG52YXIgdXRjTWludXRlcyA9IHV0Y01pbnV0ZS5yYW5nZTtcblxudmFyIHV0Y0hvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDTWludXRlcygwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uSG91cik7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25Ib3VyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENIb3VycygpO1xufSk7XG52YXIgdXRjSG91cnMgPSB1dGNIb3VyLnJhbmdlO1xuXG52YXIgdXRjRGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkRheTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRGF0ZSgpIC0gMTtcbn0pO1xudmFyIHV0Y0RheXMgPSB1dGNEYXkucmFuZ2U7XG5cbmZ1bmN0aW9uIHV0Y1dlZWtkYXkoaSkge1xuICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIChkYXRlLmdldFVUQ0RheSgpICsgNyAtIGkpICUgNyk7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXAgKiA3KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25XZWVrO1xuICB9KTtcbn1cblxudmFyIHV0Y1N1bmRheSA9IHV0Y1dlZWtkYXkoMCk7XG52YXIgdXRjTW9uZGF5ID0gdXRjV2Vla2RheSgxKTtcbnZhciB1dGNUdWVzZGF5ID0gdXRjV2Vla2RheSgyKTtcbnZhciB1dGNXZWRuZXNkYXkgPSB1dGNXZWVrZGF5KDMpO1xudmFyIHV0Y1RodXJzZGF5ID0gdXRjV2Vla2RheSg0KTtcbnZhciB1dGNGcmlkYXkgPSB1dGNXZWVrZGF5KDUpO1xudmFyIHV0Y1NhdHVyZGF5ID0gdXRjV2Vla2RheSg2KTtcblxudmFyIHV0Y1N1bmRheXMgPSB1dGNTdW5kYXkucmFuZ2U7XG52YXIgdXRjTW9uZGF5cyA9IHV0Y01vbmRheS5yYW5nZTtcbnZhciB1dGNUdWVzZGF5cyA9IHV0Y1R1ZXNkYXkucmFuZ2U7XG52YXIgdXRjV2VkbmVzZGF5cyA9IHV0Y1dlZG5lc2RheS5yYW5nZTtcbnZhciB1dGNUaHVyc2RheXMgPSB1dGNUaHVyc2RheS5yYW5nZTtcbnZhciB1dGNGcmlkYXlzID0gdXRjRnJpZGF5LnJhbmdlO1xudmFyIHV0Y1NhdHVyZGF5cyA9IHV0Y1NhdHVyZGF5LnJhbmdlO1xuXG52YXIgdXRjTW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDRGF0ZSgxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENNb250aChkYXRlLmdldFVUQ01vbnRoKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRVVENNb250aCgpIC0gc3RhcnQuZ2V0VVRDTW9udGgoKSArIChlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCkpICogMTI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ01vbnRoKCk7XG59KTtcbnZhciB1dGNNb250aHMgPSB1dGNNb250aC5yYW5nZTtcblxudmFyIHV0Y1llYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxudXRjWWVhci5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgcmV0dXJuICFpc0Zpbml0ZShrID0gTWF0aC5mbG9vcihrKSkgfHwgIShrID4gMCkgPyBudWxsIDogbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoTWF0aC5mbG9vcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLyBrKSAqIGspO1xuICAgIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgc3RlcCAqIGspO1xuICB9KTtcbn07XG52YXIgdXRjWWVhcnMgPSB1dGNZZWFyLnJhbmdlO1xuXG5leHBvcnRzLnRpbWVEYXkgPSBkYXk7XG5leHBvcnRzLnRpbWVEYXlzID0gZGF5cztcbmV4cG9ydHMudGltZUZyaWRheSA9IGZyaWRheTtcbmV4cG9ydHMudGltZUZyaWRheXMgPSBmcmlkYXlzO1xuZXhwb3J0cy50aW1lSG91ciA9IGhvdXI7XG5leHBvcnRzLnRpbWVIb3VycyA9IGhvdXJzO1xuZXhwb3J0cy50aW1lSW50ZXJ2YWwgPSBuZXdJbnRlcnZhbDtcbmV4cG9ydHMudGltZU1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmQ7XG5leHBvcnRzLnRpbWVNaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHM7XG5leHBvcnRzLnRpbWVNaW51dGUgPSBtaW51dGU7XG5leHBvcnRzLnRpbWVNaW51dGVzID0gbWludXRlcztcbmV4cG9ydHMudGltZU1vbmRheSA9IG1vbmRheTtcbmV4cG9ydHMudGltZU1vbmRheXMgPSBtb25kYXlzO1xuZXhwb3J0cy50aW1lTW9udGggPSBtb250aDtcbmV4cG9ydHMudGltZU1vbnRocyA9IG1vbnRocztcbmV4cG9ydHMudGltZVNhdHVyZGF5ID0gc2F0dXJkYXk7XG5leHBvcnRzLnRpbWVTYXR1cmRheXMgPSBzYXR1cmRheXM7XG5leHBvcnRzLnRpbWVTZWNvbmQgPSBzZWNvbmQ7XG5leHBvcnRzLnRpbWVTZWNvbmRzID0gc2Vjb25kcztcbmV4cG9ydHMudGltZVN1bmRheSA9IHN1bmRheTtcbmV4cG9ydHMudGltZVN1bmRheXMgPSBzdW5kYXlzO1xuZXhwb3J0cy50aW1lVGh1cnNkYXkgPSB0aHVyc2RheTtcbmV4cG9ydHMudGltZVRodXJzZGF5cyA9IHRodXJzZGF5cztcbmV4cG9ydHMudGltZVR1ZXNkYXkgPSB0dWVzZGF5O1xuZXhwb3J0cy50aW1lVHVlc2RheXMgPSB0dWVzZGF5cztcbmV4cG9ydHMudGltZVdlZG5lc2RheSA9IHdlZG5lc2RheTtcbmV4cG9ydHMudGltZVdlZG5lc2RheXMgPSB3ZWRuZXNkYXlzO1xuZXhwb3J0cy50aW1lV2VlayA9IHN1bmRheTtcbmV4cG9ydHMudGltZVdlZWtzID0gc3VuZGF5cztcbmV4cG9ydHMudGltZVllYXIgPSB5ZWFyO1xuZXhwb3J0cy50aW1lWWVhcnMgPSB5ZWFycztcbmV4cG9ydHMudXRjRGF5ID0gdXRjRGF5O1xuZXhwb3J0cy51dGNEYXlzID0gdXRjRGF5cztcbmV4cG9ydHMudXRjRnJpZGF5ID0gdXRjRnJpZGF5O1xuZXhwb3J0cy51dGNGcmlkYXlzID0gdXRjRnJpZGF5cztcbmV4cG9ydHMudXRjSG91ciA9IHV0Y0hvdXI7XG5leHBvcnRzLnV0Y0hvdXJzID0gdXRjSG91cnM7XG5leHBvcnRzLnV0Y01pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmQ7XG5leHBvcnRzLnV0Y01pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcbmV4cG9ydHMudXRjTWludXRlID0gdXRjTWludXRlO1xuZXhwb3J0cy51dGNNaW51dGVzID0gdXRjTWludXRlcztcbmV4cG9ydHMudXRjTW9uZGF5ID0gdXRjTW9uZGF5O1xuZXhwb3J0cy51dGNNb25kYXlzID0gdXRjTW9uZGF5cztcbmV4cG9ydHMudXRjTW9udGggPSB1dGNNb250aDtcbmV4cG9ydHMudXRjTW9udGhzID0gdXRjTW9udGhzO1xuZXhwb3J0cy51dGNTYXR1cmRheSA9IHV0Y1NhdHVyZGF5O1xuZXhwb3J0cy51dGNTYXR1cmRheXMgPSB1dGNTYXR1cmRheXM7XG5leHBvcnRzLnV0Y1NlY29uZCA9IHNlY29uZDtcbmV4cG9ydHMudXRjU2Vjb25kcyA9IHNlY29uZHM7XG5leHBvcnRzLnV0Y1N1bmRheSA9IHV0Y1N1bmRheTtcbmV4cG9ydHMudXRjU3VuZGF5cyA9IHV0Y1N1bmRheXM7XG5leHBvcnRzLnV0Y1RodXJzZGF5ID0gdXRjVGh1cnNkYXk7XG5leHBvcnRzLnV0Y1RodXJzZGF5cyA9IHV0Y1RodXJzZGF5cztcbmV4cG9ydHMudXRjVHVlc2RheSA9IHV0Y1R1ZXNkYXk7XG5leHBvcnRzLnV0Y1R1ZXNkYXlzID0gdXRjVHVlc2RheXM7XG5leHBvcnRzLnV0Y1dlZG5lc2RheSA9IHV0Y1dlZG5lc2RheTtcbmV4cG9ydHMudXRjV2VkbmVzZGF5cyA9IHV0Y1dlZG5lc2RheXM7XG5leHBvcnRzLnV0Y1dlZWsgPSB1dGNTdW5kYXk7XG5leHBvcnRzLnV0Y1dlZWtzID0gdXRjU3VuZGF5cztcbmV4cG9ydHMudXRjWWVhciA9IHV0Y1llYXI7XG5leHBvcnRzLnV0Y1llYXJzID0gdXRjWWVhcnM7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtdGltZXIvIHYxLjAuMTAgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnJhbWUgPSAwLCAvLyBpcyBhbiBhbmltYXRpb24gZnJhbWUgcGVuZGluZz9cbiAgICB0aW1lb3V0ID0gMCwgLy8gaXMgYSB0aW1lb3V0IHBlbmRpbmc/XG4gICAgaW50ZXJ2YWwgPSAwLCAvLyBhcmUgYW55IHRpbWVycyBhY3RpdmU/XG4gICAgcG9rZURlbGF5ID0gMTAwMCwgLy8gaG93IGZyZXF1ZW50bHkgd2UgY2hlY2sgZm9yIGNsb2NrIHNrZXdcbiAgICB0YXNrSGVhZCxcbiAgICB0YXNrVGFpbCxcbiAgICBjbG9ja0xhc3QgPSAwLFxuICAgIGNsb2NrTm93ID0gMCxcbiAgICBjbG9ja1NrZXcgPSAwLFxuICAgIGNsb2NrID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSBcIm9iamVjdFwiICYmIHBlcmZvcm1hbmNlLm5vdyA/IHBlcmZvcm1hbmNlIDogRGF0ZSxcbiAgICBzZXRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIDogZnVuY3Rpb24oZikgeyBzZXRUaW1lb3V0KGYsIDE3KTsgfTtcblxuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gY2xvY2tOb3cgfHwgKHNldEZyYW1lKGNsZWFyTm93KSwgY2xvY2tOb3cgPSBjbG9jay5ub3coKSArIGNsb2NrU2tldyk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyTm93KCkge1xuICBjbG9ja05vdyA9IDA7XG59XG5cbmZ1bmN0aW9uIFRpbWVyKCkge1xuICB0aGlzLl9jYWxsID1cbiAgdGhpcy5fdGltZSA9XG4gIHRoaXMuX25leHQgPSBudWxsO1xufVxuXG5UaW1lci5wcm90b3R5cGUgPSB0aW1lci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUaW1lcixcbiAgcmVzdGFydDogZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgdGltZSA9ICh0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lKSArIChkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheSk7XG4gICAgaWYgKCF0aGlzLl9uZXh0ICYmIHRhc2tUYWlsICE9PSB0aGlzKSB7XG4gICAgICBpZiAodGFza1RhaWwpIHRhc2tUYWlsLl9uZXh0ID0gdGhpcztcbiAgICAgIGVsc2UgdGFza0hlYWQgPSB0aGlzO1xuICAgICAgdGFza1RhaWwgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9jYWxsID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgc2xlZXAoKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2NhbGwpIHtcbiAgICAgIHRoaXMuX2NhbGwgPSBudWxsO1xuICAgICAgdGhpcy5fdGltZSA9IEluZmluaXR5O1xuICAgICAgc2xlZXAoKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRpbWVyKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiB0aW1lckZsdXNoKCkge1xuICBub3coKTsgLy8gR2V0IHRoZSBjdXJyZW50IHRpbWUsIGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgKytmcmFtZTsgLy8gUHJldGVuZCB3ZeKAmXZlIHNldCBhbiBhbGFybSwgaWYgd2UgaGF2ZW7igJl0IGFscmVhZHkuXG4gIHZhciB0ID0gdGFza0hlYWQsIGU7XG4gIHdoaWxlICh0KSB7XG4gICAgaWYgKChlID0gY2xvY2tOb3cgLSB0Ll90aW1lKSA+PSAwKSB0Ll9jYWxsLmNhbGwobnVsbCwgZSk7XG4gICAgdCA9IHQuX25leHQ7XG4gIH1cbiAgLS1mcmFtZTtcbn1cblxuZnVuY3Rpb24gd2FrZSgpIHtcbiAgY2xvY2tOb3cgPSAoY2xvY2tMYXN0ID0gY2xvY2subm93KCkpICsgY2xvY2tTa2V3O1xuICBmcmFtZSA9IHRpbWVvdXQgPSAwO1xuICB0cnkge1xuICAgIHRpbWVyRmx1c2goKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmcmFtZSA9IDA7XG4gICAgbmFwKCk7XG4gICAgY2xvY2tOb3cgPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBva2UoKSB7XG4gIHZhciBub3cgPSBjbG9jay5ub3coKSwgZGVsYXkgPSBub3cgLSBjbG9ja0xhc3Q7XG4gIGlmIChkZWxheSA+IHBva2VEZWxheSkgY2xvY2tTa2V3IC09IGRlbGF5LCBjbG9ja0xhc3QgPSBub3c7XG59XG5cbmZ1bmN0aW9uIG5hcCgpIHtcbiAgdmFyIHQwLCB0MSA9IHRhc2tIZWFkLCB0MiwgdGltZSA9IEluZmluaXR5O1xuICB3aGlsZSAodDEpIHtcbiAgICBpZiAodDEuX2NhbGwpIHtcbiAgICAgIGlmICh0aW1lID4gdDEuX3RpbWUpIHRpbWUgPSB0MS5fdGltZTtcbiAgICAgIHQwID0gdDEsIHQxID0gdDEuX25leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQyID0gdDEuX25leHQsIHQxLl9uZXh0ID0gbnVsbDtcbiAgICAgIHQxID0gdDAgPyB0MC5fbmV4dCA9IHQyIDogdGFza0hlYWQgPSB0MjtcbiAgICB9XG4gIH1cbiAgdGFza1RhaWwgPSB0MDtcbiAgc2xlZXAodGltZSk7XG59XG5cbmZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgaWYgKGZyYW1lKSByZXR1cm47IC8vIFNvb25lc3QgYWxhcm0gYWxyZWFkeSBzZXQsIG9yIHdpbGwgYmUuXG4gIGlmICh0aW1lb3V0KSB0aW1lb3V0ID0gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB2YXIgZGVsYXkgPSB0aW1lIC0gY2xvY2tOb3c7IC8vIFN0cmljdGx5IGxlc3MgdGhhbiBpZiB3ZSByZWNvbXB1dGVkIGNsb2NrTm93LlxuICBpZiAoZGVsYXkgPiAyNCkge1xuICAgIGlmICh0aW1lIDwgSW5maW5pdHkpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHdha2UsIHRpbWUgLSBjbG9jay5ub3coKSAtIGNsb2NrU2tldyk7XG4gICAgaWYgKGludGVydmFsKSBpbnRlcnZhbCA9IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaW50ZXJ2YWwpIGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpLCBpbnRlcnZhbCA9IHNldEludGVydmFsKHBva2UsIHBva2VEZWxheSk7XG4gICAgZnJhbWUgPSAxLCBzZXRGcmFtZSh3YWtlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0aW1lb3V0JDEoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICBkZWxheSA9IGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5O1xuICB0LnJlc3RhcnQoZnVuY3Rpb24oZWxhcHNlZCkge1xuICAgIHQuc3RvcCgpO1xuICAgIGNhbGxiYWNrKGVsYXBzZWQgKyBkZWxheSk7XG4gIH0sIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGludGVydmFsJDEoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyLCB0b3RhbCA9IGRlbGF5O1xuICBpZiAoZGVsYXkgPT0gbnVsbCkgcmV0dXJuIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpLCB0O1xuICBkZWxheSA9ICtkZWxheSwgdGltZSA9IHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWU7XG4gIHQucmVzdGFydChmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICBlbGFwc2VkICs9IHRvdGFsO1xuICAgIHQucmVzdGFydCh0aWNrLCB0b3RhbCArPSBkZWxheSwgdGltZSk7XG4gICAgY2FsbGJhY2soZWxhcHNlZCk7XG4gIH0sIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydHMuaW50ZXJ2YWwgPSBpbnRlcnZhbCQxO1xuZXhwb3J0cy5ub3cgPSBub3c7XG5leHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0JDE7XG5leHBvcnRzLnRpbWVyID0gdGltZXI7XG5leHBvcnRzLnRpbWVyRmx1c2ggPSB0aW1lckZsdXNoO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXRyYW5zaXRpb24vIHYxLjMuMiBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLXNlbGVjdGlvbicpLCByZXF1aXJlKCdkMy1kaXNwYXRjaCcpLCByZXF1aXJlKCdkMy10aW1lcicpLCByZXF1aXJlKCdkMy1pbnRlcnBvbGF0ZScpLCByZXF1aXJlKCdkMy1jb2xvcicpLCByZXF1aXJlKCdkMy1lYXNlJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtc2VsZWN0aW9uJywgJ2QzLWRpc3BhdGNoJywgJ2QzLXRpbWVyJywgJ2QzLWludGVycG9sYXRlJywgJ2QzLWNvbG9yJywgJ2QzLWVhc2UnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSwgZ2xvYmFsLmQzLCBnbG9iYWwuZDMsIGdsb2JhbC5kMywgZ2xvYmFsLmQzLCBnbG9iYWwuZDMsIGdsb2JhbC5kMykpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNTZWxlY3Rpb24sIGQzRGlzcGF0Y2gsIGQzVGltZXIsIGQzSW50ZXJwb2xhdGUsIGQzQ29sb3IsIGQzRWFzZSkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9uID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcInN0YXJ0XCIsIFwiZW5kXCIsIFwiY2FuY2VsXCIsIFwiaW50ZXJydXB0XCIpO1xudmFyIGVtcHR5VHdlZW4gPSBbXTtcblxudmFyIENSRUFURUQgPSAwO1xudmFyIFNDSEVEVUxFRCA9IDE7XG52YXIgU1RBUlRJTkcgPSAyO1xudmFyIFNUQVJURUQgPSAzO1xudmFyIFJVTk5JTkcgPSA0O1xudmFyIEVORElORyA9IDU7XG52YXIgRU5ERUQgPSA2O1xuXG5mdW5jdGlvbiBzY2hlZHVsZShub2RlLCBuYW1lLCBpZCwgaW5kZXgsIGdyb3VwLCB0aW1pbmcpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlcykgbm9kZS5fX3RyYW5zaXRpb24gPSB7fTtcbiAgZWxzZSBpZiAoaWQgaW4gc2NoZWR1bGVzKSByZXR1cm47XG4gIGNyZWF0ZShub2RlLCBpZCwge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgaW5kZXg6IGluZGV4LCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgZ3JvdXA6IGdyb3VwLCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgb246IGVtcHR5T24sXG4gICAgdHdlZW46IGVtcHR5VHdlZW4sXG4gICAgdGltZTogdGltaW5nLnRpbWUsXG4gICAgZGVsYXk6IHRpbWluZy5kZWxheSxcbiAgICBkdXJhdGlvbjogdGltaW5nLmR1cmF0aW9uLFxuICAgIGVhc2U6IHRpbWluZy5lYXNlLFxuICAgIHRpbWVyOiBudWxsLFxuICAgIHN0YXRlOiBDUkVBVEVEXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IENSRUFURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5mdW5jdGlvbiBzZXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gU1RBUlRFRCkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGU7IGFscmVhZHkgcnVubmluZ1wiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5mdW5jdGlvbiBnZXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGUgfHwgIShzY2hlZHVsZSA9IHNjaGVkdWxlW2lkXSkpIHRocm93IG5ldyBFcnJvcihcInRyYW5zaXRpb24gbm90IGZvdW5kXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShub2RlLCBpZCwgc2VsZikge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICB0d2VlbjtcblxuICAvLyBJbml0aWFsaXplIHRoZSBzZWxmIHRpbWVyIHdoZW4gdGhlIHRyYW5zaXRpb24gaXMgY3JlYXRlZC5cbiAgLy8gTm90ZSB0aGUgYWN0dWFsIGRlbGF5IGlzIG5vdCBrbm93biB1bnRpbCB0aGUgZmlyc3QgY2FsbGJhY2shXG4gIHNjaGVkdWxlc1tpZF0gPSBzZWxmO1xuICBzZWxmLnRpbWVyID0gZDNUaW1lci50aW1lcihzY2hlZHVsZSwgMCwgc2VsZi50aW1lKTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZShlbGFwc2VkKSB7XG4gICAgc2VsZi5zdGF0ZSA9IFNDSEVEVUxFRDtcbiAgICBzZWxmLnRpbWVyLnJlc3RhcnQoc3RhcnQsIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG5cbiAgICAvLyBJZiB0aGUgZWxhcHNlZCBkZWxheSBpcyBsZXNzIHRoYW4gb3VyIGZpcnN0IHNsZWVwLCBzdGFydCBpbW1lZGlhdGVseS5cbiAgICBpZiAoc2VsZi5kZWxheSA8PSBlbGFwc2VkKSBzdGFydChlbGFwc2VkIC0gc2VsZi5kZWxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgdmFyIGksIGosIG4sIG87XG5cbiAgICAvLyBJZiB0aGUgc3RhdGUgaXMgbm90IFNDSEVEVUxFRCwgdGhlbiB3ZSBwcmV2aW91c2x5IGVycm9yZWQgb24gc3RhcnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNDSEVEVUxFRCkgcmV0dXJuIHN0b3AoKTtcblxuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIG8gPSBzY2hlZHVsZXNbaV07XG4gICAgICBpZiAoby5uYW1lICE9PSBzZWxmLm5hbWUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBXaGlsZSB0aGlzIGVsZW1lbnQgYWxyZWFkeSBoYXMgYSBzdGFydGluZyB0cmFuc2l0aW9uIGR1cmluZyB0aGlzIGZyYW1lLFxuICAgICAgLy8gZGVmZXIgc3RhcnRpbmcgYW4gaW50ZXJydXB0aW5nIHRyYW5zaXRpb24gdW50aWwgdGhhdCB0cmFuc2l0aW9uIGhhcyBhXG4gICAgICAvLyBjaGFuY2UgdG8gdGljayAoYW5kIHBvc3NpYmx5IGVuZCk7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzU0IVxuICAgICAgaWYgKG8uc3RhdGUgPT09IFNUQVJURUQpIHJldHVybiBkM1RpbWVyLnRpbWVvdXQoc3RhcnQpO1xuXG4gICAgICAvLyBJbnRlcnJ1cHQgdGhlIGFjdGl2ZSB0cmFuc2l0aW9uLCBpZiBhbnkuXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gUlVOTklORykge1xuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIG8udGltZXIuc3RvcCgpO1xuICAgICAgICBvLm9uLmNhbGwoXCJpbnRlcnJ1cHRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgby5pbmRleCwgby5ncm91cCk7XG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gICAgICB9XG5cbiAgICAgIC8vIENhbmNlbCBhbnkgcHJlLWVtcHRlZCB0cmFuc2l0aW9ucy5cbiAgICAgIGVsc2UgaWYgKCtpIDwgaWQpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiY2FuY2VsXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmVyIHRoZSBmaXJzdCB0aWNrIHRvIGVuZCBvZiB0aGUgY3VycmVudCBmcmFtZTsgc2VlIGQzL2QzIzE1NzYuXG4gICAgLy8gTm90ZSB0aGUgdHJhbnNpdGlvbiBtYXkgYmUgY2FuY2VsZWQgYWZ0ZXIgc3RhcnQgYW5kIGJlZm9yZSB0aGUgZmlyc3QgdGljayFcbiAgICAvLyBOb3RlIHRoaXMgbXVzdCBiZSBzY2hlZHVsZWQgYmVmb3JlIHRoZSBzdGFydCBldmVudDsgc2VlIGQzL2QzLXRyYW5zaXRpb24jMTYhXG4gICAgLy8gQXNzdW1pbmcgdGhpcyBpcyBzdWNjZXNzZnVsLCBzdWJzZXF1ZW50IGNhbGxiYWNrcyBnbyBzdHJhaWdodCB0byB0aWNrLlxuICAgIGQzVGltZXIudGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBTVEFSVEVEKSB7XG4gICAgICAgIHNlbGYuc3RhdGUgPSBSVU5OSU5HO1xuICAgICAgICBzZWxmLnRpbWVyLnJlc3RhcnQodGljaywgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcbiAgICAgICAgdGljayhlbGFwc2VkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERpc3BhdGNoIHRoZSBzdGFydCBldmVudC5cbiAgICAvLyBOb3RlIHRoaXMgbXVzdCBiZSBkb25lIGJlZm9yZSB0aGUgdHdlZW4gYXJlIGluaXRpYWxpemVkLlxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVElORztcbiAgICBzZWxmLm9uLmNhbGwoXCJzdGFydFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcbiAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gU1RBUlRJTkcpIHJldHVybjsgLy8gaW50ZXJydXB0ZWRcbiAgICBzZWxmLnN0YXRlID0gU1RBUlRFRDtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHR3ZWVuLCBkZWxldGluZyBudWxsIHR3ZWVuLlxuICAgIHR3ZWVuID0gbmV3IEFycmF5KG4gPSBzZWxmLnR3ZWVuLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgaiA9IC0xOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobyA9IHNlbGYudHdlZW5baV0udmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKSkge1xuICAgICAgICB0d2VlblsrK2pdID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgdHdlZW4ubGVuZ3RoID0gaiArIDE7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICB2YXIgdCA9IGVsYXBzZWQgPCBzZWxmLmR1cmF0aW9uID8gc2VsZi5lYXNlLmNhbGwobnVsbCwgZWxhcHNlZCAvIHNlbGYuZHVyYXRpb24pIDogKHNlbGYudGltZXIucmVzdGFydChzdG9wKSwgc2VsZi5zdGF0ZSA9IEVORElORywgMSksXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IHR3ZWVuLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICB0d2VlbltpXS5jYWxsKG5vZGUsIHQpO1xuICAgIH1cblxuICAgIC8vIERpc3BhdGNoIHRoZSBlbmQgZXZlbnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgPT09IEVORElORykge1xuICAgICAgc2VsZi5vbi5jYWxsKFwiZW5kXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgICAgc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgc2VsZi5zdGF0ZSA9IEVOREVEO1xuICAgIHNlbGYudGltZXIuc3RvcCgpO1xuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaWRdO1xuICAgIGZvciAodmFyIGkgaW4gc2NoZWR1bGVzKSByZXR1cm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJydXB0KG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBhY3RpdmUsXG4gICAgICBlbXB0eSA9IHRydWUsXG4gICAgICBpO1xuXG4gIGlmICghc2NoZWR1bGVzKSByZXR1cm47XG5cbiAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcblxuICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkubmFtZSAhPT0gbmFtZSkgeyBlbXB0eSA9IGZhbHNlOyBjb250aW51ZTsgfVxuICAgIGFjdGl2ZSA9IHNjaGVkdWxlLnN0YXRlID4gU1RBUlRJTkcgJiYgc2NoZWR1bGUuc3RhdGUgPCBFTkRJTkc7XG4gICAgc2NoZWR1bGUuc3RhdGUgPSBFTkRFRDtcbiAgICBzY2hlZHVsZS50aW1lci5zdG9wKCk7XG4gICAgc2NoZWR1bGUub24uY2FsbChhY3RpdmUgPyBcImludGVycnVwdFwiIDogXCJjYW5jZWxcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2NoZWR1bGUuaW5kZXgsIHNjaGVkdWxlLmdyb3VwKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICB9XG5cbiAgaWYgKGVtcHR5KSBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9pbnRlcnJ1cHQobmFtZSkge1xuICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIGludGVycnVwdCh0aGlzLCBuYW1lKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHR3ZWVuUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSB0d2VlbjAgPSB0d2VlbjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjEgPSB0d2VlbjEuc2xpY2UoKTtcbiAgICAgICAgICB0d2VlbjEuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHR3ZWVuRnVuY3Rpb24oaWQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlLnR3ZWVuO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xuICAgICAgdHdlZW4xID0gKHR3ZWVuMCA9IHR3ZWVuKS5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgdCA9IHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9LCBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xW2ldID0gdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPT09IG4pIHR3ZWVuMS5wdXNoKHQpO1xuICAgIH1cblxuICAgIHNjaGVkdWxlLnR3ZWVuID0gdHdlZW4xO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3R3ZWVuKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIG5hbWUgKz0gXCJcIjtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgdHdlZW4gPSBnZXQodGhpcy5ub2RlKCksIGlkKS50d2VlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuLmxlbmd0aCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh0ID0gdHdlZW5baV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbCA/IHR3ZWVuUmVtb3ZlIDogdHdlZW5GdW5jdGlvbikoaWQsIG5hbWUsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIHR3ZWVuVmFsdWUodHJhbnNpdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdHJhbnNpdGlvbi5faWQ7XG5cbiAgdHJhbnNpdGlvbi5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCk7XG4gICAgKHNjaGVkdWxlLnZhbHVlIHx8IChzY2hlZHVsZS52YWx1ZSA9IHt9KSlbbmFtZV0gPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBnZXQobm9kZSwgaWQpLnZhbHVlW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShhLCBiKSB7XG4gIHZhciBjO1xuICByZXR1cm4gKHR5cGVvZiBiID09PSBcIm51bWJlclwiID8gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZU51bWJlclxuICAgICAgOiBiIGluc3RhbmNlb2YgZDNDb2xvci5jb2xvciA/IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVSZ2JcbiAgICAgIDogKGMgPSBkM0NvbG9yLmNvbG9yKGIpKSA/IChiID0gYywgZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVJnYilcbiAgICAgIDogZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVN0cmluZykoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCwgdmFsdWUxID0gdmFsdWUodGhpcyksIHN0cmluZzE7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpLCBzdHJpbmcxO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX2F0dHIobmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gZDNTZWxlY3Rpb24ubmFtZXNwYWNlKG5hbWUpLCBpID0gZnVsbG5hbWUgPT09IFwidHJhbnNmb3JtXCIgPyBkM0ludGVycG9sYXRlLmludGVycG9sYXRlVHJhbnNmb3JtU3ZnIDogaW50ZXJwb2xhdGU7XG4gIHJldHVybiB0aGlzLmF0dHJUd2VlbihuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbikoZnVsbG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJhdHRyLlwiICsgbmFtZSwgdmFsdWUpKVxuICAgICAgOiB2YWx1ZSA9PSBudWxsID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkoZnVsbG5hbWUpXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KShmdWxsbmFtZSwgaSwgdmFsdWUpKTtcbn1cblxuZnVuY3Rpb24gYXR0ckludGVycG9sYXRlKG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBpLmNhbGwodGhpcywgdCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRySW50ZXJwb2xhdGVOUyhmdWxsbmFtZSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCBpLmNhbGwodGhpcywgdCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW5OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiBhdHRySW50ZXJwb2xhdGVOUyhmdWxsbmFtZSwgaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmZ1bmN0aW9uIGF0dHJUd2VlbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIGF0dHJJbnRlcnBvbGF0ZShuYW1lLCBpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9hdHRyVHdlZW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGtleSA9IFwiYXR0ci5cIiArIG5hbWU7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgdmFyIGZ1bGxuYW1lID0gZDNTZWxlY3Rpb24ubmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIChmdWxsbmFtZS5sb2NhbCA/IGF0dHJUd2Vlbk5TIDogYXR0clR3ZWVuKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cblxuZnVuY3Rpb24gZGVsYXlGdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlbGF5Q29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9kZWxheSh2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBkZWxheUZ1bmN0aW9uXG4gICAgICAgICAgOiBkZWxheUNvbnN0YW50KShpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5kZWxheTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25GdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Db25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fZHVyYXRpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZHVyYXRpb25GdW5jdGlvblxuICAgICAgICAgIDogZHVyYXRpb25Db25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIGVhc2VDb25zdGFudChpZCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmVhc2UgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9lYXNlKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaChlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZWFzZTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9maWx0ZXIobWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IGQzU2VsZWN0aW9uLm1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9tZXJnZSh0cmFuc2l0aW9uKSB7XG4gIGlmICh0cmFuc2l0aW9uLl9pZCAhPT0gdGhpcy5faWQpIHRocm93IG5ldyBFcnJvcjtcblxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gdHJhbnNpdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0KG5hbWUpIHtcbiAgcmV0dXJuIChuYW1lICsgXCJcIikudHJpbSgpLnNwbGl0KC9efFxccysvKS5ldmVyeShmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiAhdCB8fCB0ID09PSBcInN0YXJ0XCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgb24wLCBvbjEsIHNpdCA9IHN0YXJ0KG5hbWUpID8gaW5pdCA6IHNldDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNpdCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub247XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjApIChvbjEgPSAob24wID0gb24pLmNvcHkoKSkub24obmFtZSwgbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyXG4gICAgICA/IGdldCh0aGlzLm5vZGUoKSwgaWQpLm9uLm9uKG5hbWUpXG4gICAgICA6IHRoaXMuZWFjaChvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVGdW5jdGlvbihpZCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuX190cmFuc2l0aW9uKSBpZiAoK2kgIT09IGlkKSByZXR1cm47XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3JlbW92ZSgpIHtcbiAgcmV0dXJuIHRoaXMub24oXCJlbmQucmVtb3ZlXCIsIHJlbW92ZUZ1bmN0aW9uKHRoaXMuX2lkKSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fc2VsZWN0KHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IGQzU2VsZWN0aW9uLnNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgICBzY2hlZHVsZShzdWJncm91cFtpXSwgbmFtZSwgaWQsIGksIHN1Ymdyb3VwLCBnZXQobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fc2VsZWN0QWxsKHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IGQzU2VsZWN0aW9uLnNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGRyZW4gPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCksIGNoaWxkLCBpbmhlcml0ID0gZ2V0KG5vZGUsIGlkKSwgayA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGsgPCBsOyArK2spIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPSBjaGlsZHJlbltrXSkge1xuICAgICAgICAgICAgc2NoZWR1bGUoY2hpbGQsIG5hbWUsIGlkLCBrLCBjaGlsZHJlbiwgaW5oZXJpdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKGNoaWxkcmVuKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKTtcbn1cblxudmFyIFNlbGVjdGlvbiA9IGQzU2VsZWN0aW9uLnNlbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3I7XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fc2VsZWN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9ncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuXG5mdW5jdGlvbiBzdHlsZU51bGwobmFtZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IGQzU2VsZWN0aW9uLnN0eWxlKHRoaXMsIG5hbWUpLFxuICAgICAgICBzdHJpbmcxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIGQzU2VsZWN0aW9uLnN0eWxlKHRoaXMsIG5hbWUpKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgc3RyaW5nMTAgPSBzdHJpbmcxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBkM1NlbGVjdGlvbi5zdHlsZSh0aGlzLCBuYW1lKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IGQzU2VsZWN0aW9uLnN0eWxlKHRoaXMsIG5hbWUpLFxuICAgICAgICB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSxcbiAgICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSBzdHJpbmcxID0gdmFsdWUxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIGQzU2VsZWN0aW9uLnN0eWxlKHRoaXMsIG5hbWUpKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlTWF5YmVSZW1vdmUoaWQsIG5hbWUpIHtcbiAgdmFyIG9uMCwgb24xLCBsaXN0ZW5lcjAsIGtleSA9IFwic3R5bGUuXCIgKyBuYW1lLCBldmVudCA9IFwiZW5kLlwiICsga2V5LCByZW1vdmU7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICBvbiA9IHNjaGVkdWxlLm9uLFxuICAgICAgICBsaXN0ZW5lciA9IHNjaGVkdWxlLnZhbHVlW2tleV0gPT0gbnVsbCA/IHJlbW92ZSB8fCAocmVtb3ZlID0gc3R5bGVSZW1vdmUobmFtZSkpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmIChvbiAhPT0gb24wIHx8IGxpc3RlbmVyMCAhPT0gbGlzdGVuZXIpIChvbjEgPSAob24wID0gb24pLmNvcHkoKSkub24oZXZlbnQsIGxpc3RlbmVyMCA9IGxpc3RlbmVyKTtcblxuICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3N0eWxlKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgaSA9IChuYW1lICs9IFwiXCIpID09PSBcInRyYW5zZm9ybVwiID8gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlTnVsbChuYW1lLCBpKSlcbiAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIHN0eWxlUmVtb3ZlKG5hbWUpKVxuICAgIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUZ1bmN0aW9uKG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJzdHlsZS5cIiArIG5hbWUsIHZhbHVlKSkpXG4gICAgICAuZWFjaChzdHlsZU1heWJlUmVtb3ZlKHRoaXMuX2lkLCBuYW1lKSlcbiAgICA6IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlQ29uc3RhbnQobmFtZSwgaSwgdmFsdWUpLCBwcmlvcml0eSlcbiAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIG51bGwpO1xufVxuXG5mdW5jdGlvbiBzdHlsZUludGVycG9sYXRlKG5hbWUsIGksIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBpLmNhbGwodGhpcywgdCksIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIHQsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0ID0gKGkwID0gaSkgJiYgc3R5bGVJbnRlcnBvbGF0ZShuYW1lLCBpLCBwcmlvcml0eSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9zdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIga2V5ID0gXCJzdHlsZS5cIiArIChuYW1lICs9IFwiXCIpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpO1xufVxuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUxID0gdmFsdWUodGhpcyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlMSA9PSBudWxsID8gXCJcIiA6IHZhbHVlMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl90ZXh0KHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLnR3ZWVuKFwidGV4dFwiLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyB0ZXh0RnVuY3Rpb24odHdlZW5WYWx1ZSh0aGlzLCBcInRleHRcIiwgdmFsdWUpKVxuICAgICAgOiB0ZXh0Q29uc3RhbnQodmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCIpKTtcbn1cblxuZnVuY3Rpb24gdGV4dEludGVycG9sYXRlKGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gaS5jYWxsKHRoaXMsIHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0VHdlZW4odmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiB0ZXh0SW50ZXJwb2xhdGUoaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fdGV4dFR3ZWVuKHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcInRleHRcIjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHRleHRUd2Vlbih2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3RyYW5zaXRpb24oKSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkMCA9IHRoaXMuX2lkLFxuICAgICAgaWQxID0gbmV3SWQoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICB2YXIgaW5oZXJpdCA9IGdldChub2RlLCBpZDApO1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZDEsIGksIGdyb3VwLCB7XG4gICAgICAgICAgdGltZTogaW5oZXJpdC50aW1lICsgaW5oZXJpdC5kZWxheSArIGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgICAgZHVyYXRpb246IGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgICAgZWFzZTogaW5oZXJpdC5lYXNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkMSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fZW5kKCkge1xuICB2YXIgb24wLCBvbjEsIHRoYXQgPSB0aGlzLCBpZCA9IHRoYXQuX2lkLCBzaXplID0gdGhhdC5zaXplKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgY2FuY2VsID0ge3ZhbHVlOiByZWplY3R9LFxuICAgICAgICBlbmQgPSB7dmFsdWU6IGZ1bmN0aW9uKCkgeyBpZiAoLS1zaXplID09PSAwKSByZXNvbHZlKCk7IH19O1xuXG4gICAgdGhhdC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgICAgaWYgKG9uICE9PSBvbjApIHtcbiAgICAgICAgb24xID0gKG9uMCA9IG9uKS5jb3B5KCk7XG4gICAgICAgIG9uMS5fLmNhbmNlbC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmludGVycnVwdC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmVuZC5wdXNoKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICAgIH0pO1xuICB9KTtcbn1cblxudmFyIGlkID0gMDtcblxuZnVuY3Rpb24gVHJhbnNpdGlvbihncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG4gIHRoaXMuX25hbWUgPSBuYW1lO1xuICB0aGlzLl9pZCA9IGlkO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIGQzU2VsZWN0aW9uLnNlbGVjdGlvbigpLnRyYW5zaXRpb24obmFtZSk7XG59XG5cbmZ1bmN0aW9uIG5ld0lkKCkge1xuICByZXR1cm4gKytpZDtcbn1cblxudmFyIHNlbGVjdGlvbl9wcm90b3R5cGUgPSBkM1NlbGVjdGlvbi5zZWxlY3Rpb24ucHJvdG90eXBlO1xuXG5UcmFuc2l0aW9uLnByb3RvdHlwZSA9IHRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNpdGlvbixcbiAgc2VsZWN0OiB0cmFuc2l0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiB0cmFuc2l0aW9uX3NlbGVjdEFsbCxcbiAgZmlsdGVyOiB0cmFuc2l0aW9uX2ZpbHRlcixcbiAgbWVyZ2U6IHRyYW5zaXRpb25fbWVyZ2UsXG4gIHNlbGVjdGlvbjogdHJhbnNpdGlvbl9zZWxlY3Rpb24sXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb25fdHJhbnNpdGlvbixcbiAgY2FsbDogc2VsZWN0aW9uX3Byb3RvdHlwZS5jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fcHJvdG90eXBlLmVtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fcHJvdG90eXBlLmVhY2gsXG4gIG9uOiB0cmFuc2l0aW9uX29uLFxuICBhdHRyOiB0cmFuc2l0aW9uX2F0dHIsXG4gIGF0dHJUd2VlbjogdHJhbnNpdGlvbl9hdHRyVHdlZW4sXG4gIHN0eWxlOiB0cmFuc2l0aW9uX3N0eWxlLFxuICBzdHlsZVR3ZWVuOiB0cmFuc2l0aW9uX3N0eWxlVHdlZW4sXG4gIHRleHQ6IHRyYW5zaXRpb25fdGV4dCxcbiAgdGV4dFR3ZWVuOiB0cmFuc2l0aW9uX3RleHRUd2VlbixcbiAgcmVtb3ZlOiB0cmFuc2l0aW9uX3JlbW92ZSxcbiAgdHdlZW46IHRyYW5zaXRpb25fdHdlZW4sXG4gIGRlbGF5OiB0cmFuc2l0aW9uX2RlbGF5LFxuICBkdXJhdGlvbjogdHJhbnNpdGlvbl9kdXJhdGlvbixcbiAgZWFzZTogdHJhbnNpdGlvbl9lYXNlLFxuICBlbmQ6IHRyYW5zaXRpb25fZW5kXG59O1xuXG52YXIgZGVmYXVsdFRpbWluZyA9IHtcbiAgdGltZTogbnVsbCwgLy8gU2V0IG9uIHVzZS5cbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiAyNTAsXG4gIGVhc2U6IGQzRWFzZS5lYXNlQ3ViaWNJbk91dFxufTtcblxuZnVuY3Rpb24gaW5oZXJpdChub2RlLCBpZCkge1xuICB2YXIgdGltaW5nO1xuICB3aGlsZSAoISh0aW1pbmcgPSBub2RlLl9fdHJhbnNpdGlvbikgfHwgISh0aW1pbmcgPSB0aW1pbmdbaWRdKSkge1xuICAgIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFRpbWluZy50aW1lID0gZDNUaW1lci5ub3coKSwgZGVmYXVsdFRpbWluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpbWluZztcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3RyYW5zaXRpb24obmFtZSkge1xuICB2YXIgaWQsXG4gICAgICB0aW1pbmc7XG5cbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgaWQgPSBuYW1lLl9pZCwgbmFtZSA9IG5hbWUuX25hbWU7XG4gIH0gZWxzZSB7XG4gICAgaWQgPSBuZXdJZCgpLCAodGltaW5nID0gZGVmYXVsdFRpbWluZykudGltZSA9IGQzVGltZXIubm93KCksIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZCwgaSwgZ3JvdXAsIHRpbWluZyB8fCBpbmhlcml0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuXG5kM1NlbGVjdGlvbi5zZWxlY3Rpb24ucHJvdG90eXBlLmludGVycnVwdCA9IHNlbGVjdGlvbl9pbnRlcnJ1cHQ7XG5kM1NlbGVjdGlvbi5zZWxlY3Rpb24ucHJvdG90eXBlLnRyYW5zaXRpb24gPSBzZWxlY3Rpb25fdHJhbnNpdGlvbjtcblxudmFyIHJvb3QgPSBbbnVsbF07XG5cbmZ1bmN0aW9uIGFjdGl2ZShub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgaTtcblxuICBpZiAoc2NoZWR1bGVzKSB7XG4gICAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBpZiAoKHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldKS5zdGF0ZSA+IFNDSEVEVUxFRCAmJiBzY2hlZHVsZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNpdGlvbihbW25vZGVdXSwgcm9vdCwgbmFtZSwgK2kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLmFjdGl2ZSA9IGFjdGl2ZTtcbmV4cG9ydHMuaW50ZXJydXB0ID0gaW50ZXJydXB0O1xuZXhwb3J0cy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy16b29tLyB2MS44LjMgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1kaXNwYXRjaCcpLCByZXF1aXJlKCdkMy1kcmFnJyksIHJlcXVpcmUoJ2QzLWludGVycG9sYXRlJyksIHJlcXVpcmUoJ2QzLXNlbGVjdGlvbicpLCByZXF1aXJlKCdkMy10cmFuc2l0aW9uJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtZGlzcGF0Y2gnLCAnZDMtZHJhZycsICdkMy1pbnRlcnBvbGF0ZScsICdkMy1zZWxlY3Rpb24nLCAnZDMtdHJhbnNpdGlvbiddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9LCBnbG9iYWwuZDMsIGdsb2JhbC5kMywgZ2xvYmFsLmQzLCBnbG9iYWwuZDMsIGdsb2JhbC5kMykpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNEaXNwYXRjaCwgZDNEcmFnLCBkM0ludGVycG9sYXRlLCBkM1NlbGVjdGlvbiwgZDNUcmFuc2l0aW9uKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFpvb21FdmVudCh0YXJnZXQsIHR5cGUsIHRyYW5zZm9ybSkge1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShrLCB4LCB5KSB7XG4gIHRoaXMuayA9IGs7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm0sXG4gIHNjYWxlOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgPT09IDEgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmsgKiBrLCB0aGlzLngsIHRoaXMueSk7XG4gIH0sXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB4ID09PSAwICYgeSA9PT0gMCA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuaywgdGhpcy54ICsgdGhpcy5rICogeCwgdGhpcy55ICsgdGhpcy5rICogeSk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBbcG9pbnRbMF0gKiB0aGlzLmsgKyB0aGlzLngsIHBvaW50WzFdICogdGhpcy5rICsgdGhpcy55XTtcbiAgfSxcbiAgYXBwbHlYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggKiB0aGlzLmsgKyB0aGlzLng7XG4gIH0sXG4gIGFwcGx5WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5ICogdGhpcy5rICsgdGhpcy55O1xuICB9LFxuICBpbnZlcnQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIFsobG9jYXRpb25bMF0gLSB0aGlzLngpIC8gdGhpcy5rLCAobG9jYXRpb25bMV0gLSB0aGlzLnkpIC8gdGhpcy5rXTtcbiAgfSxcbiAgaW52ZXJ0WDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAoeCAtIHRoaXMueCkgLyB0aGlzLms7XG4gIH0sXG4gIGludmVydFk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gKHkgLSB0aGlzLnkpIC8gdGhpcy5rO1xuICB9LFxuICByZXNjYWxlWDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4LmNvcHkoKS5kb21haW4oeC5yYW5nZSgpLm1hcCh0aGlzLmludmVydFgsIHRoaXMpLm1hcCh4LmludmVydCwgeCkpO1xuICB9LFxuICByZXNjYWxlWTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5LmNvcHkoKS5kb21haW4oeS5yYW5nZSgpLm1hcCh0aGlzLmludmVydFksIHRoaXMpLm1hcCh5LmludmVydCwgeSkpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIikgc2NhbGUoXCIgKyB0aGlzLmsgKyBcIilcIjtcbiAgfVxufTtcblxudmFyIGlkZW50aXR5ID0gbmV3IFRyYW5zZm9ybSgxLCAwLCAwKTtcblxudHJhbnNmb3JtLnByb3RvdHlwZSA9IFRyYW5zZm9ybS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShub2RlKSB7XG4gIHdoaWxlICghbm9kZS5fX3pvb20pIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHJldHVybiBub2RlLl9fem9vbTtcbn1cblxuZnVuY3Rpb24gbm9wcm9wYWdhdGlvbigpIHtcbiAgZDNTZWxlY3Rpb24uZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIG5vZXZlbnQoKSB7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoKSB7XG4gIHJldHVybiAhZDNTZWxlY3Rpb24uZXZlbnQuY3RybEtleSAmJiAhZDNTZWxlY3Rpb24uZXZlbnQuYnV0dG9uO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0RXh0ZW50KCkge1xuICB2YXIgZSA9IHRoaXM7XG4gIGlmIChlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgIGUgPSBlLm93bmVyU1ZHRWxlbWVudCB8fCBlO1xuICAgIGlmIChlLmhhc0F0dHJpYnV0ZShcInZpZXdCb3hcIikpIHtcbiAgICAgIGUgPSBlLnZpZXdCb3guYmFzZVZhbDtcbiAgICAgIHJldHVybiBbW2UueCwgZS55XSwgW2UueCArIGUud2lkdGgsIGUueSArIGUuaGVpZ2h0XV07XG4gICAgfVxuICAgIHJldHVybiBbWzAsIDBdLCBbZS53aWR0aC5iYXNlVmFsLnZhbHVlLCBlLmhlaWdodC5iYXNlVmFsLnZhbHVlXV07XG4gIH1cbiAgcmV0dXJuIFtbMCwgMF0sIFtlLmNsaWVudFdpZHRoLCBlLmNsaWVudEhlaWdodF1dO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtKCkge1xuICByZXR1cm4gdGhpcy5fX3pvb20gfHwgaWRlbnRpdHk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXaGVlbERlbHRhKCkge1xuICByZXR1cm4gLWQzU2VsZWN0aW9uLmV2ZW50LmRlbHRhWSAqIChkM1NlbGVjdGlvbi5ldmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZDNTZWxlY3Rpb24uZXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvdWNoYWJsZSgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbnN0cmFpbih0cmFuc2Zvcm0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSB7XG4gIHZhciBkeDAgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMF1bMF0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzBdLFxuICAgICAgZHgxID0gdHJhbnNmb3JtLmludmVydFgoZXh0ZW50WzFdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVswXSxcbiAgICAgIGR5MCA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFswXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMV0sXG4gICAgICBkeTEgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMV1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzFdWzFdO1xuICByZXR1cm4gdHJhbnNmb3JtLnRyYW5zbGF0ZShcbiAgICBkeDEgPiBkeDAgPyAoZHgwICsgZHgxKSAvIDIgOiBNYXRoLm1pbigwLCBkeDApIHx8IE1hdGgubWF4KDAsIGR4MSksXG4gICAgZHkxID4gZHkwID8gKGR5MCArIGR5MSkgLyAyIDogTWF0aC5taW4oMCwgZHkwKSB8fCBNYXRoLm1heCgwLCBkeTEpXG4gICk7XG59XG5cbmZ1bmN0aW9uIHpvb20oKSB7XG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgZXh0ZW50ID0gZGVmYXVsdEV4dGVudCxcbiAgICAgIGNvbnN0cmFpbiA9IGRlZmF1bHRDb25zdHJhaW4sXG4gICAgICB3aGVlbERlbHRhID0gZGVmYXVsdFdoZWVsRGVsdGEsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgc2NhbGVFeHRlbnQgPSBbMCwgSW5maW5pdHldLFxuICAgICAgdHJhbnNsYXRlRXh0ZW50ID0gW1stSW5maW5pdHksIC1JbmZpbml0eV0sIFtJbmZpbml0eSwgSW5maW5pdHldXSxcbiAgICAgIGR1cmF0aW9uID0gMjUwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBkM0ludGVycG9sYXRlLmludGVycG9sYXRlWm9vbSxcbiAgICAgIGxpc3RlbmVycyA9IGQzRGlzcGF0Y2guZGlzcGF0Y2goXCJzdGFydFwiLCBcInpvb21cIiwgXCJlbmRcIiksXG4gICAgICB0b3VjaHN0YXJ0aW5nLFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICB0b3VjaERlbGF5ID0gNTAwLFxuICAgICAgd2hlZWxEZWxheSA9IDE1MCxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMDtcblxuICBmdW5jdGlvbiB6b29tKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvblxuICAgICAgICAucHJvcGVydHkoXCJfX3pvb21cIiwgZGVmYXVsdFRyYW5zZm9ybSlcbiAgICAgICAgLm9uKFwid2hlZWwuem9vbVwiLCB3aGVlbGVkKVxuICAgICAgICAub24oXCJtb3VzZWRvd24uem9vbVwiLCBtb3VzZWRvd25lZClcbiAgICAgICAgLm9uKFwiZGJsY2xpY2suem9vbVwiLCBkYmxjbGlja2VkKVxuICAgICAgLmZpbHRlcih0b3VjaGFibGUpXG4gICAgICAgIC5vbihcInRvdWNoc3RhcnQuem9vbVwiLCB0b3VjaHN0YXJ0ZWQpXG4gICAgICAgIC5vbihcInRvdWNobW92ZS56b29tXCIsIHRvdWNobW92ZWQpXG4gICAgICAgIC5vbihcInRvdWNoZW5kLnpvb20gdG91Y2hjYW5jZWwuem9vbVwiLCB0b3VjaGVuZGVkKVxuICAgICAgICAuc3R5bGUoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XG4gIH1cblxuICB6b29tLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gY29sbGVjdGlvbi5zZWxlY3Rpb24gPyBjb2xsZWN0aW9uLnNlbGVjdGlvbigpIDogY29sbGVjdGlvbjtcbiAgICBzZWxlY3Rpb24ucHJvcGVydHkoXCJfX3pvb21cIiwgZGVmYXVsdFRyYW5zZm9ybSk7XG4gICAgaWYgKGNvbGxlY3Rpb24gIT09IHNlbGVjdGlvbikge1xuICAgICAgc2NoZWR1bGUoY29sbGVjdGlvbiwgdHJhbnNmb3JtLCBwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5pbnRlcnJ1cHQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgICAuem9vbShudWxsLCB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRyYW5zZm9ybSlcbiAgICAgICAgICAgIC5lbmQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB6b29tLnNjYWxlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHApIHtcbiAgICB6b29tLnNjYWxlVG8oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrMCA9IHRoaXMuX196b29tLmssXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBrMCAqIGsxO1xuICAgIH0sIHApO1xuICB9O1xuXG4gIHpvb20uc2NhbGVUbyA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgaywgcCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwLFxuICAgICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgICBrMSA9IHR5cGVvZiBrID09PSBcImZ1bmN0aW9uXCIgPyBrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodDAsIGsxKSwgcDAsIHAxKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwKTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW4odGhpcy5fX3pvb20udHJhbnNsYXRlKFxuICAgICAgICB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeCxcbiAgICAgICAgdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHlcbiAgICAgICksIGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0pO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIHgsIHksIHApIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbihpZGVudGl0eS50cmFuc2xhdGUocDBbMF0sIHAwWzFdKS5zY2FsZSh0LmspLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IC14LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteCxcbiAgICAgICAgdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IC15LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteVxuICAgICAgKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzY2FsZSh0cmFuc2Zvcm0sIGspIHtcbiAgICBrID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCBrKSk7XG4gICAgcmV0dXJuIGsgPT09IHRyYW5zZm9ybS5rID8gdHJhbnNmb3JtIDogbmV3IFRyYW5zZm9ybShrLCB0cmFuc2Zvcm0ueCwgdHJhbnNmb3JtLnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHRyYW5zZm9ybSwgcDAsIHAxKSB7XG4gICAgdmFyIHggPSBwMFswXSAtIHAxWzBdICogdHJhbnNmb3JtLmssIHkgPSBwMFsxXSAtIHAxWzFdICogdHJhbnNmb3JtLms7XG4gICAgcmV0dXJuIHggPT09IHRyYW5zZm9ybS54ICYmIHkgPT09IHRyYW5zZm9ybS55ID8gdHJhbnNmb3JtIDogbmV3IFRyYW5zZm9ybSh0cmFuc2Zvcm0uaywgeCwgeSk7XG4gIH1cblxuICBmdW5jdGlvbiBjZW50cm9pZChleHRlbnQpIHtcbiAgICByZXR1cm4gWygrZXh0ZW50WzBdWzBdICsgK2V4dGVudFsxXVswXSkgLyAyLCAoK2V4dGVudFswXVsxXSArICtleHRlbnRbMV1bMV0pIC8gMl07XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZSh0cmFuc2l0aW9uLCB0cmFuc2Zvcm0sIHBvaW50KSB7XG4gICAgdHJhbnNpdGlvblxuICAgICAgICAub24oXCJzdGFydC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuc3RhcnQoKTsgfSlcbiAgICAgICAgLm9uKFwiaW50ZXJydXB0Lnpvb20gZW5kLnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5lbmQoKTsgfSlcbiAgICAgICAgLnR3ZWVuKFwiem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGcgPSBnZXN0dXJlKHRoYXQsIGFyZ3MpLFxuICAgICAgICAgICAgICBlID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpLFxuICAgICAgICAgICAgICBwID0gcG9pbnQgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHBvaW50ID09PSBcImZ1bmN0aW9uXCIgPyBwb2ludC5hcHBseSh0aGF0LCBhcmdzKSA6IHBvaW50LFxuICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgoZVsxXVswXSAtIGVbMF1bMF0sIGVbMV1bMV0gLSBlWzBdWzFdKSxcbiAgICAgICAgICAgICAgYSA9IHRoYXQuX196b29tLFxuICAgICAgICAgICAgICBiID0gdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoYXQsIGFyZ3MpIDogdHJhbnNmb3JtLFxuICAgICAgICAgICAgICBpID0gaW50ZXJwb2xhdGUoYS5pbnZlcnQocCkuY29uY2F0KHcgLyBhLmspLCBiLmludmVydChwKS5jb25jYXQodyAvIGIuaykpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gMSkgdCA9IGI7IC8vIEF2b2lkIHJvdW5kaW5nIGVycm9yIG9uIGVuZC5cbiAgICAgICAgICAgIGVsc2UgeyB2YXIgbCA9IGkodCksIGsgPSB3IC8gbFsyXTsgdCA9IG5ldyBUcmFuc2Zvcm0oaywgcFswXSAtIGxbMF0gKiBrLCBwWzFdIC0gbFsxXSAqIGspOyB9XG4gICAgICAgICAgICBnLnpvb20obnVsbCwgdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXN0dXJlKHRoYXQsIGFyZ3MsIGNsZWFuKSB7XG4gICAgcmV0dXJuICghY2xlYW4gJiYgdGhhdC5fX3pvb21pbmcpIHx8IG5ldyBHZXN0dXJlKHRoYXQsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gR2VzdHVyZSh0aGF0LCBhcmdzKSB7XG4gICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudC5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB0aGlzLnRhcHMgPSAwO1xuICB9XG5cbiAgR2VzdHVyZS5wcm90b3R5cGUgPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCsrdGhpcy5hY3RpdmUgPT09IDEpIHtcbiAgICAgICAgdGhpcy50aGF0Ll9fem9vbWluZyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdChcInN0YXJ0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB6b29tOiBmdW5jdGlvbihrZXksIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRoaXMubW91c2UgJiYga2V5ICE9PSBcIm1vdXNlXCIpIHRoaXMubW91c2VbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMubW91c2VbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gwICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMFsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDBbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gxICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDFbMF0pO1xuICAgICAgdGhpcy50aGF0Ll9fem9vbSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMuZW1pdChcInpvb21cIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy50aGF0Ll9fem9vbWluZztcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBkM1NlbGVjdGlvbi5jdXN0b21FdmVudChuZXcgWm9vbUV2ZW50KHpvb20sIHR5cGUsIHRoaXMudGhhdC5fX3pvb20pLCBsaXN0ZW5lcnMuYXBwbHksIGxpc3RlbmVycywgW3R5cGUsIHRoaXMudGhhdCwgdGhpcy5hcmdzXSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHdoZWVsZWQoKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIHQuayAqIE1hdGgucG93KDIsIHdoZWVsRGVsdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSxcbiAgICAgICAgcCA9IGQzU2VsZWN0aW9uLm1vdXNlKHRoaXMpO1xuXG4gICAgLy8gSWYgdGhlIG1vdXNlIGlzIGluIHRoZSBzYW1lIGxvY2F0aW9uIGFzIGJlZm9yZSwgcmV1c2UgaXQuXG4gICAgLy8gSWYgdGhlcmUgd2VyZSByZWNlbnQgd2hlZWwgZXZlbnRzLCByZXNldCB0aGUgd2hlZWwgaWRsZSB0aW1lb3V0LlxuICAgIGlmIChnLndoZWVsKSB7XG4gICAgICBpZiAoZy5tb3VzZVswXVswXSAhPT0gcFswXSB8fCBnLm1vdXNlWzBdWzFdICE9PSBwWzFdKSB7XG4gICAgICAgIGcubW91c2VbMV0gPSB0LmludmVydChnLm1vdXNlWzBdID0gcCk7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQoZy53aGVlbCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3aGVlbCBldmVudCB3b27igJl0IHRyaWdnZXIgYSB0cmFuc2Zvcm0gY2hhbmdlLCBpZ25vcmUgaXQuXG4gICAgZWxzZSBpZiAodC5rID09PSBrKSByZXR1cm47XG5cbiAgICAvLyBPdGhlcndpc2UsIGNhcHR1cmUgdGhlIG1vdXNlIHBvaW50IGFuZCBsb2NhdGlvbiBhdCB0aGUgc3RhcnQuXG4gICAgZWxzZSB7XG4gICAgICBnLm1vdXNlID0gW3AsIHQuaW52ZXJ0KHApXTtcbiAgICAgIGQzVHJhbnNpdGlvbi5pbnRlcnJ1cHQodGhpcyk7XG4gICAgICBnLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgbm9ldmVudCgpO1xuICAgIGcud2hlZWwgPSBzZXRUaW1lb3V0KHdoZWVsaWRsZWQsIHdoZWVsRGVsYXkpO1xuICAgIGcuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodCwgayksIGcubW91c2VbMF0sIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG5cbiAgICBmdW5jdGlvbiB3aGVlbGlkbGVkKCkge1xuICAgICAgZy53aGVlbCA9IG51bGw7XG4gICAgICBnLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKCkge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzLCB0cnVlKSxcbiAgICAgICAgdiA9IGQzU2VsZWN0aW9uLnNlbGVjdChkM1NlbGVjdGlvbi5ldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS56b29tXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC56b29tXCIsIG1vdXNldXBwZWQsIHRydWUpLFxuICAgICAgICBwID0gZDNTZWxlY3Rpb24ubW91c2UodGhpcyksXG4gICAgICAgIHgwID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTAgPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRZO1xuXG4gICAgZDNEcmFnLmRyYWdEaXNhYmxlKGQzU2VsZWN0aW9uLmV2ZW50LnZpZXcpO1xuICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICBnLm1vdXNlID0gW3AsIHRoaXMuX196b29tLmludmVydChwKV07XG4gICAgZDNUcmFuc2l0aW9uLmludGVycnVwdCh0aGlzKTtcbiAgICBnLnN0YXJ0KCk7XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmVkKCkge1xuICAgICAgbm9ldmVudCgpO1xuICAgICAgaWYgKCFnLm1vdmVkKSB7XG4gICAgICAgIHZhciBkeCA9IGQzU2VsZWN0aW9uLmV2ZW50LmNsaWVudFggLSB4MCwgZHkgPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRZIC0geTA7XG4gICAgICAgIGcubW92ZWQgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgICAgfVxuICAgICAgZy56b29tKFwibW91c2VcIiwgY29uc3RyYWluKHRyYW5zbGF0ZShnLnRoYXQuX196b29tLCBnLm1vdXNlWzBdID0gZDNTZWxlY3Rpb24ubW91c2UoZy50aGF0KSwgZy5tb3VzZVsxXSksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwcGVkKCkge1xuICAgICAgdi5vbihcIm1vdXNlbW92ZS56b29tIG1vdXNldXAuem9vbVwiLCBudWxsKTtcbiAgICAgIGQzRHJhZy5kcmFnRW5hYmxlKGQzU2VsZWN0aW9uLmV2ZW50LnZpZXcsIGcubW92ZWQpO1xuICAgICAgbm9ldmVudCgpO1xuICAgICAgZy5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkYmxjbGlja2VkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgcDAgPSBkM1NlbGVjdGlvbi5tb3VzZSh0aGlzKSxcbiAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICBrMSA9IHQwLmsgKiAoZDNTZWxlY3Rpb24uZXZlbnQuc2hpZnRLZXkgPyAwLjUgOiAyKSxcbiAgICAgICAgdDEgPSBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0cmFuc2xhdGVFeHRlbnQpO1xuXG4gICAgbm9ldmVudCgpO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIGQzU2VsZWN0aW9uLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoc2NoZWR1bGUsIHQxLCBwMCk7XG4gICAgZWxzZSBkM1NlbGVjdGlvbi5zZWxlY3QodGhpcykuY2FsbCh6b29tLnRyYW5zZm9ybSwgdDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGQzU2VsZWN0aW9uLmV2ZW50LnRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzLCBkM1NlbGVjdGlvbi5ldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT09IG4pLFxuICAgICAgICBzdGFydGVkLCBpLCB0LCBwO1xuXG4gICAgbm9wcm9wYWdhdGlvbigpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gZDNTZWxlY3Rpb24udG91Y2godGhpcywgdG91Y2hlcywgdC5pZGVudGlmaWVyKTtcbiAgICAgIHAgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApLCB0LmlkZW50aWZpZXJdO1xuICAgICAgaWYgKCFnLnRvdWNoMCkgZy50b3VjaDAgPSBwLCBzdGFydGVkID0gdHJ1ZSwgZy50YXBzID0gMSArICEhdG91Y2hzdGFydGluZztcbiAgICAgIGVsc2UgaWYgKCFnLnRvdWNoMSAmJiBnLnRvdWNoMFsyXSAhPT0gcFsyXSkgZy50b3VjaDEgPSBwLCBnLnRhcHMgPSAwO1xuICAgIH1cblxuICAgIGlmICh0b3VjaHN0YXJ0aW5nKSB0b3VjaHN0YXJ0aW5nID0gY2xlYXJUaW1lb3V0KHRvdWNoc3RhcnRpbmcpO1xuXG4gICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgIGlmIChnLnRhcHMgPCAyKSB0b3VjaHN0YXJ0aW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hzdGFydGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgICAgZDNUcmFuc2l0aW9uLmludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKCkge1xuICAgIGlmICghdGhpcy5fX3pvb21pbmcpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgdG91Y2hlcyA9IGQzU2VsZWN0aW9uLmV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIHQsIHAsIGw7XG5cbiAgICBub2V2ZW50KCk7XG4gICAgaWYgKHRvdWNoc3RhcnRpbmcpIHRvdWNoc3RhcnRpbmcgPSBjbGVhclRpbWVvdXQodG91Y2hzdGFydGluZyk7XG4gICAgZy50YXBzID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXSwgcCA9IGQzU2VsZWN0aW9uLnRvdWNoKHRoaXMsIHRvdWNoZXMsIHQuaWRlbnRpZmllcik7XG4gICAgICBpZiAoZy50b3VjaDAgJiYgZy50b3VjaDBbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDBbMF0gPSBwO1xuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDFbMF0gPSBwO1xuICAgIH1cbiAgICB0ID0gZy50aGF0Ll9fem9vbTtcbiAgICBpZiAoZy50b3VjaDEpIHtcbiAgICAgIHZhciBwMCA9IGcudG91Y2gwWzBdLCBsMCA9IGcudG91Y2gwWzFdLFxuICAgICAgICAgIHAxID0gZy50b3VjaDFbMF0sIGwxID0gZy50b3VjaDFbMV0sXG4gICAgICAgICAgZHAgPSAoZHAgPSBwMVswXSAtIHAwWzBdKSAqIGRwICsgKGRwID0gcDFbMV0gLSBwMFsxXSkgKiBkcCxcbiAgICAgICAgICBkbCA9IChkbCA9IGwxWzBdIC0gbDBbMF0pICogZGwgKyAoZGwgPSBsMVsxXSAtIGwwWzFdKSAqIGRsO1xuICAgICAgdCA9IHNjYWxlKHQsIE1hdGguc3FydChkcCAvIGRsKSk7XG4gICAgICBwID0gWyhwMFswXSArIHAxWzBdKSAvIDIsIChwMFsxXSArIHAxWzFdKSAvIDJdO1xuICAgICAgbCA9IFsobDBbMF0gKyBsMVswXSkgLyAyLCAobDBbMV0gKyBsMVsxXSkgLyAyXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZy50b3VjaDApIHAgPSBnLnRvdWNoMFswXSwgbCA9IGcudG91Y2gwWzFdO1xuICAgIGVsc2UgcmV0dXJuO1xuICAgIGcuem9vbShcInRvdWNoXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUodCwgcCwgbCksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB0b3VjaGVzID0gZDNTZWxlY3Rpb24uZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgdDtcblxuICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICB9XG4gICAgaWYgKGcudG91Y2gxICYmICFnLnRvdWNoMCkgZy50b3VjaDAgPSBnLnRvdWNoMSwgZGVsZXRlIGcudG91Y2gxO1xuICAgIGlmIChnLnRvdWNoMCkgZy50b3VjaDBbMV0gPSB0aGlzLl9fem9vbS5pbnZlcnQoZy50b3VjaDBbMF0pO1xuICAgIGVsc2Uge1xuICAgICAgZy5lbmQoKTtcbiAgICAgIC8vIElmIHRoaXMgd2FzIGEgZGJsdGFwLCByZXJvdXRlIHRvIHRoZSAob3B0aW9uYWwpIGRibGNsaWNrLnpvb20gaGFuZGxlci5cbiAgICAgIGlmIChnLnRhcHMgPT09IDIpIHtcbiAgICAgICAgdmFyIHAgPSBkM1NlbGVjdGlvbi5zZWxlY3QodGhpcykub24oXCJkYmxjbGljay56b29tXCIpO1xuICAgICAgICBpZiAocCkgcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHpvb20ud2hlZWxEZWx0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh3aGVlbERlbHRhID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHpvb20pIDogd2hlZWxEZWx0YTtcbiAgfTtcblxuICB6b29tLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIHpvb20pIDogZmlsdGVyO1xuICB9O1xuXG4gIHpvb20udG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgem9vbS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXh0ZW50ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbWytfWzBdWzBdLCArX1swXVsxXV0sIFsrX1sxXVswXSwgK19bMV1bMV1dXSksIHpvb20pIDogZXh0ZW50O1xuICB9O1xuXG4gIHpvb20uc2NhbGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGVFeHRlbnRbMF0gPSArX1swXSwgc2NhbGVFeHRlbnRbMV0gPSArX1sxXSwgem9vbSkgOiBbc2NhbGVFeHRlbnRbMF0sIHNjYWxlRXh0ZW50WzFdXTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2xhdGVFeHRlbnRbMF1bMF0gPSArX1swXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzBdID0gK19bMV1bMF0sIHRyYW5zbGF0ZUV4dGVudFswXVsxXSA9ICtfWzBdWzFdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV0gPSArX1sxXVsxXSwgem9vbSkgOiBbW3RyYW5zbGF0ZUV4dGVudFswXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdXSwgW3RyYW5zbGF0ZUV4dGVudFsxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzFdXV07XG4gIH07XG5cbiAgem9vbS5jb25zdHJhaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29uc3RyYWluID0gXywgem9vbSkgOiBjb25zdHJhaW47XG4gIH07XG5cbiAgem9vbS5kdXJhdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkdXJhdGlvbiA9ICtfLCB6b29tKSA6IGR1cmF0aW9uO1xuICB9O1xuXG4gIHpvb20uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCB6b29tKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHpvb20ub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gem9vbSA6IHZhbHVlO1xuICB9O1xuXG4gIHpvb20uY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgem9vbSkgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHJldHVybiB6b29tO1xufVxuXG5leHBvcnRzLnpvb20gPSB6b29tO1xuZXhwb3J0cy56b29tSWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuem9vbVRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IG9iamVjdENyZWF0ZVBvbHlmaWxsXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IG9iamVjdEtleXNQb2x5ZmlsbFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbFxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG52YXIgaGFzRGVmaW5lUHJvcGVydHk7XG50cnkge1xuICB2YXIgbyA9IHt9O1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ3gnLCB7IHZhbHVlOiAwIH0pO1xuICBoYXNEZWZpbmVQcm9wZXJ0eSA9IG8ueCA9PT0gMDtcbn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH1cbmlmIChoYXNEZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlIG51bWJlciAod2hvc2UgdmFsdWUgaXMgemVybyBvclxuICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS5cbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IGFyZyAhPT0gYXJnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG59XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cztcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdC4nKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJyVzOiAlcycsIHcubmFtZSwgdy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBiaW5kLmNhbGwob25jZVdyYXBwZXIsIHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFldmxpc3RlbmVyKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKSB7XG4gIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSB7XG4gICAga2V5cy5wdXNoKGspO1xuICB9XG4gIHJldHVybiBrO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25CaW5kUG9seWZpbGwoY29udGV4dCkge1xuICB2YXIgZm4gPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wia2F0ZXhcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wia2F0ZXhcIl0gPSBmYWN0b3J5KCk7XG59KSgodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2thdGV4Lmxlc3NcbnZhciBrYXRleCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1NvdXJjZUxvY2F0aW9uLmpzXG4vKipcbiAqIExleGluZyBvciBwYXJzaW5nIHBvc2l0aW9uYWwgaW5mb3JtYXRpb24gZm9yIGVycm9yIHJlcG9ydGluZy5cbiAqIFRoaXMgb2JqZWN0IGlzIGltbXV0YWJsZS5cbiAqL1xudmFyIFNvdXJjZUxvY2F0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gVGhlICsgcHJlZml4IGluZGljYXRlcyB0aGF0IHRoZXNlIGZpZWxkcyBhcmVuJ3Qgd3JpdGVhYmxlXG4gIC8vIExleGVyIGhvbGRpbmcgdGhlIGlucHV0IHN0cmluZy5cbiAgLy8gU3RhcnQgb2Zmc2V0LCB6ZXJvLWJhc2VkIGluY2x1c2l2ZS5cbiAgLy8gRW5kIG9mZnNldCwgemVyby1iYXNlZCBleGNsdXNpdmUuXG4gIGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKGxleGVyLCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5sZXhlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0ID0gdm9pZCAwO1xuICAgIHRoaXMuZW5kID0gdm9pZCAwO1xuICAgIHRoaXMubGV4ZXIgPSBsZXhlcjtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gIH1cbiAgLyoqXG4gICAqIE1lcmdlcyB0d28gYFNvdXJjZUxvY2F0aW9uYHMgZnJvbSBsb2NhdGlvbiBwcm92aWRlcnMsIGdpdmVuIHRoZXkgYXJlXG4gICAqIHByb3ZpZGVkIGluIG9yZGVyIG9mIGFwcGVhcmFuY2UuXG4gICAqIC0gUmV0dXJucyB0aGUgZmlyc3Qgb25lJ3MgbG9jYXRpb24gaWYgb25seSB0aGUgZmlyc3QgaXMgcHJvdmlkZWQuXG4gICAqIC0gUmV0dXJucyBhIG1lcmdlZCByYW5nZSBvZiB0aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGlmIGJvdGggYXJlIHByb3ZpZGVkXG4gICAqICAgYW5kIHRoZWlyIGxleGVycyBtYXRjaC5cbiAgICogLSBPdGhlcndpc2UsIHJldHVybnMgbnVsbC5cbiAgICovXG5cblxuICBTb3VyY2VMb2NhdGlvbi5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoIXNlY29uZCkge1xuICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LmxvYztcbiAgICB9IGVsc2UgaWYgKCFmaXJzdCB8fCAhZmlyc3QubG9jIHx8ICFzZWNvbmQubG9jIHx8IGZpcnN0LmxvYy5sZXhlciAhPT0gc2Vjb25kLmxvYy5sZXhlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgU291cmNlTG9jYXRpb24oZmlyc3QubG9jLmxleGVyLCBmaXJzdC5sb2Muc3RhcnQsIHNlY29uZC5sb2MuZW5kKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNvdXJjZUxvY2F0aW9uO1xufSgpO1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1Rva2VuLmpzXG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcXVpcmVkIHRvIGJyZWFrIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBUb2tlbiwgTGV4ZXIsIGFuZFxuICogUGFyc2VFcnJvci5cbiAqL1xuXG4vKipcbiAqIFRoZSByZXN1bHRpbmcgdG9rZW4gcmV0dXJuZWQgZnJvbSBgbGV4YC5cbiAqXG4gKiBJdCBjb25zaXN0cyBvZiB0aGUgdG9rZW4gdGV4dCBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gKiBUaGUgcG9zaXRpb24gaW5mb3JtYXRpb24gaXMgZXNzZW50aWFsbHkgYSByYW5nZSBpbiBhbiBpbnB1dCBzdHJpbmcsXG4gKiBidXQgaW5zdGVhZCBvZiByZWZlcmVuY2luZyB0aGUgYmFyZSBpbnB1dCBzdHJpbmcsIHdlIHJlZmVyIHRvIHRoZSBsZXhlci5cbiAqIFRoYXQgd2F5IGl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBleHRyYSBtZXRhZGF0YSB0byB0aGUgaW5wdXQgc3RyaW5nLFxuICogbGlrZSBmb3IgZXhhbXBsZSBhIGZpbGUgbmFtZSBvciBzaW1pbGFyLlxuICpcbiAqIFRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBvcHRpb25hbCwgc28gaXQgaXMgT0sgdG8gY29uc3RydWN0IHN5bnRoZXRpY1xuICogdG9rZW5zIGlmIGFwcHJvcHJpYXRlLiBOb3QgcHJvdmlkaW5nIGF2YWlsYWJsZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBtYXlcbiAqIGxlYWQgdG8gZGVncmFkZWQgZXJyb3IgcmVwb3J0aW5nLCB0aG91Z2guXG4gKi9cbnZhciBUb2tlbl9Ub2tlbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRva2VuKHRleHQsIC8vIHRoZSB0ZXh0IG9mIHRoaXMgdG9rZW5cbiAgbG9jKSB7XG4gICAgdGhpcy50ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMubG9jID0gdm9pZCAwO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5sb2MgPSBsb2M7XG4gIH1cbiAgLyoqXG4gICAqIEdpdmVuIGEgcGFpciBvZiB0b2tlbnMgKHRoaXMgYW5kIGVuZFRva2VuKSwgY29tcHV0ZSBhIGBUb2tlbmAgZW5jb21wYXNzaW5nXG4gICAqIHRoZSB3aG9sZSBpbnB1dCByYW5nZSBlbmNsb3NlZCBieSB0aGVzZSB0d28uXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFRva2VuLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShlbmRUb2tlbiwgLy8gbGFzdCB0b2tlbiBvZiB0aGUgcmFuZ2UsIGluY2x1c2l2ZVxuICB0ZXh0KSAvLyB0aGUgdGV4dCBvZiB0aGUgbmV3bHkgY29uc3RydWN0ZWQgdG9rZW5cbiAge1xuICAgIHJldHVybiBuZXcgVG9rZW4odGV4dCwgU291cmNlTG9jYXRpb24ucmFuZ2UodGhpcywgZW5kVG9rZW4pKTtcbiAgfTtcblxuICByZXR1cm4gVG9rZW47XG59KCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9QYXJzZUVycm9yLmpzXG5cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBQYXJzZUVycm9yIGNsYXNzLCB3aGljaCBpcyB0aGUgbWFpbiBlcnJvciB0aHJvd24gYnkgS2FUZVhcbiAqIGZ1bmN0aW9ucyB3aGVuIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZy4gVGhpcyBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGludGVybmFsXG4gKiBlcnJvcnMgZnJvbSBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24gdGhhdCB0aGUgdXNlciBwcm92aWRlZC5cbiAqXG4gKiBJZiBwb3NzaWJsZSwgYSBjYWxsZXIgc2hvdWxkIHByb3ZpZGUgYSBUb2tlbiBvciBQYXJzZU5vZGUgd2l0aCBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hlcmUgaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlIHByb2JsZW0gb2NjdXJyZWQuXG4gKi9cbnZhciBQYXJzZUVycm9yID0gLy8gRXJyb3IgcG9zaXRpb24gYmFzZWQgb24gcGFzc2VkLWluIFRva2VuIG9yIFBhcnNlTm9kZS5cbmZ1bmN0aW9uIFBhcnNlRXJyb3IobWVzc2FnZSwgLy8gVGhlIGVycm9yIG1lc3NhZ2VcbnRva2VuKSAvLyBBbiBvYmplY3QgcHJvdmlkaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uXG57XG4gIHRoaXMucG9zaXRpb24gPSB2b2lkIDA7XG4gIHZhciBlcnJvciA9IFwiS2FUZVggcGFyc2UgZXJyb3I6IFwiICsgbWVzc2FnZTtcbiAgdmFyIHN0YXJ0O1xuICB2YXIgbG9jID0gdG9rZW4gJiYgdG9rZW4ubG9jO1xuXG4gIGlmIChsb2MgJiYgbG9jLnN0YXJ0IDw9IGxvYy5lbmQpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIHRoZSBpbnB1dCBhbmQgYSBwb3NpdGlvbiwgbWFrZSB0aGUgZXJyb3IgYSBiaXQgZmFuY2llclxuICAgIC8vIEdldCB0aGUgaW5wdXRcbiAgICB2YXIgaW5wdXQgPSBsb2MubGV4ZXIuaW5wdXQ7IC8vIFByZXBlbmQgc29tZSBpbmZvcm1hdGlvblxuXG4gICAgc3RhcnQgPSBsb2Muc3RhcnQ7XG4gICAgdmFyIGVuZCA9IGxvYy5lbmQ7XG5cbiAgICBpZiAoc3RhcnQgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgZXJyb3IgKz0gXCIgYXQgZW5kIG9mIGlucHV0OiBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IgKz0gXCIgYXQgcG9zaXRpb24gXCIgKyAoc3RhcnQgKyAxKSArIFwiOiBcIjtcbiAgICB9IC8vIFVuZGVybGluZSB0b2tlbiBpbiBxdWVzdGlvbiB1c2luZyBjb21iaW5pbmcgdW5kZXJzY29yZXNcblxuXG4gICAgdmFyIHVuZGVybGluZWQgPSBpbnB1dC5zbGljZShzdGFydCwgZW5kKS5yZXBsYWNlKC9bXl0vZywgXCIkJlxcdTAzMzJcIik7IC8vIEV4dHJhY3Qgc29tZSBjb250ZXh0IGZyb20gdGhlIGlucHV0IGFuZCBhZGQgaXQgdG8gdGhlIGVycm9yXG5cbiAgICB2YXIgbGVmdDtcblxuICAgIGlmIChzdGFydCA+IDE1KSB7XG4gICAgICBsZWZ0ID0gXCLigKZcIiArIGlucHV0LnNsaWNlKHN0YXJ0IC0gMTUsIHN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IGlucHV0LnNsaWNlKDAsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICB2YXIgcmlnaHQ7XG5cbiAgICBpZiAoZW5kICsgMTUgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHJpZ2h0ID0gaW5wdXQuc2xpY2UoZW5kLCBlbmQgKyAxNSkgKyBcIuKAplwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodCA9IGlucHV0LnNsaWNlKGVuZCk7XG4gICAgfVxuXG4gICAgZXJyb3IgKz0gbGVmdCArIHVuZGVybGluZWQgKyByaWdodDtcbiAgfSAvLyBTb21lIGhhY2tlcnkgdG8gbWFrZSBQYXJzZUVycm9yIGEgcHJvdG90eXBlIG9mIEVycm9yXG4gIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84NDYwNzUzXG5cblxuICB2YXIgc2VsZiA9IG5ldyBFcnJvcihlcnJvcik7XG4gIHNlbGYubmFtZSA9IFwiUGFyc2VFcnJvclwiOyAvLyAkRmxvd0ZpeE1lXG5cbiAgc2VsZi5fX3Byb3RvX18gPSBQYXJzZUVycm9yLnByb3RvdHlwZTsgLy8gJEZsb3dGaXhNZVxuXG4gIHNlbGYucG9zaXRpb24gPSBzdGFydDtcbiAgcmV0dXJuIHNlbGY7XG59OyAvLyAkRmxvd0ZpeE1lIE1vcmUgaGFja2VyeVxuXG5cblBhcnNlRXJyb3IucHJvdG90eXBlLl9fcHJvdG9fXyA9IEVycm9yLnByb3RvdHlwZTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19QYXJzZUVycm9yID0gKFBhcnNlRXJyb3IpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMuanNcbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGEgbGlzdCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB3aGljaCBhcmUgdXNlZnVsIGluIG90aGVyXG4gKiBmaWxlcy5cbiAqL1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgY29udGFpbmVkIGluIGEgbGlzdFxuICovXG52YXIgY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhsaXN0LCBlbGVtKSB7XG4gIHJldHVybiBsaXN0LmluZGV4T2YoZWxlbSkgIT09IC0xO1xufTtcbi8qKlxuICogUHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgaWYgYSBzZXR0aW5nIGlzIHVuZGVmaW5lZFxuICogTk9URTogQ291bGRuJ3QgdXNlIGBUYCBhcyB0aGUgb3V0cHV0IHR5cGUgZHVlIHRvIGZhY2Vib29rL2Zsb3cjNTAyMi5cbiAqL1xuXG5cbnZhciBkZWZsdCA9IGZ1bmN0aW9uIGRlZmx0KHNldHRpbmcsIGRlZmF1bHRJZlVuZGVmaW5lZCkge1xuICByZXR1cm4gc2V0dGluZyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdElmVW5kZWZpbmVkIDogc2V0dGluZztcbn07IC8vIGh5cGhlbmF0ZSBhbmQgZXNjYXBlIGFkYXB0ZWQgZnJvbSBGYWNlYm9vaydzIFJlYWN0IHVuZGVyIEFwYWNoZSAyIGxpY2Vuc2VcblxuXG52YXIgdXBwZXJjYXNlID0gLyhbQS1aXSkvZztcblxudmFyIGh5cGhlbmF0ZSA9IGZ1bmN0aW9uIGh5cGhlbmF0ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHVwcGVyY2FzZSwgXCItJDFcIikudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBFU0NBUEVfTE9PS1VQID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gIFwiPFwiOiBcIiZsdDtcIixcbiAgXCJcXFwiXCI6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjeDI3O1wiXG59O1xudmFyIEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqL1xuXG5mdW5jdGlvbiB1dGlsc19lc2NhcGUodGV4dCkge1xuICByZXR1cm4gU3RyaW5nKHRleHQpLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gRVNDQVBFX0xPT0tVUFttYXRjaF07XG4gIH0pO1xufVxuLyoqXG4gKiBTb21ldGltZXMgd2Ugd2FudCB0byBwdWxsIG91dCB0aGUgaW5uZXJtb3N0IGVsZW1lbnQgb2YgYSBncm91cC4gSW4gbW9zdFxuICogY2FzZXMsIHRoaXMgd2lsbCBqdXN0IGJlIHRoZSBncm91cCBpdHNlbGYsIGJ1dCB3aGVuIG9yZGdyb3VwcyBhbmQgY29sb3JzIGhhdmVcbiAqIGEgc2luZ2xlIGVsZW1lbnQsIHdlIHdhbnQgdG8gcHVsbCB0aGF0IG91dC5cbiAqL1xuXG5cbnZhciBnZXRCYXNlRWxlbSA9IGZ1bmN0aW9uIGdldEJhc2VFbGVtKGdyb3VwKSB7XG4gIGlmIChncm91cC50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICBpZiAoZ3JvdXAuYm9keS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC5ib2R5WzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcImNvbG9yXCIpIHtcbiAgICBpZiAoZ3JvdXAuYm9keS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC5ib2R5WzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcImZvbnRcIikge1xuICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC5ib2R5KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ3JvdXA7XG4gIH1cbn07XG4vKipcbiAqIFRlWGJvb2sgYWxnb3JpdGhtcyBvZnRlbiByZWZlcmVuY2UgXCJjaGFyYWN0ZXIgYm94ZXNcIiwgd2hpY2ggYXJlIHNpbXBseSBncm91cHNcbiAqIHdpdGggYSBzaW5nbGUgY2hhcmFjdGVyIGluIHRoZW0uIFRvIGRlY2lkZSBpZiBzb21ldGhpbmcgaXMgYSBjaGFyYWN0ZXIgYm94LFxuICogd2UgZmluZCBpdHMgaW5uZXJtb3N0IGdyb3VwLCBhbmQgc2VlIGlmIGl0IGlzIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAqL1xuXG5cbnZhciB1dGlsc19pc0NoYXJhY3RlckJveCA9IGZ1bmN0aW9uIGlzQ2hhcmFjdGVyQm94KGdyb3VwKSB7XG4gIHZhciBiYXNlRWxlbSA9IGdldEJhc2VFbGVtKGdyb3VwKTsgLy8gVGhlc2UgYXJlIGFsbCB0aGV5IHR5cGVzIG9mIGdyb3VwcyB3aGljaCBob2xkIHNpbmdsZSBjaGFyYWN0ZXJzXG5cbiAgcmV0dXJuIGJhc2VFbGVtLnR5cGUgPT09IFwibWF0aG9yZFwiIHx8IGJhc2VFbGVtLnR5cGUgPT09IFwidGV4dG9yZFwiIHx8IGJhc2VFbGVtLnR5cGUgPT09IFwiYXRvbVwiO1xufTtcblxudmFyIGFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydCh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBub24tbnVsbCwgYnV0IGdvdCAnICsgU3RyaW5nKHZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdXRpbHMgPSAoe1xuICBjb250YWluczogY29udGFpbnMsXG4gIGRlZmx0OiBkZWZsdCxcbiAgZXNjYXBlOiB1dGlsc19lc2NhcGUsXG4gIGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuICBnZXRCYXNlRWxlbTogZ2V0QmFzZUVsZW0sXG4gIGlzQ2hhcmFjdGVyQm94OiB1dGlsc19pc0NoYXJhY3RlckJveFxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9TZXR0aW5ncy5qc1xuLyogZXNsaW50IG5vLWNvbnNvbGU6MCAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBtb2R1bGUgZm9yIHN0b3Jpbmcgc2V0dGluZ3MgcGFzc2VkIGludG8gS2FUZVguIEl0IGNvcnJlY3RseSBoYW5kbGVzXG4gKiBkZWZhdWx0IHNldHRpbmdzLlxuICovXG5cblxuXG5cbi8qKlxuICogVGhlIG1haW4gU2V0dGluZ3Mgb2JqZWN0XG4gKlxuICogVGhlIGN1cnJlbnQgb3B0aW9ucyBzdG9yZWQgYXJlOlxuICogIC0gZGlzcGxheU1vZGU6IFdoZXRoZXIgdGhlIGV4cHJlc3Npb24gc2hvdWxkIGJlIHR5cGVzZXQgYXMgaW5saW5lIG1hdGhcbiAqICAgICAgICAgICAgICAgICAoZmFsc2UsIHRoZSBkZWZhdWx0KSwgbWVhbmluZyB0aGF0IHRoZSBtYXRoIHN0YXJ0cyBpblxuICogICAgICAgICAgICAgICAgIFxcdGV4dHN0eWxlIGFuZCBpcyBwbGFjZWQgaW4gYW4gaW5saW5lLWJsb2NrKTsgb3IgYXMgZGlzcGxheVxuICogICAgICAgICAgICAgICAgIG1hdGggKHRydWUpLCBtZWFuaW5nIHRoYXQgdGhlIG1hdGggc3RhcnRzIGluIFxcZGlzcGxheXN0eWxlXG4gKiAgICAgICAgICAgICAgICAgYW5kIGlzIHBsYWNlZCBpbiBhIGJsb2NrIHdpdGggdmVydGljYWwgbWFyZ2luLlxuICovXG52YXIgU2V0dGluZ3NfU2V0dGluZ3MgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZXR0aW5ncyhvcHRpb25zKSB7XG4gICAgdGhpcy5kaXNwbGF5TW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxlcW5vID0gdm9pZCAwO1xuICAgIHRoaXMuZmxlcW4gPSB2b2lkIDA7XG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvckNvbG9yID0gdm9pZCAwO1xuICAgIHRoaXMubWFjcm9zID0gdm9pZCAwO1xuICAgIHRoaXMuY29sb3JJc1RleHRDb2xvciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cmljdCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXhFeHBhbmQgPSB2b2lkIDA7XG4gICAgdGhpcy5hbGxvd2VkUHJvdG9jb2xzID0gdm9pZCAwO1xuICAgIC8vIGFsbG93IG51bGwgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZGlzcGxheU1vZGUgPSB1dGlscy5kZWZsdChvcHRpb25zLmRpc3BsYXlNb2RlLCBmYWxzZSk7XG4gICAgdGhpcy5sZXFubyA9IHV0aWxzLmRlZmx0KG9wdGlvbnMubGVxbm8sIGZhbHNlKTtcbiAgICB0aGlzLmZsZXFuID0gdXRpbHMuZGVmbHQob3B0aW9ucy5mbGVxbiwgZmFsc2UpO1xuICAgIHRoaXMudGhyb3dPbkVycm9yID0gdXRpbHMuZGVmbHQob3B0aW9ucy50aHJvd09uRXJyb3IsIHRydWUpO1xuICAgIHRoaXMuZXJyb3JDb2xvciA9IHV0aWxzLmRlZmx0KG9wdGlvbnMuZXJyb3JDb2xvciwgXCIjY2MwMDAwXCIpO1xuICAgIHRoaXMubWFjcm9zID0gb3B0aW9ucy5tYWNyb3MgfHwge307XG4gICAgdGhpcy5jb2xvcklzVGV4dENvbG9yID0gdXRpbHMuZGVmbHQob3B0aW9ucy5jb2xvcklzVGV4dENvbG9yLCBmYWxzZSk7XG4gICAgdGhpcy5zdHJpY3QgPSB1dGlscy5kZWZsdChvcHRpb25zLnN0cmljdCwgXCJ3YXJuXCIpO1xuICAgIHRoaXMubWF4U2l6ZSA9IE1hdGgubWF4KDAsIHV0aWxzLmRlZmx0KG9wdGlvbnMubWF4U2l6ZSwgSW5maW5pdHkpKTtcbiAgICB0aGlzLm1heEV4cGFuZCA9IE1hdGgubWF4KDAsIHV0aWxzLmRlZmx0KG9wdGlvbnMubWF4RXhwYW5kLCAxMDAwKSk7XG4gICAgdGhpcy5hbGxvd2VkUHJvdG9jb2xzID0gdXRpbHMuZGVmbHQob3B0aW9ucy5hbGxvd2VkUHJvdG9jb2xzLCBbXCJodHRwXCIsIFwiaHR0cHNcIiwgXCJtYWlsdG9cIiwgXCJfcmVsYXRpdmVcIl0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXBvcnQgbm9uc3RyaWN0IChub24tTGFUZVgtY29tcGF0aWJsZSkgaW5wdXQuXG4gICAqIENhbiBzYWZlbHkgbm90IGJlIGNhbGxlZCBpZiBgdGhpcy5zdHJpY3RgIGlzIGZhbHNlIGluIEphdmFTY3JpcHQuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFNldHRpbmdzLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVwb3J0Tm9uc3RyaWN0ID0gZnVuY3Rpb24gcmVwb3J0Tm9uc3RyaWN0KGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKSB7XG4gICAgdmFyIHN0cmljdCA9IHRoaXMuc3RyaWN0O1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gQWxsb3cgcmV0dXJuIHZhbHVlIG9mIHN0cmljdCBmdW5jdGlvbiB0byBiZSBib29sZWFuIG9yIHN0cmluZ1xuICAgICAgLy8gKG9yIG51bGwvdW5kZWZpbmVkLCBtZWFuaW5nIG5vIGZ1cnRoZXIgcHJvY2Vzc2luZykuXG4gICAgICBzdHJpY3QgPSBzdHJpY3QoZXJyb3JDb2RlLCBlcnJvck1zZywgdG9rZW4pO1xuICAgIH1cblxuICAgIGlmICghc3RyaWN0IHx8IHN0cmljdCA9PT0gXCJpZ25vcmVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSB0cnVlIHx8IHN0cmljdCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJMYVRlWC1pbmNvbXBhdGlibGUgaW5wdXQgYW5kIHN0cmljdCBtb2RlIGlzIHNldCB0byAnZXJyb3InOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSwgdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSBcIndhcm5cIikge1xuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gJ3dhcm4nOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdvbid0IGhhcHBlbiBpbiB0eXBlLXNhZmUgY29kZVxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gXCIgKyAoXCJ1bnJlY29nbml6ZWQgJ1wiICsgc3RyaWN0ICsgXCInOiBcIiArIGVycm9yTXNnICsgXCIgW1wiICsgZXJyb3JDb2RlICsgXCJdXCIpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdG8gYXBwbHkgc3RyaWN0IChMYVRlWC1hZGhlcmluZykgYmVoYXZpb3IgZm9yIHVudXN1YWxcbiAgICogaW5wdXQgKGxpa2UgYFxcXFxgKS4gIFVubGlrZSBgbm9uc3RyaWN0YCwgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3I7XG4gICAqIGluc3RlYWQsIFwiZXJyb3JcIiB0cmFuc2xhdGVzIHRvIGEgcmV0dXJuIHZhbHVlIG9mIGB0cnVlYCwgd2hpbGUgXCJpZ25vcmVcIlxuICAgKiB0cmFuc2xhdGVzIHRvIGEgcmV0dXJuIHZhbHVlIG9mIGBmYWxzZWAuICBNYXkgc3RpbGwgcHJpbnQgYSB3YXJuaW5nOlxuICAgKiBcIndhcm5cIiBwcmludHMgYSB3YXJuaW5nIGFuZCByZXR1cm5zIGBmYWxzZWAuXG4gICAqIFRoaXMgaXMgZm9yIHRoZSBzZWNvbmQgY2F0ZWdvcnkgb2YgYGVycm9yQ29kZWBzIGxpc3RlZCBpbiB0aGUgUkVBRE1FLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51c2VTdHJpY3RCZWhhdmlvciA9IGZ1bmN0aW9uIHVzZVN0cmljdEJlaGF2aW9yKGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKSB7XG4gICAgdmFyIHN0cmljdCA9IHRoaXMuc3RyaWN0O1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gQWxsb3cgcmV0dXJuIHZhbHVlIG9mIHN0cmljdCBmdW5jdGlvbiB0byBiZSBib29sZWFuIG9yIHN0cmluZ1xuICAgICAgLy8gKG9yIG51bGwvdW5kZWZpbmVkLCBtZWFuaW5nIG5vIGZ1cnRoZXIgcHJvY2Vzc2luZykuXG4gICAgICAvLyBCdXQgY2F0Y2ggYW55IGV4Y2VwdGlvbnMgdGhyb3duIGJ5IGZ1bmN0aW9uLCB0cmVhdGluZyB0aGVtXG4gICAgICAvLyBsaWtlIFwiZXJyb3JcIi5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmljdCA9IHN0cmljdChlcnJvckNvZGUsIGVycm9yTXNnLCB0b2tlbik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzdHJpY3QgPSBcImVycm9yXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzdHJpY3QgfHwgc3RyaWN0ID09PSBcImlnbm9yZVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChzdHJpY3QgPT09IHRydWUgfHwgc3RyaWN0ID09PSBcImVycm9yXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSBcIndhcm5cIikge1xuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gJ3dhcm4nOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdvbid0IGhhcHBlbiBpbiB0eXBlLXNhZmUgY29kZVxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gXCIgKyAoXCJ1bnJlY29nbml6ZWQgJ1wiICsgc3RyaWN0ICsgXCInOiBcIiArIGVycm9yTXNnICsgXCIgW1wiICsgZXJyb3JDb2RlICsgXCJdXCIpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNldHRpbmdzO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfU2V0dGluZ3MgPSAoU2V0dGluZ3NfU2V0dGluZ3MpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvU3R5bGUuanNcbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFuZCBjbGFzc2VzIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBzdHlsZXNcbiAqIHVzZWQgaW4gVGVYLiBJdCBwcm92aWRlcyBhIGdlbmVyaWMgYFN0eWxlYCBjbGFzcywgd2hpY2ggaG9sZHMgaW5mb3JtYXRpb25cbiAqIGFib3V0IGEgc3BlY2lmaWMgc3R5bGUuIEl0IHRoZW4gcHJvdmlkZXMgaW5zdGFuY2VzIG9mIGFsbCB0aGUgZGlmZmVyZW50IGtpbmRzXG4gKiBvZiBzdHlsZXMgcG9zc2libGUsIGFuZCBwcm92aWRlcyBmdW5jdGlvbnMgdG8gbW92ZSBiZXR3ZWVuIHRoZW0gYW5kIGdldFxuICogaW5mb3JtYXRpb24gYWJvdXQgdGhlbS5cbiAqL1xuXG4vKipcbiAqIFRoZSBtYWluIHN0eWxlIGNsYXNzLiBDb250YWlucyBhIHVuaXF1ZSBpZCBmb3IgdGhlIHN0eWxlLCBhIHNpemUgKHdoaWNoIGlzXG4gKiB0aGUgc2FtZSBmb3IgY3JhbXBlZCBhbmQgdW5jcmFtcGVkIHZlcnNpb24gb2YgYSBzdHlsZSksIGFuZCBhIGNyYW1wZWQgZmxhZy5cbiAqL1xudmFyIFN0eWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3R5bGUoaWQsIHNpemUsIGNyYW1wZWQpIHtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMuc2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNyYW1wZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5jcmFtcGVkID0gY3JhbXBlZDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdHlsZSBvZiBhIHN1cGVyc2NyaXB0IGdpdmVuIGEgYmFzZSBpbiB0aGUgY3VycmVudCBzdHlsZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gU3R5bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5zdXAgPSBmdW5jdGlvbiBzdXAoKSB7XG4gICAgcmV0dXJuIFN0eWxlX3N0eWxlc1tfc3VwW3RoaXMuaWRdXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdHlsZSBvZiBhIHN1YnNjcmlwdCBnaXZlbiBhIGJhc2UgaW4gdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnN1YiA9IGZ1bmN0aW9uIHN1YigpIHtcbiAgICByZXR1cm4gU3R5bGVfc3R5bGVzW19zdWJbdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0eWxlIG9mIGEgZnJhY3Rpb24gbnVtZXJhdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICAgKiBzdHlsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZnJhY051bSA9IGZ1bmN0aW9uIGZyYWNOdW0oKSB7XG4gICAgcmV0dXJuIFN0eWxlX3N0eWxlc1tfZnJhY051bVt0aGlzLmlkXV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3R5bGUgb2YgYSBmcmFjdGlvbiBkZW5vbWluYXRvciBnaXZlbiB0aGUgZnJhY3Rpb24gaW4gdGhlIGN1cnJlbnRcbiAgICogc3R5bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmZyYWNEZW4gPSBmdW5jdGlvbiBmcmFjRGVuKCkge1xuICAgIHJldHVybiBTdHlsZV9zdHlsZXNbX2ZyYWNEZW5bdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNyYW1wZWQgdmVyc2lvbiBvZiBhIHN0eWxlIChpbiBwYXJ0aWN1bGFyLCBjcmFtcGluZyBhIGNyYW1wZWQgc3R5bGVcbiAgICogZG9lc24ndCBjaGFuZ2UgdGhlIHN0eWxlKS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JhbXAgPSBmdW5jdGlvbiBjcmFtcCgpIHtcbiAgICByZXR1cm4gU3R5bGVfc3R5bGVzW19jcmFtcFt0aGlzLmlkXV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHRleHQgb3IgZGlzcGxheSB2ZXJzaW9uIG9mIHRoaXMgc3R5bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRleHQgPSBmdW5jdGlvbiB0ZXh0KCkge1xuICAgIHJldHVybiBTdHlsZV9zdHlsZXNbX3RleHRbdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIHN0eWxlIGlzIHRpZ2h0bHkgc3BhY2VkIChzY3JpcHRzdHlsZS9zY3JpcHRzY3JpcHRzdHlsZSlcbiAgICovXG4gIDtcblxuICBfcHJvdG8uaXNUaWdodCA9IGZ1bmN0aW9uIGlzVGlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSA+PSAyO1xuICB9O1xuXG4gIHJldHVybiBTdHlsZTtcbn0oKTsgLy8gRXhwb3J0IGFuIGludGVyZmFjZSBmb3IgdHlwZSBjaGVja2luZywgYnV0IGRvbid0IGV4cG9zZSB0aGUgaW1wbGVtZW50YXRpb24uXG4vLyBUaGlzIHdheSwgbm8gbW9yZSBzdHlsZXMgY2FuIGJlIGdlbmVyYXRlZC5cblxuXG4vLyBJRHMgb2YgdGhlIGRpZmZlcmVudCBzdHlsZXNcbnZhciBEID0gMDtcbnZhciBEYyA9IDE7XG52YXIgVCA9IDI7XG52YXIgVGMgPSAzO1xudmFyIFMgPSA0O1xudmFyIFNjID0gNTtcbnZhciBTUyA9IDY7XG52YXIgU1NjID0gNzsgLy8gSW5zdGFuY2VzIG9mIHRoZSBkaWZmZXJlbnQgc3R5bGVzXG5cbnZhciBTdHlsZV9zdHlsZXMgPSBbbmV3IFN0eWxlKEQsIDAsIGZhbHNlKSwgbmV3IFN0eWxlKERjLCAwLCB0cnVlKSwgbmV3IFN0eWxlKFQsIDEsIGZhbHNlKSwgbmV3IFN0eWxlKFRjLCAxLCB0cnVlKSwgbmV3IFN0eWxlKFMsIDIsIGZhbHNlKSwgbmV3IFN0eWxlKFNjLCAyLCB0cnVlKSwgbmV3IFN0eWxlKFNTLCAzLCBmYWxzZSksIG5ldyBTdHlsZShTU2MsIDMsIHRydWUpXTsgLy8gTG9va3VwIHRhYmxlcyBmb3Igc3dpdGNoaW5nIGZyb20gb25lIHN0eWxlIHRvIGFub3RoZXJcblxudmFyIF9zdXAgPSBbUywgU2MsIFMsIFNjLCBTUywgU1NjLCBTUywgU1NjXTtcbnZhciBfc3ViID0gW1NjLCBTYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIF9mcmFjTnVtID0gW1QsIFRjLCBTLCBTYywgU1MsIFNTYywgU1MsIFNTY107XG52YXIgX2ZyYWNEZW4gPSBbVGMsIFRjLCBTYywgU2MsIFNTYywgU1NjLCBTU2MsIFNTY107XG52YXIgX2NyYW1wID0gW0RjLCBEYywgVGMsIFRjLCBTYywgU2MsIFNTYywgU1NjXTtcbnZhciBfdGV4dCA9IFtELCBEYywgVCwgVGMsIFQsIFRjLCBULCBUY107IC8vIFdlIG9ubHkgZXhwb3J0IHNvbWUgb2YgdGhlIHN0eWxlcy5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX1N0eWxlID0gKHtcbiAgRElTUExBWTogU3R5bGVfc3R5bGVzW0RdLFxuICBURVhUOiBTdHlsZV9zdHlsZXNbVF0sXG4gIFNDUklQVDogU3R5bGVfc3R5bGVzW1NdLFxuICBTQ1JJUFRTQ1JJUFQ6IFN0eWxlX3N0eWxlc1tTU11cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdW5pY29kZVNjcmlwdHMuanNcbi8qXG4gKiBUaGlzIGZpbGUgZGVmaW5lcyB0aGUgVW5pY29kZSBzY3JpcHRzIGFuZCBzY3JpcHQgZmFtaWxpZXMgdGhhdCB3ZVxuICogc3VwcG9ydC4gVG8gYWRkIG5ldyBzY3JpcHRzIG9yIGZhbWlsaWVzLCBqdXN0IGFkZCBhIG5ldyBlbnRyeSB0byB0aGVcbiAqIHNjcmlwdERhdGEgYXJyYXkgYmVsb3cuIEFkZGluZyBzY3JpcHRzIHRvIHRoZSBzY3JpcHREYXRhIGFycmF5IGFsbG93c1xuICogY2hhcmFjdGVycyBmcm9tIHRoYXQgc2NyaXB0IHRvIGFwcGVhciBpbiBcXHRleHR7fSBlbnZpcm9ubWVudHMuXG4gKi9cblxuLyoqXG4gKiBFYWNoIHNjcmlwdCBvciBzY3JpcHQgZmFtaWx5IGhhcyBhIG5hbWUgYW5kIGFuIGFycmF5IG9mIGJsb2Nrcy5cbiAqIEVhY2ggYmxvY2sgaXMgYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgd2hpY2ggc3BlY2lmeSB0aGUgc3RhcnQgYW5kXG4gKiBlbmQgcG9pbnRzIChpbmNsdXNpdmUpIG9mIGEgYmxvY2sgb2YgVW5pY29kZSBjb2RlcG9pbnRzLlxuICovXG5cbi8qKlxuICogVW5pY29kZSBibG9jayBkYXRhIGZvciB0aGUgZmFtaWxpZXMgb2Ygc2NyaXB0cyB3ZSBzdXBwb3J0IGluIFxcdGV4dHt9LlxuICogU2NyaXB0cyBvbmx5IG5lZWQgdG8gYXBwZWFyIGhlcmUgaWYgdGhleSBkbyBub3QgaGF2ZSBmb250IG1ldHJpY3MuXG4gKi9cbnZhciBzY3JpcHREYXRhID0gW3tcbiAgLy8gTGF0aW4gY2hhcmFjdGVycyBiZXlvbmQgdGhlIExhdGluLTEgY2hhcmFjdGVycyB3ZSBoYXZlIG1ldHJpY3MgZm9yLlxuICAvLyBOZWVkZWQgZm9yIEN6ZWNoLCBIdW5nYXJpYW4gYW5kIFR1cmtpc2ggdGV4dCwgZm9yIGV4YW1wbGUuXG4gIG5hbWU6ICdsYXRpbicsXG4gIGJsb2NrczogW1sweDAxMDAsIDB4MDI0Zl0sIC8vIExhdGluIEV4dGVuZGVkLUEgYW5kIExhdGluIEV4dGVuZGVkLUJcbiAgWzB4MDMwMCwgMHgwMzZmXV1cbn0sIHtcbiAgLy8gVGhlIEN5cmlsbGljIHNjcmlwdCB1c2VkIGJ5IFJ1c3NpYW4gYW5kIHJlbGF0ZWQgbGFuZ3VhZ2VzLlxuICAvLyBBIEN5cmlsbGljIHN1YnNldCB1c2VkIHRvIGJlIHN1cHBvcnRlZCBhcyBleHBsaWNpdGx5IGRlZmluZWRcbiAgLy8gc3ltYm9scyBpbiBzeW1ib2xzLmpzXG4gIG5hbWU6ICdjeXJpbGxpYycsXG4gIGJsb2NrczogW1sweDA0MDAsIDB4MDRmZl1dXG59LCB7XG4gIC8vIFRoZSBCcmFobWljIHNjcmlwdHMgb2YgU291dGggYW5kIFNvdXRoZWFzdCBBc2lhXG4gIC8vIERldmFuYWdhcmkgKDA5MDDigJMwOTdGKVxuICAvLyBCZW5nYWxpICgwOTgw4oCTMDlGRilcbiAgLy8gR3VybXVraGkgKDBBMDDigJMwQTdGKVxuICAvLyBHdWphcmF0aSAoMEE4MOKAkzBBRkYpXG4gIC8vIE9yaXlhICgwQjAw4oCTMEI3RilcbiAgLy8gVGFtaWwgKDBCODDigJMwQkZGKVxuICAvLyBUZWx1Z3UgKDBDMDDigJMwQzdGKVxuICAvLyBLYW5uYWRhICgwQzgw4oCTMENGRilcbiAgLy8gTWFsYXlhbGFtICgwRDAw4oCTMEQ3RilcbiAgLy8gU2luaGFsYSAoMEQ4MOKAkzBERkYpXG4gIC8vIFRoYWkgKDBFMDDigJMwRTdGKVxuICAvLyBMYW8gKDBFODDigJMwRUZGKVxuICAvLyBUaWJldGFuICgwRjAw4oCTMEZGRilcbiAgLy8gTXlhbm1hciAoMTAwMOKAkzEwOUYpXG4gIG5hbWU6ICdicmFobWljJyxcbiAgYmxvY2tzOiBbWzB4MDkwMCwgMHgxMDlGXV1cbn0sIHtcbiAgbmFtZTogJ2dlb3JnaWFuJyxcbiAgYmxvY2tzOiBbWzB4MTBBMCwgMHgxMGZmXV1cbn0sIHtcbiAgLy8gQ2hpbmVzZSBhbmQgSmFwYW5lc2UuXG4gIC8vIFRoZSBcImtcIiBpbiBjamsgaXMgZm9yIEtvcmVhbiwgYnV0IHdlJ3ZlIHNlcGFyYXRlZCBLb3JlYW4gb3V0XG4gIG5hbWU6IFwiY2prXCIsXG4gIGJsb2NrczogW1sweDMwMDAsIDB4MzBGRl0sIC8vIENKSyBzeW1ib2xzIGFuZCBwdW5jdHVhdGlvbiwgSGlyYWdhbmEsIEthdGFrYW5hXG4gIFsweDRFMDAsIDB4OUZBRl0sIC8vIENKSyBpZGVvZ3JhbXNcbiAgWzB4RkYwMCwgMHhGRjYwXV1cbn0sIHtcbiAgLy8gS29yZWFuXG4gIG5hbWU6ICdoYW5ndWwnLFxuICBibG9ja3M6IFtbMHhBQzAwLCAweEQ3QUZdXVxufV07XG4vKipcbiAqIEdpdmVuIGEgY29kZXBvaW50LCByZXR1cm4gdGhlIG5hbWUgb2YgdGhlIHNjcmlwdCBvciBzY3JpcHQgZmFtaWx5XG4gKiBpdCBpcyBmcm9tLCBvciBudWxsIGlmIGl0IGlzIG5vdCBwYXJ0IG9mIGEga25vd24gYmxvY2tcbiAqL1xuXG5mdW5jdGlvbiBzY3JpcHRGcm9tQ29kZXBvaW50KGNvZGVwb2ludCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2NyaXB0ID0gc2NyaXB0RGF0YVtpXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzY3JpcHQuYmxvY2tzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGJsb2NrID0gc2NyaXB0LmJsb2Nrc1tfaV07XG5cbiAgICAgIGlmIChjb2RlcG9pbnQgPj0gYmxvY2tbMF0gJiYgY29kZXBvaW50IDw9IGJsb2NrWzFdKSB7XG4gICAgICAgIHJldHVybiBzY3JpcHQubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbGwgdGhlIHN1cHBvcnRlZCBibG9ja3MgaW4gYSBzaW5nbGUgYXJyYXkuXG4gKiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiB0byBtYWtlIHN1cHBvcnRlZENvZGVwb2ludCgpIGZhc3QuXG4gKi9cblxudmFyIGFsbEJsb2NrcyA9IFtdO1xuc2NyaXB0RGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gIHJldHVybiBzLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgcmV0dXJuIGFsbEJsb2Nrcy5wdXNoLmFwcGx5KGFsbEJsb2NrcywgYik7XG4gIH0pO1xufSk7XG4vKipcbiAqIEdpdmVuIGEgY29kZXBvaW50LCByZXR1cm4gdHJ1ZSBpZiBpdCBmYWxscyB3aXRoaW4gb25lIG9mIHRoZVxuICogc2NyaXB0cyBvciBzY3JpcHQgZmFtaWxpZXMgZGVmaW5lZCBhYm92ZSBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIE1pY3JvIGJlbmNobWFya3Mgc2hvd3MgdGhhdCB0aGlzIGlzIGZhc3RlciB0aGFuXG4gKiAvW1xcdTMwMDAtXFx1MzBGRlxcdTRFMDAtXFx1OUZBRlxcdUZGMDAtXFx1RkY2MFxcdUFDMDAtXFx1RDdBRlxcdTA5MDAtXFx1MTA5Rl0vLnRlc3QoKVxuICogaW4gRmlyZWZveCwgQ2hyb21lIGFuZCBOb2RlLlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRlZENvZGVwb2ludChjb2RlcG9pbnQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxCbG9ja3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBpZiAoY29kZXBvaW50ID49IGFsbEJsb2Nrc1tpXSAmJiBjb2RlcG9pbnQgPD0gYWxsQmxvY2tzW2kgKyAxXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3ZnR2VvbWV0cnkuanNcbi8qKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHN1cHBvcnQgdG8gZG9tVHJlZS5qc1xuICogSXQncyBhIHN0b3JlaG91c2Ugb2YgcGF0aCBnZW9tZXRyeSBmb3IgU1ZHIGltYWdlcy5cbiAqL1xuLy8gSW4gYWxsIHBhdGhzIGJlbG93LCB0aGUgdmlld0JveC10by1lbSBzY2FsZSBpcyAxMDAwOjEuXG52YXIgaExpbmVQYWQgPSA4MDsgLy8gcGFkZGluZyBhYm92ZSBhIHNxcnQgdmluaWN1bHVtLlxuXG52YXIgc3ZnR2VvbWV0cnlfcGF0aCA9IHtcbiAgLy8gc3FydE1haW4gcGF0aCBnZW9tZXRyeSBpcyBmcm9tIGdseXBoIFUyMjFBIGluIHRoZSBmb250IEthVGVYIE1haW5cbiAgLy8gQWxsIHN1cmRzIGhhdmUgODAgdW5pdHMgcGFkZGluZyBhYm92ZSB0aGUgdmluaWN1bHVtbi5cbiAgc3FydE1haW46IFwiTTk1LFwiICsgKDYyMiArIGhMaW5lUGFkKSArIFwiYy0yLjcsMCwtNy4xNywtMi43LC0xMy41LC04Yy01LjgsLTUuMywtOS41LFxcbi0xMCwtOS41LC0xNGMwLC0yLDAuMywtMy4zLDEsLTRjMS4zLC0yLjcsMjMuODMsLTIwLjcsNjcuNSwtNTRjNDQuMiwtMzMuMyw2NS44LFxcbi01MC4zLDY2LjUsLTUxYzEuMywtMS4zLDMsLTIsNSwtMmM0LjcsMCw4LjcsMy4zLDEyLDEwczE3MywzNzgsMTczLDM3OGMwLjcsMCxcXG4zNS4zLC03MSwxMDQsLTIxM2M2OC43LC0xNDIsMTM3LjUsLTI4NSwyMDYuNSwtNDI5YzY5LC0xNDQsMTA0LjUsLTIxNy43LDEwNi41LFxcbi0yMjFjNS4zLC05LjMsMTIsLTE0LDIwLC0xNEg0MDAwMDB2NDBIODQ1LjI3MjRzLTIyNS4yNzIsNDY3LC0yMjUuMjcyLDQ2N1xcbnMtMjM1LDQ4NiwtMjM1LDQ4NmMtMi43LDQuNywtOSw3LC0xOSw3Yy02LDAsLTEwLC0xLC0xMiwtM3MtMTk0LC00MjIsLTE5NCwtNDIyXFxucy02NSw0NywtNjUsNDd6IE04MzQgXCIgKyBoTGluZVBhZCArIFwiSDQwMDAwMHY0MEg4NDV6XCIsXG4gIC8vIHNpemUxIGlzIGZyb20gZ2x5cGggVTIyMUEgaW4gdGhlIGZvbnQgS2FUZVhfU2l6ZTEtUmVndWxhclxuICBzcXJ0U2l6ZTE6IFwiTTI2MyxcIiArICg2MDEgKyBoTGluZVBhZCkgKyBcImMwLjcsMCwxOCwzOS43LDUyLDExOWMzNCw3OS4zLDY4LjE2NyxcXG4xNTguNywxMDIuNSwyMzhjMzQuMyw3OS4zLDUxLjgsMTE5LjMsNTIuNSwxMjBjMzQwLC03MDQuNyw1MTAuNywtMTA2MC4zLDUxMiwtMTA2N1xcbmM0LjcsLTcuMywxMSwtMTEsMTksLTExSDQwMDAwdjQwSDEwMTIuM3MtMjcxLjMsNTY3LC0yNzEuMyw1NjdjLTM4LjcsODAuNywtODQsXFxuMTc1LC0xMzYsMjgzYy01MiwxMDgsLTg5LjE2NywxODUuMywtMTExLjUsMjMyYy0yMi4zLDQ2LjcsLTMzLjgsNzAuMywtMzQuNSw3MVxcbmMtNC43LDQuNywtMTIuMyw3LC0yMyw3cy0xMiwtMSwtMTIsLTFzLTEwOSwtMjUzLC0xMDksLTI1M2MtNzIuNywtMTY4LC0xMDkuMyxcXG4tMjUyLC0xMTAsLTI1MmMtMTAuNyw4LC0yMiwxNi43LC0zNCwyNmMtMjIsMTcuMywtMzMuMywyNiwtMzQsMjZzLTI2LC0yNiwtMjYsLTI2XFxuczc2LC01OSw3NiwtNTlzNzYsLTYwLDc2LC02MHogTTEwMDEgXCIgKyBoTGluZVBhZCArIFwiSDQwMDAwdjQwSDEwMTJ6XCIsXG4gIC8vIHNpemUyIGlzIGZyb20gZ2x5cGggVTIyMUEgaW4gdGhlIGZvbnQgS2FUZVhfU2l6ZTItUmVndWxhclxuICAvLyBUaGUgODAgdW5pdHMgcGFkZGluZyBpcyBtb3N0IG9idmlvdXMgaGVyZS4gTm90ZSBzdGFydCBub2RlIGF0IE0xMDAxIDgwLlxuICBzcXJ0U2l6ZTI6IFwiTTEwMDEsXCIgKyBoTGluZVBhZCArIFwiSDQwMDAwMHY0MEgxMDEzLjFzLTgzLjQsMjY4LC0yNjQuMSw4NDBjLTE4MC43LFxcbjU3MiwtMjc3LDg3Ni4zLC0yODksOTEzYy00LjcsNC43LC0xMi43LDcsLTI0LDdzLTEyLDAsLTEyLDBjLTEuMywtMy4zLC0zLjcsLTExLjcsXFxuLTcsLTI1Yy0zNS4zLC0xMjUuMywtMTA2LjcsLTM3My4zLC0yMTQsLTc0NGMtMTAsMTIsLTIxLDI1LC0zMywzOXMtMzIsMzksLTMyLDM5XFxuYy02LC01LjMsLTE1LC0xNCwtMjcsLTI2czI1LC0zMCwyNSwtMzBjMjYuNywtMzIuNyw1MiwtNjMsNzYsLTkxczUyLC02MCw1MiwtNjBcXG5zMjA4LDcyMiwyMDgsNzIyYzU2LC0xNzUuMywxMjYuMywtMzk3LjMsMjExLC02NjZjODQuNywtMjY4LjcsMTUzLjgsLTQ4OC4yLDIwNy41LFxcbi02NTguNWM1My43LC0xNzAuMyw4NC41LC0yNjYuOCw5Mi41LC0yODkuNWM0LC02LjcsMTAsLTEwLDE4LC0xMHpcXG5NMTAwMSBcIiArIGhMaW5lUGFkICsgXCJINDAwMDAwdjQwSDEwMTN6XCIsXG4gIC8vIHNpemUzIGlzIGZyb20gZ2x5cGggVTIyMUEgaW4gdGhlIGZvbnQgS2FUZVhfU2l6ZTMtUmVndWxhclxuICBzcXJ0U2l6ZTM6IFwiTTQyNCxcIiArICgyMzk4ICsgaExpbmVQYWQpICsgXCJjLTEuMywtMC43LC0zOC41LC0xNzIsLTExMS41LC01MTRjLTczLFxcbi0zNDIsLTEwOS44LC01MTMuMywtMTEwLjUsLTUxNGMwLC0yLC0xMC43LDE0LjMsLTMyLDQ5Yy00LjcsNy4zLC05LjgsMTUuNywtMTUuNSxcXG4yNWMtNS43LDkuMywtOS44LDE2LC0xMi41LDIwcy01LDcsLTUsN2MtNCwtMy4zLC04LjMsLTcuNywtMTMsLTEzcy0xMywtMTMsLTEzLFxcbi0xM3M3NiwtMTIyLDc2LC0xMjJzNzcsLTEyMSw3NywtMTIxczIwOSw5NjgsMjA5LDk2OGMwLC0yLDg0LjcsLTM2MS43LDI1NCwtMTA3OVxcbmMxNjkuMywtNzE3LjMsMjU0LjcsLTEwNzcuNywyNTYsLTEwODFjNCwtNi43LDEwLC0xMCwxOCwtMTBINDAwMDAwdjQwSDEwMTQuNlxcbnMtODcuMywzNzguNywtMjcyLjYsMTE2NmMtMTg1LjMsNzg3LjMsLTI3OS4zLDExODIuMywtMjgyLDExODVjLTIsNiwtMTAsOSwtMjQsOVxcbmMtOCwwLC0xMiwtMC43LC0xMiwtMnogTTEwMDEgXCIgKyBoTGluZVBhZCArIFwiSDQwMDAwMHY0MEgxMDE0elwiLFxuICAvLyBzaXplNCBpcyBmcm9tIGdseXBoIFUyMjFBIGluIHRoZSBmb250IEthVGVYX1NpemU0LVJlZ3VsYXJcbiAgc3FydFNpemU0OiBcIk00NzMsXCIgKyAoMjcxMyArIGhMaW5lUGFkKSArIFwiYzMzOS4zLC0xNzk5LjMsNTA5LjMsLTI3MDAsNTEwLC0yNzAyXFxuYzMuMywtNy4zLDkuMywtMTEsMTgsLTExSDQwMDAwMHY0MEgxMDE3LjdzLTkwLjUsNDc4LC0yNzYuMiwxNDY2Yy0xODUuNyw5ODgsXFxuLTI3OS41LDE0ODMsLTI4MS41LDE0ODVjLTIsNiwtMTAsOSwtMjQsOWMtOCwwLC0xMiwtMC43LC0xMiwtMmMwLC0xLjMsLTUuMywtMzIsXFxuLTE2LC05MmMtNTAuNywtMjkzLjMsLTExOS43LC02OTMuMywtMjA3LC0xMjAwYzAsLTEuMywtNS4zLDguNywtMTYsMzBjLTEwLjcsXFxuMjEuMywtMjEuMyw0Mi43LC0zMiw2NHMtMTYsMzMsLTE2LDMzcy0yNiwtMjYsLTI2LC0yNnM3NiwtMTUzLDc2LC0xNTNzNzcsLTE1MSxcXG43NywtMTUxYzAuNywwLjcsMzUuNywyMDIsMTA1LDYwNGM2Ny4zLDQwMC43LDEwMiw2MDIuNywxMDQsNjA2elxcbk0xMDAxIFwiICsgaExpbmVQYWQgKyBcIkg0MDAwMDB2NDBIMTAxN3pcIixcbiAgLy8gVGhlIGRvdWJsZWxlZnRhcnJvdyBnZW9tZXRyeSBpcyBmcm9tIGdseXBoIFUrMjFEMCBpbiB0aGUgZm9udCBLYVRlWCBNYWluXG4gIGRvdWJsZWxlZnRhcnJvdzogXCJNMjYyIDE1N1xcbmwxMC0xMGMzNC0zNiA2Mi43LTc3IDg2LTEyMyAzLjMtOCA1LTEzLjMgNS0xNiAwLTUuMy02LjctOC0yMC04LTcuM1xcbiAwLTEyLjIuNS0xNC41IDEuNS0yLjMgMS00LjggNC41LTcuNSAxMC41LTQ5LjMgOTcuMy0xMjEuNyAxNjkuMy0yMTcgMjE2LTI4XFxuIDE0LTU3LjMgMjUtODggMzMtNi43IDItMTEgMy44LTEzIDUuNS0yIDEuNy0zIDQuMi0zIDcuNXMxIDUuOCAzIDcuNVxcbmMyIDEuNyA2LjMgMy41IDEzIDUuNSA2OCAxNy4zIDEyOC4yIDQ3LjggMTgwLjUgOTEuNSA1Mi4zIDQzLjcgOTMuOCA5Ni4yIDEyNC41XFxuIDE1Ny41IDkuMyA4IDE1LjMgMTIuMyAxOCAxM2g2YzEyLS43IDE4LTQgMTgtMTAgMC0yLTEuNy03LTUtMTUtMjMuMy00Ni01Mi04N1xcbi04Ni0xMjNsLTEwLTEwaDM5OTczOHYtNDBIMjE4YzMyOCAwIDAgMCAwIDBsLTEwLThjLTI2LjctMjAtNjUuNy00My0xMTctNjkgMi43XFxuLTIgNi0zLjcgMTAtNSAzNi43LTE2IDcyLjMtMzcuMyAxMDctNjRsMTAtOGgzOTk3ODJ2LTQwelxcbm04IDB2NDBoMzk5NzMwdi00MHptMCAxOTR2NDBoMzk5NzMwdi00MHpcIixcbiAgLy8gZG91YmxlcmlnaHRhcnJvdyBpcyBmcm9tIGdseXBoIFUrMjFEMiBpbiBmb250IEthVGVYIE1haW5cbiAgZG91YmxlcmlnaHRhcnJvdzogXCJNMzk5NzM4IDM5MmxcXG4tMTAgMTBjLTM0IDM2LTYyLjcgNzctODYgMTIzLTMuMyA4LTUgMTMuMy01IDE2IDAgNS4zIDYuNyA4IDIwIDggNy4zIDAgMTIuMi0uNVxcbiAxNC41LTEuNSAyLjMtMSA0LjgtNC41IDcuNS0xMC41IDQ5LjMtOTcuMyAxMjEuNy0xNjkuMyAyMTctMjE2IDI4LTE0IDU3LjMtMjUgODhcXG4tMzMgNi43LTIgMTEtMy44IDEzLTUuNSAyLTEuNyAzLTQuMiAzLTcuNXMtMS01LjgtMy03LjVjLTItMS43LTYuMy0zLjUtMTMtNS41LTY4XFxuLTE3LjMtMTI4LjItNDcuOC0xODAuNS05MS41LTUyLjMtNDMuNy05My44LTk2LjItMTI0LjUtMTU3LjUtOS4zLTgtMTUuMy0xMi4zLTE4XFxuLTEzaC02Yy0xMiAuNy0xOCA0LTE4IDEwIDAgMiAxLjcgNyA1IDE1IDIzLjMgNDYgNTIgODcgODYgMTIzbDEwIDEwSDB2NDBoMzk5NzgyXFxuYy0zMjggMCAwIDAgMCAwbDEwIDhjMjYuNyAyMCA2NS43IDQzIDExNyA2OS0yLjcgMi02IDMuNy0xMCA1LTM2LjcgMTYtNzIuMyAzNy4zXFxuLTEwNyA2NGwtMTAgOEgwdjQwek0wIDE1N3Y0MGgzOTk3MzB2LTQwem0wIDE5NHY0MGgzOTk3MzB2LTQwelwiLFxuICAvLyBsZWZ0YXJyb3cgaXMgZnJvbSBnbHlwaCBVKzIxOTAgaW4gZm9udCBLYVRlWCBNYWluXG4gIGxlZnRhcnJvdzogXCJNNDAwMDAwIDI0MUgxMTBsMy0zYzY4LjctNTIuNyAxMTMuNy0xMjBcXG4gMTM1LTIwMiA0LTE0LjcgNi0yMyA2LTI1IDAtNy4zLTctMTEtMjEtMTEtOCAwLTEzLjIuOC0xNS41IDIuNS0yLjMgMS43LTQuMiA1LjhcXG4tNS41IDEyLjUtMS4zIDQuNy0yLjcgMTAuMy00IDE3LTEyIDQ4LjctMzQuOCA5Mi02OC41IDEzMFM2NS4zIDIyOC4zIDE4IDI0N1xcbmMtMTAgNC0xNiA3LjctMTggMTEgMCA4LjcgNiAxNC4zIDE4IDE3IDQ3LjMgMTguNyA4Ny44IDQ3IDEyMS41IDg1UzE5NiA0NDEuMyAyMDhcXG4gNDkwYy43IDIgMS4zIDUgMiA5czEuMiA2LjcgMS41IDhjLjMgMS4zIDEgMy4zIDIgNnMyLjIgNC41IDMuNSA1LjVjMS4zIDEgMy4zXFxuIDEuOCA2IDIuNXM2IDEgMTAgMWMxNCAwIDIxLTMuNyAyMS0xMSAwLTItMi0xMC4zLTYtMjUtMjAtNzkuMy02NS0xNDYuNy0xMzUtMjAyXFxuIGwtMy0zaDM5OTg5MHpNMTAwIDI0MXY0MGgzOTk5MDB2LTQwelwiLFxuICAvLyBvdmVyYnJhY2UgaXMgZnJvbSBnbHlwaHMgVSsyM0E5LzIzQTgvMjNBNyBpbiBmb250IEthVGVYX1NpemU0LVJlZ3VsYXJcbiAgbGVmdGJyYWNlOiBcIk02IDU0OGwtNi02di0zNWw2LTExYzU2LTEwNCAxMzUuMy0xODEuMyAyMzgtMjMyIDU3LjMtMjguNyAxMTdcXG4tNDUgMTc5LTUwaDM5OTU3N3YxMjBINDAzYy00My4zIDctODEgMTUtMTEzIDI2LTEwMC43IDMzLTE3OS43IDkxLTIzNyAxNzQtMi43XFxuIDUtNiA5LTEwIDEzLS43IDEtNy4zIDEtMjAgMUg2elwiLFxuICBsZWZ0YnJhY2V1bmRlcjogXCJNMCA2bDYtNmgxN2MxMi42ODggMCAxOS4zMTMuMyAyMCAxIDQgNCA3LjMxMyA4LjMgMTAgMTNcXG4gMzUuMzEzIDUxLjMgODAuODEzIDkzLjggMTM2LjUgMTI3LjUgNTUuNjg4IDMzLjcgMTE3LjE4OCA1NS44IDE4NC41IDY2LjUuNjg4XFxuIDAgMiAuMyA0IDEgMTguNjg4IDIuNyA3NiA0LjMgMTcyIDVoMzk5NDUwdjEyMEg0MjlsLTYtMWMtMTI0LjY4OC04LTIzNS02MS43XFxuLTMzMS0xNjFDNjAuNjg3IDEzOC43IDMyLjMxMiA5OS4zIDcgNTRMMCA0MVY2elwiLFxuICAvLyBvdmVyZ3JvdXAgaXMgZnJvbSB0aGUgTW5TeW1ib2wgcGFja2FnZSAocHVibGljIGRvbWFpbilcbiAgbGVmdGdyb3VwOiBcIk00MDAwMDAgODBcXG5INDM1QzY0IDgwIDE2OC4zIDIyOS40IDIxIDI2MGMtNS45IDEuMi0xOCAwLTE4IDAtMiAwLTMtMS0zLTN2LTM4Qzc2IDYxIDI1NyAwXFxuIDQzNSAwaDM5OTU2NXpcIixcbiAgbGVmdGdyb3VwdW5kZXI6IFwiTTQwMDAwMCAyNjJcXG5INDM1QzY0IDI2MiAxNjguMyAxMTIuNiAyMSA4MmMtNS45LTEuMi0xOCAwLTE4IDAtMiAwLTMgMS0zIDN2MzhjNzYgMTU4IDI1NyAyMTlcXG4gNDM1IDIxOWgzOTk1NjV6XCIsXG4gIC8vIEhhcnBvb25zIGFyZSBmcm9tIGdseXBoIFUrMjFCRCBpbiBmb250IEthVGVYIE1haW5cbiAgbGVmdGhhcnBvb246IFwiTTAgMjY3Yy43IDUuMyAzIDEwIDcgMTRoMzk5OTkzdi00MEg5M2MzLjNcXG4tMy4zIDEwLjItOS41IDIwLjUtMTguNXMxNy44LTE1LjggMjIuNS0yMC41YzUwLjctNTIgODgtMTEwLjMgMTEyLTE3NSA0LTExLjMgNVxcbi0xOC4zIDMtMjEtMS4zLTQtNy4zLTYtMTgtNi04IDAtMTMgLjctMTUgMnMtNC43IDYuNy04IDE2Yy00MiA5OC43LTEwNy4zIDE3NC43XFxuLTE5NiAyMjgtNi43IDQuNy0xMC43IDgtMTIgMTAtMS4zIDItMiA1LjctMiAxMXptMTAwLTI2djQwaDM5OTkwMHYtNDB6XCIsXG4gIGxlZnRoYXJwb29ucGx1czogXCJNMCAyNjdjLjcgNS4zIDMgMTAgNyAxNGgzOTk5OTN2LTQwSDkzYzMuMy0zLjMgMTAuMi05LjVcXG4gMjAuNS0xOC41czE3LjgtMTUuOCAyMi41LTIwLjVjNTAuNy01MiA4OC0xMTAuMyAxMTItMTc1IDQtMTEuMyA1LTE4LjMgMy0yMS0xLjNcXG4tNC03LjMtNi0xOC02LTggMC0xMyAuNy0xNSAycy00LjcgNi43LTggMTZjLTQyIDk4LjctMTA3LjMgMTc0LjctMTk2IDIyOC02LjcgNC43XFxuLTEwLjcgOC0xMiAxMC0xLjMgMi0yIDUuNy0yIDExem0xMDAtMjZ2NDBoMzk5OTAwdi00MHpNMCA0MzV2NDBoNDAwMDAwdi00MHpcXG5tMCAwdjQwaDQwMDAwMHYtNDB6XCIsXG4gIGxlZnRoYXJwb29uZG93bjogXCJNNyAyNDFjLTQgNC02LjMzMyA4LjY2Ny03IDE0IDAgNS4zMzMuNjY3IDkgMiAxMXM1LjMzM1xcbiA1LjMzMyAxMiAxMGM5MC42NjcgNTQgMTU2IDEzMCAxOTYgMjI4IDMuMzMzIDEwLjY2NyA2LjMzMyAxNi4zMzMgOSAxNyAyIC42NjcgNVxcbiAxIDkgMWg1YzEwLjY2NyAwIDE2LjY2Ny0yIDE4LTYgMi0yLjY2NyAxLTkuNjY3LTMtMjEtMzItODcuMzMzLTgyLjY2Ny0xNTcuNjY3XFxuLTE1Mi0yMTFsLTMtM2gzOTk5MDd2LTQwek05MyAyODEgSDQwMDAwMCB2LTQwTDcgMjQxelwiLFxuICBsZWZ0aGFycG9vbmRvd25wbHVzOiBcIk03IDQzNWMtNCA0LTYuMyA4LjctNyAxNCAwIDUuMy43IDkgMiAxMXM1LjMgNS4zIDEyXFxuIDEwYzkwLjcgNTQgMTU2IDEzMCAxOTYgMjI4IDMuMyAxMC43IDYuMyAxNi4zIDkgMTcgMiAuNyA1IDEgOSAxaDVjMTAuNyAwIDE2LjdcXG4tMiAxOC02IDItMi43IDEtOS43LTMtMjEtMzItODcuMy04Mi43LTE1Ny43LTE1Mi0yMTFsLTMtM2gzOTk5MDd2LTQwSDd6bTkzIDBcXG52NDBoMzk5OTAwdi00MHpNMCAyNDF2NDBoMzk5OTAwdi00MHptMCAwdjQwaDM5OTkwMHYtNDB6XCIsXG4gIC8vIGhvb2sgaXMgZnJvbSBnbHlwaCBVKzIxQTkgaW4gZm9udCBLYVRlWCBNYWluXG4gIGxlZnRob29rOiBcIk00MDAwMDAgMjgxIEgxMDNzLTMzLTExLjItNjEtMzMuNVMwIDE5Ny4zIDAgMTY0czE0LjItNjEuMiA0Mi41XFxuLTgzLjVDNzAuOCA1OC4yIDEwNCA0NyAxNDIgNDcgYzE2LjcgMCAyNSA2LjcgMjUgMjAgMCAxMi04LjcgMTguNy0yNiAyMC00MCAzLjNcXG4tNjguNyAxNS43LTg2IDM3LTEwIDEyLTE1IDI1LjMtMTUgNDAgMCAyMi43IDkuOCA0MC43IDI5LjUgNTQgMTkuNyAxMy4zIDQzLjUgMjFcXG4gNzEuNSAyM2gzOTk4NTl6TTEwMyAyODF2LTQwaDM5OTg5N3Y0MHpcIixcbiAgbGVmdGxpbmVzZWdtZW50OiBcIk00MCAyODEgVjQyOCBIMCBWOTQgSDQwIFYyNDEgSDQwMDAwMCB2NDB6XFxuTTQwIDI4MSBWNDI4IEgwIFY5NCBINDAgVjI0MSBINDAwMDAwIHY0MHpcIixcbiAgbGVmdG1hcHN0bzogXCJNNDAgMjgxIFY0NDhIMFY3NEg0MFYyNDFINDAwMDAwdjQwelxcbk00MCAyODEgVjQ0OEgwVjc0SDQwVjI0MUg0MDAwMDB2NDB6XCIsXG4gIC8vIHRvZnJvbSBpcyBmcm9tIGdseXBoIFUrMjFDNCBpbiBmb250IEthVGVYIEFNUyBSZWd1bGFyXG4gIGxlZnRUb0Zyb206IFwiTTAgMTQ3aDQwMDAwMHY0MEgwem0wIDIxNGM2OCA0MCAxMTUuNyA5NS43IDE0MyAxNjdoMjJjMTUuMyAwIDIzXFxuLS4zIDIzLTEgMC0xLjMtNS4zLTEzLjctMTYtMzctMTgtMzUuMy00MS4zLTY5LTcwLTEwMWwtNy04aDM5OTkwNXYtNDBIOTVsNy04XFxuYzI4LjctMzIgNTItNjUuNyA3MC0xMDEgMTAuNy0yMy4zIDE2LTM1LjcgMTYtMzcgMC0uNy03LjctMS0yMy0xaC0yMkMxMTUuNyAyNjUuM1xcbiA2OCAzMjEgMCAzNjF6bTAtMTc0di00MGgzOTk5MDB2NDB6bTEwMCAxNTR2NDBoMzk5OTAwdi00MHpcIixcbiAgbG9uZ2VxdWFsOiBcIk0wIDUwIGg0MDAwMDAgdjQwSDB6IG0wIDE5NGg0MDAwMHY0MEgwelxcbk0wIDUwIGg0MDAwMDAgdjQwSDB6IG0wIDE5NGg0MDAwMHY0MEgwelwiLFxuICBtaWRicmFjZTogXCJNMjAwNDI4IDMzNFxcbmMtMTAwLjctOC4zLTE5NS4zLTQ0LTI4MC0xMDgtNTUuMy00Mi0xMDEuNy05My0xMzktMTUzbC05LTE0Yy0yLjcgNC01LjcgOC43LTkgMTRcXG4tNTMuMyA4Ni43LTEyMy43IDE1My0yMTEgMTk5LTY2LjcgMzYtMTM3LjMgNTYuMy0yMTIgNjJIMFYyMTRoMTk5NTY4YzE3OC4zLTExLjdcXG4gMzExLjctNzguMyA0MDMtMjAxIDYtOCA5LjctMTIgMTEtMTIgLjctLjcgNi43LTEgMTgtMXMxNy4zLjMgMTggMWMxLjMgMCA1IDQgMTFcXG4gMTIgNDQuNyA1OS4zIDEwMS4zIDEwNi4zIDE3MCAxNDFzMTQ1LjMgNTQuMyAyMjkgNjBoMTk5NTcydjEyMHpcIixcbiAgbWlkYnJhY2V1bmRlcjogXCJNMTk5NTcyIDIxNFxcbmMxMDAuNyA4LjMgMTk1LjMgNDQgMjgwIDEwOCA1NS4zIDQyIDEwMS43IDkzIDEzOSAxNTNsOSAxNGMyLjctNCA1LjctOC43IDktMTRcXG4gNTMuMy04Ni43IDEyMy43LTE1MyAyMTEtMTk5IDY2LjctMzYgMTM3LjMtNTYuMyAyMTItNjJoMTk5NTY4djEyMEgyMDA0MzJjLTE3OC4zXFxuIDExLjctMzExLjcgNzguMy00MDMgMjAxLTYgOC05LjcgMTItMTEgMTItLjcuNy02LjcgMS0xOCAxcy0xNy4zLS4zLTE4LTFjLTEuMyAwXFxuLTUtNC0xMS0xMi00NC43LTU5LjMtMTAxLjMtMTA2LjMtMTcwLTE0MXMtMTQ1LjMtNTQuMy0yMjktNjBIMFYyMTR6XCIsXG4gIG9paW50U2l6ZTE6IFwiTTUxMi42IDcxLjZjMjcyLjYgMCAzMjAuMyAxMDYuOCAzMjAuMyAxNzguMiAwIDcwLjgtNDcuNyAxNzcuNlxcbi0zMjAuMyAxNzcuNlMxOTMuMSAzMjAuNiAxOTMuMSAyNDkuOGMwLTcxLjQgNDYuOS0xNzguMiAzMTkuNS0xNzguMnpcXG5tMzY4LjEgMTc4LjJjMC04Ni40LTYwLjktMjE1LjQtMzY4LjEtMjE1LjQtMzA2LjQgMC0zNjcuMyAxMjktMzY3LjMgMjE1LjQgMCA4NS44XFxuNjAuOSAyMTQuOCAzNjcuMyAyMTQuOCAzMDcuMiAwIDM2OC4xLTEyOSAzNjguMS0yMTQuOHpcIixcbiAgb2lpbnRTaXplMjogXCJNNzU3LjggMTAwLjFjMzg0LjcgMCA0NTEuMSAxMzcuNiA0NTEuMSAyMzAgMCA5MS4zLTY2LjQgMjI4LjhcXG4tNDUxLjEgMjI4LjgtMzg2LjMgMC00NTIuNy0xMzcuNS00NTIuNy0yMjguOCAwLTkyLjQgNjYuNC0yMzAgNDUyLjctMjMwelxcbm01MDIuNCAyMzBjMC0xMTEuMi04Mi40LTI3Ny4yLTUwMi40LTI3Ny4ycy01MDQgMTY2LTUwNCAyNzcuMlxcbmMwIDExMCA4NCAyNzYgNTA0IDI3NnM1MDIuNC0xNjYgNTAyLjQtMjc2elwiLFxuICBvaWlpbnRTaXplMTogXCJNNjgxLjQgNzEuNmM0MDguOSAwIDQ4MC41IDEwNi44IDQ4MC41IDE3OC4yIDAgNzAuOC03MS42IDE3Ny42XFxuLTQ4MC41IDE3Ny42UzIwMi4xIDMyMC42IDIwMi4xIDI0OS44YzAtNzEuNCA3MC41LTE3OC4yIDQ3OS4zLTE3OC4yelxcbm01MjUuOCAxNzguMmMwLTg2LjQtODYuOC0yMTUuNC01MjUuNy0yMTUuNC00MzcuOSAwLTUyNC43IDEyOS01MjQuNyAyMTUuNCAwXFxuODUuOCA4Ni44IDIxNC44IDUyNC43IDIxNC44IDQzOC45IDAgNTI1LjctMTI5IDUyNS43LTIxNC44elwiLFxuICBvaWlpbnRTaXplMjogXCJNMTAyMS4yIDUzYzYwMy42IDAgNzA3LjggMTY1LjggNzA3LjggMjc3LjIgMCAxMTAtMTA0LjIgMjc1LjhcXG4tNzA3LjggMjc1LjgtNjA2IDAtNzEwLjItMTY1LjgtNzEwLjItMjc1LjhDMzExIDIxOC44IDQxNS4yIDUzIDEwMjEuMiA1M3pcXG5tNzcwLjQgMjc3LjFjMC0xMzEuMi0xMjYuNC0zMjcuNi03NzAuNS0zMjcuNlMyNDguNCAxOTguOSAyNDguNCAzMzAuMVxcbmMwIDEzMCAxMjguOCAzMjYuNCA3NzIuNyAzMjYuNHM3NzAuNS0xOTYuNCA3NzAuNS0zMjYuNHpcIixcbiAgcmlnaHRhcnJvdzogXCJNMCAyNDF2NDBoMzk5ODkxYy00Ny4zIDM1LjMtODQgNzgtMTEwIDEyOFxcbi0xNi43IDMyLTI3LjcgNjMuNy0zMyA5NSAwIDEuMy0uMiAyLjctLjUgNC0uMyAxLjMtLjUgMi4zLS41IDMgMCA3LjMgNi43IDExIDIwXFxuIDExIDggMCAxMy4yLS44IDE1LjUtMi41IDIuMy0xLjcgNC4yLTUuNSA1LjUtMTEuNSAyLTEzLjMgNS43LTI3IDExLTQxIDE0LjctNDQuN1xcbiAzOS04NC41IDczLTExOS41czczLjctNjAuMiAxMTktNzUuNWM2LTIgOS01LjcgOS0xMXMtMy05LTktMTFjLTQ1LjMtMTUuMy04NVxcbi00MC41LTExOS03NS41cy01OC4zLTc0LjgtNzMtMTE5LjVjLTQuNy0xNC04LjMtMjcuMy0xMS00MC0xLjMtNi43LTMuMi0xMC44LTUuNVxcbi0xMi41LTIuMy0xLjctNy41LTIuNS0xNS41LTIuNS0xNCAwLTIxIDMuNy0yMSAxMSAwIDIgMiAxMC4zIDYgMjUgMjAuNyA4My4zIDY3XFxuIDE1MS43IDEzOSAyMDV6bTAgMHY0MGgzOTk5MDB2LTQwelwiLFxuICByaWdodGJyYWNlOiBcIk00MDAwMDAgNTQybFxcbi02IDZoLTE3Yy0xMi43IDAtMTkuMy0uMy0yMC0xLTQtNC03LjMtOC4zLTEwLTEzLTM1LjMtNTEuMy04MC44LTkzLjgtMTM2LjUtMTI3LjVcXG5zLTExNy4yLTU1LjgtMTg0LjUtNjYuNWMtLjcgMC0yLS4zLTQtMS0xOC43LTIuNy03Ni00LjMtMTcyLTVIMFYyMTRoMzk5NTcxbDYgMVxcbmMxMjQuNyA4IDIzNSA2MS43IDMzMSAxNjEgMzEuMyAzMy4zIDU5LjcgNzIuNyA4NSAxMThsNyAxM3YzNXpcIixcbiAgcmlnaHRicmFjZXVuZGVyOiBcIk0zOTk5OTQgMGw2IDZ2MzVsLTYgMTFjLTU2IDEwNC0xMzUuMyAxODEuMy0yMzggMjMyLTU3LjNcXG4gMjguNy0xMTcgNDUtMTc5IDUwSC0zMDBWMjE0aDM5OTg5N2M0My4zLTcgODEtMTUgMTEzLTI2IDEwMC43LTMzIDE3OS43LTkxIDIzN1xcbi0xNzQgMi43LTUgNi05IDEwLTEzIC43LTEgNy4zLTEgMjAtMWgxN3pcIixcbiAgcmlnaHRncm91cDogXCJNMCA4MGgzOTk1NjVjMzcxIDAgMjY2LjcgMTQ5LjQgNDE0IDE4MCA1LjkgMS4yIDE4IDAgMTggMCAyIDBcXG4gMy0xIDMtM3YtMzhjLTc2LTE1OC0yNTctMjE5LTQzNS0yMTlIMHpcIixcbiAgcmlnaHRncm91cHVuZGVyOiBcIk0wIDI2MmgzOTk1NjVjMzcxIDAgMjY2LjctMTQ5LjQgNDE0LTE4MCA1LjktMS4yIDE4IDAgMThcXG4gMCAyIDAgMyAxIDMgM3YzOGMtNzYgMTU4LTI1NyAyMTktNDM1IDIxOUgwelwiLFxuICByaWdodGhhcnBvb246IFwiTTAgMjQxdjQwaDM5OTk5M2M0LjctNC43IDctOS4zIDctMTQgMC05LjNcXG4tMy43LTE1LjMtMTEtMTgtOTIuNy01Ni43LTE1OS0xMzMuNy0xOTktMjMxLTMuMy05LjMtNi0xNC43LTgtMTYtMi0xLjMtNy0yLTE1LTJcXG4tMTAuNyAwLTE2LjcgMi0xOCA2LTIgMi43LTEgOS43IDMgMjEgMTUuMyA0MiAzNi43IDgxLjggNjQgMTE5LjUgMjcuMyAzNy43IDU4XFxuIDY5LjIgOTIgOTQuNXptMCAwdjQwaDM5OTkwMHYtNDB6XCIsXG4gIHJpZ2h0aGFycG9vbnBsdXM6IFwiTTAgMjQxdjQwaDM5OTk5M2M0LjctNC43IDctOS4zIDctMTQgMC05LjMtMy43LTE1LjMtMTFcXG4tMTgtOTIuNy01Ni43LTE1OS0xMzMuNy0xOTktMjMxLTMuMy05LjMtNi0xNC43LTgtMTYtMi0xLjMtNy0yLTE1LTItMTAuNyAwLTE2LjdcXG4gMi0xOCA2LTIgMi43LTEgOS43IDMgMjEgMTUuMyA0MiAzNi43IDgxLjggNjQgMTE5LjUgMjcuMyAzNy43IDU4IDY5LjIgOTIgOTQuNXpcXG5tMCAwdjQwaDM5OTkwMHYtNDB6IG0xMDAgMTk0djQwaDM5OTkwMHYtNDB6bTAgMHY0MGgzOTk5MDB2LTQwelwiLFxuICByaWdodGhhcnBvb25kb3duOiBcIk0zOTk3NDcgNTExYzAgNy4zIDYuNyAxMSAyMCAxMSA4IDAgMTMtLjggMTUtMi41czQuNy02LjhcXG4gOC0xNS41YzQwLTk0IDk5LjMtMTY2LjMgMTc4LTIxNyAxMy4zLTggMjAuMy0xMi4zIDIxLTEzIDUuMy0zLjMgOC41LTUuOCA5LjVcXG4tNy41IDEtMS43IDEuNS01LjIgMS41LTEwLjVzLTIuMy0xMC4zLTctMTVIMHY0MGgzOTk5MDhjLTM0IDI1LjMtNjQuNyA1Ny05MiA5NVxcbi0yNy4zIDM4LTQ4LjcgNzcuNy02NCAxMTktMy4zIDguNy01IDE0LTUgMTZ6TTAgMjQxdjQwaDM5OTkwMHYtNDB6XCIsXG4gIHJpZ2h0aGFycG9vbmRvd25wbHVzOiBcIk0zOTk3NDcgNzA1YzAgNy4zIDYuNyAxMSAyMCAxMSA4IDAgMTMtLjhcXG4gMTUtMi41czQuNy02LjggOC0xNS41YzQwLTk0IDk5LjMtMTY2LjMgMTc4LTIxNyAxMy4zLTggMjAuMy0xMi4zIDIxLTEzIDUuMy0zLjNcXG4gOC41LTUuOCA5LjUtNy41IDEtMS43IDEuNS01LjIgMS41LTEwLjVzLTIuMy0xMC4zLTctMTVIMHY0MGgzOTk5MDhjLTM0IDI1LjNcXG4tNjQuNyA1Ny05MiA5NS0yNy4zIDM4LTQ4LjcgNzcuNy02NCAxMTktMy4zIDguNy01IDE0LTUgMTZ6TTAgNDM1djQwaDM5OTkwMHYtNDB6XFxubTAtMTk0djQwaDQwMDAwMHYtNDB6bTAgMHY0MGg0MDAwMDB2LTQwelwiLFxuICByaWdodGhvb2s6IFwiTTM5OTg1OSAyNDFjLTc2NCAwIDAgMCAwIDAgNDAtMy4zIDY4LjctMTUuNyA4Ni0zNyAxMC0xMiAxNS0yNS4zXFxuIDE1LTQwIDAtMjIuNy05LjgtNDAuNy0yOS41LTU0LTE5LjctMTMuMy00My41LTIxLTcxLjUtMjMtMTcuMy0xLjMtMjYtOC0yNi0yMCAwXFxuLTEzLjMgOC43LTIwIDI2LTIwIDM4IDAgNzEgMTEuMiA5OSAzMy41IDAgMCA3IDUuNiAyMSAxNi43IDE0IDExLjIgMjEgMzMuNSAyMVxcbiA2Ni44cy0xNCA2MS4yLTQyIDgzLjVjLTI4IDIyLjMtNjEgMzMuNS05OSAzMy41TDAgMjQxeiBNMCAyODF2LTQwaDM5OTg1OXY0MHpcIixcbiAgcmlnaHRsaW5lc2VnbWVudDogXCJNMzk5OTYwIDI0MSBWOTQgaDQwIFY0MjggaC00MCBWMjgxIEgwIHYtNDB6XFxuTTM5OTk2MCAyNDEgVjk0IGg0MCBWNDI4IGgtNDAgVjI4MSBIMCB2LTQwelwiLFxuICByaWdodFRvRnJvbTogXCJNNDAwMDAwIDE2N2MtNzAuNy00Mi0xMTgtOTcuNy0xNDItMTY3aC0yM2MtMTUuMyAwLTIzIC4zLTIzXFxuIDEgMCAxLjMgNS4zIDEzLjcgMTYgMzcgMTggMzUuMyA0MS4zIDY5IDcwIDEwMWw3IDhIMHY0MGgzOTk5MDVsLTcgOGMtMjguNyAzMlxcbi01MiA2NS43LTcwIDEwMS0xMC43IDIzLjMtMTYgMzUuNy0xNiAzNyAwIC43IDcuNyAxIDIzIDFoMjNjMjQtNjkuMyA3MS4zLTEyNSAxNDJcXG4tMTY3eiBNMTAwIDE0N3Y0MGgzOTk5MDB2LTQwek0wIDM0MXY0MGgzOTk5MDB2LTQwelwiLFxuICAvLyB0d29oZWFkbGVmdGFycm93IGlzIGZyb20gZ2x5cGggVSsyMTlFIGluIGZvbnQgS2FUZVggQU1TIFJlZ3VsYXJcbiAgdHdvaGVhZGxlZnRhcnJvdzogXCJNMCAxNjdjNjggNDBcXG4gMTE1LjcgOTUuNyAxNDMgMTY3aDIyYzE1LjMgMCAyMy0uMyAyMy0xIDAtMS4zLTUuMy0xMy43LTE2LTM3LTE4LTM1LjMtNDEuMy02OVxcbi03MC0xMDFsLTctOGgxMjVsOSA3YzUwLjcgMzkuMyA4NSA4NiAxMDMgMTQwaDQ2YzAtNC43LTYuMy0xOC43LTE5LTQyLTE4LTM1LjNcXG4tNDAtNjcuMy02Ni05NmwtOS05aDM5OTcxNnYtNDBIMjg0bDktOWMyNi0yOC43IDQ4LTYwLjcgNjYtOTYgMTIuNy0yMy4zMzMgMTlcXG4tMzcuMzMzIDE5LTQyaC00NmMtMTggNTQtNTIuMyAxMDAuNy0xMDMgMTQwbC05IDdIOTVsNy04YzI4LjctMzIgNTItNjUuNyA3MC0xMDFcXG4gMTAuNy0yMy4zMzMgMTYtMzUuNyAxNi0zNyAwLS43LTcuNy0xLTIzLTFoLTIyQzExNS43IDcxLjMgNjggMTI3IDAgMTY3elwiLFxuICB0d29oZWFkcmlnaHRhcnJvdzogXCJNNDAwMDAwIDE2N1xcbmMtNjgtNDAtMTE1LjctOTUuNy0xNDMtMTY3aC0yMmMtMTUuMyAwLTIzIC4zLTIzIDEgMCAxLjMgNS4zIDEzLjcgMTYgMzcgMTggMzUuM1xcbiA0MS4zIDY5IDcwIDEwMWw3IDhoLTEyNWwtOS03Yy01MC43LTM5LjMtODUtODYtMTAzLTE0MGgtNDZjMCA0LjcgNi4zIDE4LjcgMTkgNDJcXG4gMTggMzUuMyA0MCA2Ny4zIDY2IDk2bDkgOUgwdjQwaDM5OTcxNmwtOSA5Yy0yNiAyOC43LTQ4IDYwLjctNjYgOTYtMTIuNyAyMy4zMzNcXG4tMTkgMzcuMzMzLTE5IDQyaDQ2YzE4LTU0IDUyLjMtMTAwLjcgMTAzLTE0MGw5LTdoMTI1bC03IDhjLTI4LjcgMzItNTIgNjUuNy03MFxcbiAxMDEtMTAuNyAyMy4zMzMtMTYgMzUuNy0xNiAzNyAwIC43IDcuNyAxIDIzIDFoMjJjMjcuMy03MS4zIDc1LTEyNyAxNDMtMTY3elwiLFxuICAvLyB0aWxkZTEgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIGEgZ2x5cGggZnJvbSB0aGUgTW5TeW1ib2wgcGFja2FnZVxuICB0aWxkZTE6IFwiTTIwMCA1NS41MzhjLTc3IDAtMTY4IDczLjk1My0xNzcgNzMuOTUzLTMgMC03XFxuLTIuMTc1LTktNS40MzdMMiA5N2MtMS0yLTItNC0yLTYgMC00IDItNyA1LTlsMjAtMTJDMTE2IDEyIDE3MSAwIDIwNyAwYzg2IDBcXG4gMTE0IDY4IDE5MSA2OCA3OCAwIDE2OC02OCAxNzctNjggNCAwIDcgMiA5IDVsMTIgMTljMSAyLjE3NSAyIDQuMzUgMiA2LjUyNSAwXFxuIDQuMzUtMiA3LjYxMy01IDkuNzg4bC0xOSAxMy4wNWMtOTIgNjMuMDc3LTExNi45MzcgNzUuMzA4LTE4MyA3Ni4xMjhcXG4tNjguMjY3Ljg0Ny0xMTMtNzMuOTUyLTE5MS03My45NTJ6XCIsXG4gIC8vIGRpdHRvIHRpbGRlMiwgdGlsZGUzLCAmIHRpbGRlNFxuICB0aWxkZTI6IFwiTTM0NCA1NS4yNjZjLTE0MiAwLTMwMC42MzggODEuMzE2LTMxMS41IDg2LjQxOFxcbi04LjAxIDMuNzYyLTIyLjUgMTAuOTEtMjMuNSA1LjU2MkwxIDEyMGMtMS0yLTEtMy0xLTQgMC01IDMtOSA4LTEwbDE4LjQtOUMxNjAuOVxcbiAzMS45IDI4MyAwIDM1OCAwYzE0OCAwIDE4OCAxMjIgMzMxIDEyMnMzMTQtOTcgMzI2LTk3YzQgMCA4IDIgMTAgN2w3IDIxLjExNFxcbmMxIDIuMTQgMSAzLjIxIDEgNC4yOCAwIDUuMzQ3LTMgOS42MjYtNyAxMC42OTZsLTIyLjMgMTIuNjIyQzg1Mi42IDE1OC4zNzIgNzUxXFxuIDE4MS40NzYgNjc2IDE4MS40NzZjLTE0OSAwLTE4OS0xMjYuMjEtMzMyLTEyNi4yMXpcIixcbiAgdGlsZGUzOiBcIk03ODYgNTlDNDU3IDU5IDMyIDE3NS4yNDIgMTMgMTc1LjI0MmMtNiAwLTEwLTMuNDU3XFxuLTExLTEwLjM3TC4xNSAxMzhjLTEtNyAzLTEyIDEwLTEzbDE5LjItNi40QzM3OC40IDQwLjcgNjM0LjMgMCA4MDQuMyAwYzMzNyAwXFxuIDQxMS44IDE1NyA3NDYuOCAxNTcgMzI4IDAgNzU0LTExMiA3NzMtMTEyIDUgMCAxMCAzIDExIDlsMSAxNC4wNzVjMSA4LjA2Ni0uNjk3XFxuIDE2LjU5NS02LjY5NyAxNy40OTJsLTIxLjA1MiA3LjMxYy0zNjcuOSA5OC4xNDYtNjA5LjE1IDEyMi42OTYtNzc4LjE1IDEyMi42OTZcXG4gLTMzOCAwLTQwOS0xNTYuNTczLTc0NC0xNTYuNTczelwiLFxuICB0aWxkZTQ6IFwiTTc4NiA1OEM0NTcgNTggMzIgMTc3LjQ4NyAxMyAxNzcuNDg3Yy02IDAtMTAtMy4zNDVcXG4tMTEtMTAuMDM1TC4xNSAxNDNjLTEtNyAzLTEyIDEwLTEzbDIyLTYuN0MzODEuMiAzNSA2MzcuMTUgMCA4MDcuMTUgMGMzMzcgMCA0MDlcXG4gMTc3IDc0NCAxNzcgMzI4IDAgNzU0LTEyNyA3NzMtMTI3IDUgMCAxMCAzIDExIDlsMSAxNC43OTRjMSA3LjgwNS0zIDEzLjM4LTlcXG4gMTQuNDk1bC0yMC43IDUuNTc0Yy0zNjYuODUgOTkuNzktNjA3LjMgMTM5LjM3Mi03NzYuMyAxMzkuMzcyLTMzOCAwLTQwOVxcbiAtMTc1LjIzNi03NDQtMTc1LjIzNnpcIixcbiAgLy8gdmVjIGlzIGZyb20gZ2x5cGggVSsyMEQ3IGluIGZvbnQgS2FUZVggTWFpblxuICB2ZWM6IFwiTTM3NyAyMGMwLTUuMzMzIDEuODMzLTEwIDUuNS0xNFMzOTEgMCAzOTcgMGM0LjY2NyAwIDguNjY3IDEuNjY3IDEyIDVcXG4zLjMzMyAyLjY2NyA2LjY2NyA5IDEwIDE5IDYuNjY3IDI0LjY2NyAyMC4zMzMgNDMuNjY3IDQxIDU3IDcuMzMzIDQuNjY3IDExXFxuMTAuNjY3IDExIDE4IDAgNi0xIDEwLTMgMTJzLTYuNjY3IDUtMTQgOWMtMjguNjY3IDE0LjY2Ny01My42NjcgMzUuNjY3LTc1IDYzXFxuLTEuMzMzIDEuMzMzLTMuMTY3IDMuNS01LjUgNi41cy00IDQuODMzLTUgNS41Yy0xIC42NjctMi41IDEuMzMzLTQuNSAycy00LjMzMyAxXFxuLTcgMWMtNC42NjcgMC05LjE2Ny0xLjgzMy0xMy41LTUuNVMzMzcgMTg0IDMzNyAxNzhjMC0xMi42NjcgMTUuNjY3LTMyLjMzMyA0Ny01OVxcbkgyMTNsLTE3MS0xYy04LjY2Ny02LTEzLTEyLjMzMy0xMy0xOSAwLTQuNjY3IDQuMzMzLTExLjMzMyAxMy0yMGgzNTlcXG5jLTE2LTI1LjMzMy0yNC00NS0yNC01OXpcIixcbiAgLy8gd2lkZWhhdDEgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIGEgZ2x5cGggZnJvbSB0aGUgTW5TeW1ib2wgcGFja2FnZVxuICB3aWRlaGF0MTogXCJNNTI5IDBoNWw1MTkgMTE1YzUgMSA5IDUgOSAxMCAwIDEtMSAyLTEgM2wtNCAyMlxcbmMtMSA1LTUgOS0xMSA5aC0yTDUzMiA2NyAxOSAxNTloLTJjLTUgMC05LTQtMTEtOWwtNS0yMmMtMS02IDItMTIgOC0xM3pcIixcbiAgLy8gZGl0dG8gd2lkZWhhdDIsIHdpZGVoYXQzLCAmIHdpZGVoYXQ0XG4gIHdpZGVoYXQyOiBcIk0xMTgxIDBoMmwxMTcxIDE3NmM2IDAgMTAgNSAxMCAxMWwtMiAyM2MtMSA2LTUgMTBcXG4tMTEgMTBoLTFMMTE4MiA2NyAxNSAyMjBoLTFjLTYgMC0xMC00LTExLTEwbC0yLTIzYy0xLTYgNC0xMSAxMC0xMXpcIixcbiAgd2lkZWhhdDM6IFwiTTExODEgMGgybDExNzEgMjM2YzYgMCAxMCA1IDEwIDExbC0yIDIzYy0xIDYtNSAxMFxcbi0xMSAxMGgtMUwxMTgyIDY3IDE1IDI4MGgtMWMtNiAwLTEwLTQtMTEtMTBsLTItMjNjLTEtNiA0LTExIDEwLTExelwiLFxuICB3aWRlaGF0NDogXCJNMTE4MSAwaDJsMTE3MSAyOTZjNiAwIDEwIDUgMTAgMTFsLTIgMjNjLTEgNi01IDEwXFxuLTExIDEwaC0xTDExODIgNjcgMTUgMzQwaC0xYy02IDAtMTAtNC0xMS0xMGwtMi0yM2MtMS02IDQtMTEgMTAtMTF6XCIsXG4gIC8vIHdpZGVjaGVjayBwYXRocyBhcmUgYWxsIGludmVydGVkIHZlcnNpb25zIG9mIHdpZGVoYXRcbiAgd2lkZWNoZWNrMTogXCJNNTI5LDE1OWg1bDUxOSwtMTE1YzUsLTEsOSwtNSw5LC0xMGMwLC0xLC0xLC0yLC0xLC0zbC00LC0yMmMtMSxcXG4tNSwtNSwtOSwtMTEsLTloLTJsLTUxMiw5MmwtNTEzLC05MmgtMmMtNSwwLC05LDQsLTExLDlsLTUsMjJjLTEsNiwyLDEyLDgsMTN6XCIsXG4gIHdpZGVjaGVjazI6IFwiTTExODEsMjIwaDJsMTE3MSwtMTc2YzYsMCwxMCwtNSwxMCwtMTFsLTIsLTIzYy0xLC02LC01LC0xMCxcXG4tMTEsLTEwaC0xbC0xMTY4LDE1M2wtMTE2NywtMTUzaC0xYy02LDAsLTEwLDQsLTExLDEwbC0yLDIzYy0xLDYsNCwxMSwxMCwxMXpcIixcbiAgd2lkZWNoZWNrMzogXCJNMTE4MSwyODBoMmwxMTcxLC0yMzZjNiwwLDEwLC01LDEwLC0xMWwtMiwtMjNjLTEsLTYsLTUsLTEwLFxcbi0xMSwtMTBoLTFsLTExNjgsMjEzbC0xMTY3LC0yMTNoLTFjLTYsMCwtMTAsNCwtMTEsMTBsLTIsMjNjLTEsNiw0LDExLDEwLDExelwiLFxuICB3aWRlY2hlY2s0OiBcIk0xMTgxLDM0MGgybDExNzEsLTI5NmM2LDAsMTAsLTUsMTAsLTExbC0yLC0yM2MtMSwtNiwtNSwtMTAsXFxuLTExLC0xMGgtMWwtMTE2OCwyNzNsLTExNjcsLTI3M2gtMWMtNiwwLC0xMCw0LC0xMSwxMGwtMiwyM2MtMSw2LDQsMTEsMTAsMTF6XCIsXG4gIC8vIFRoZSBuZXh0IHRlbiBwYXRocyBzdXBwb3J0IHJlYWN0aW9uIGFycm93cyBmcm9tIHRoZSBtaGNoZW0gcGFja2FnZS5cbiAgLy8gQXJyb3dzIGZvciBcXGNlezwtLT59IGFyZSBvZmZzZXQgZnJvbSB4QXhpcyBieSAwLjIyZXgsIHBlciBtaGNoZW0gaW4gTGFUZVhcbiAgLy8gYmFyYWJvdmVsZWZ0YXJyb3cgaXMgbW9zdGx5IGZyb20gZnJvbSBnbHlwaCBVKzIxOTAgaW4gZm9udCBLYVRlWCBNYWluXG4gIGJhcmFib3ZlbGVmdGFycm93OiBcIk00MDAwMDAgNjIwaC0zOTk4OTBsMyAtM2M2OC43IC01Mi43IDExMy43IC0xMjAgMTM1IC0yMDJcXG5jNCAtMTQuNyA2IC0yMyA2IC0yNWMwIC03LjMgLTcgLTExIC0yMSAtMTFjLTggMCAtMTMuMiAwLjggLTE1LjUgMi41XFxuYy0yLjMgMS43IC00LjIgNS44IC01LjUgMTIuNWMtMS4zIDQuNyAtMi43IDEwLjMgLTQgMTdjLTEyIDQ4LjcgLTM0LjggOTIgLTY4LjUgMTMwXFxucy03NC4yIDY2LjMgLTEyMS41IDg1Yy0xMCA0IC0xNiA3LjcgLTE4IDExYzAgOC43IDYgMTQuMyAxOCAxN2M0Ny4zIDE4LjcgODcuOCA0N1xcbjEyMS41IDg1czU2LjUgODEuMyA2OC41IDEzMGMwLjcgMiAxLjMgNSAyIDlzMS4yIDYuNyAxLjUgOGMwLjMgMS4zIDEgMy4zIDIgNlxcbnMyLjIgNC41IDMuNSA1LjVjMS4zIDEgMy4zIDEuOCA2IDIuNXM2IDEgMTAgMWMxNCAwIDIxIC0zLjcgMjEgLTExXFxuYzAgLTIgLTIgLTEwLjMgLTYgLTI1Yy0yMCAtNzkuMyAtNjUgLTE0Ni43IC0xMzUgLTIwMmwtMyAtM2gzOTk4OTB6XFxuTTEwMCA2MjB2NDBoMzk5OTAwdi00MHogTTAgMjQxdjQwaDM5OTkwMHYtNDB6TTAgMjQxdjQwaDM5OTkwMHYtNDB6XCIsXG4gIC8vIHJpZ2h0YXJyb3dhYm92ZWJhciBpcyBtb3N0bHkgZnJvbSBnbHlwaCBVKzIxOTIsIEthVGVYIE1haW5cbiAgcmlnaHRhcnJvd2Fib3ZlYmFyOiBcIk0wIDI0MXY0MGgzOTk4OTFjLTQ3LjMgMzUuMy04NCA3OC0xMTAgMTI4LTE2LjcgMzJcXG4tMjcuNyA2My43LTMzIDk1IDAgMS4zLS4yIDIuNy0uNSA0LS4zIDEuMy0uNSAyLjMtLjUgMyAwIDcuMyA2LjcgMTEgMjAgMTEgOCAwXFxuMTMuMi0uOCAxNS41LTIuNSAyLjMtMS43IDQuMi01LjUgNS41LTExLjUgMi0xMy4zIDUuNy0yNyAxMS00MSAxNC43LTQ0LjcgMzlcXG4tODQuNSA3My0xMTkuNXM3My43LTYwLjIgMTE5LTc1LjVjNi0yIDktNS43IDktMTFzLTMtOS05LTExYy00NS4zLTE1LjMtODUtNDAuNVxcbi0xMTktNzUuNXMtNTguMy03NC44LTczLTExOS41Yy00LjctMTQtOC4zLTI3LjMtMTEtNDAtMS4zLTYuNy0zLjItMTAuOC01LjVcXG4tMTIuNS0yLjMtMS43LTcuNS0yLjUtMTUuNS0yLjUtMTQgMC0yMSAzLjctMjEgMTEgMCAyIDIgMTAuMyA2IDI1IDIwLjcgODMuMyA2N1xcbjE1MS43IDEzOSAyMDV6bTk2IDM3OWgzOTk4OTR2NDBIMHptMCAwaDM5OTkwNHY0MEgwelwiLFxuICAvLyBUaGUgc2hvcnQgbGVmdCBoYXJwb29uIGhhcyAwLjVlbSAoaS5lLiA1MDAgdW5pdHMpIGtlcm4gb24gdGhlIGxlZnQgZW5kLlxuICAvLyBSZWYgZnJvbSBtaGNoZW0uc3R5OiBcXHJsYXB7XFxyYWlzZWJveHstLjIyZXh9eyRcXGtlcm4wLjVlbVxuICBiYXJhYm92ZXNob3J0bGVmdGhhcnBvb246IFwiTTUwNyw0MzVjLTQsNCwtNi4zLDguNywtNywxNGMwLDUuMywwLjcsOSwyLDExXFxuYzEuMywyLDUuMyw1LjMsMTIsMTBjOTAuNyw1NCwxNTYsMTMwLDE5NiwyMjhjMy4zLDEwLjcsNi4zLDE2LjMsOSwxN1xcbmMyLDAuNyw1LDEsOSwxYzAsMCw1LDAsNSwwYzEwLjcsMCwxNi43LC0yLDE4LC02YzIsLTIuNywxLC05LjcsLTMsLTIxXFxuYy0zMiwtODcuMywtODIuNywtMTU3LjcsLTE1MiwtMjExYzAsMCwtMywtMywtMywtM2wzOTkzNTEsMGwwLC00MFxcbmMtMzk4NTcwLDAsLTM5OTQzNywwLC0zOTk0MzcsMHogTTU5MyA0MzUgdjQwIEgzOTk1MDAgdi00MHpcXG5NMCAyODEgdi00MCBIMzk5OTA4IHY0MHogTTAgMjgxIHYtNDAgSDM5OTkwOCB2NDB6XCIsXG4gIHJpZ2h0aGFycG9vbmFib3Zlc2hvcnRiYXI6IFwiTTAsMjQxIGwwLDQwYzM5OTEyNiwwLDM5OTk5MywwLDM5OTk5MywwXFxuYzQuNywtNC43LDcsLTkuMyw3LC0xNGMwLC05LjMsLTMuNywtMTUuMywtMTEsLTE4Yy05Mi43LC01Ni43LC0xNTksLTEzMy43LC0xOTksXFxuLTIzMWMtMy4zLC05LjMsLTYsLTE0LjcsLTgsLTE2Yy0yLC0xLjMsLTcsLTIsLTE1LC0yYy0xMC43LDAsLTE2LjcsMiwtMTgsNlxcbmMtMiwyLjcsLTEsOS43LDMsMjFjMTUuMyw0MiwzNi43LDgxLjgsNjQsMTE5LjVjMjcuMywzNy43LDU4LDY5LjIsOTIsOTQuNXpcXG5NMCAyNDEgdjQwIEgzOTk5MDggdi00MHogTTAgNDc1IHYtNDAgSDM5OTUwMCB2NDB6IE0wIDQ3NSB2LTQwIEgzOTk1MDAgdjQwelwiLFxuICBzaG9ydGJhcmFib3ZlbGVmdGhhcnBvb246IFwiTTcsNDM1Yy00LDQsLTYuMyw4LjcsLTcsMTRjMCw1LjMsMC43LDksMiwxMVxcbmMxLjMsMiw1LjMsNS4zLDEyLDEwYzkwLjcsNTQsMTU2LDEzMCwxOTYsMjI4YzMuMywxMC43LDYuMywxNi4zLDksMTdjMiwwLjcsNSwxLDksXFxuMWMwLDAsNSwwLDUsMGMxMC43LDAsMTYuNywtMiwxOCwtNmMyLC0yLjcsMSwtOS43LC0zLC0yMWMtMzIsLTg3LjMsLTgyLjcsLTE1Ny43LFxcbi0xNTIsLTIxMWMwLDAsLTMsLTMsLTMsLTNsMzk5OTA3LDBsMCwtNDBjLTM5OTEyNiwwLC0zOTk5OTMsMCwtMzk5OTkzLDB6XFxuTTkzIDQzNSB2NDAgSDQwMDAwMCB2LTQweiBNNTAwIDI0MSB2NDAgSDQwMDAwMCB2LTQweiBNNTAwIDI0MSB2NDAgSDQwMDAwMCB2LTQwelwiLFxuICBzaG9ydHJpZ2h0aGFycG9vbmFib3ZlYmFyOiBcIk01MywyNDFsMCw0MGMzOTg1NzAsMCwzOTk0MzcsMCwzOTk0MzcsMFxcbmM0LjcsLTQuNyw3LC05LjMsNywtMTRjMCwtOS4zLC0zLjcsLTE1LjMsLTExLC0xOGMtOTIuNywtNTYuNywtMTU5LC0xMzMuNywtMTk5LFxcbi0yMzFjLTMuMywtOS4zLC02LC0xNC43LC04LC0xNmMtMiwtMS4zLC03LC0yLC0xNSwtMmMtMTAuNywwLC0xNi43LDIsLTE4LDZcXG5jLTIsMi43LC0xLDkuNywzLDIxYzE1LjMsNDIsMzYuNyw4MS44LDY0LDExOS41YzI3LjMsMzcuNyw1OCw2OS4yLDkyLDk0LjV6XFxuTTUwMCAyNDEgdjQwIEgzOTk0MDggdi00MHogTTUwMCA0MzUgdjQwIEg0MDAwMDAgdi00MHpcIlxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHN2Z0dlb21ldHJ5ID0gKHtcbiAgcGF0aDogc3ZnR2VvbWV0cnlfcGF0aFxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90cmVlLmpzXG5cblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIGRvY3VtZW50IGZyYWdtZW50LCB3aGljaCBjb250YWlucyBlbGVtZW50cywgYnV0IHdoZW5cbiAqIHBsYWNlZCBpbnRvIHRoZSBET00gZG9lc24ndCBoYXZlIGFueSByZXByZXNlbnRhdGlvbiBpdHNlbGYuIEl0IG9ubHkgY29udGFpbnNcbiAqIGNoaWxkcmVuIGFuZCBkb2Vzbid0IGhhdmUgYW55IERPTSBub2RlIHByb3BlcnRpZXMuXG4gKi9cbnZhciB0cmVlX0RvY3VtZW50RnJhZ21lbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvLyBIdG1sRG9tTm9kZVxuICAvLyBOZXZlciB1c2VkOyBuZWVkZWQgZm9yIHNhdGlzZnlpbmcgaW50ZXJmYWNlLlxuICBmdW5jdGlvbiBEb2N1bWVudEZyYWdtZW50KGNoaWxkcmVuKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuY2xhc3NlcyA9IFtdO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmRlcHRoID0gMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gMDtcbiAgICB0aGlzLnN0eWxlID0ge307XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKTtcbiAgfVxuICAvKiogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBhIG5vZGUuICovXG4gIDtcblxuICBfcHJvdG8udG9Ob2RlID0gZnVuY3Rpb24gdG9Ob2RlKCkge1xuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFnLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBmcmFnO1xuICB9XG4gIC8qKiBDb252ZXJ0IHRoZSBmcmFnbWVudCBpbnRvIEhUTUwgbWFya3VwLiAqL1xuICA7XG5cbiAgX3Byb3RvLnRvTWFya3VwID0gZnVuY3Rpb24gdG9NYXJrdXAoKSB7XG4gICAgdmFyIG1hcmt1cCA9IFwiXCI7IC8vIFNpbXBseSBjb25jYXRlbmF0ZSB0aGUgbWFya3VwIGZvciB0aGUgY2hpbGRyZW4gdG9nZXRoZXIuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgc3RyaW5nLCBzaW1pbGFyIHRvIGlubmVyVGV4dC4gQXBwbGllcyB0b1xuICAgKiBNYXRoRG9tTm9kZSdzIG9ubHkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvVGV4dCA9IGZ1bmN0aW9uIHRvVGV4dCgpIHtcbiAgICAvLyBUbyBhdm9pZCB0aGlzLCB3ZSB3b3VsZCBzdWJjbGFzcyBkb2N1bWVudEZyYWdtZW50IHNlcGFyYXRlbHkgZm9yXG4gICAgLy8gTWF0aE1MLCBidXQgcG9seWZpbGxzIGZvciBzdWJjbGFzc2luZyBpcyBleHBlbnNpdmUgcGVyIFBSIDE0NjkuXG4gICAgLy8gJEZsb3dGaXhNZTogT25seSB3b3JrcyBmb3IgQ2hpbGRUeXBlID0gTWF0aERvbU5vZGUuXG4gICAgdmFyIHRvVGV4dCA9IGZ1bmN0aW9uIHRvVGV4dChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnRvVGV4dCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAodG9UZXh0KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIHJldHVybiBEb2N1bWVudEZyYWdtZW50O1xufSgpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZG9tVHJlZS5qc1xuLyoqXG4gKiBUaGVzZSBvYmplY3RzIHN0b3JlIHRoZSBkYXRhIGFib3V0IHRoZSBET00gbm9kZXMgd2UgY3JlYXRlLCBhcyB3ZWxsIGFzIHNvbWVcbiAqIGV4dHJhIGRhdGEuIFRoZXkgY2FuIHRoZW4gYmUgdHJhbnNmb3JtZWQgaW50byByZWFsIERPTSBub2RlcyB3aXRoIHRoZVxuICogYHRvTm9kZWAgZnVuY3Rpb24gb3IgSFRNTCBtYXJrdXAgdXNpbmcgYHRvTWFya3VwYC4gVGhleSBhcmUgdXNlZnVsIGZvciBib3RoXG4gKiBzdG9yaW5nIGV4dHJhIHByb3BlcnRpZXMgb24gdGhlIG5vZGVzLCBhcyB3ZWxsIGFzIHByb3ZpZGluZyBhIHdheSB0byBlYXNpbHlcbiAqIHdvcmsgd2l0aCB0aGUgRE9NLlxuICpcbiAqIFNpbWlsYXIgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggTWF0aE1MIG5vZGVzIGV4aXN0IGluIG1hdGhNTFRyZWUuanMuXG4gKlxuICogVE9ETzogcmVmYWN0b3IgYHNwYW5gIGFuZCBgYW5jaG9yYCBpbnRvIGNvbW1vbiBzdXBlcmNsYXNzIHdoZW5cbiAqIHRhcmdldCBlbnZpcm9ubWVudHMgc3VwcG9ydCBjbGFzcyBpbmhlcml0YW5jZVxuICovXG5cblxuXG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gSFRNTCBjbGFzc05hbWUgYmFzZWQgb24gYSBsaXN0IG9mIGNsYXNzZXMuIEluIGFkZGl0aW9uIHRvIGpvaW5pbmdcbiAqIHdpdGggc3BhY2VzLCB3ZSBhbHNvIHJlbW92ZSBlbXB0eSBjbGFzc2VzLlxuICovXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiBjcmVhdGVDbGFzcyhjbGFzc2VzKSB7XG4gIHJldHVybiBjbGFzc2VzLmZpbHRlcihmdW5jdGlvbiAoY2xzKSB7XG4gICAgcmV0dXJuIGNscztcbiAgfSkuam9pbihcIiBcIik7XG59O1xuXG52YXIgaW5pdE5vZGUgPSBmdW5jdGlvbiBpbml0Tm9kZShjbGFzc2VzLCBvcHRpb25zLCBzdHlsZSkge1xuICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgdGhpcy5oZWlnaHQgPSAwO1xuICB0aGlzLmRlcHRoID0gMDtcbiAgdGhpcy5tYXhGb250U2l6ZSA9IDA7XG4gIHRoaXMuc3R5bGUgPSBzdHlsZSB8fCB7fTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgdGhpcy5jbGFzc2VzLnB1c2goXCJtdGlnaHRcIik7XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBDb252ZXJ0IGludG8gYW4gSFRNTCBub2RlXG4gKi9cblxuXG52YXIgX3RvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSh0YWdOYW1lKSB7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTsgLy8gQXBwbHkgdGhlIGNsYXNzXG5cbiAgbm9kZS5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpOyAvLyBBcHBseSBpbmxpbmUgc3R5bGVzXG5cbiAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qgc2VlbSB0byB1bmRlcnN0YW5kIHNwYW4uc3R5bGUncyB0eXBlLlxuICAgICAgbm9kZS5zdHlsZVtzdHlsZV0gPSB0aGlzLnN0eWxlW3N0eWxlXTtcbiAgICB9XG4gIH0gLy8gQXBwbHkgYXR0cmlidXRlc1xuXG5cbiAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodGhpcy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgIH1cbiAgfSAvLyBBcHBlbmQgdGhlIGNoaWxkcmVuLCBhbHNvIGFzIEhUTUwgbm9kZXNcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG4vKipcbiAqIENvbnZlcnQgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmdcbiAqL1xuXG5cbnZhciBfdG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCh0YWdOYW1lKSB7XG4gIHZhciBtYXJrdXAgPSBcIjxcIiArIHRhZ05hbWU7IC8vIEFkZCB0aGUgY2xhc3NcblxuICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCkge1xuICAgIG1hcmt1cCArPSBcIiBjbGFzcz1cXFwiXCIgKyB1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSkgKyBcIlxcXCJcIjtcbiAgfVxuXG4gIHZhciBzdHlsZXMgPSBcIlwiOyAvLyBBZGQgdGhlIHN0eWxlcywgYWZ0ZXIgaHlwaGVuYXRpb25cblxuICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICBzdHlsZXMgKz0gdXRpbHMuaHlwaGVuYXRlKHN0eWxlKSArIFwiOlwiICsgdGhpcy5zdHlsZVtzdHlsZV0gKyBcIjtcIjtcbiAgICB9XG4gIH1cblxuICBpZiAoc3R5bGVzKSB7XG4gICAgbWFya3VwICs9IFwiIHN0eWxlPVxcXCJcIiArIHV0aWxzLmVzY2FwZShzdHlsZXMpICsgXCJcXFwiXCI7XG4gIH0gLy8gQWRkIHRoZSBhdHRyaWJ1dGVzXG5cblxuICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgIG1hcmt1cCArPSBcIiBcIiArIGF0dHIgKyBcIj1cXFwiXCIgKyB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKSArIFwiXFxcIlwiO1xuICAgIH1cbiAgfVxuXG4gIG1hcmt1cCArPSBcIj5cIjsgLy8gQWRkIHRoZSBtYXJrdXAgb2YgdGhlIGNoaWxkcmVuLCBhbHNvIGFzIG1hcmt1cFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gIH1cblxuICBtYXJrdXAgKz0gXCI8L1wiICsgdGFnTmFtZSArIFwiPlwiO1xuICByZXR1cm4gbWFya3VwO1xufTsgLy8gTWFraW5nIHRoZSB0eXBlIGJlbG93IGV4YWN0IHdpdGggYWxsIG9wdGlvbmFsIGZpZWxkcyBkb2Vzbid0IHdvcmsgZHVlIHRvXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy80NTgyXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy81Njg4XG4vLyBIb3dldmVyLCBzaW5jZSAqYWxsKiBmaWVsZHMgYXJlIG9wdGlvbmFsLCAkU2hhcGU8PiB3b3JrcyBhcyBzdWdnZXN0ZWQgaW4gNTY4OFxuLy8gYWJvdmUuXG4vLyBUaGlzIHR5cGUgZG9lcyBub3QgaW5jbHVkZSBhbGwgQ1NTIHByb3BlcnRpZXMuIEFkZGl0aW9uYWwgcHJvcGVydGllcyBzaG91bGRcbi8vIGJlIGFkZGVkIGFzIG5lZWRlZC5cblxuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgc3BhbiBub2RlLCB3aXRoIGEgY2xhc3NOYW1lLCBhIGxpc3Qgb2YgY2hpbGRyZW4sIGFuZFxuICogYW4gaW5saW5lIHN0eWxlLiBJdCBhbHNvIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGl0cyBoZWlnaHQsIGRlcHRoLCBhbmRcbiAqIG1heEZvbnRTaXplLlxuICpcbiAqIFJlcHJlc2VudHMgdHdvIHR5cGVzIHdpdGggZGlmZmVyZW50IHVzZXM6IFN2Z1NwYW4gdG8gd3JhcCBhbiBTVkcgYW5kIERvbVNwYW5cbiAqIG90aGVyd2lzZS4gVGhpcyB0eXBlc2FmZXR5IGlzIGltcG9ydGFudCB3aGVuIEhUTUwgYnVpbGRlcnMgYWNjZXNzIGEgc3BhbidzXG4gKiBjaGlsZHJlbi5cbiAqL1xudmFyIGRvbVRyZWVfU3BhbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNwYW4oY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMsIHN0eWxlKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuZGVwdGggPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgaW5pdE5vZGUuY2FsbCh0aGlzLCBjbGFzc2VzLCBvcHRpb25zLCBzdHlsZSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGFuIGFyYml0cmFyeSBhdHRyaWJ1dGUgb24gdGhlIHNwYW4uIFdhcm5pbmc6IHVzZSB0aGlzIHdpc2VseS4gTm90XG4gICAqIGFsbCBicm93c2VycyBzdXBwb3J0IGF0dHJpYnV0ZXMgdGhlIHNhbWUsIGFuZCBoYXZpbmcgdG9vIG1hbnkgY3VzdG9tXG4gICAqIGF0dHJpYnV0ZXMgaXMgcHJvYmFibHkgYmFkLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBTcGFuLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB1dGlscy5jb250YWlucyh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICByZXR1cm4gX3RvTm9kZS5jYWxsKHRoaXMsIFwic3BhblwiKTtcbiAgfTtcblxuICBfcHJvdG8udG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCgpIHtcbiAgICByZXR1cm4gX3RvTWFya3VwLmNhbGwodGhpcywgXCJzcGFuXCIpO1xuICB9O1xuXG4gIHJldHVybiBTcGFuO1xufSgpO1xuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhbiBhbmNob3IgKDxhPikgZWxlbWVudCB3aXRoIGEgaHlwZXJsaW5rLiAgU2VlIGBzcGFuYFxuICogZm9yIGZ1cnRoZXIgZGV0YWlscy5cbiAqL1xuXG52YXIgZG9tVHJlZV9BbmNob3IgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmNob3IoaHJlZiwgY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgaW5pdE5vZGUuY2FsbCh0aGlzLCBjbGFzc2VzLCBvcHRpb25zKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gQW5jaG9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8yLmhhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICByZXR1cm4gX3RvTm9kZS5jYWxsKHRoaXMsIFwiYVwiKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvTWFya3VwID0gZnVuY3Rpb24gdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIF90b01hcmt1cC5jYWxsKHRoaXMsIFwiYVwiKTtcbiAgfTtcblxuICByZXR1cm4gQW5jaG9yO1xufSgpO1xuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhbiBpbWFnZSBlbWJlZCAoPGltZz4pIGVsZW1lbnQuXG4gKi9cblxudmFyIGRvbVRyZWVfSW1nID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW1nKHNyYywgYWx0LCBzdHlsZSkge1xuICAgIHRoaXMuc3JjID0gdm9pZCAwO1xuICAgIHRoaXMuYWx0ID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcHRoID0gdm9pZCAwO1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFsdCA9IGFsdDtcbiAgICB0aGlzLnNyYyA9IHNyYztcbiAgICB0aGlzLmNsYXNzZXMgPSBbXCJtb3JkXCJdO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gSW1nLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLmhhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKTtcbiAgfTtcblxuICBfcHJvdG8zLnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgbm9kZS5zcmMgPSB0aGlzLnNyYztcbiAgICBub2RlLmFsdCA9IHRoaXMuYWx0O1xuICAgIG5vZGUuY2xhc3NOYW1lID0gXCJtb3JkXCI7IC8vIEFwcGx5IGlubGluZSBzdHlsZXNcblxuICAgIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIG5vZGUuc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvMy50b01hcmt1cCA9IGZ1bmN0aW9uIHRvTWFya3VwKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIjxpbWcgIHNyYz0nXCIgKyB0aGlzLnNyYyArIFwiICdhbHQ9J1wiICsgdGhpcy5hbHQgKyBcIicgXCI7IC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuXG4gICAgdmFyIHN0eWxlcyA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGVzICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyBcIjpcIiArIHRoaXMuc3R5bGVbc3R5bGVdICsgXCI7XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgbWFya3VwICs9IFwiIHN0eWxlPVxcXCJcIiArIHV0aWxzLmVzY2FwZShzdHlsZXMpICsgXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiJy8+XCI7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfTtcblxuICByZXR1cm4gSW1nO1xufSgpO1xudmFyIGlDb21iaW5hdGlvbnMgPSB7XG4gICfDric6IFwiXFx1MDEzMVxcdTAzMDJcIixcbiAgJ8OvJzogXCJcXHUwMTMxXFx1MDMwOFwiLFxuICAnw60nOiBcIlxcdTAxMzFcXHUwMzAxXCIsXG4gIC8vICfEqyc6ICdcXHUwMTMxXFx1MDMwNCcsIC8vIGVuYWJsZSB3aGVuIHdlIGFkZCBFeHRlbmRlZCBMYXRpblxuICAnw6wnOiBcIlxcdTAxMzFcXHUwMzAwXCJcbn07XG4vKipcbiAqIEEgc3ltYm9sIG5vZGUgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYSBzaW5nbGUgc3ltYm9sLiBJdCBlaXRoZXIgcmVuZGVyc1xuICogdG8gYSBzaW5nbGUgdGV4dCBub2RlLCBvciBhIHNwYW4gd2l0aCBhIHNpbmdsZSB0ZXh0IG5vZGUgaW4gaXQsIGRlcGVuZGluZyBvblxuICogd2hldGhlciBpdCBoYXMgQ1NTIGNsYXNzZXMsIHN0eWxlcywgb3IgbmVlZHMgaXRhbGljIGNvcnJlY3Rpb24uXG4gKi9cblxudmFyIGRvbVRyZWVfU3ltYm9sTm9kZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN5bWJvbE5vZGUodGV4dCwgaGVpZ2h0LCBkZXB0aCwgaXRhbGljLCBza2V3LCB3aWR0aCwgY2xhc3Nlcywgc3R5bGUpIHtcbiAgICB0aGlzLnRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLml0YWxpYyA9IHZvaWQgMDtcbiAgICB0aGlzLnNrZXcgPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMDtcbiAgICB0aGlzLmRlcHRoID0gZGVwdGggfHwgMDtcbiAgICB0aGlzLml0YWxpYyA9IGl0YWxpYyB8fCAwO1xuICAgIHRoaXMuc2tldyA9IHNrZXcgfHwgMDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gMDsgLy8gTWFyayB0ZXh0IGZyb20gbm9uLUxhdGluIHNjcmlwdHMgd2l0aCBzcGVjaWZpYyBjbGFzc2VzIHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gc3BlY2lmeSB3aGljaCBmb250cyB0byB1c2UuICBUaGlzIGFsbG93cyB1cyB0byByZW5kZXIgdGhlc2VcbiAgICAvLyBjaGFyYWN0ZXJzIHdpdGggYSBzZXJpZiBmb250IGluIHNpdHVhdGlvbnMgd2hlcmUgdGhlIGJyb3dzZXIgd291bGRcbiAgICAvLyBlaXRoZXIgZGVmYXVsdCB0byBhIHNhbnMgc2VyaWYgb3IgcmVuZGVyIGEgcGxhY2Vob2xkZXIgY2hhcmFjdGVyLlxuICAgIC8vIFdlIHVzZSBDU1MgY2xhc3MgbmFtZXMgbGlrZSBjamtfZmFsbGJhY2ssIGhhbmd1bF9mYWxsYmFjayBhbmRcbiAgICAvLyBicmFobWljX2ZhbGxiYWNrLiBTZWUgLi91bmljb2RlU2NyaXB0cy5qcyBmb3IgdGhlIHNldCBvZiBwb3NzaWJsZVxuICAgIC8vIHNjcmlwdCBuYW1lc1xuXG4gICAgdmFyIHNjcmlwdCA9IHNjcmlwdEZyb21Db2RlcG9pbnQodGhpcy50ZXh0LmNoYXJDb2RlQXQoMCkpO1xuXG4gICAgaWYgKHNjcmlwdCkge1xuICAgICAgdGhpcy5jbGFzc2VzLnB1c2goc2NyaXB0ICsgXCJfZmFsbGJhY2tcIik7XG4gICAgfVxuXG4gICAgaWYgKC9bw67Dr8Otw6xdLy50ZXN0KHRoaXMudGV4dCkpIHtcbiAgICAgIC8vIGFkZCDEqyB3aGVuIHdlIGFkZCBFeHRlbmRlZCBMYXRpblxuICAgICAgdGhpcy50ZXh0ID0gaUNvbWJpbmF0aW9uc1t0aGlzLnRleHRdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG80ID0gU3ltYm9sTm9kZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNC5oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB1dGlscy5jb250YWlucyh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0ZXh0IG5vZGUgb3Igc3BhbiBmcm9tIGEgc3ltYm9sIG5vZGUuIE5vdGUgdGhhdCBhIHNwYW4gaXMgb25seVxuICAgKiBjcmVhdGVkIGlmIGl0IGlzIG5lZWRlZC5cbiAgICovXG4gIDtcblxuICBfcHJvdG80LnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCk7XG4gICAgdmFyIHNwYW4gPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuaXRhbGljID4gMCkge1xuICAgICAgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgc3Bhbi5zdHlsZS5tYXJnaW5SaWdodCA9IHRoaXMuaXRhbGljICsgXCJlbVwiO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuLmNsYXNzTmFtZSA9IGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgIHNwYW4gPSBzcGFuIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpOyAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzZWVtIHRvIHVuZGVyc3RhbmQgc3Bhbi5zdHlsZSdzIHR5cGUuXG5cbiAgICAgICAgc3Bhbi5zdHlsZVtzdHlsZV0gPSB0aGlzLnN0eWxlW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3Bhbikge1xuICAgICAgc3Bhbi5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIHJldHVybiBzcGFuO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHN5bWJvbCBub2RlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzQudG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCgpIHtcbiAgICAvLyBUT0RPKGFscGVydCk6IE1vcmUgZHVwbGljYXRpb24gdGhhbiBJJ2QgbGlrZSBmcm9tXG4gICAgLy8gc3Bhbi5wcm90b3R5cGUudG9NYXJrdXAgYW5kIHN5bWJvbE5vZGUucHJvdG90eXBlLnRvTm9kZS4uLlxuICAgIHZhciBuZWVkc1NwYW4gPSBmYWxzZTtcbiAgICB2YXIgbWFya3VwID0gXCI8c3BhblwiO1xuXG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgIG5lZWRzU3BhbiA9IHRydWU7XG4gICAgICBtYXJrdXAgKz0gXCIgY2xhc3M9XFxcIlwiO1xuICAgICAgbWFya3VwICs9IHV0aWxzLmVzY2FwZShjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpKTtcbiAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVzID0gXCJcIjtcblxuICAgIGlmICh0aGlzLml0YWxpYyA+IDApIHtcbiAgICAgIHN0eWxlcyArPSBcIm1hcmdpbi1yaWdodDpcIiArIHRoaXMuaXRhbGljICsgXCJlbTtcIjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGVzICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyBcIjpcIiArIHRoaXMuc3R5bGVbc3R5bGVdICsgXCI7XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgbmVlZHNTcGFuID0gdHJ1ZTtcbiAgICAgIG1hcmt1cCArPSBcIiBzdHlsZT1cXFwiXCIgKyB1dGlscy5lc2NhcGUoc3R5bGVzKSArIFwiXFxcIlwiO1xuICAgIH1cblxuICAgIHZhciBlc2NhcGVkID0gdXRpbHMuZXNjYXBlKHRoaXMudGV4dCk7XG5cbiAgICBpZiAobmVlZHNTcGFuKSB7XG4gICAgICBtYXJrdXAgKz0gXCI+XCI7XG4gICAgICBtYXJrdXAgKz0gZXNjYXBlZDtcbiAgICAgIG1hcmt1cCArPSBcIjwvc3Bhbj5cIjtcbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlc2NhcGVkO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3ltYm9sTm9kZTtcbn0oKTtcbi8qKlxuICogU1ZHIG5vZGVzIGFyZSB1c2VkIHRvIHJlbmRlciBzdHJldGNoeSB3aWRlIGVsZW1lbnRzLlxuICovXG5cbnZhciBTdmdOb2RlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3ZnTm9kZShjaGlsZHJlbiwgYXR0cmlidXRlcykge1xuICAgIHRoaXMuY2hpbGRyZW4gPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gdm9pZCAwO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICB9XG5cbiAgdmFyIF9wcm90bzUgPSBTdmdOb2RlLnByb3RvdHlwZTtcblxuICBfcHJvdG81LnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICB2YXIgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwic3ZnXCIpOyAvLyBBcHBseSBhdHRyaWJ1dGVzXG5cbiAgICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90bzUudG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCgpIHtcbiAgICB2YXIgbWFya3VwID0gXCI8c3ZnXCI7IC8vIEFwcGx5IGF0dHJpYnV0ZXNcblxuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArIFwiPSdcIiArIHRoaXMuYXR0cmlidXRlc1thdHRyXSArIFwiJ1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIj5cIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI8L3N2Zz5cIjtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9O1xuXG4gIHJldHVybiBTdmdOb2RlO1xufSgpO1xudmFyIGRvbVRyZWVfUGF0aE5vZGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXRoTm9kZShwYXRoTmFtZSwgYWx0ZXJuYXRlKSB7XG4gICAgdGhpcy5wYXRoTmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFsdGVybmF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhdGhOYW1lID0gcGF0aE5hbWU7XG4gICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7IC8vIFVzZWQgb25seSBmb3IgdGFsbCBcXHNxcnRcbiAgfVxuXG4gIHZhciBfcHJvdG82ID0gUGF0aE5vZGUucHJvdG90eXBlO1xuXG4gIF9wcm90bzYudG9Ob2RlID0gZnVuY3Rpb24gdG9Ob2RlKCkge1xuICAgIHZhciBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgXCJwYXRoXCIpO1xuXG4gICAgaWYgKHRoaXMuYWx0ZXJuYXRlKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRcIiwgdGhpcy5hbHRlcm5hdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRcIiwgc3ZnR2VvbWV0cnkucGF0aFt0aGlzLnBhdGhOYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvNi50b01hcmt1cCA9IGZ1bmN0aW9uIHRvTWFya3VwKCkge1xuICAgIGlmICh0aGlzLmFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIFwiPHBhdGggZD0nXCIgKyB0aGlzLmFsdGVybmF0ZSArIFwiJy8+XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIjxwYXRoIGQ9J1wiICsgc3ZnR2VvbWV0cnkucGF0aFt0aGlzLnBhdGhOYW1lXSArIFwiJy8+XCI7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQYXRoTm9kZTtcbn0oKTtcbnZhciBMaW5lTm9kZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpbmVOb2RlKGF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgfVxuXG4gIHZhciBfcHJvdG83ID0gTGluZU5vZGUucHJvdG90eXBlO1xuXG4gIF9wcm90bzcudG9Ob2RlID0gZnVuY3Rpb24gdG9Ob2RlKCkge1xuICAgIHZhciBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgXCJsaW5lXCIpOyAvLyBBcHBseSBhdHRyaWJ1dGVzXG5cbiAgICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvNy50b01hcmt1cCA9IGZ1bmN0aW9uIHRvTWFya3VwKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIjxsaW5lXCI7XG5cbiAgICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIiBcIiArIGF0dHIgKyBcIj0nXCIgKyB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0gKyBcIidcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCIvPlwiO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH07XG5cbiAgcmV0dXJuIExpbmVOb2RlO1xufSgpO1xuZnVuY3Rpb24gYXNzZXJ0U3ltYm9sRG9tTm9kZShncm91cCkge1xuICBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBkb21UcmVlX1N5bWJvbE5vZGUpIHtcbiAgICByZXR1cm4gZ3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3ltYm9sTm9kZSBidXQgZ290IFwiICsgU3RyaW5nKGdyb3VwKSArIFwiLlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U3Bhbihncm91cCkge1xuICBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBkb21UcmVlX1NwYW4pIHtcbiAgICByZXR1cm4gZ3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3BhbjxIdG1sRG9tTm9kZT4gYnV0IGdvdCBcIiArIFN0cmluZyhncm91cCkgKyBcIi5cIik7XG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3VibW9kdWxlcy9rYXRleC1mb250cy9mb250TWV0cmljc0RhdGEuanNcbi8vIFRoaXMgZmlsZSBpcyBHRU5FUkFURUQgYnkgYnVpbGRNZXRyaWNzLnNoLiBETyBOT1QgTU9ESUZZLlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZm9udE1ldHJpY3NEYXRhID0gKHtcbiAgXCJBTVMtUmVndWxhclwiOiB7XG4gICAgXCI2NVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI2N1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI3MFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI3NFwiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMCwgMC41XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjc3XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjk0NDQ1XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjc5XCI6IFswLjE2NjY3LCAwLjY4ODg5LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjgxXCI6IFswLjE2NjY3LCAwLjY4ODg5LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjgzXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg0XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg1XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg2XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg3XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAxLjBdLFxuICAgIFwiODhcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODlcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTBcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTA3XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjE2NVwiOiBbMCwgMC42NzUsIDAuMDI1LCAwLCAwLjc1XSxcbiAgICBcIjE3NFwiOiBbMC4xNTU1OSwgMC42OTIyNCwgMCwgMCwgMC45NDY2Nl0sXG4gICAgXCIyNDBcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiMjk1XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU0MDI4XSxcbiAgICBcIjcxMFwiOiBbMCwgMC44MjUsIDAsIDAsIDIuMzMzMzRdLFxuICAgIFwiNzMyXCI6IFswLCAwLjksIDAsIDAsIDIuMzMzMzRdLFxuICAgIFwiNzcwXCI6IFswLCAwLjgyNSwgMCwgMCwgMi4zMzMzNF0sXG4gICAgXCI3NzFcIjogWzAsIDAuOSwgMCwgMCwgMi4zMzMzNF0sXG4gICAgXCI5ODlcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTAwOFwiOiBbMCwgMC40MzA1NiwgMC4wNDAyOCwgMCwgMC42NjY2N10sXG4gICAgXCI4MjQ1XCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjI3NV0sXG4gICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU0MDI4XSxcbiAgICBcIjg0ODdcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODQ5OFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NTAyXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg1MDNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODUwNFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NTEzXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg1OTJcIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwLCAwLjVdLFxuICAgIFwiODU5NFwiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDAsIDAuNV0sXG4gICAgXCI4NjAyXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2MDNcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODYwNlwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MDhcIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDEuMF0sXG4gICAgXCI4NjEwXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg2MTFcIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODYxOVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MjBcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjIxXCI6IFstMC4xMzMxMywgMC4zNzc4OCwgMCwgMCwgMS4zODg4OV0sXG4gICAgXCI4NjIyXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2MjRcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNV0sXG4gICAgXCI4NjI1XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjVdLFxuICAgIFwiODYzMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MzFcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjM0XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg2MzVcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODYzOFwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC40MTY2N10sXG4gICAgXCI4NjM5XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjQxNjY3XSxcbiAgICBcIjg2NDJcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNDE2NjddLFxuICAgIFwiODY0M1wiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC40MTY2N10sXG4gICAgXCI4NjQ0XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODY0NlwiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NDdcIjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjQ4XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg2NDlcIjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjUwXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg2NTFcIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDEuMF0sXG4gICAgXCI4NjUyXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1M1wiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjU0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTVcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY2NlwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NjdcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjY5XCI6IFstMC4xMzMxMywgMC4zNzc4OCwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NzJcIjogWy0wLjA2NCwgMC40MzcsIDAsIDAsIDEuMzM0XSxcbiAgICBcIjg2NzRcIjogWy0wLjA2NCwgMC40MzcsIDAsIDAsIDEuMzM0XSxcbiAgICBcIjg3MDVcIjogWzAsIDAuODI1LCAwLCAwLCAwLjVdLFxuICAgIFwiODcwOFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NzA5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MTdcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNDI5MTddLFxuICAgIFwiODcyMlwiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzI0XCI6IFswLjA4MTk4LCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MjZcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODczM1wiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg3MzdcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODczOFwiOiBbMC4wMzUxNywgMC41MjIzOSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NzM5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjIyMjIyXSxcbiAgICBcIjg3NDBcIjogWzAuMjUxNDIsIDAuNzQxMTEsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODc0MVwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI4NzQyXCI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwLCAwLjVdLFxuICAgIFwiODc1NlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzU3XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3NjRcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NjVcIjogWy0wLjEzMzEzLCAwLjM3Nzg4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NjlcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NzBcIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NzRcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc3NlwiOiBbLTAuMDE2ODgsIDAuNDgzMTIsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc3OFwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzgyXCI6IFswLjA2MDYyLCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODNcIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4NVwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzg2XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODdcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc5MFwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzkxXCI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3OTZcIjogWzAuMDgxOTgsIDAuOTE2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwNlwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODA3XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MDhcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwOVwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODEyXCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjVdLFxuICAgIFwiODgxNFwiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODE1XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTZcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxN1wiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODE4XCI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTlcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgyMlwiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODIzXCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MjhcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgyOVwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODMwXCI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzFcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzMlwiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODMzXCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDBcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0MVwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQyXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDNcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0N1wiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQ4XCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NThcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1OVwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODYxXCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NjJcIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NjNcIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NjRcIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NjVcIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NzJcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODg3M1wiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4ODc0XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjg4NzZcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODg3N1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4ODc4XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg4NzlcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODg4MlwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODgzXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4ODRcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg4NVwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODg4XCI6IFswLCAwLjU0OTg2LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg4OTBcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODg5MVwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4ODkyXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg5MDFcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODkwM1wiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTA1XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MDZcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkwN1wiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTA4XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MDlcIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MTBcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzYwNDJdLFxuICAgIFwiODkxMVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43NjA0Ml0sXG4gICAgXCI4OTEyXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MTNcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkxNFwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4OTE1XCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg5MTZcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODkxOFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkxOVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkyMFwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMS4zMzMzNF0sXG4gICAgXCI4OTIxXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAxLjMzMzM0XSxcbiAgICBcIjg5MjJcIjogWzAuMzg1NjksIDAuODg1NjksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkyM1wiOiBbMC4zODU2OSwgMC44ODU2OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTI2XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MjdcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkyOFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTI5XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MzRcIjogWzAuMjMyMjIsIDAuNzQxMTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkzNVwiOiBbMC4yMzIyMiwgMC43NDExMSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTM2XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MzdcIjogWzAuMjMyMjIsIDAuNzQxMTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkzOFwiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTM5XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5NDBcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODk0MVwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTk0XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5OTVcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTQxNlwiOiBbMC4xNTU1OSwgMC42OTIyNCwgMCwgMCwgMC45MDIyMl0sXG4gICAgXCI5NDg0XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjVdLFxuICAgIFwiOTQ4OFwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC41XSxcbiAgICBcIjk0OTJcIjogWzAsIDAuMzc3ODgsIDAsIDAsIDAuNV0sXG4gICAgXCI5NDk2XCI6IFswLCAwLjM3Nzg4LCAwLCAwLCAwLjVdLFxuICAgIFwiOTU4NVwiOiBbMC4xOTQ0NCwgMC42ODg4OSwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5NTg2XCI6IFswLjE5NDQ0LCAwLjc0MTExLCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjk2MzJcIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk2MzNcIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk2NTBcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTY1MVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5NjU0XCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk2NjBcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTY2MVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5NjY0XCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk2NzRcIjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTczM1wiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC45NDQ0NV0sXG4gICAgXCIxMDAwM1wiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIxMDAxNlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIxMDczMVwiOiBbMC4xMTExMSwgMC42OTIyNCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCIxMDg0NlwiOiBbMC4xOTQ0NCwgMC43NTU4MywgMCwgMCwgMC42MTExMV0sXG4gICAgXCIxMDg3N1wiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg3OFwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg4NVwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg4NlwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg4N1wiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg4OFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg4OVwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg5MFwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg5MVwiOiBbMC40ODI1NiwgMC45ODI1NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDg5MlwiOiBbMC40ODI1NiwgMC45ODI1NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkwMVwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkwMlwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkzM1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkzNFwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkzNVwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkzNlwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkzN1wiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDkzOFwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDk0OVwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDk1MFwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDk1NVwiOiBbMC4yODQ4MSwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDk1NlwiOiBbMC4yODQ4MSwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM1MFwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC4yMjIyMl0sXG4gICAgXCI1NzM1MVwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI1NzM1MlwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM1M1wiOiBbMCwgMC40MzA1NiwgMC4wNDAyOCwgMCwgMC42NjY2N10sXG4gICAgXCI1NzM1NlwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM1N1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM1OFwiOiBbMC40MTk1MSwgMC45MTk1MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM1OVwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM2MFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM2MVwiOiBbMC40MTk1MSwgMC45MTk1MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM2NlwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM2N1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM2OFwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM2OVwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM3MFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NzM3MVwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF1cbiAgfSxcbiAgXCJDYWxpZ3JhcGhpYy1SZWd1bGFyXCI6IHtcbiAgICBcIjQ4XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNDlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1MFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1M1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTVcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTk0NDUsIDAuNzk4NDddLFxuICAgIFwiNjZcIjogWzAsIDAuNjgzMzMsIDAuMDMwNDEsIDAuMTM4ODksIDAuNjU2ODFdLFxuICAgIFwiNjdcIjogWzAsIDAuNjgzMzMsIDAuMDU4MzQsIDAuMTM4ODksIDAuNTI2NTNdLFxuICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNzcxMzldLFxuICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAuMDg5NDQsIDAuMTExMTEsIDAuNTI3NzhdLFxuICAgIFwiNzBcIjogWzAsIDAuNjgzMzMsIDAuMDk5MzEsIDAuMTExMTEsIDAuNzE4NzVdLFxuICAgIFwiNzFcIjogWzAuMDk3MjIsIDAuNjgzMzMsIDAuMDU5MywgMC4xMTExMSwgMC41OTQ4N10sXG4gICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4wMDk2NSwgMC4xMTExMSwgMC44NDQ1Ml0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzM4MiwgMCwgMC41NDQ1Ml0sXG4gICAgXCI3NFwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4xODQ3MiwgMC4xNjY2NywgMC42Nzc3OF0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMC4wMTQ0NSwgMC4wNTU1NiwgMC43NjE5NV0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4xMzg4OSwgMC42ODk3Ml0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODMzMywgMCwgMC4xMzg4OSwgMS4yMDA5XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjE0NzM2LCAwLjA4MzM0LCAwLjgyMDQ5XSxcbiAgICBcIjc5XCI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjExMTExLCAwLjc5NjExXSxcbiAgICBcIjgwXCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLjA4MzM0LCAwLjY5NTU2XSxcbiAgICBcIjgxXCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLCAwLjExMTExLCAwLjgxNjY3XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4MzMzLCAwLCAwLjA4MzM0LCAwLjg0NzVdLFxuICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDc1LCAwLjEzODg5LCAwLjYwNTU2XSxcbiAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjI1NDE3LCAwLCAwLjU0NDY0XSxcbiAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjA4MzM0LCAwLjYyNTgzXSxcbiAgICBcIjg2XCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLCAwLjYxMjc4XSxcbiAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLjA4MzM0LCAwLjk4Nzc4XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLjE0NjQzLCAwLjEzODg5LCAwLjcxMzNdLFxuICAgIFwiODlcIjogWzAuMDk3MjIsIDAuNjgzMzMsIDAuMDgyMjIsIDAuMDgzMzQsIDAuNjY4MzRdLFxuICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAuMDc5NDQsIDAuMTM4ODksIDAuNzI0NzNdXG4gIH0sXG4gIFwiRnJha3R1ci1SZWd1bGFyXCI6IHtcbiAgICBcIjMzXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjI5NTc0XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjIxNDcxXSxcbiAgICBcIjM4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjczNzg2XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjIxMjAxXSxcbiAgICBcIjQwXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwLCAwLjM4ODY1XSxcbiAgICBcIjQxXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwLCAwLjM4ODY1XSxcbiAgICBcIjQyXCI6IFswLCAwLjYyMTE5LCAwLCAwLCAwLjI3NzY0XSxcbiAgICBcIjQzXCI6IFswLjA4MzE5LCAwLjU4MjgzLCAwLCAwLCAwLjc1NjIzXSxcbiAgICBcIjQ0XCI6IFswLCAwLjEwODAzLCAwLCAwLCAwLjI3NzY0XSxcbiAgICBcIjQ1XCI6IFswLjA4MzE5LCAwLjU4MjgzLCAwLCAwLCAwLjc1NjIzXSxcbiAgICBcIjQ2XCI6IFswLCAwLjEwODAzLCAwLCAwLCAwLjI3NzY0XSxcbiAgICBcIjQ3XCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjQ4XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjQ5XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjUwXCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjUxXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjUyXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjUzXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjU0XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjU1XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjU2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjU3XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjU4XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjIxNjA2XSxcbiAgICBcIjU5XCI6IFswLjEyNjA0LCAwLjQ3NTM0LCAwLCAwLCAwLjIxNjA2XSxcbiAgICBcIjYxXCI6IFstMC4xMzA5OSwgMC4zNjg2NiwgMCwgMCwgMC43NTYyM10sXG4gICAgXCI2M1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4zNjI0NV0sXG4gICAgXCI2NVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC43MTc2XSxcbiAgICBcIjY2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjg4Mzk3XSxcbiAgICBcIjY3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjYxMjU0XSxcbiAgICBcIjY4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgzMTU4XSxcbiAgICBcIjY5XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY2Mjc4XSxcbiAgICBcIjcwXCI6IFswLjEyNjA0LCAwLjY5MTQxLCAwLCAwLCAwLjYxMTE5XSxcbiAgICBcIjcxXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjc4NTM5XSxcbiAgICBcIjcyXCI6IFswLjA2MzAyLCAwLjY5MTQxLCAwLCAwLCAwLjcyMDNdLFxuICAgIFwiNzNcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNTU0NDhdLFxuICAgIFwiNzRcIjogWzAuMTI2MDQsIDAuNjkxNDEsIDAsIDAsIDAuNTUyMzFdLFxuICAgIFwiNzVcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNjY4NDVdLFxuICAgIFwiNzZcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNjY2MDJdLFxuICAgIFwiNzdcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDEuMDQ5NTNdLFxuICAgIFwiNzhcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODMyMTJdLFxuICAgIFwiNzlcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODI2OTldLFxuICAgIFwiODBcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDAsIDAuODI3NTNdLFxuICAgIFwiODFcIjogWzAuMDM3ODEsIDAuNjkxNDEsIDAsIDAsIDAuODI2OTldLFxuICAgIFwiODJcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODI4MDddLFxuICAgIFwiODNcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODI4NjFdLFxuICAgIFwiODRcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNjY4OTldLFxuICAgIFwiODVcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNjQ1NzZdLFxuICAgIFwiODZcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODMxMzFdLFxuICAgIFwiODdcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDEuMDQ2MDJdLFxuICAgIFwiODhcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNzE5MjJdLFxuICAgIFwiODlcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDAsIDAuODMyOTNdLFxuICAgIFwiOTBcIjogWzAuMTI2MDQsIDAuNjkxNDEsIDAsIDAsIDAuNjAyMDFdLFxuICAgIFwiOTFcIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDAsIDAuMjc3NjRdLFxuICAgIFwiOTNcIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDAsIDAuMjc3NjRdLFxuICAgIFwiOTRcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNDk5NjVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTAwNDZdLFxuICAgIFwiOThcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNTEzMTVdLFxuICAgIFwiOTlcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuMzg5NDZdLFxuICAgIFwiMTAwXCI6IFswLCAwLjYyMTE5LCAwLCAwLCAwLjQ5ODU3XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC40MDA1M10sXG4gICAgXCIxMDJcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDAsIDAuMzI2MjZdLFxuICAgIFwiMTAzXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMzddLFxuICAgIFwiMTA0XCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjUyMTI2XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yNzg5OV0sXG4gICAgXCIxMDZcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjgwODhdLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjM4OTQ2XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yNzk1M10sXG4gICAgXCIxMDlcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNzY2NzZdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUyNjY2XSxcbiAgICBcIjExMVwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC40ODg4NV0sXG4gICAgXCIxMTJcIjogWzAuMTg5MDYsIDAuNTIzOTYsIDAsIDAsIDAuNTAwNDZdLFxuICAgIFwiMTEzXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjQ4OTEyXSxcbiAgICBcIjExNFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC4zODkxOV0sXG4gICAgXCIxMTVcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNDQyNjZdLFxuICAgIFwiMTE2XCI6IFswLCAwLjYyMTE5LCAwLCAwLCAwLjMzMzAxXSxcbiAgICBcIjExN1wiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MTcyXSxcbiAgICBcIjExOFwiOiBbMCwgMC41MjM5NiwgMCwgMCwgMC41MTE4XSxcbiAgICBcIjExOVwiOiBbMCwgMC41MjM5NiwgMCwgMCwgMC43NzM1MV0sXG4gICAgXCIxMjBcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuMzg4NjVdLFxuICAgIFwiMTIxXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjQ5ODg0XSxcbiAgICBcIjEyMlwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC4zOTA1NF0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjIxNDcxXSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjE0NzFdLFxuICAgIFwiNTgxMTJcIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuNDk3NDldLFxuICAgIFwiNTgxMTNcIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuNDk4M10sXG4gICAgXCI1ODExNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC4zMzMyOF0sXG4gICAgXCI1ODExNVwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC4zMjkyM10sXG4gICAgXCI1ODExNlwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDM0M10sXG4gICAgXCI1ODExN1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4zMzMwMV0sXG4gICAgXCI1ODExOFwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC4zMzQwOV0sXG4gICAgXCI1ODExOVwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDA3M11cbiAgfSxcbiAgXCJNYWluLUJvbGRcIjoge1xuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzVdLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjAyNzhdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiMzZcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI0M1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI0NFwiOiBbMC4xOTQ0NCwgMC4xNTU1NiwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI0NVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4zODMzM10sXG4gICAgXCI0NlwiOiBbMCwgMC4xNTU1NiwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjQ5XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1MFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUyXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1M1wiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU1XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU4XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjU5XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjYwXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjYxXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI2MlwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NDMwNV0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44Njk0NF0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MTgwNV0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MzA1NV0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44ODE5NF0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43NTU1NV0sXG4gICAgXCI3MFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43MjM2MV0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45MDQxNl0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45XSxcbiAgICBcIjczXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjQzNjExXSxcbiAgICBcIjc0XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjU5NDQ0XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjkwMTM4XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjY5MTY2XSxcbiAgICBcIjc3XCI6IFswLCAwLjY4NjExLCAwLCAwLCAxLjA5MTY2XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLFxuICAgIFwiNzlcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODYzODhdLFxuICAgIFwiODBcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzg2MTFdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjg2MTEsIDAsIDAsIDAuODYzODhdLFxuICAgIFwiODJcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODYyNV0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44XSxcbiAgICBcIjg1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg4NDcyXSxcbiAgICBcIjg2XCI6IFswLCAwLjY4NjExLCAwLjAxNTk3LCAwLCAwLjg2OTQ0XSxcbiAgICBcIjg3XCI6IFswLCAwLjY4NjExLCAwLjAxNTk3LCAwLCAxLjE4ODg4XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2OTQ0XSxcbiAgICBcIjg5XCI6IFswLCAwLjY4NjExLCAwLjAyODc1LCAwLCAwLjg2OTQ0XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiOTVcIjogWzAuMzEsIDAuMTM0NDQsIDAuMDMxOTQsIDAsIDAuNTc1XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU1OTAyXSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTI3MDhdLFxuICAgIFwiMTAyXCI6IFswLCAwLjY5NDQ0LCAwLjEwOTAzLCAwLCAwLjM1MTM5XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTU5NywgMCwgMC41NzVdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMzUxMzldLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYwNjk0XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC42MDY5NF0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDczNjFdLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ1MzYxXSxcbiAgICBcIjExNlwiOiBbMCwgMC42MzQ5MiwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAxNTk3LCAwLCAwLjYwNjk0XSxcbiAgICBcIjExOVwiOiBbMCwgMC40NDQ0NCwgMC4wMTU5NywgMCwgMC44MzA1NV0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjA2OTRdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwLCAwLjYwNjk0XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MTExMV0sXG4gICAgXCIxMjNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjEyNFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCIxMjVcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zNDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiMTY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIxNzJcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg2OTQ0XSxcbiAgICBcIjE3N1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCIxODRcIjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiMTk4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAxLjA0MTY2XSxcbiAgICBcIjIxNVwiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCIyMTZcIjogWzAuMDQ4NjEsIDAuNzM0NzIsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMjIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU5NzIyXSxcbiAgICBcIjIzMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC44MzA1NV0sXG4gICAgXCIyNDdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMjQ4XCI6IFswLjA5NzIyLCAwLjU0MTY3LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiMzM4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAxLjE2OTQ0XSxcbiAgICBcIjMzOVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuMzUxMzldLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNjMxOTQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjcxM1wiOiBbMCwgMC41OTYxMSwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44Njk0NF0sXG4gICAgXCI3MzJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjczM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjY5MTY2XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45NTgzM10sXG4gICAgXCI5MjBcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgwNTU1XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MzA1NV0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDAsIDAuNTc1XSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDAsIDEuMTQ5OTldLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjAyNzhdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MDI3OF0sXG4gICAgXCI4MjI0XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjgyMjVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiODI0MlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC4zNDQ0NF0sXG4gICAgXCI4NDA3XCI6IFswLCAwLjcyNDQ0LCAwLjE1NDg2LCAwLCAwLjU3NV0sXG4gICAgXCI4NDYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NzU5XSxcbiAgICBcIjg0NjVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiODQ2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40NzM2MV0sXG4gICAgXCI4NDcyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjc0MDI3XSxcbiAgICBcIjg0NzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiODUwMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4NTkyXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NTkzXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NTk0XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NTk1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NTk2XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NTk3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NTk4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg1OTlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODYwMFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjAxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2MzZcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2MzdcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2NDBcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2NDFcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2NTZcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2NTdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiODY1OFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODY1OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4NjYwXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjYxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjg3MDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODcwNlwiOiBbMCwgMC42OTQ0NCwgMC4wNjM4OSwgMCwgMC42Mjg0N10sXG4gICAgXCI4NzA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg3MDlcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3MTFcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiODcxMlwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzE1XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg3MjJcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODcyM1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4NzI1XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzI2XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzI3XCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMCwgMC41NzVdLFxuICAgIFwiODcyOFwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3MjlcIjogWy0wLjAyNjM5LCAwLjQ3MzYxLCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzMwXCI6IFswLjE4LCAwLjgyLCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjg3MzNcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODczNFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg3MzlcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiODc0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODc0M1wiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzQ0XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg3NDVcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODc0NlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzQ3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEyNzc4LCAwLCAwLjU2ODc1XSxcbiAgICBcIjg3NjRcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3NjhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiODc3MVwiOiBbMC4wMDIyMiwgMC41MDIyMiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4Nzc2XCI6IFswLjAyNDQ0LCAwLjUyNDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3ODFcIjogWzAuMDAyMjIsIDAuNTAyMjIsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgwMVwiOiBbMC4wMDIyMiwgMC41MDIyMiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODA0XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MDVcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgxMFwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4ODExXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg4MjZcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgyN1wiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODM0XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MzVcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgzOFwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODM5XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NDZcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODg0OVwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODUwXCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTFcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODg1MlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4ODUzXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTRcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg1NVwiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODU2XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg2NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjg4NjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4OTAwXCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODkwMVwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiODkwMlwiOiBbLTAuMDI3NzgsIDAuNDcyMjIsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg5NjhcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiODk2OVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjg5NzFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiODk5NFwiOiBbLTAuMTM4ODksIDAuMzYxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODk5NVwiOiBbLTAuMTM4ODksIDAuMzYxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiOTY1MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wMjIyMl0sXG4gICAgXCI5NjU3XCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMCwgMC41NzVdLFxuICAgIFwiOTY2MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wMjIyMl0sXG4gICAgXCI5NjY3XCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMCwgMC41NzVdLFxuICAgIFwiOTcxMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI5ODI0XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjk4MjVcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiOTgyNlwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5ODI3XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjk4MzdcIjogWzAsIDAuNzUsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiOTgzOFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCI5ODM5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjEwMjE2XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjEwMjE3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjEwODE1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLFxuICAgIFwiMTA5MjdcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMTA5MjhcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNTczNzZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDBdXG4gIH0sXG4gIFwiTWFpbi1Cb2xkSXRhbGljXCI6IHtcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLjExNDE3LCAwLCAwLjM4NjExXSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLjA3OTM5LCAwLCAwLjYyMDU1XSxcbiAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA2ODMzLCAwLCAwLjk0NDQ0XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLjEyODYxLCAwLCAwLjk0NDQ0XSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLjA4NTI4LCAwLCAwLjg4NTU1XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLjEyOTQ1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLjE1ODA2LCAwLCAwLjQ3MzMzXSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLjAzMzA2LCAwLCAwLjQ3MzMzXSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLjE0MzMzLCAwLCAwLjU5MTExXSxcbiAgICBcIjQzXCI6IFswLjEwMzMzLCAwLjYwMzMzLCAwLjAzMzA2LCAwLCAwLjg4NTU1XSxcbiAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjE0NzIyLCAwLCAwLCAwLjM1NTU1XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLjAyNjExLCAwLCAwLjQxNDQ0XSxcbiAgICBcIjQ2XCI6IFswLCAwLjE0NzIyLCAwLCAwLCAwLjM1NTU1XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLjE1ODA2LCAwLCAwLjU5MTExXSxcbiAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjQ5XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjUyXCI6IFswLjE5NDQ0LCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU1XCI6IFswLjE5NDQ0LCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU4XCI6IFswLCAwLjQ0NDQ0LCAwLjA2Njk1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjU5XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA2Njk1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjYxXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMC4wNjgzMywgMCwgMC44ODU1NV0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMTQ3MiwgMCwgMC41OTExMV0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMC4wOTIwOCwgMCwgMC44ODU1NV0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44NjU1NV0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODYxMSwgMC4wOTkyLCAwLCAwLjgxNjY2XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4NjExLCAwLjE0MjA4LCAwLCAwLjgyNjY2XSxcbiAgICBcIjY4XCI6IFswLCAwLjY4NjExLCAwLjA5MDYyLCAwLCAwLjg3NTU1XSxcbiAgICBcIjY5XCI6IFswLCAwLjY4NjExLCAwLjExNDMxLCAwLCAwLjc1NjY2XSxcbiAgICBcIjcwXCI6IFswLCAwLjY4NjExLCAwLjEyOTAzLCAwLCAwLjcyNzIyXSxcbiAgICBcIjcxXCI6IFswLCAwLjY4NjExLCAwLjA3MzQ3LCAwLCAwLjg5NTI3XSxcbiAgICBcIjcyXCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAwLjg5NjFdLFxuICAgIFwiNzNcIjogWzAsIDAuNjg2MTEsIDAuMTU2ODEsIDAsIDAuNDcxNjZdLFxuICAgIFwiNzRcIjogWzAsIDAuNjg2MTEsIDAuMTQ1LCAwLCAwLjYxMDU1XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4NjExLCAwLjE0MjA4LCAwLCAwLjg5NDk5XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjY5Nzc3XSxcbiAgICBcIjc3XCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAxLjA3Mjc3XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAwLjg5NjFdLFxuICAgIFwiNzlcIjogWzAsIDAuNjg2MTEsIDAuMDkwNjIsIDAsIDAuODU0OTldLFxuICAgIFwiODBcIjogWzAsIDAuNjg2MTEsIDAuMDk5MiwgMCwgMC43ODcyMV0sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMC4wOTA2MiwgMCwgMC44NTQ5OV0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODYxMSwgMC4wMjU1OSwgMCwgMC44NTk0NF0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODYxMSwgMC4xMTI2NCwgMCwgMC42NDk5OV0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODYxMSwgMC4xMjkwMywgMCwgMC43OTYxXSxcbiAgICBcIjg1XCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAwLjg4MDgzXSxcbiAgICBcIjg2XCI6IFswLCAwLjY4NjExLCAwLjE4NjI1LCAwLCAwLjg2NTU1XSxcbiAgICBcIjg3XCI6IFswLCAwLjY4NjExLCAwLjE4NjI1LCAwLCAxLjE1OTk5XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4NjExLCAwLjE1NjgxLCAwLCAwLjg2NTU1XSxcbiAgICBcIjg5XCI6IFswLCAwLjY4NjExLCAwLjE5ODAzLCAwLCAwLjg2NTU1XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4NjExLCAwLjE0MjA4LCAwLCAwLjcwODg4XSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLjE4NzUsIDAsIDAuMzU2MTFdLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAuMDk5NzIsIDAsIDAuMzU2MTFdLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAuMDY3MDksIDAsIDAuNTkxMTFdLFxuICAgIFwiOTVcIjogWzAuMzEsIDAuMTM0NDQsIDAuMDk4MTEsIDAsIDAuNTkxMTFdLFxuICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAuMDk0MjYsIDAsIDAuNTkxMTFdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAuMDc4NjEsIDAsIDAuNTMyMjJdLFxuICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAuMDUyMjIsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLjEwODYxLCAwLCAwLjU5MTExXSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMC4wODUsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjIxNzc4LCAwLCAwLjRdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwNSwgMCwgMC41MzIyMl0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAuMDk0MjYsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTA1XCI6IFswLCAwLjY5MzI2LCAwLjExMzg3LCAwLCAwLjM1NTU1XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42OTMyNiwgMC4xNjcyLCAwLCAwLjM1NTU1XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4xMTExMSwgMCwgMC41MzIyMl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMTA4NjEsIDAsIDAuMjk2NjZdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLjA5NDI2LCAwLCAwLjk0NDQ0XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NDQ0NCwgMC4wOTQyNiwgMCwgMC42NDk5OV0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDc4NjEsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA3ODYxLCAwLCAwLjU5MTExXSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4xMDUsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ0NDQ0LCAwLjExMTExLCAwLCAwLjUwMTY3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMC4wODE2NywgMCwgMC40ODY5NF0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAuMDk2MzksIDAsIDAuMzg1XSxcbiAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMC4wOTQyNiwgMCwgMC42MjA1NV0sXG4gICAgXCIxMThcIjogWzAsIDAuNDQ0NDQsIDAuMTExMTEsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjExMTExLCAwLCAwLjc2Nzc3XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMC4xMjU4MywgMCwgMC41NjA1NV0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMTA1LCAwLCAwLjU2MTY2XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NDQ0NCwgMC4xMzg4OSwgMCwgMC40OTA1NV0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzQ0NDQsIDAuMTE0NzIsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg2ODUzXSxcbiAgICBcIjE2OFwiOiBbMCwgMC42OTQ0NCwgMC4xMTQ3MywgMCwgMC41OTExMV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuOTQ4ODhdLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjUzMjIyXSxcbiAgICBcIjE5OFwiOiBbMCwgMC42ODYxMSwgMC4xMTQzMSwgMCwgMS4wMjI3N10sXG4gICAgXCIyMTZcIjogWzAuMDQ4NjEsIDAuNzM0NzIsIDAuMDkwNjIsIDAsIDAuODg1NTVdLFxuICAgIFwiMjIzXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA5NzM2LCAwLCAwLjY2NV0sXG4gICAgXCIyMzBcIjogWzAsIDAuNDQ0NDQsIDAuMDg1LCAwLCAwLjgyNjY2XSxcbiAgICBcIjI0OFwiOiBbMC4wOTcyMiwgMC41NDE2NywgMC4wOTQ1OCwgMCwgMC41OTExMV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDQ0NDQsIDAuMDk0MjYsIDAsIDAuMzU1NTVdLFxuICAgIFwiMzM4XCI6IFswLCAwLjY4NjExLCAwLjExNDMxLCAwLCAxLjE0MDU0XSxcbiAgICBcIjMzOVwiOiBbMCwgMC40NDQ0NCwgMC4wODUsIDAsIDAuODI2NjZdLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA0NjExLCAwLCAwLjM4NV0sXG4gICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAuMDY3MDksIDAsIDAuNTkxMTFdLFxuICAgIFwiNzExXCI6IFswLCAwLjYzMTk0LCAwLjA4MjcxLCAwLCAwLjU5MTExXSxcbiAgICBcIjcxM1wiOiBbMCwgMC41OTQ0NCwgMC4xMDQ0NCwgMCwgMC41OTExMV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAuMDg1MjgsIDAsIDAuNTkxMTFdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU5MTExXSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMC4xMDMzMywgMCwgMC41OTExMV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjk0NDQsIDAuMTI5NDUsIDAsIDAuMzU1NTVdLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjk0ODg4XSxcbiAgICBcIjczMlwiOiBbMCwgMC42OTQ0NCwgMC4xMTQ3MiwgMCwgMC41OTExMV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAuMTE0NzIsIDAsIDAuNTkxMTFdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4NjExLCAwLjEyOTAzLCAwLCAwLjY5Nzc3XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45NDQ0NF0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjg2MTEsIDAuMDkwNjIsIDAsIDAuODg1NTVdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgwNjY2XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODYxMSwgMC4xNTA5MiwgMCwgMC43Njc3N10sXG4gICAgXCI5MjhcIjogWzAsIDAuNjg2MTEsIDAuMTcyMDgsIDAsIDAuODk2MV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjg2MTEsIDAuMTE0MzEsIDAsIDAuODI2NjZdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4NjExLCAwLjEwNzc4LCAwLCAwLjg4NTU1XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODYxMSwgMC4wNTYzMiwgMCwgMC44MjY2Nl0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjg2MTEsIDAuMTA3NzgsIDAsIDAuODg1NTVdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4NjExLCAwLjA5OTIsIDAsIDAuODI2NjZdLFxuICAgIFwiODIxMVwiOiBbMCwgMC40NDQ0NCwgMC4wOTgxMSwgMCwgMC41OTExMV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQ0NDQ0LCAwLjA5ODExLCAwLCAxLjE4MjIxXSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAuMTI5NDUsIDAsIDAuMzU1NTVdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMC4xMjk0NSwgMCwgMC4zNTU1NV0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLjE2NzcyLCAwLCAwLjYyMDU1XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAuMDc5MzksIDAsIDAuNjIwNTVdXG4gIH0sXG4gIFwiTWFpbi1JdGFsaWNcIjoge1xuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDAsIDAuMzA2NjddLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAuMDY5NjEsIDAsIDAuNTE0NDRdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDY2MTYsIDAsIDAuODE3NzddLFxuICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAuMTM2MzksIDAsIDAuODE3NzddLFxuICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAuMDk2OTQsIDAsIDAuNzY2NjZdLFxuICAgIFwiMzlcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDAsIDAuMzA2NjddLFxuICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAuMTYxOTQsIDAsIDAuNDA4ODldLFxuICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAuMDM2OTQsIDAsIDAuNDA4ODldLFxuICAgIFwiNDJcIjogWzAsIDAuNzUsIDAuMTQ5MTcsIDAsIDAuNTExMTFdLFxuICAgIFwiNDNcIjogWzAuMDU2NjcsIDAuNTYxNjcsIDAuMDM2OTQsIDAsIDAuNzY2NjZdLFxuICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTA1NTYsIDAsIDAsIDAuMzA2NjddLFxuICAgIFwiNDVcIjogWzAsIDAuNDMwNTYsIDAuMDI4MjYsIDAsIDAuMzU3NzhdLFxuICAgIFwiNDZcIjogWzAsIDAuMTA1NTYsIDAsIDAsIDAuMzA2NjddLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAuMTYxOTQsIDAsIDAuNTExMTFdLFxuICAgIFwiNDhcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNDlcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTFcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTJcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTRcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTVcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTdcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAuMDU4MiwgMCwgMC4zMDY2N10sXG4gICAgXCI1OVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTgyLCAwLCAwLjMwNjY3XSxcbiAgICBcIjYxXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMC4wNjYxNiwgMCwgMC43NjY2Nl0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwLCAwLjUxMTExXSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLjA5NTk3LCAwLCAwLjc2NjY2XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc0MzMzXSxcbiAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwLCAwLjcwMzg5XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwLCAwLjcxNTU1XSxcbiAgICBcIjY4XCI6IFswLCAwLjY4MzMzLCAwLjA5NDAzLCAwLCAwLjc1NV0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODMzMywgMC4xMjAyOCwgMCwgMC42NzgzM10sXG4gICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMCwgMC42NTI3N10sXG4gICAgXCI3MVwiOiBbMCwgMC42ODMzMywgMC4wODcyMiwgMCwgMC43NzM2MV0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4xNjM4OSwgMCwgMC43NDMzM10sXG4gICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4xNTgwNiwgMCwgMC4zODU1NV0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODMzMywgMC4xNDAyOCwgMCwgMC41MjVdLFxuICAgIFwiNzVcIjogWzAsIDAuNjgzMzMsIDAuMTQ1MjgsIDAsIDAuNzY4ODhdLFxuICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjI3MjJdLFxuICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuODk2NjZdLFxuICAgIFwiNzhcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuNzQzMzNdLFxuICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDAsIDAuNzY2NjZdLFxuICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTAyNTcsIDAsIDAuNjc4MzNdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjgzMzMsIDAuMDk0MDMsIDAsIDAuNzY2NjZdLFxuICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAuMDM4NjgsIDAsIDAuNzI5NDRdLFxuICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMTE5NzIsIDAsIDAuNTYyMjJdLFxuICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAuMTMzMDUsIDAsIDAuNzE1NTVdLFxuICAgIFwiODVcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuNzQzMzNdLFxuICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMTgzNjEsIDAsIDAuNzQzMzNdLFxuICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMTgzNjEsIDAsIDAuOTk4ODhdLFxuICAgIFwiODhcIjogWzAsIDAuNjgzMzMsIDAuMTU4MDYsIDAsIDAuNzQzMzNdLFxuICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMTkzODMsIDAsIDAuNzQzMzNdLFxuICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAuMTQ1MjgsIDAsIDAuNjEzMzNdLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAuMTg3NSwgMCwgMC4zMDY2N10sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMC4xMDUyOCwgMCwgMC4zMDY2N10sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMC4wNjY0NiwgMCwgMC41MTExMV0sXG4gICAgXCI5NVwiOiBbMC4zMSwgMC4xMjA1NiwgMC4wOTIwOCwgMCwgMC41MTExMV0sXG4gICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMCwgMC41MTExMV0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMC4wNjMxMiwgMCwgMC40Nl0sXG4gICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMC4wNTY1MywgMCwgMC40Nl0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDAsIDAuNTExMTFdLFxuICAgIFwiMTAxXCI6IFswLCAwLjQzMDU2LCAwLjA3NTE0LCAwLCAwLjQ2XSxcbiAgICBcIjEwMlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4yMTE5NCwgMCwgMC4zMDY2N10sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDAsIDAuNDZdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLjA3NjcxLCAwLCAwLjUxMTExXSxcbiAgICBcIjEwNVwiOiBbMCwgMC42NTUzNiwgMC4xMDE5LCAwLCAwLjMwNjY3XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NTUzNiwgMC4xNDQ2NywgMCwgMC4zMDY2N10sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAuMTA3NjQsIDAsIDAuNDZdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjEwMzMzLCAwLCAwLjI1NTU1XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMCwgMC44MTc3N10sXG4gICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDAsIDAuNTYyMjJdLFxuICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLjA2MzEyLCAwLCAwLjUxMTExXSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNjMxMiwgMCwgMC41MTExMV0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDAsIDAuNDZdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjEwNzY0LCAwLCAwLjQyMTY2XSxcbiAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMC4wODIwOCwgMCwgMC40MDg4OV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAuMDk0ODYsIDAsIDAuMzMyMjJdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLjA3NjcxLCAwLCAwLjUzNjY2XSxcbiAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4xMDc2NCwgMCwgMC40Nl0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMTA3NjQsIDAsIDAuNjY0NDRdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLjEyMDQyLCAwLCAwLjQ2Mzg5XSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wODg0NywgMCwgMC40ODU1NV0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAuMTIyOTIsIDAsIDAuNDA4ODldLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjMxNzg2LCAwLjExNTg1LCAwLCAwLjUxMTExXSxcbiAgICBcIjE2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43NjkwOV0sXG4gICAgXCIxNjhcIjogWzAsIDAuNjY3ODYsIDAuMTA0NzQsIDAsIDAuNTExMTFdLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMTI5XSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40Nl0sXG4gICAgXCIxOThcIjogWzAsIDAuNjgzMzMsIDAuMTIwMjgsIDAsIDAuODgyNzddLFxuICAgIFwiMjE2XCI6IFswLjA0ODYxLCAwLjczMTk0LCAwLjA5NDAzLCAwLCAwLjc2NjY2XSxcbiAgICBcIjIyM1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMDUxNCwgMCwgMC41MzY2Nl0sXG4gICAgXCIyMzBcIjogWzAsIDAuNDMwNTYsIDAuMDc1MTQsIDAsIDAuNzE1NTVdLFxuICAgIFwiMjQ4XCI6IFswLjA5NzIyLCAwLjUyNzc4LCAwLjA5MTk0LCAwLCAwLjUxMTExXSxcbiAgICBcIjMwNVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wMjc3OCwgMC4zMjI0Nl0sXG4gICAgXCIzMzhcIjogWzAsIDAuNjgzMzMsIDAuMTIwMjgsIDAsIDAuOTg0OTldLFxuICAgIFwiMzM5XCI6IFswLCAwLjQzMDU2LCAwLjA3NTE0LCAwLCAwLjcxNTU1XSxcbiAgICBcIjU2N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC4zODQwM10sXG4gICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDAsIDAuNTExMTFdLFxuICAgIFwiNzExXCI6IFswLCAwLjYyODQ3LCAwLjA4Mjk1LCAwLCAwLjUxMTExXSxcbiAgICBcIjcxM1wiOiBbMCwgMC41NjE2NywgMC4xMDMzMywgMCwgMC41MTExMV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAuMDk2OTQsIDAsIDAuNTExMTFdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMC4xMDgwNiwgMCwgMC41MTExMV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjY3ODYsIDAuMTE3NTIsIDAsIDAuMzA2NjddLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMTI5XSxcbiAgICBcIjczMlwiOiBbMCwgMC42Njc4NiwgMC4xMTU4NSwgMCwgMC41MTExMV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAuMTIyNSwgMCwgMC41MTExMV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjgzMzMsIDAuMTMzMDUsIDAsIDAuNjI3MjJdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjgxNzc3XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wOTQwMywgMCwgMC43NjY2Nl0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjkyMjJdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLjE1Mjk0LCAwLCAwLjY2NDQ0XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4xNjM4OSwgMCwgMC43NDMzM10sXG4gICAgXCI5MzFcIjogWzAsIDAuNjgzMzMsIDAuMTIwMjgsIDAsIDAuNzE1NTVdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLjExMTExLCAwLCAwLjc2NjY2XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMC4wNTk4NiwgMCwgMC43MTU1NV0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjgzMzMsIDAuMTExMTEsIDAsIDAuNzY2NjZdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwLCAwLjcxNTU1XSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDMwNTYsIDAuMDkyMDgsIDAsIDAuNTExMTFdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40MzA1NiwgMC4wOTIwOCwgMCwgMS4wMjIyMl0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwLCAwLjMwNjY3XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDAsIDAuMzA2NjddLFxuICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMC4xNjg1LCAwLCAwLjUxNDQ0XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAuMDY5NjEsIDAsIDAuNTE0NDRdLFxuICAgIFwiODQ2M1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NDAyOF1cbiAgfSxcbiAgXCJNYWluLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiNDNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTA1NTYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDVcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuMzMzMzNdLFxuICAgIFwiNDZcIjogWzAsIDAuMTA1NTYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI0OFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjQ5XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1MVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjUyXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU1XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1N1wiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU4XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjU5XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjYwXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI2MVwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNjJcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc1XSxcbiAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjcwODM0XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjY4XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc2Mzg5XSxcbiAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY4MDU2XSxcbiAgICBcIjcwXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY1Mjc4XSxcbiAgICBcIjcxXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc4NDcyXSxcbiAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc1XSxcbiAgICBcIjczXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjM2MTExXSxcbiAgICBcIjc0XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjUxMzg5XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjYyNV0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC45MTY2N10sXG4gICAgXCI3OFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42ODA1Nl0sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MzYxMV0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI4NlwiOiBbMCwgMC42ODMzMywgMC4wMTM4OSwgMCwgMC43NV0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODMzMywgMC4wMTM4OSwgMCwgMS4wMjc3OF0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI4OVwiOiBbMCwgMC42ODMzMywgMC4wMjUsIDAsIDAuNzVdLFxuICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiOTJcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjk1XCI6IFswLjMxLCAwLjEyMDU2LCAwLjAyNzc4LCAwLCAwLjVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiMTAxXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4wNzc3OCwgMCwgMC4zMDU1Nl0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDEzODksIDAsIDAuNV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiMTA1XCI6IFswLCAwLjY2Nzg2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42Njc4NiwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuMzkxNjddLFxuICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjM5NDQ1XSxcbiAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLjAxMzg5LCAwLCAwLjUyNzc4XSxcbiAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMTM4OSwgMCwgMC43MjIyMl0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwLCAwLjUyNzc4XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMjNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCIxMjRcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiMTI1XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjMxNzg2LCAwLCAwLCAwLjVdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjE2N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxNjhcIjogWzAsIDAuNjY3ODYsIDAsIDAsIDAuNV0sXG4gICAgXCIxNzJcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc1XSxcbiAgICBcIjE3N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxODJcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjE5OFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC45MDI3OF0sXG4gICAgXCIyMTVcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMjE2XCI6IFswLjA0ODYxLCAwLjczMTk0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjIyM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjIzMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCIyNDdcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMjQ4XCI6IFswLjA5NzIyLCAwLjUyNzc4LCAwLCAwLCAwLjVdLFxuICAgIFwiMzA1XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjMzOFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMS4wMTM4OV0sXG4gICAgXCIzMzlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcxMVwiOiBbMCwgMC42Mjg0NywgMCwgMCwgMC41XSxcbiAgICBcIjcxM1wiOiBbMCwgMC41Njc3OCwgMCwgMCwgMC41XSxcbiAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcyOVwiOiBbMCwgMC42Njc4NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzVdLFxuICAgIFwiNzMyXCI6IFswLCAwLjY2Nzg2LCAwLCAwLCAwLjVdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjYyNV0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42OTQ0NV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTI4XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc1XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5MzNcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkzNlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODIxMVwiOiBbMCwgMC40MzA1NiwgMC4wMjc3OCwgMCwgMC41XSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDAsIDEuMF0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI4MjI0XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjgyMjVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODIzMFwiOiBbMCwgMC4xMiwgMCwgMCwgMS4xNzJdLFxuICAgIFwiODI0MlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC4yNzVdLFxuICAgIFwiODQwN1wiOiBbMCwgMC43MTQ0NCwgMC4xNTM4MiwgMCwgMC41XSxcbiAgICBcIjg0NjNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTQwMjhdLFxuICAgIFwiODQ2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NDY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLjExMTExLCAwLjQxNjY3XSxcbiAgICBcIjg0NzJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMTExMTEsIDAuNjM2NDZdLFxuICAgIFwiODQ3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NTAxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg1OTJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODU5M1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjg1OTRcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODU5NVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjg1OTZcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODU5N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjg1OThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMF0sXG4gICAgXCI4NTk5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjBdLFxuICAgIFwiODYwMFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MDFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjE0XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjE3XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuMTI2XSxcbiAgICBcIjg2MThcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS4xMjZdLFxuICAgIFwiODYzNlwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjM3XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NDBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY0MVwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjUyXCI6IFswLjAxMSwgMC42NzEsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjU2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODY1OFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjU5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg2NjBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY2MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4NzA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3MDZcIjogWzAsIDAuNjk0NDQsIDAuMDU1NTYsIDAuMDgzMzQsIDAuNTMwOV0sXG4gICAgXCI4NzA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3MDlcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzExXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg3MTJcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3MTVcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3MjJcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODcyM1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzI1XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiODcyNlwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjg3MjdcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwLCAwLjVdLFxuICAgIFwiODcyOFwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzI5XCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMCwgMC41XSxcbiAgICBcIjg3MzBcIjogWzAuMiwgMC44LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg3MzNcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODczNFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMS4wXSxcbiAgICBcIjg3MzZcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODczOVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4NzQxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiODc0M1wiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzQ0XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3NDVcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODc0NlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzQ3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMTExLCAwLCAwLjQxNjY3XSxcbiAgICBcIjg3NjRcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NjhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODc3MVwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc3M1wiOiBbLTAuMDIyLCAwLjU4OSwgMCwgMCwgMS4wXSxcbiAgICBcIjg3NzZcIjogWy0wLjAxNjg4LCAwLjQ4MzEyLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODFcIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODRcIjogWy0wLjEzMywgMC42NywgMCwgMCwgMC43NzhdLFxuICAgIFwiODgwMVwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwNFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODA1XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTBcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAxLjBdLFxuICAgIFwiODgxMVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDEuMF0sXG4gICAgXCI4ODI2XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODI3XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODM0XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODM1XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODM4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzlcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0NlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4ODQ5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTBcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1MVwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4ODUyXCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg4NTNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1NFwiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODU1XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTZcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4NjdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODg2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NzJcIjogWzAuMjQ5LCAwLjc1LCAwLCAwLCAwLjg2N10sXG4gICAgXCI4OTAwXCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMCwgMC41XSxcbiAgICBcIjg5MDFcIjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjg5MDJcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwLCAwLjVdLFxuICAgIFwiODkwNFwiOiBbMC4wMDUsIDAuNTA1LCAwLCAwLCAwLjldLFxuICAgIFwiODk0MlwiOiBbMC4wMywgMC45LCAwLCAwLCAwLjI3OF0sXG4gICAgXCI4OTQzXCI6IFstMC4xOSwgMC4zMSwgMCwgMCwgMS4xNzJdLFxuICAgIFwiODk0NVwiOiBbLTAuMSwgMC44MiwgMCwgMCwgMS4yODJdLFxuICAgIFwiODk2OFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4OTY5XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjg5NzBcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODk3MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4OTk0XCI6IFstMC4xNDIzNiwgMC4zNTc2NCwgMCwgMCwgMS4wXSxcbiAgICBcIjg5OTVcIjogWy0wLjE0MjM2LCAwLjM1NzY0LCAwLCAwLCAxLjBdLFxuICAgIFwiOTEzNlwiOiBbMC4yNDQsIDAuNzQ0LCAwLCAwLCAwLjQxMl0sXG4gICAgXCI5MTM3XCI6IFswLjI0NCwgMC43NDQsIDAsIDAsIDAuNDEyXSxcbiAgICBcIjk2NTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTY1N1wiOiBbLTAuMDM0NzIsIDAuNDY1MjgsIDAsIDAsIDAuNV0sXG4gICAgXCI5NjYxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjk2NjdcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwLCAwLjVdLFxuICAgIFwiOTcxMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wXSxcbiAgICBcIjk4MjRcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTgyNVwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5ODI2XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk4MjdcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTgzN1wiOiBbMCwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI5ODM4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjk4MzlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiMTAyMTZcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiMTAyMTdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiMTAyMjJcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMCwgMC40MTJdLFxuICAgIFwiMTAyMjNcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMCwgMC40MTJdLFxuICAgIFwiMTAyMjlcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS42MDldLFxuICAgIFwiMTAyMzBcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS42MzhdLFxuICAgIFwiMTAyMzFcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS44NTldLFxuICAgIFwiMTAyMzJcIjogWzAuMDI0LCAwLjUyNSwgMCwgMCwgMS42MDldLFxuICAgIFwiMTAyMzNcIjogWzAuMDI0LCAwLjUyNSwgMCwgMCwgMS42MzhdLFxuICAgIFwiMTAyMzRcIjogWzAuMDI0LCAwLjUyNSwgMCwgMCwgMS44NThdLFxuICAgIFwiMTAyMzZcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS42MzhdLFxuICAgIFwiMTA4MTVcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiMTA5MjdcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MjhcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNzZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDBdXG4gIH0sXG4gIFwiTWF0aC1Cb2xkSXRhbGljXCI6IHtcbiAgICBcIjY1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2OTQ0XSxcbiAgICBcIjY2XCI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwLCAwLjg2NjRdLFxuICAgIFwiNjdcIjogWzAsIDAuNjg2MTEsIDAuMDY5NzksIDAsIDAuODE2OTRdLFxuICAgIFwiNjhcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDAsIDAuOTM4MTJdLFxuICAgIFwiNjlcIjogWzAsIDAuNjg2MTEsIDAuMDU0NTEsIDAsIDAuODEwMDddLFxuICAgIFwiNzBcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDAuNjg4ODldLFxuICAgIFwiNzFcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODg2NzNdLFxuICAgIFwiNzJcIjogWzAsIDAuNjg2MTEsIDAuMDgyMjksIDAsIDAuOTgyMjldLFxuICAgIFwiNzNcIjogWzAsIDAuNjg2MTEsIDAuMDc3NzgsIDAsIDAuNTExMTFdLFxuICAgIFwiNzRcIjogWzAsIDAuNjg2MTEsIDAuMTAwNjksIDAsIDAuNjMxMjVdLFxuICAgIFwiNzVcIjogWzAsIDAuNjg2MTEsIDAuMDY5NzksIDAsIDAuOTcxMThdLFxuICAgIFwiNzZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzU1NTVdLFxuICAgIFwiNzdcIjogWzAsIDAuNjg2MTEsIDAuMTE0MjQsIDAsIDEuMTQyMDFdLFxuICAgIFwiNzhcIjogWzAsIDAuNjg2MTEsIDAuMTE0MjQsIDAsIDAuOTUwMzRdLFxuICAgIFwiNzlcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDAsIDAuODM2NjZdLFxuICAgIFwiODBcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDAuNzIzMDldLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjg2MTEsIDAsIDAsIDAuODY4NjFdLFxuICAgIFwiODJcIjogWzAsIDAuNjg2MTEsIDAuMDA0MjEsIDAsIDAuODcyMzVdLFxuICAgIFwiODNcIjogWzAsIDAuNjg2MTEsIDAuMDUzODIsIDAsIDAuNjkyNzFdLFxuICAgIFwiODRcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDAuNjM2NjNdLFxuICAgIFwiODVcIjogWzAsIDAuNjg2MTEsIDAuMTE0MjQsIDAsIDAuODAwMjddLFxuICAgIFwiODZcIjogWzAsIDAuNjg2MTEsIDAuMjU1NTUsIDAsIDAuNjc3NzhdLFxuICAgIFwiODdcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDEuMDkzMDVdLFxuICAgIFwiODhcIjogWzAsIDAuNjg2MTEsIDAuMDc3NzgsIDAsIDAuOTQ3MjJdLFxuICAgIFwiODlcIjogWzAsIDAuNjg2MTEsIDAuMjU1NTUsIDAsIDAuNjc0NThdLFxuICAgIFwiOTBcIjogWzAsIDAuNjg2MTEsIDAuMDY5NzksIDAsIDAuNzcyNTddLFxuICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjMyODddLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTIwODNdLFxuICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTEzNDJdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYwOTcyXSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41NTM2MV0sXG4gICAgXCIxMDJcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTEwNDIsIDAsIDAuNTY4MDZdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjU0NDldLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NzU5XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42OTMyNiwgMCwgMCwgMC40MDQ4XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42OTMyNiwgMC4wNjIyLCAwLCAwLjQ3MDgzXSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wMTg1MiwgMCwgMC42MDM3XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMC4wMDg4LCAwLCAwLjM0ODE1XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMS4wMzI0XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC43MTI5Nl0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTg0NzJdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjYwMDkyXSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC41NDIxM10sXG4gICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDAsIDAuNTI4N10sXG4gICAgXCIxMTVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTMxMjVdLFxuICAgIFwiMTE2XCI6IFswLCAwLjYzNDkyLCAwLCAwLCAwLjQxNTI4XSxcbiAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42ODEwMl0sXG4gICAgXCIxMThcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNTY2NjZdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjAyNzc4LCAwLCAwLjgzMTQ4XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42NTkwM10sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNTkwMjhdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLjA0MjEzLCAwLCAwLjU1NTA5XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMC42NTY5NF0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY4NjExLCAwLjAzMTk0LCAwLCAwLjg2NzIyXSxcbiAgICBcIjkyM1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MDU1NV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjg2MTEsIDAuMDc0NTgsIDAsIDAuODQxMjVdLFxuICAgIFwiOTI4XCI6IFswLCAwLjY4NjExLCAwLjA4MjI5LCAwLCAwLjk4MjI5XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42ODYxMSwgMC4wNTQ1MSwgMCwgMC44ODUwN10sXG4gICAgXCI5MzNcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDAuNjcwODNdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjkzNlwiOiBbMCwgMC42ODYxMSwgMC4xMTY1MywgMCwgMC43MTQwMl0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjg2MTEsIDAuMDQ4MzUsIDAsIDAuODc4OV0sXG4gICAgXCI5NDVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNzYwNjRdLFxuICAgIFwiOTQ2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNDAzLCAwLCAwLjY1OTcyXSxcbiAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNjM4OSwgMCwgMC41OTAwM10sXG4gICAgXCI5NDhcIjogWzAsIDAuNjk0NDQsIDAuMDM4MTksIDAsIDAuNTIyMjJdLFxuICAgIFwiOTQ5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUyODgyXSxcbiAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNjIxNSwgMCwgMC41MDgzM10sXG4gICAgXCI5NTFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNl0sXG4gICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDMxOTQsIDAsIDAuNTYxOF0sXG4gICAgXCI5NTNcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDEyMDRdLFxuICAgIFwiOTU0XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjY2NzU5XSxcbiAgICBcIjk1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NzA4M10sXG4gICAgXCI5NTZcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNzA3ODddLFxuICAgIFwiOTU3XCI6IFswLCAwLjQ0NDQ0LCAwLjA2ODk4LCAwLCAwLjU3Njg1XSxcbiAgICBcIjk1OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzAyMSwgMCwgMC41MDgzM10sXG4gICAgXCI5NTlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTg0NzJdLFxuICAgIFwiOTYwXCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjY4MjQxXSxcbiAgICBcIjk2MVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC42MTE4XSxcbiAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40NDQ0NCwgMC4wNzkxNywgMCwgMC40MjM2MV0sXG4gICAgXCI5NjNcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNjg1ODhdLFxuICAgIFwiOTY0XCI6IFswLCAwLjQ0NDQ0LCAwLjEzNDcyLCAwLCAwLjUyMDgzXSxcbiAgICBcIjk2NVwiOiBbMCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC42MzA1NV0sXG4gICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNzQ3MjJdLFxuICAgIFwiOTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjcxODA1XSxcbiAgICBcIjk2OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzcwNCwgMCwgMC43NTgzM10sXG4gICAgXCI5NjlcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNzE3ODJdLFxuICAgIFwiOTc3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY5MTU1XSxcbiAgICBcIjk4MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC43MTI1XSxcbiAgICBcIjk4MlwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMCwgMC45NzVdLFxuICAgIFwiMTAwOVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC42MTE4XSxcbiAgICBcIjEwMTNcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDgzMzNdXG4gIH0sXG4gIFwiTWF0aC1JdGFsaWNcIjoge1xuICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODksIDAuNzVdLFxuICAgIFwiNjZcIjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzQsIDAuNzU4NTFdLFxuICAgIFwiNjdcIjogWzAsIDAuNjgzMzMsIDAuMDcxNTMsIDAuMDgzMzQsIDAuNzE0NzJdLFxuICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDU1NTYsIDAuODI3OTJdLFxuICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzQsIDAuNzM4Ml0sXG4gICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNCwgMC42NDMwNl0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNCwgMC43ODYyNV0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1NiwgMC44MzEyNV0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4xMTExMSwgMC40Mzk1OF0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODMzMywgMC4wOTYxOCwgMC4xNjY2NywgMC41NTQ1MV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wNTU1NiwgMC44NDkzMV0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4wMjc3OCwgMC42ODA1Nl0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wODMzNCwgMC45NzAxNF0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wODMzNCwgMC44MDM0N10sXG4gICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNCwgMC43NjI3OF0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNCwgMC42NDIwMV0sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODMzMywgMCwgMC4wODMzNCwgMC43OTA1Nl0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMDc3MywgMC4wODMzNCwgMC43NTkyOV0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODMzMywgMC4wNTc2NCwgMC4wODMzNCwgMC42MTMyXSxcbiAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0LCAwLjU4NDM4XSxcbiAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjAyNzc4LCAwLjY4Mjc4XSxcbiAgICBcIjg2XCI6IFswLCAwLjY4MzMzLCAwLjIyMjIyLCAwLCAwLjU4MzMzXSxcbiAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLjA3ODQ3LCAwLjA4MzM0LCAwLjgyODQ3XSxcbiAgICBcIjg5XCI6IFswLCAwLjY4MzMzLCAwLjIyMjIyLCAwLCAwLjU4MDU2XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0LCAwLjY4MjY0XSxcbiAgICBcIjk3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyODU5XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQyOTE3XSxcbiAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQzMjc2XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMC4xNjY2NywgMC41MjA0OV0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDY1NjNdLFxuICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEwNzY0LCAwLjE2NjY3LCAwLjQ4OTU5XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wMjc3OCwgMC40NzY5N10sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc2MTZdLFxuICAgIFwiMTA1XCI6IFswLCAwLjY1OTUyLCAwLCAwLCAwLjM0NDUxXSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NTk1MiwgMC4wNTcyNCwgMCwgMC40MTE4MV0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAuMDMxNDgsIDAsIDAuNTIwNl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMDE5NjgsIDAuMDgzMzQsIDAuMjk4MzhdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjg3ODAxXSxcbiAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC42MDAyM10sXG4gICAgXCIxMTFcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDg0NzJdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjUwMzEzXSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wODMzNCwgMC40NDY0MV0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDAuMDU1NTYsIDAuNDUxMTZdLFxuICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQ2ODc1XSxcbiAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMC4wODMzNCwgMC4zNjExMV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuNTcyNDZdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4LCAwLjQ4NDcyXSxcbiAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMjY5MSwgMC4wODMzNCwgMC43MTU5Ml0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuNTcxNTNdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2LCAwLjQ5MDI4XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMC4wNDM5OCwgMC4wNTU1NiwgMC40NjUwNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzQsIDAuNjE1MjhdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3LCAwLjgzMzM0XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNCwgMC43NjI3OF0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjcsIDAuNjk0NDVdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLjA3NTY5LCAwLjA4MzM0LCAwLjc0MjM2XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1NiwgMC44MzEyNV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzQsIDAuNzc5ODZdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA1NTU2LCAwLjU4MzMzXSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNCwgMC42NjY2N10sXG4gICAgXCI5MzZcIjogWzAsIDAuNjgzMzMsIDAuMTEsIDAuMDU1NTYsIDAuNjEyMjJdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0LCAwLjc3MjRdLFxuICAgIFwiOTQ1XCI6IFswLCAwLjQzMDU2LCAwLjAwMzcsIDAuMDI3NzgsIDAuNjM5N10sXG4gICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUyNzgsIDAuMDgzMzQsIDAuNTY1NjNdLFxuICAgIFwiOTQ3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA1NTU2LCAwLCAwLjUxNzczXSxcbiAgICBcIjk0OFwiOiBbMCwgMC42OTQ0NCwgMC4wMzc4NSwgMC4wNTU1NiwgMC40NDQ0NF0sXG4gICAgXCI5NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuNDY2MzJdLFxuICAgIFwiOTUwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA3Mzc4LCAwLjA4MzM0LCAwLjQzNzVdLFxuICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2LCAwLjQ5NjUzXSxcbiAgICBcIjk1MlwiOiBbMCwgMC42OTQ0NCwgMC4wMjc3OCwgMC4wODMzNCwgMC40Njk0NF0sXG4gICAgXCI5NTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuMzUzOTRdLFxuICAgIFwiOTU0XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjU3NjE2XSxcbiAgICBcIjk1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI5NTZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuNjAyNTVdLFxuICAgIFwiOTU3XCI6IFswLCAwLjQzMDU2LCAwLjA2MzY2LCAwLjAyNzc4LCAwLjQ5Mzk4XSxcbiAgICBcIjk1OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNDYwMSwgMC4xMTExMSwgMC40Mzc1XSxcbiAgICBcIjk1OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40ODQ3Ml0sXG4gICAgXCI5NjBcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAsIDAuNTcwMDNdLFxuICAgIFwiOTYxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjUxNzAyXSxcbiAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40MzA1NiwgMC4wNzk4NiwgMC4wODMzNCwgMC4zNjI4NV0sXG4gICAgXCI5NjNcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAsIDAuNTcxNDFdLFxuICAgIFwiOTY0XCI6IFswLCAwLjQzMDU2LCAwLjExMzIsIDAuMDI3NzgsIDAuNDM3MTVdLFxuICAgIFwiOTY1XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4LCAwLjU0MDI4XSxcbiAgICBcIjk2NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC42NTQxN10sXG4gICAgXCI5NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNjI1NjldLFxuICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNTg4LCAwLjExMTExLCAwLjY1MTM5XSxcbiAgICBcIjk2OVwiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMCwgMC42MjI0NV0sXG4gICAgXCI5NzdcIjogWzAsIDAuNjk0NDQsIDAsIDAuMDgzMzQsIDAuNTkxNDRdLFxuICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLjA4MzM0LCAwLjU5NTgzXSxcbiAgICBcIjk4MlwiOiBbMCwgMC40MzA1NiwgMC4wMjc3OCwgMCwgMC44MjgxM10sXG4gICAgXCIxMDA5XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjUxNzAyXSxcbiAgICBcIjEwMTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDA1OV1cbiAgfSxcbiAgXCJNYXRoLVJlZ3VsYXJcIjoge1xuICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODksIDAuNzVdLFxuICAgIFwiNjZcIjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzQsIDAuNzU4NTFdLFxuICAgIFwiNjdcIjogWzAsIDAuNjgzMzMsIDAuMDcxNTMsIDAuMDgzMzQsIDAuNzE0NzJdLFxuICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDU1NTYsIDAuODI3OTJdLFxuICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzQsIDAuNzM4Ml0sXG4gICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNCwgMC42NDMwNl0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNCwgMC43ODYyNV0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1NiwgMC44MzEyNV0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4xMTExMSwgMC40Mzk1OF0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODMzMywgMC4wOTYxOCwgMC4xNjY2NywgMC41NTQ1MV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wNTU1NiwgMC44NDkzMV0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4wMjc3OCwgMC42ODA1Nl0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wODMzNCwgMC45NzAxNF0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wODMzNCwgMC44MDM0N10sXG4gICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNCwgMC43NjI3OF0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNCwgMC42NDIwMV0sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODMzMywgMCwgMC4wODMzNCwgMC43OTA1Nl0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMDc3MywgMC4wODMzNCwgMC43NTkyOV0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODMzMywgMC4wNTc2NCwgMC4wODMzNCwgMC42MTMyXSxcbiAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0LCAwLjU4NDM4XSxcbiAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjAyNzc4LCAwLjY4Mjc4XSxcbiAgICBcIjg2XCI6IFswLCAwLjY4MzMzLCAwLjIyMjIyLCAwLCAwLjU4MzMzXSxcbiAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLjA3ODQ3LCAwLjA4MzM0LCAwLjgyODQ3XSxcbiAgICBcIjg5XCI6IFswLCAwLjY4MzMzLCAwLjIyMjIyLCAwLCAwLjU4MDU2XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0LCAwLjY4MjY0XSxcbiAgICBcIjk3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyODU5XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQyOTE3XSxcbiAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQzMjc2XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMC4xNjY2NywgMC41MjA0OV0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDY1NjNdLFxuICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEwNzY0LCAwLjE2NjY3LCAwLjQ4OTU5XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wMjc3OCwgMC40NzY5N10sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc2MTZdLFxuICAgIFwiMTA1XCI6IFswLCAwLjY1OTUyLCAwLCAwLCAwLjM0NDUxXSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NTk1MiwgMC4wNTcyNCwgMCwgMC40MTE4MV0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAuMDMxNDgsIDAsIDAuNTIwNl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMDE5NjgsIDAuMDgzMzQsIDAuMjk4MzhdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjg3ODAxXSxcbiAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC42MDAyM10sXG4gICAgXCIxMTFcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDg0NzJdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjUwMzEzXSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wODMzNCwgMC40NDY0MV0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDAuMDU1NTYsIDAuNDUxMTZdLFxuICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQ2ODc1XSxcbiAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMC4wODMzNCwgMC4zNjExMV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuNTcyNDZdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4LCAwLjQ4NDcyXSxcbiAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMjY5MSwgMC4wODMzNCwgMC43MTU5Ml0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuNTcxNTNdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2LCAwLjQ5MDI4XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMC4wNDM5OCwgMC4wNTU1NiwgMC40NjUwNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzQsIDAuNjE1MjhdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3LCAwLjgzMzM0XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNCwgMC43NjI3OF0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjcsIDAuNjk0NDVdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLjA3NTY5LCAwLjA4MzM0LCAwLjc0MjM2XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1NiwgMC44MzEyNV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzQsIDAuNzc5ODZdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA1NTU2LCAwLjU4MzMzXSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNCwgMC42NjY2N10sXG4gICAgXCI5MzZcIjogWzAsIDAuNjgzMzMsIDAuMTEsIDAuMDU1NTYsIDAuNjEyMjJdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0LCAwLjc3MjRdLFxuICAgIFwiOTQ1XCI6IFswLCAwLjQzMDU2LCAwLjAwMzcsIDAuMDI3NzgsIDAuNjM5N10sXG4gICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUyNzgsIDAuMDgzMzQsIDAuNTY1NjNdLFxuICAgIFwiOTQ3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA1NTU2LCAwLCAwLjUxNzczXSxcbiAgICBcIjk0OFwiOiBbMCwgMC42OTQ0NCwgMC4wMzc4NSwgMC4wNTU1NiwgMC40NDQ0NF0sXG4gICAgXCI5NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuNDY2MzJdLFxuICAgIFwiOTUwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA3Mzc4LCAwLjA4MzM0LCAwLjQzNzVdLFxuICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2LCAwLjQ5NjUzXSxcbiAgICBcIjk1MlwiOiBbMCwgMC42OTQ0NCwgMC4wMjc3OCwgMC4wODMzNCwgMC40Njk0NF0sXG4gICAgXCI5NTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuMzUzOTRdLFxuICAgIFwiOTU0XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjU3NjE2XSxcbiAgICBcIjk1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI5NTZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuNjAyNTVdLFxuICAgIFwiOTU3XCI6IFswLCAwLjQzMDU2LCAwLjA2MzY2LCAwLjAyNzc4LCAwLjQ5Mzk4XSxcbiAgICBcIjk1OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNDYwMSwgMC4xMTExMSwgMC40Mzc1XSxcbiAgICBcIjk1OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40ODQ3Ml0sXG4gICAgXCI5NjBcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAsIDAuNTcwMDNdLFxuICAgIFwiOTYxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjUxNzAyXSxcbiAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40MzA1NiwgMC4wNzk4NiwgMC4wODMzNCwgMC4zNjI4NV0sXG4gICAgXCI5NjNcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAsIDAuNTcxNDFdLFxuICAgIFwiOTY0XCI6IFswLCAwLjQzMDU2LCAwLjExMzIsIDAuMDI3NzgsIDAuNDM3MTVdLFxuICAgIFwiOTY1XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4LCAwLjU0MDI4XSxcbiAgICBcIjk2NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC42NTQxN10sXG4gICAgXCI5NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNjI1NjldLFxuICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNTg4LCAwLjExMTExLCAwLjY1MTM5XSxcbiAgICBcIjk2OVwiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMCwgMC42MjI0NV0sXG4gICAgXCI5NzdcIjogWzAsIDAuNjk0NDQsIDAsIDAuMDgzMzQsIDAuNTkxNDRdLFxuICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLjA4MzM0LCAwLjU5NTgzXSxcbiAgICBcIjk4MlwiOiBbMCwgMC40MzA1NiwgMC4wMjc3OCwgMCwgMC44MjgxM10sXG4gICAgXCIxMDA5XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjUxNzAyXSxcbiAgICBcIjEwMTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDA1OV1cbiAgfSxcbiAgXCJTYW5zU2VyaWYtQm9sZFwiOiB7XG4gICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zNjY2N10sXG4gICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTgzNF0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC45MTY2N10sXG4gICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41NV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMS4wMjkxMl0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzA1Nl0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40Mjc3OF0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40Mjc3OF0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMCwgMC41NV0sXG4gICAgXCI0M1wiOiBbMC4xMTY2NywgMC42MTY2NywgMCwgMCwgMC44NTU1Nl0sXG4gICAgXCI0NFwiOiBbMC4xMDU1NiwgMC4xMzA1NiwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI0NVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC4zNjY2N10sXG4gICAgXCI0NlwiOiBbMCwgMC4xMzA1NiwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NV0sXG4gICAgXCI0OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI0OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1MVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1MlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI1OVwiOiBbMC4xMDU1NiwgMC40NTgzMywgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI2MVwiOiBbLTAuMDkzNzUsIDAuNDA2MjUsIDAsIDAsIDAuODU1NTZdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE5NDVdLFxuICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNjVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNjZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNjdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzhdLFxuICAgIFwiNjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiNjlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjQxNjddLFxuICAgIFwiNzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiNzFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNzJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiNzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzMwNTZdLFxuICAgIFwiNzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE5NDVdLFxuICAgIFwiNzVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzYzODldLFxuICAgIFwiNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTgwNTZdLFxuICAgIFwiNzdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuOTc3NzhdLFxuICAgIFwiNzhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiNzlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiODBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzhdLFxuICAgIFwiODFcIjogWzAuMTA1NTYsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiODJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzhdLFxuICAgIFwiODNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiODVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzYzODldLFxuICAgIFwiODZcIjogWzAsIDAuNjk0NDQsIDAuMDE1MjgsIDAsIDAuNzMzMzRdLFxuICAgIFwiODdcIjogWzAsIDAuNjk0NDQsIDAuMDE1MjgsIDAsIDEuMDM4ODldLFxuICAgIFwiODhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiODlcIjogWzAsIDAuNjk0NDQsIDAuMDI3NSwgMCwgMC43MzMzNF0sXG4gICAgXCI5MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NzIyM10sXG4gICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zNDMwNl0sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zNDMwNl0sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI5NVwiOiBbMC4zNSwgMC4xMDgzMywgMC4wMzA1NiwgMCwgMC41NV0sXG4gICAgXCI5N1wiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41MjVdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiOTlcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNDg4ODldLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41MTExMV0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMDc2MzksIDAsIDAuMzM2MTFdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjU1XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjU1NTZdLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjI4NjExXSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MzA1Nl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjU1NTZdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjg2NjY3XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTVdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NTgzMywgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDU4MzMsIDAuMDE1MjgsIDAsIDAuMzcyMjJdLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjQyMTY3XSxcbiAgICBcIjExNlwiOiBbMCwgMC41ODkyOSwgMCwgMCwgMC40MDQxN10sXG4gICAgXCIxMTdcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjVdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjc0NDQ1XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41XSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NTgzMywgMC4wMTUyOCwgMCwgMC41XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC40NzYzOV0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzQ0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiMTY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sXG4gICAgXCIxODBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjQ4ODg5XSxcbiAgICBcIjMwNVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC4yNTU1Nl0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDU4MzMsIDAsIDAsIDAuMjg2MTFdLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjcxMVwiOiBbMCwgMC42MzU0MiwgMCwgMCwgMC41NV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNjM3NzgsIDAsIDAsIDAuNTVdLFxuICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjcyOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNzMyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjczM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTgwNTZdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjkxNjY3XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44NTU1Nl0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjcyMjNdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg1NTU2XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODU1NTZdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDU4MzMsIDAuMDMwNTYsIDAsIDAuNTVdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40NTgzMywgMC4wMzA1NiwgMCwgMS4xMDAwMV0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTgzNF0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1ODM0XVxuICB9LFxuICBcIlNhbnNTZXJpZi1JdGFsaWNcIjoge1xuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAuMDU3MzMsIDAsIDAuMzE5NDVdLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAuMDAzMTYsIDAsIDAuNV0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNTA4NywgMCwgMC44MzMzNF0sXG4gICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLjAzMTI2LCAwLCAwLjgzMzM0XSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLjAzMDU4LCAwLCAwLjc1ODM0XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLjA3ODE2LCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLjEzMTY0LCAwLCAwLjM4ODg5XSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLjAyNTM2LCAwLCAwLjM4ODg5XSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLjExNzc1LCAwLCAwLjVdLFxuICAgIFwiNDNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAuMDI1MzYsIDAsIDAuNzc3NzhdLFxuICAgIFwiNDRcIjogWzAuMTI1LCAwLjA4MzMzLCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLjAxOTQ2LCAwLCAwLjMzMzMzXSxcbiAgICBcIjQ2XCI6IFswLCAwLjA4MzMzLCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLjEzMTY0LCAwLCAwLjVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI0OVwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjUwXCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1MlwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjUzXCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1NVwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjU2XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NDQ0NCwgMC4wMjUwMiwgMCwgMC4yNzc3OF0sXG4gICAgXCI1OVwiOiBbMC4xMjUsIDAuNDQ0NDQsIDAuMDI1MDIsIDAsIDAuMjc3NzhdLFxuICAgIFwiNjFcIjogWy0wLjEzLCAwLjM3LCAwLjA1MDg3LCAwLCAwLjc3Nzc4XSxcbiAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLjExODA5LCAwLCAwLjQ3MjIyXSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLjA3NTU1LCAwLCAwLjY2NjY3XSxcbiAgICBcIjY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjY2XCI6IFswLCAwLjY5NDQ0LCAwLjA4MjkzLCAwLCAwLjY2NjY3XSxcbiAgICBcIjY3XCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjYzODg5XSxcbiAgICBcIjY4XCI6IFswLCAwLjY5NDQ0LCAwLjA3NTU1LCAwLCAwLjcyMjIzXSxcbiAgICBcIjY5XCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjU5NzIyXSxcbiAgICBcIjcwXCI6IFswLCAwLjY5NDQ0LCAwLjEzMzcyLCAwLCAwLjU2OTQ1XSxcbiAgICBcIjcxXCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjY2NjY3XSxcbiAgICBcIjcyXCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjcwODM0XSxcbiAgICBcIjczXCI6IFswLCAwLjY5NDQ0LCAwLjEzMzcyLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjc0XCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjQ3MjIyXSxcbiAgICBcIjc1XCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjY5NDQ1XSxcbiAgICBcIjc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU0MTY3XSxcbiAgICBcIjc3XCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjg3NV0sXG4gICAgXCI3OFwiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC43MDgzNF0sXG4gICAgXCI3OVwiOiBbMCwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC43MzYxMV0sXG4gICAgXCI4MFwiOiBbMCwgMC42OTQ0NCwgMC4wODI5MywgMCwgMC42Mzg4OV0sXG4gICAgXCI4MVwiOiBbMC4xMjUsIDAuNjk0NDQsIDAuMDc1NTUsIDAsIDAuNzM2MTFdLFxuICAgIFwiODJcIjogWzAsIDAuNjk0NDQsIDAuMDgyOTMsIDAsIDAuNjQ1ODRdLFxuICAgIFwiODNcIjogWzAsIDAuNjk0NDQsIDAuMDkyMDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODRcIjogWzAsIDAuNjk0NDQsIDAuMTMzNzIsIDAsIDAuNjgwNTZdLFxuICAgIFwiODVcIjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuNjg3NV0sXG4gICAgXCI4NlwiOiBbMCwgMC42OTQ0NCwgMC4xNjE1LCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3XCI6IFswLCAwLjY5NDQ0LCAwLjE2MTUsIDAsIDAuOTQ0NDVdLFxuICAgIFwiODhcIjogWzAsIDAuNjk0NDQsIDAuMTMzNzIsIDAsIDAuNjY2NjddLFxuICAgIFwiODlcIjogWzAsIDAuNjk0NDQsIDAuMTcyNjEsIDAsIDAuNjY2NjddLFxuICAgIFwiOTBcIjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNjExMTFdLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAuMTU5NDIsIDAsIDAuMjg4ODldLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAuMDg3MTksIDAsIDAuMjg4ODldLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAuMDc5OSwgMCwgMC41XSxcbiAgICBcIjk1XCI6IFswLjM1LCAwLjA5NDQ0LCAwLjA4NjE2LCAwLCAwLjVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAuMDA5ODEsIDAsIDAuNDgwNTZdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAuMDMwNTcsIDAsIDAuNTE2NjddLFxuICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAuMDgzMzYsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLjA5NDgzLCAwLCAwLjUxNjY3XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMC4wNjc3OCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMjE3MDUsIDAsIDAuMzA1NTZdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjVdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLjAxNzc4LCAwLCAwLjUxNjY3XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42NzkzNywgMC4wOTcxOCwgMCwgMC4yMzg4OV0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjc5MzcsIDAuMDkxNjIsIDAsIDAuMjY2NjddLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjA4MzM2LCAwLCAwLjQ4ODg5XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMC4wOTQ4MywgMCwgMC4yMzg4OV0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDQ0NDQsIDAuMDE3NzgsIDAsIDAuNzk0NDVdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLjAxNzc4LCAwLCAwLjUxNjY3XSxcbiAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMC4wNjYxMywgMCwgMC41XSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMzg5LCAwLCAwLjUxNjY3XSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNDE2OSwgMCwgMC41MTY2N10sXG4gICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAuMTA4MzYsIDAsIDAuMzQxNjddLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLjA3NzgsIDAsIDAuMzgzMzNdLFxuICAgIFwiMTE2XCI6IFswLCAwLjU3MTQzLCAwLjA3MjI1LCAwLCAwLjM2MTExXSxcbiAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMC4wNDE2OSwgMCwgMC41MTY2N10sXG4gICAgXCIxMThcIjogWzAsIDAuNDQ0NDQsIDAuMTA4MzYsIDAsIDAuNDYxMTFdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjY4MzM0XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMC4wOTE2OSwgMCwgMC40NjExMV0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMTA4MzYsIDAsIDAuNDYxMTFdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLjA4NzUyLCAwLCAwLjQzNDcyXSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMjY1OSwgMC4wODgyNiwgMCwgMC41XSxcbiAgICBcIjE2OFwiOiBbMCwgMC42NzkzNywgMC4wNjM4NSwgMCwgMC41XSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Mzc1Ml0sXG4gICAgXCIxODRcIjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMzA1XCI6IFswLCAwLjQ0NDQ0LCAwLjA0MTY5LCAwLCAwLjIzODg5XSxcbiAgICBcIjU2N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNDE2OSwgMCwgMC4yNjY2N10sXG4gICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAuMDc5OSwgMCwgMC41XSxcbiAgICBcIjcxMVwiOiBbMCwgMC42MzE5NCwgMC4wODQzMiwgMCwgMC41XSxcbiAgICBcIjcxM1wiOiBbMCwgMC42MDg4OSwgMC4wODc3NiwgMCwgMC41XSxcbiAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMC4wOTIwNSwgMCwgMC41XSxcbiAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMC4wOTQ4MywgMCwgMC41XSxcbiAgICBcIjcyOVwiOiBbMCwgMC42NzkzNywgMC4wNzc3NCwgMCwgMC4yNzc3OF0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzM3NTJdLFxuICAgIFwiNzMyXCI6IFswLCAwLjY3NjU5LCAwLjA4ODI2LCAwLCAwLjVdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLjA5MjA1LCAwLCAwLjVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY5NDQ0LCAwLjEzMzcyLCAwLCAwLjU0MTY3XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjk0NDQsIDAuMDc1NTUsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjkyNlwiOiBbMCwgMC42OTQ0NCwgMC4xMjgxNiwgMCwgMC42NjY2N10sXG4gICAgXCI5MjhcIjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuNzA4MzRdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkzM1wiOiBbMCwgMC42OTQ0NCwgMC4wOTAzMSwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjk0NDQsIDAuMDQ2MDMsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY5NDQ0LCAwLjA5MDMxLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42OTQ0NCwgMC4wODI5MywgMCwgMC43MjIyMl0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQ0NDQ0LCAwLjA4NjE2LCAwLCAwLjVdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40NDQ0NCwgMC4wODYxNiwgMCwgMS4wXSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAuMDc4MTYsIDAsIDAuMjc3NzhdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMC4wNzgxNiwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLjE0MjA1LCAwLCAwLjVdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMC4wMDMxNiwgMCwgMC41XVxuICB9LFxuICBcIlNhbnNTZXJpZi1SZWd1bGFyXCI6IHtcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ1XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMzZcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43NTgzNF0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjQzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjQ0XCI6IFswLjEyNSwgMC4wODMzMywgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0NVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4zMzMzM10sXG4gICAgXCI0NlwiOiBbMCwgMC4wODMzMywgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjQ4XCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNDlcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1MFwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUxXCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTJcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1M1wiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU0XCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTVcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU3XCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNThcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNTlcIjogWzAuMTI1LCAwLjQ0NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjYxXCI6IFstMC4xMywgMC4zNywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI2NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyM10sXG4gICAgXCI2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41OTcyMl0sXG4gICAgXCI3MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41Njk0NV0sXG4gICAgXCI3MVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI3MlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDgzNF0sXG4gICAgXCI3M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI3NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI3NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42OTQ0NV0sXG4gICAgXCI3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NDE2N10sXG4gICAgXCI3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44NzVdLFxuICAgIFwiNzhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzA4MzRdLFxuICAgIFwiNzlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzM2MTFdLFxuICAgIFwiODBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODFcIjogWzAuMTI1LCAwLjY5NDQ0LCAwLCAwLCAwLjczNjExXSxcbiAgICBcIjgyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY0NTg0XSxcbiAgICBcIjgzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY4MDU2XSxcbiAgICBcIjg1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY4NzVdLFxuICAgIFwiODZcIjogWzAsIDAuNjk0NDQsIDAuMDEzODksIDAsIDAuNjY2NjddLFxuICAgIFwiODdcIjogWzAsIDAuNjk0NDQsIDAuMDEzODksIDAsIDAuOTQ0NDVdLFxuICAgIFwiODhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODlcIjogWzAsIDAuNjk0NDQsIDAuMDI1LCAwLCAwLjY2NjY3XSxcbiAgICBcIjkwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI4ODg5XSxcbiAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI4ODg5XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiOTVcIjogWzAuMzUsIDAuMDk0NDQsIDAuMDI3NzgsIDAsIDAuNV0sXG4gICAgXCI5N1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40ODA1Nl0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCI5OVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiMTAxXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4wNjk0NCwgMCwgMC4zMDU1Nl0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDEzODksIDAsIDAuNV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiMTA1XCI6IFswLCAwLjY3OTM3LCAwLCAwLCAwLjIzODg5XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NzkzNywgMCwgMCwgMC4yNjY2N10sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDg4ODldLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjIzODg5XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiMTExXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAuMDEzODksIDAsIDAuMzQxNjddLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjM4MzMzXSxcbiAgICBcIjExNlwiOiBbMCwgMC41NzE0MywgMCwgMCwgMC4zNjExMV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAxMzg5LCAwLCAwLjQ2MTExXSxcbiAgICBcIjExOVwiOiBbMCwgMC40NDQ0NCwgMC4wMTM4OSwgMCwgMC42ODMzNF0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDYxMTFdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxMzg5LCAwLCAwLjQ2MTExXSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40MzQ3Ml0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzI2NTksIDAsIDAsIDAuNV0sXG4gICAgXCIxNjhcIjogWzAsIDAuNjc5MzcsIDAsIDAsIDAuNV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4yMzg4OV0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuMjY2NjddLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzExXCI6IFswLCAwLjYzMTk0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjYwODg5LCAwLCAwLCAwLjVdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY3OTM3LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI3MzJcIjogWzAsIDAuNjc2NTksIDAsIDAsIDAuNV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTQxNjddLFxuICAgIFwiOTE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDgzNF0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDAsIDAuNV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQ0NDQ0LCAwLjAyNzc4LCAwLCAxLjBdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdXG4gIH0sXG4gIFwiU2NyaXB0LVJlZ3VsYXJcIjoge1xuICAgIFwiNjVcIjogWzAsIDAuNywgMC4yMjkyNSwgMCwgMC44MDI1M10sXG4gICAgXCI2NlwiOiBbMCwgMC43LCAwLjA0MDg3LCAwLCAwLjkwNzU3XSxcbiAgICBcIjY3XCI6IFswLCAwLjcsIDAuMTY4OSwgMCwgMC42NjYxOV0sXG4gICAgXCI2OFwiOiBbMCwgMC43LCAwLjA5MzcxLCAwLCAwLjc3NDQzXSxcbiAgICBcIjY5XCI6IFswLCAwLjcsIDAuMTg1ODMsIDAsIDAuNTYxNjJdLFxuICAgIFwiNzBcIjogWzAsIDAuNywgMC4xMzYzNCwgMCwgMC44OTU0NF0sXG4gICAgXCI3MVwiOiBbMCwgMC43LCAwLjE3MzIyLCAwLCAwLjYwOTYxXSxcbiAgICBcIjcyXCI6IFswLCAwLjcsIDAuMjk2OTQsIDAsIDAuOTY5MTldLFxuICAgIFwiNzNcIjogWzAsIDAuNywgMC4xOTE4OSwgMCwgMC44MDkwN10sXG4gICAgXCI3NFwiOiBbMC4yNzc3OCwgMC43LCAwLjE5MTg5LCAwLCAxLjA1MTU5XSxcbiAgICBcIjc1XCI6IFswLCAwLjcsIDAuMzEyNTksIDAsIDAuOTEzNjRdLFxuICAgIFwiNzZcIjogWzAsIDAuNywgMC4xOTE4OSwgMCwgMC44NzM3M10sXG4gICAgXCI3N1wiOiBbMCwgMC43LCAwLjE1OTgxLCAwLCAxLjA4MDMxXSxcbiAgICBcIjc4XCI6IFswLCAwLjcsIDAuMzUyNSwgMCwgMC45MDE1XSxcbiAgICBcIjc5XCI6IFswLCAwLjcsIDAuMDgwNzgsIDAsIDAuNzM3ODddLFxuICAgIFwiODBcIjogWzAsIDAuNywgMC4wODA3OCwgMCwgMS4wMTI2Ml0sXG4gICAgXCI4MVwiOiBbMCwgMC43LCAwLjAzMzA1LCAwLCAwLjg4MjgyXSxcbiAgICBcIjgyXCI6IFswLCAwLjcsIDAuMDYyNTksIDAsIDAuODVdLFxuICAgIFwiODNcIjogWzAsIDAuNywgMC4xOTE4OSwgMCwgMC44Njc2N10sXG4gICAgXCI4NFwiOiBbMCwgMC43LCAwLjI5MDg3LCAwLCAwLjc0Njk3XSxcbiAgICBcIjg1XCI6IFswLCAwLjcsIDAuMjU4MTUsIDAsIDAuNzk5OTZdLFxuICAgIFwiODZcIjogWzAsIDAuNywgMC4yNzUyMywgMCwgMC42MjIwNF0sXG4gICAgXCI4N1wiOiBbMCwgMC43LCAwLjI3NTIzLCAwLCAwLjgwNTMyXSxcbiAgICBcIjg4XCI6IFswLCAwLjcsIDAuMjYwMDYsIDAsIDAuOTQ0NDVdLFxuICAgIFwiODlcIjogWzAsIDAuNywgMC4yOTM5LCAwLCAwLjcwOTYxXSxcbiAgICBcIjkwXCI6IFswLCAwLjcsIDAuMjQwMzcsIDAsIDAuODIxMl1cbiAgfSxcbiAgXCJTaXplMS1SZWd1bGFyXCI6IHtcbiAgICBcIjQwXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ1ODM0XSxcbiAgICBcIjQxXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ1ODM0XSxcbiAgICBcIjQ3XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjU3Nzc4XSxcbiAgICBcIjkxXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQxNjY3XSxcbiAgICBcIjkyXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjU3Nzc4XSxcbiAgICBcIjkzXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQxNjY3XSxcbiAgICBcIjEyM1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCIxMjVcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiNzEwXCI6IFswLCAwLjcyMjIyLCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjczMlwiOiBbMCwgMC43MjIyMiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI3NzBcIjogWzAsIDAuNzIyMjIsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiNzcxXCI6IFswLCAwLjcyMjIyLCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjgyMTRcIjogWy0wLjAwMDk5LCAwLjYwMSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NTkzXCI6IFsxZS0wNSwgMC42LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg1OTVcIjogWzFlLTA1LCAwLjYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODY1N1wiOiBbMWUtMDUsIDAuNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NjU5XCI6IFsxZS0wNSwgMC42LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MTlcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuOTQ0NDVdLFxuICAgIFwiODcyMFwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC45NDQ0NV0sXG4gICAgXCI4NzIxXCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAxLjA1NTU2XSxcbiAgICBcIjg3MzBcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NzM5XCI6IFstMC4wMDU5OSwgMC42MDYsIDAsIDAsIDAuMzMzMzNdLFxuICAgIFwiODc0MVwiOiBbLTAuMDA1OTksIDAuNjA2LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3NDdcIjogWzAuMzA2MTIsIDAuODA1LCAwLjE5NDQ1LCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg3NDhcIjogWzAuMzA2LCAwLjgwNSwgMC4xOTQ0NSwgMCwgMC40NzIyMl0sXG4gICAgXCI4NzQ5XCI6IFswLjMwNiwgMC44MDUsIDAuMTk0NDUsIDAsIDAuNDcyMjJdLFxuICAgIFwiODc1MFwiOiBbMC4zMDYxMiwgMC44MDUsIDAuMTk0NDUsIDAsIDAuNDcyMjJdLFxuICAgIFwiODg5NlwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4ODk3XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg4OThcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODg5OVwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4OTY4XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg5NjlcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiODk3MFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI4OTcxXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjkxNjhcIjogWy0wLjAwMDk5LCAwLjYwMSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCIxMDIxNlwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCIxMDIxN1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCIxMDc1MlwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCIxMDc1M1wiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCIxMDc1NFwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCIxMDc1NlwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIxMDc1OFwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF1cbiAgfSxcbiAgXCJTaXplMi1SZWd1bGFyXCI6IHtcbiAgICBcIjQwXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjU5NzIyXSxcbiAgICBcIjQxXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjU5NzIyXSxcbiAgICBcIjQ3XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjgxMTExXSxcbiAgICBcIjkxXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjkyXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjgxMTExXSxcbiAgICBcIjkzXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjEyM1wiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCIxMjVcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNzEwXCI6IFswLCAwLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiNzMyXCI6IFswLCAwLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiNzcwXCI6IFswLCAwLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiNzcxXCI6IFswLCAwLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODcxOVwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4yNzc3OF0sXG4gICAgXCI4NzIwXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjI3Nzc4XSxcbiAgICBcIjg3MjFcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuNDQ0NDVdLFxuICAgIFwiODczMFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMS4wXSxcbiAgICBcIjg3NDdcIjogWzAuODYyMjUsIDEuMzYsIDAuNDQ0NDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODc0OFwiOiBbMC44NjIsIDEuMzYsIDAuNDQ0NDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODc0OVwiOiBbMC44NjIsIDEuMzYsIDAuNDQ0NDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODc1MFwiOiBbMC44NjIyNSwgMS4zNiwgMC40NDQ0NSwgMCwgMC41NTU1Nl0sXG4gICAgXCI4ODk2XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg4OTdcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODg5OFwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4ODk5XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg5NjhcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiODk2OVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCI4OTcwXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjg5NzFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiMTAyMTZcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiMTAyMTdcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiMTA3NTJcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuNTExMTJdLFxuICAgIFwiMTA3NTNcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuNTExMTJdLFxuICAgIFwiMTA3NTRcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuNTExMTJdLFxuICAgIFwiMTA3NTZcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiMTA3NThcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdXG4gIH0sXG4gIFwiU2l6ZTMtUmVndWxhclwiOiB7XG4gICAgXCI0MFwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43MzYxMV0sXG4gICAgXCI0MVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43MzYxMV0sXG4gICAgXCI0N1wiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMS4wNDQ0NV0sXG4gICAgXCI5MVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCI5MlwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMS4wNDQ0NV0sXG4gICAgXCI5M1wiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMjNcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzVdLFxuICAgIFwiMTI1XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjc1XSxcbiAgICBcIjcxMFwiOiBbMCwgMC43NSwgMCwgMCwgMS40NDQ0NV0sXG4gICAgXCI3MzJcIjogWzAsIDAuNzUsIDAsIDAsIDEuNDQ0NDVdLFxuICAgIFwiNzcwXCI6IFswLCAwLjc1LCAwLCAwLCAxLjQ0NDQ1XSxcbiAgICBcIjc3MVwiOiBbMCwgMC43NSwgMCwgMCwgMS40NDQ0NV0sXG4gICAgXCI4NzMwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAxLjBdLFxuICAgIFwiODk2OFwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI4OTY5XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjg5NzBcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiODk3MVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCIxMDIxNlwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43NV0sXG4gICAgXCIxMDIxN1wiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43NV1cbiAgfSxcbiAgXCJTaXplNC1SZWd1bGFyXCI6IHtcbiAgICBcIjQwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjc5MTY3XSxcbiAgICBcIjQxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjc5MTY3XSxcbiAgICBcIjQ3XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAxLjI3Nzc4XSxcbiAgICBcIjkxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjkyXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAxLjI3Nzc4XSxcbiAgICBcIjkzXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjEyM1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC44MDU1Nl0sXG4gICAgXCIxMjVcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuODA1NTZdLFxuICAgIFwiNzEwXCI6IFswLCAwLjgyNSwgMCwgMCwgMS44ODg5XSxcbiAgICBcIjczMlwiOiBbMCwgMC44MjUsIDAsIDAsIDEuODg4OV0sXG4gICAgXCI3NzBcIjogWzAsIDAuODI1LCAwLCAwLCAxLjg4ODldLFxuICAgIFwiNzcxXCI6IFswLCAwLjgyNSwgMCwgMCwgMS44ODg5XSxcbiAgICBcIjg3MzBcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDEuMF0sXG4gICAgXCI4OTY4XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg5NjlcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODk3MFwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4OTcxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjkxMTVcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI5MTE2XCI6IFsxZS0wNSwgMC42LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI5MTE3XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC44NzVdLFxuICAgIFwiOTExOFwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuODc1XSxcbiAgICBcIjkxMTlcIjogWzFlLTA1LCAwLjYsIDAsIDAsIDAuODc1XSxcbiAgICBcIjkxMjBcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI5MTIxXCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MTIyXCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTEyM1wiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTEyNFwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTEyNVwiOiBbLTAuMDAwOTksIDAuNjAxLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkxMjZcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkxMjdcIjogWzFlLTA1LCAwLjksIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTEyOFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTI5XCI6IFswLjkwMDAxLCAwLCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxMzBcIjogWzAsIDAuMywgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTMxXCI6IFsxZS0wNSwgMC45LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxMzJcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTEzM1wiOiBbMC45MDAwMSwgMCwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTQzXCI6IFswLjg4NTAyLCAwLjkxNSwgMCwgMCwgMS4wNTU1Nl0sXG4gICAgXCIxMDIxNlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC44MDU1Nl0sXG4gICAgXCIxMDIxN1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC44MDU1Nl0sXG4gICAgXCI1NzM0NFwiOiBbLTAuMDA0OTksIDAuNjA1LCAwLCAwLCAxLjA1NTU2XSxcbiAgICBcIjU3MzQ1XCI6IFstMC4wMDQ5OSwgMC42MDUsIDAsIDAsIDEuMDU1NTZdLFxuICAgIFwiNTc2ODBcIjogWzAsIDAuMTIsIDAsIDAsIDAuNDVdLFxuICAgIFwiNTc2ODFcIjogWzAsIDAuMTIsIDAsIDAsIDAuNDVdLFxuICAgIFwiNTc2ODJcIjogWzAsIDAuMTIsIDAsIDAsIDAuNDVdLFxuICAgIFwiNTc2ODNcIjogWzAsIDAuMTIsIDAsIDAsIDAuNDVdXG4gIH0sXG4gIFwiVHlwZXdyaXRlci1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjM1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzNlwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzdcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjM4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzOVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDBcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQxXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0MlwiOiBbMCwgMC41MjA4MywgMCwgMCwgMC41MjVdLFxuICAgIFwiNDNcIjogWy0wLjA4MDU2LCAwLjUzMDU1LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0NFwiOiBbMC4xMzg4OSwgMC4xMjUsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQ1XCI6IFstMC4wODA1NiwgMC41MzA1NSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDZcIjogWzAsIDAuMTI1LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0N1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQ5XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1MFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjUyXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1M1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU4XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1OVwiOiBbMC4xMzg4OSwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjBcIjogWy0wLjA1NTU2LCAwLjU1NTU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2MVwiOiBbLTAuMTk1NDksIDAuNDE1NjIsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjYyXCI6IFstMC4wNTU1NiwgMC41NTU1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjY0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2NVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjY3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2OFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjlcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzJcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjczXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3NFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3N1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc5XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4MFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODFcIjogWzAuMTM4ODksIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgyXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4M1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjg1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjg4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4OVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkxXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MlwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTNcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5NVwiOiBbMC4wOTUxNCwgMCwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5OFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTAxXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwM1wiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTA0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwNlwiOiBbMC4yMjIyMiwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTA3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExMlwiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTEzXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTE2XCI6IFswLCAwLjU1MzU4LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyMVwiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjNcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyNFwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTI1XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyN1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjE4NFwiOiBbMC4xOTQ0NSwgMCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzA1XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1NjdcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcxMVwiOiBbMCwgMC41NjU5NywgMCwgMCwgMC41MjVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjU2NTU1LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcxNVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzI4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc3MFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzcxXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3NzZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTE2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTI2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTMzXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkzNlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTM3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4MjQyXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MjUxXCI6IFswLjExMTExLCAwLjIxOTQ0LCAwLCAwLCAwLjUyNV1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mb250TWV0cmljcy5qc1xuXG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIG1ldHJpY3MgcmVnYXJkaW5nIGZvbnRzIGFuZCBpbmRpdmlkdWFsIHN5bWJvbHMuIFRoZSBzaWdtYVxuICogYW5kIHhpIHZhcmlhYmxlcywgYXMgd2VsbCBhcyB0aGUgbWV0cmljTWFwIG1hcCBjb250YWluIGRhdGEgZXh0cmFjdGVkIGZyb21cbiAqIFRlWCwgVGVYIGZvbnQgbWV0cmljcywgYW5kIHRoZSBUVEYgZmlsZXMuIFRoZXNlIGRhdGEgYXJlIHRoZW4gZXhwb3NlZCB2aWEgdGhlXG4gKiBgbWV0cmljc2AgdmFyaWFibGUgYW5kIHRoZSBnZXRDaGFyYWN0ZXJNZXRyaWNzIGZ1bmN0aW9uLlxuICovXG4vLyBJbiBUZVgsIHRoZXJlIGFyZSBhY3R1YWxseSB0aHJlZSBzZXRzIG9mIGRpbWVuc2lvbnMsIG9uZSBmb3IgZWFjaCBvZlxuLy8gdGV4dHN0eWxlIChzaXplIGluZGV4IDUgYW5kIGhpZ2hlcjogPj05cHQpLCBzY3JpcHRzdHlsZSAoc2l6ZSBpbmRleCAzIGFuZCA0OlxuLy8gNy04cHQpLCBhbmQgc2NyaXB0c2NyaXB0c3R5bGUgKHNpemUgaW5kZXggMSBhbmQgMjogNS02cHQpLiAgVGhlc2UgYXJlXG4vLyBwcm92aWRlZCBpbiB0aGUgdGhlIGFycmF5cyBiZWxvdywgaW4gdGhhdCBvcmRlci5cbi8vXG4vLyBUaGUgZm9udCBtZXRyaWNzIGFyZSBzdG9yZWQgaW4gZm9udHMgY21zeTEwLCBjbXN5NywgYW5kIGNtc3k1IHJlc3BzZWN0aXZlbHkuXG4vLyBUaGlzIHdhcyBkZXRlcm1pbmVkIGJ5IHJ1bm5pbmcgdGhlIGZvbGxvd2luZyBzY3JpcHQ6XG4vL1xuLy8gICAgIGxhdGV4IC1pbnRlcmFjdGlvbj1ub25zdG9wbW9kZSBcXFxuLy8gICAgICdcXGRvY3VtZW50Y2xhc3N7YXJ0aWNsZX1cXHVzZXBhY2thZ2V7YW1zbWF0aH1cXGJlZ2lue2RvY3VtZW50fScgXFxcbi8vICAgICAnJGEkIFxcZXhwYW5kYWZ0ZXJcXHNob3dcXHRoZVxcdGV4dGZvbnQyJyBcXFxuLy8gICAgICdcXGV4cGFuZGFmdGVyXFxzaG93XFx0aGVcXHNjcmlwdGZvbnQyJyBcXFxuLy8gICAgICdcXGV4cGFuZGFmdGVyXFxzaG93XFx0aGVcXHNjcmlwdHNjcmlwdGZvbnQyJyBcXFxuLy8gICAgICdcXHN0b3AnXG4vL1xuLy8gVGhlIG1ldHJpY3MgdGhlbXNlbHZlcyB3ZXJlIHJldHJlaXZlZCB1c2luZyB0aGUgZm9sbG93aW5nIGNvbW1hbmRzOlxuLy9cbi8vICAgICB0ZnRvcGwgY21zeTEwXG4vLyAgICAgdGZ0b3BsIGNtc3k3XG4vLyAgICAgdGZ0b3BsIGNtc3k1XG4vL1xuLy8gVGhlIG91dHB1dCBvZiBlYWNoIG9mIHRoZXNlIGNvbW1hbmRzIGlzIHF1aXRlIGxlbmd0aHkuICBUaGUgb25seSBwYXJ0IHdlXG4vLyBjYXJlIGFib3V0IGlzIHRoZSBGT05URElNRU4gc2VjdGlvbi4gRWFjaCB2YWx1ZSBpcyBtZWFzdXJlZCBpbiBFTXMuXG52YXIgc2lnbWFzQW5kWGlzID0ge1xuICBzbGFudDogWzAuMjUwLCAwLjI1MCwgMC4yNTBdLFxuICAvLyBzaWdtYTFcbiAgc3BhY2U6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSxcbiAgLy8gc2lnbWEyXG4gIHN0cmV0Y2g6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSxcbiAgLy8gc2lnbWEzXG4gIHNocmluazogWzAuMDAwLCAwLjAwMCwgMC4wMDBdLFxuICAvLyBzaWdtYTRcbiAgeEhlaWdodDogWzAuNDMxLCAwLjQzMSwgMC40MzFdLFxuICAvLyBzaWdtYTVcbiAgcXVhZDogWzEuMDAwLCAxLjE3MSwgMS40NzJdLFxuICAvLyBzaWdtYTZcbiAgZXh0cmFTcGFjZTogWzAuMDAwLCAwLjAwMCwgMC4wMDBdLFxuICAvLyBzaWdtYTdcbiAgbnVtMTogWzAuNjc3LCAwLjczMiwgMC45MjVdLFxuICAvLyBzaWdtYThcbiAgbnVtMjogWzAuMzk0LCAwLjM4NCwgMC4zODddLFxuICAvLyBzaWdtYTlcbiAgbnVtMzogWzAuNDQ0LCAwLjQ3MSwgMC41MDRdLFxuICAvLyBzaWdtYTEwXG4gIGRlbm9tMTogWzAuNjg2LCAwLjc1MiwgMS4wMjVdLFxuICAvLyBzaWdtYTExXG4gIGRlbm9tMjogWzAuMzQ1LCAwLjM0NCwgMC41MzJdLFxuICAvLyBzaWdtYTEyXG4gIHN1cDE6IFswLjQxMywgMC41MDMsIDAuNTA0XSxcbiAgLy8gc2lnbWExM1xuICBzdXAyOiBbMC4zNjMsIDAuNDMxLCAwLjQwNF0sXG4gIC8vIHNpZ21hMTRcbiAgc3VwMzogWzAuMjg5LCAwLjI4NiwgMC4yOTRdLFxuICAvLyBzaWdtYTE1XG4gIHN1YjE6IFswLjE1MCwgMC4xNDMsIDAuMjAwXSxcbiAgLy8gc2lnbWExNlxuICBzdWIyOiBbMC4yNDcsIDAuMjg2LCAwLjQwMF0sXG4gIC8vIHNpZ21hMTdcbiAgc3VwRHJvcDogWzAuMzg2LCAwLjM1MywgMC40OTRdLFxuICAvLyBzaWdtYTE4XG4gIHN1YkRyb3A6IFswLjA1MCwgMC4wNzEsIDAuMTAwXSxcbiAgLy8gc2lnbWExOVxuICBkZWxpbTE6IFsyLjM5MCwgMS43MDAsIDEuOTgwXSxcbiAgLy8gc2lnbWEyMFxuICBkZWxpbTI6IFsxLjAxMCwgMS4xNTcsIDEuNDIwXSxcbiAgLy8gc2lnbWEyMVxuICBheGlzSGVpZ2h0OiBbMC4yNTAsIDAuMjUwLCAwLjI1MF0sXG4gIC8vIHNpZ21hMjJcbiAgLy8gVGhlc2UgZm9udCBtZXRyaWNzIGFyZSBleHRyYWN0ZWQgZnJvbSBUZVggYnkgdXNpbmcgdGZ0b3BsIG9uIGNtZXgxMC50Zm07XG4gIC8vIHRoZXkgY29ycmVzcG9uZCB0byB0aGUgZm9udCBwYXJhbWV0ZXJzIG9mIHRoZSBleHRlbnNpb24gZm9udHMgKGZhbWlseSAzKS5cbiAgLy8gU2VlIHRoZSBUZVhib29rLCBwYWdlIDQ0MS4gSW4gQU1TVGVYLCB0aGUgZXh0ZW5zaW9uIGZvbnRzIHNjYWxlOyB0b1xuICAvLyBtYXRjaCBjbWV4Nywgd2UnZCB1c2UgY21leDcudGZtIHZhbHVlcyBmb3Igc2NyaXB0IGFuZCBzY3JpcHRzY3JpcHRcbiAgLy8gdmFsdWVzLlxuICBkZWZhdWx0UnVsZVRoaWNrbmVzczogWzAuMDQsIDAuMDQ5LCAwLjA0OV0sXG4gIC8vIHhpODsgY21leDc6IDAuMDQ5XG4gIGJpZ09wU3BhY2luZzE6IFswLjExMSwgMC4xMTEsIDAuMTExXSxcbiAgLy8geGk5XG4gIGJpZ09wU3BhY2luZzI6IFswLjE2NiwgMC4xNjYsIDAuMTY2XSxcbiAgLy8geGkxMFxuICBiaWdPcFNwYWNpbmczOiBbMC4yLCAwLjIsIDAuMl0sXG4gIC8vIHhpMTFcbiAgYmlnT3BTcGFjaW5nNDogWzAuNiwgMC42MTEsIDAuNjExXSxcbiAgLy8geGkxMjsgY21leDc6IDAuNjExXG4gIGJpZ09wU3BhY2luZzU6IFswLjEsIDAuMTQzLCAwLjE0M10sXG4gIC8vIHhpMTM7IGNtZXg3OiAwLjE0M1xuICAvLyBUaGUgXFxzcXJ0IHJ1bGUgd2lkdGggaXMgdGFrZW4gZnJvbSB0aGUgaGVpZ2h0IG9mIHRoZSBzdXJkIGNoYXJhY3Rlci5cbiAgLy8gU2luY2Ugd2UgdXNlIHRoZSBzYW1lIGZvbnQgYXQgYWxsIHNpemVzLCB0aGlzIHRoaWNrbmVzcyBkb2Vzbid0IHNjYWxlLlxuICBzcXJ0UnVsZVRoaWNrbmVzczogWzAuMDQsIDAuMDQsIDAuMDRdLFxuICAvLyBUaGlzIHZhbHVlIGRldGVybWluZXMgaG93IGxhcmdlIGEgcHQgaXMsIGZvciBtZXRyaWNzIHdoaWNoIGFyZSBkZWZpbmVkXG4gIC8vIGluIHRlcm1zIG9mIHB0cy5cbiAgLy8gVGhpcyB2YWx1ZSBpcyBhbHNvIHVzZWQgaW4ga2F0ZXgubGVzczsgaWYgeW91IGNoYW5nZSBpdCBtYWtlIHN1cmUgdGhlXG4gIC8vIHZhbHVlcyBtYXRjaC5cbiAgcHRQZXJFbTogWzEwLjAsIDEwLjAsIDEwLjBdLFxuICAvLyBUaGUgc3BhY2UgYmV0d2VlbiBhZGphY2VudCBgfGAgY29sdW1ucyBpbiBhbiBhcnJheSBkZWZpbml0aW9uLiBGcm9tXG4gIC8vIGBcXHNob3d0aGVcXGRvdWJsZXJ1bGVzZXBgIGluIExhVGVYLiBFcXVhbHMgMi4wIC8gcHRQZXJFbS5cbiAgZG91YmxlUnVsZVNlcDogWzAuMiwgMC4yLCAwLjJdXG59OyAvLyBUaGlzIG1hcCBjb250YWlucyBhIG1hcHBpbmcgZnJvbSBmb250IG5hbWUgYW5kIGNoYXJhY3RlciBjb2RlIHRvIGNoYXJhY3RlclxuLy8gbWV0cmljcywgaW5jbHVkaW5nIGhlaWdodCwgZGVwdGgsIGl0YWxpYyBjb3JyZWN0aW9uLCBhbmQgc2tldyAoa2VybiBmcm9tIHRoZVxuLy8gY2hhcmFjdGVyIHRvIHRoZSBjb3JyZXNwb25kaW5nIFxcc2tld2NoYXIpXG4vLyBUaGlzIG1hcCBpcyBnZW5lcmF0ZWQgdmlhIGBtYWtlIG1ldHJpY3NgLiBJdCBzaG91bGQgbm90IGJlIGNoYW5nZWQgbWFudWFsbHkuXG5cbiAvLyBUaGVzZSBhcmUgdmVyeSByb3VnaCBhcHByb3hpbWF0aW9ucy4gIFdlIGRlZmF1bHQgdG8gVGltZXMgTmV3IFJvbWFuIHdoaWNoXG4vLyBzaG91bGQgaGF2ZSBMYXRpbi0xIGFuZCBDeXJpbGxpYyBjaGFyYWN0ZXJzLCBidXQgbWF5IG5vdCBkZXBlbmRpbmcgb24gdGhlXG4vLyBvcGVyYXRpbmcgc3lzdGVtLiAgVGhlIG1ldHJpY3MgZG8gbm90IGFjY291bnQgZm9yIGV4dHJhIGhlaWdodCBmcm9tIHRoZVxuLy8gYWNjZW50cy4gIEluIHRoZSBjYXNlIG9mIEN5cmlsbGljIGNoYXJhY3RlcnMgd2hpY2ggaGF2ZSBib3RoIGFzY2VuZGVycyBhbmRcbi8vIGRlc2NlbmRlcnMgd2UgcHJlZmVyIGFwcHJveGltYXRpb25zIHdpdGggYXNjZW5kZXJzLCBwcmltYXJpbHkgdG8gcHJldmVudFxuLy8gdGhlIGZyYWN0aW9uIGJhciBvciByb290IGxpbmUgZnJvbSBpbnRlcnNlY3RpbmcgdGhlIGdseXBoLlxuLy8gVE9ETyhrZXZpbmIpIGFsbG93IHVuaW9uIG9mIG11bHRpcGxlIGdseXBoIG1ldHJpY3MgZm9yIGJldHRlciBhY2N1cmFjeS5cblxudmFyIGV4dHJhQ2hhcmFjdGVyTWFwID0ge1xuICAvLyBMYXRpbi0xXG4gICfDhSc6ICdBJyxcbiAgJ8OHJzogJ0MnLFxuICAnw5AnOiAnRCcsXG4gICfDnic6ICdvJyxcbiAgJ8OlJzogJ2EnLFxuICAnw6cnOiAnYycsXG4gICfDsCc6ICdkJyxcbiAgJ8O+JzogJ28nLFxuICAvLyBDeXJpbGxpY1xuICAn0JAnOiAnQScsXG4gICfQkSc6ICdCJyxcbiAgJ9CSJzogJ0InLFxuICAn0JMnOiAnRicsXG4gICfQlCc6ICdBJyxcbiAgJ9CVJzogJ0UnLFxuICAn0JYnOiAnSycsXG4gICfQlyc6ICczJyxcbiAgJ9CYJzogJ04nLFxuICAn0JknOiAnTicsXG4gICfQmic6ICdLJyxcbiAgJ9CbJzogJ04nLFxuICAn0JwnOiAnTScsXG4gICfQnSc6ICdIJyxcbiAgJ9CeJzogJ08nLFxuICAn0J8nOiAnTicsXG4gICfQoCc6ICdQJyxcbiAgJ9ChJzogJ0MnLFxuICAn0KInOiAnVCcsXG4gICfQoyc6ICd5JyxcbiAgJ9CkJzogJ08nLFxuICAn0KUnOiAnWCcsXG4gICfQpic6ICdVJyxcbiAgJ9CnJzogJ2gnLFxuICAn0KgnOiAnVycsXG4gICfQqSc6ICdXJyxcbiAgJ9CqJzogJ0InLFxuICAn0KsnOiAnWCcsXG4gICfQrCc6ICdCJyxcbiAgJ9CtJzogJzMnLFxuICAn0K4nOiAnWCcsXG4gICfQryc6ICdSJyxcbiAgJ9CwJzogJ2EnLFxuICAn0LEnOiAnYicsXG4gICfQsic6ICdhJyxcbiAgJ9CzJzogJ3InLFxuICAn0LQnOiAneScsXG4gICfQtSc6ICdlJyxcbiAgJ9C2JzogJ20nLFxuICAn0LcnOiAnZScsXG4gICfQuCc6ICduJyxcbiAgJ9C5JzogJ24nLFxuICAn0LonOiAnbicsXG4gICfQuyc6ICduJyxcbiAgJ9C8JzogJ20nLFxuICAn0L0nOiAnbicsXG4gICfQvic6ICdvJyxcbiAgJ9C/JzogJ24nLFxuICAn0YAnOiAncCcsXG4gICfRgSc6ICdjJyxcbiAgJ9GCJzogJ28nLFxuICAn0YMnOiAneScsXG4gICfRhCc6ICdiJyxcbiAgJ9GFJzogJ3gnLFxuICAn0YYnOiAnbicsXG4gICfRhyc6ICduJyxcbiAgJ9GIJzogJ3cnLFxuICAn0YknOiAndycsXG4gICfRiic6ICdhJyxcbiAgJ9GLJzogJ20nLFxuICAn0YwnOiAnYScsXG4gICfRjSc6ICdlJyxcbiAgJ9GOJzogJ20nLFxuICAn0Y8nOiAncidcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhZGRzIG5ldyBmb250IG1ldHJpY3MgdG8gZGVmYXVsdCBtZXRyaWNNYXBcbiAqIEl0IGNhbiBhbHNvIG92ZXJyaWRlIGV4aXN0aW5nIG1ldHJpY3NcbiAqL1xuZnVuY3Rpb24gc2V0Rm9udE1ldHJpY3MoZm9udE5hbWUsIG1ldHJpY3MpIHtcbiAgZm9udE1ldHJpY3NEYXRhW2ZvbnROYW1lXSA9IG1ldHJpY3M7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgbG9va2luZyB1cCBpbmZvcm1hdGlvbiBpbiB0aGVcbiAqIG1ldHJpY01hcCB0YWJsZS4gSXQgdGFrZXMgYSBjaGFyYWN0ZXIgYXMgYSBzdHJpbmcsIGFuZCBhIGZvbnQuXG4gKlxuICogTm90ZTogdGhlIGB3aWR0aGAgcHJvcGVydHkgbWF5IGJlIHVuZGVmaW5lZCBpZiBmb250TWV0cmljc0RhdGEuanMgd2Fzbid0XG4gKiBidWlsdCB1c2luZyBgTWFrZSBleHRlbmRlZF9tZXRyaWNzYC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRDaGFyYWN0ZXJNZXRyaWNzKGNoYXJhY3RlciwgZm9udCwgbW9kZSkge1xuICBpZiAoIWZvbnRNZXRyaWNzRGF0YVtmb250XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZvbnQgbWV0cmljcyBub3QgZm91bmQgZm9yIGZvbnQ6IFwiICsgZm9udCArIFwiLlwiKTtcbiAgfVxuXG4gIHZhciBjaCA9IGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuICB2YXIgbWV0cmljcyA9IGZvbnRNZXRyaWNzRGF0YVtmb250XVtjaF07XG5cbiAgaWYgKCFtZXRyaWNzICYmIGNoYXJhY3RlclswXSBpbiBleHRyYUNoYXJhY3Rlck1hcCkge1xuICAgIGNoID0gZXh0cmFDaGFyYWN0ZXJNYXBbY2hhcmFjdGVyWzBdXS5jaGFyQ29kZUF0KDApO1xuICAgIG1ldHJpY3MgPSBmb250TWV0cmljc0RhdGFbZm9udF1bY2hdO1xuICB9XG5cbiAgaWYgKCFtZXRyaWNzICYmIG1vZGUgPT09ICd0ZXh0Jykge1xuICAgIC8vIFdlIGRvbid0IHR5cGljYWxseSBoYXZlIGZvbnQgbWV0cmljcyBmb3IgQXNpYW4gc2NyaXB0cy5cbiAgICAvLyBCdXQgc2luY2Ugd2Ugc3VwcG9ydCB0aGVtIGluIHRleHQgbW9kZSwgd2UgbmVlZCB0byByZXR1cm5cbiAgICAvLyBzb21lIHNvcnQgb2YgbWV0cmljcy5cbiAgICAvLyBTbyBpZiB0aGUgY2hhcmFjdGVyIGlzIGluIGEgc2NyaXB0IHdlIHN1cHBvcnQgYnV0IHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBtZXRyaWNzIGZvciBpdCwganVzdCB1c2UgdGhlIG1ldHJpY3MgZm9yXG4gICAgLy8gdGhlIExhdGluIGNhcGl0YWwgbGV0dGVyIE0uIFRoaXMgaXMgY2xvc2UgZW5vdWdoIGJlY2F1c2VcbiAgICAvLyB3ZSAoY3VycmVudGx5KSBvbmx5IGNhcmUgYWJvdXQgdGhlIGhlaWdodCBvZiB0aGUgZ2xweWhcbiAgICAvLyBub3QgaXRzIHdpZHRoLlxuICAgIGlmIChzdXBwb3J0ZWRDb2RlcG9pbnQoY2gpKSB7XG4gICAgICBtZXRyaWNzID0gZm9udE1ldHJpY3NEYXRhW2ZvbnRdWzc3XTsgLy8gNzcgaXMgdGhlIGNoYXJjb2RlIGZvciAnTSdcbiAgICB9XG4gIH1cblxuICBpZiAobWV0cmljcykge1xuICAgIHJldHVybiB7XG4gICAgICBkZXB0aDogbWV0cmljc1swXSxcbiAgICAgIGhlaWdodDogbWV0cmljc1sxXSxcbiAgICAgIGl0YWxpYzogbWV0cmljc1syXSxcbiAgICAgIHNrZXc6IG1ldHJpY3NbM10sXG4gICAgICB3aWR0aDogbWV0cmljc1s0XVxuICAgIH07XG4gIH1cbn1cbnZhciBmb250TWV0cmljc0J5U2l6ZUluZGV4ID0ge307XG4vKipcbiAqIEdldCB0aGUgZm9udCBtZXRyaWNzIGZvciBhIGdpdmVuIHNpemUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0R2xvYmFsTWV0cmljcyhzaXplKSB7XG4gIHZhciBzaXplSW5kZXg7XG5cbiAgaWYgKHNpemUgPj0gNSkge1xuICAgIHNpemVJbmRleCA9IDA7XG4gIH0gZWxzZSBpZiAoc2l6ZSA+PSAzKSB7XG4gICAgc2l6ZUluZGV4ID0gMTtcbiAgfSBlbHNlIHtcbiAgICBzaXplSW5kZXggPSAyO1xuICB9XG5cbiAgaWYgKCFmb250TWV0cmljc0J5U2l6ZUluZGV4W3NpemVJbmRleF0pIHtcbiAgICB2YXIgbWV0cmljcyA9IGZvbnRNZXRyaWNzQnlTaXplSW5kZXhbc2l6ZUluZGV4XSA9IHtcbiAgICAgIGNzc0VtUGVyTXU6IHNpZ21hc0FuZFhpcy5xdWFkW3NpemVJbmRleF0gLyAxOFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc2lnbWFzQW5kWGlzKSB7XG4gICAgICBpZiAoc2lnbWFzQW5kWGlzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgbWV0cmljc1trZXldID0gc2lnbWFzQW5kWGlzW2tleV1bc2l6ZUluZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9udE1ldHJpY3NCeVNpemVJbmRleFtzaXplSW5kZXhdO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3ltYm9scy5qc1xuLyoqXG4gKiBUaGlzIGZpbGUgaG9sZHMgYSBsaXN0IG9mIGFsbCBuby1hcmd1bWVudCBmdW5jdGlvbnMgYW5kIHNpbmdsZS1jaGFyYWN0ZXJcbiAqIHN5bWJvbHMgKGxpa2UgJ2EnIG9yICc7JykuXG4gKlxuICogRm9yIGVhY2ggb2YgdGhlIHN5bWJvbHMsIHRoZXJlIGFyZSB0aHJlZSBwcm9wZXJ0aWVzIHRoZXkgY2FuIGhhdmU6XG4gKiAtIGZvbnQgKHJlcXVpcmVkKTogdGhlIGZvbnQgdG8gYmUgdXNlZCBmb3IgdGhpcyBzeW1ib2wuIEVpdGhlciBcIm1haW5cIiAodGhlXG4gICAgIG5vcm1hbCBmb250KSwgb3IgXCJhbXNcIiAodGhlIGFtcyBmb250cykuXG4gKiAtIGdyb3VwIChyZXF1aXJlZCk6IHRoZSBQYXJzZU5vZGUgZ3JvdXAgdHlwZSB0aGUgc3ltYm9sIHNob3VsZCBoYXZlIChpLmUuXG4gICAgIFwidGV4dG9yZFwiLCBcIm1hdGhvcmRcIiwgZXRjKS5cbiAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9LYVRlWC9LYVRlWC93aWtpL0V4YW1pbmluZy1UZVgjZ3JvdXAtdHlwZXNcbiAqIC0gcmVwbGFjZTogdGhlIGNoYXJhY3RlciB0aGF0IHRoaXMgc3ltYm9sIG9yIGZ1bmN0aW9uIHNob3VsZCBiZVxuICogICByZXBsYWNlZCB3aXRoIChpLmUuIFwiXFxwaGlcIiBoYXMgYSByZXBsYWNlIHZhbHVlIG9mIFwiXFx1MDNkNVwiLCB0aGUgcGhpXG4gKiAgIGNoYXJhY3RlciBpbiB0aGUgbWFpbiBmb250KS5cbiAqXG4gKiBUaGUgb3V0ZXJtb3N0IG1hcCBpbiB0aGUgdGFibGUgaW5kaWNhdGVzIHdoYXQgbW9kZSB0aGUgc3ltYm9scyBzaG91bGQgYmVcbiAqIGFjY2VwdGVkIGluIChlLmcuIFwibWF0aFwiIG9yIFwidGV4dFwiKS5cbiAqL1xuLy8gU29tZSBvZiB0aGVzZSBoYXZlIGEgXCItdG9rZW5cIiBzdWZmaXggc2luY2UgdGhlc2UgYXJlIGFsc28gdXNlZCBhcyBgUGFyc2VOb2RlYFxuLy8gdHlwZXMgZm9yIHJhdyB0ZXh0IHRva2VucywgYW5kIHdlIHdhbnQgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggaGlnaGVyLWxldmVsXG4vLyBgUGFyc2VOb2RlYCB0eXBlcy4gVGhlc2UgYFBhcnNlTm9kZWBzIGFyZSBjb25zdHJ1Y3RlZCB3aXRoaW4gYFBhcnNlcmAgYnlcbi8vIGxvb2tpbmcgdXAgdGhlIGBzeW1ib2xzYCBtYXAuXG52YXIgQVRPTVMgPSB7XG4gIFwiYmluXCI6IDEsXG4gIFwiY2xvc2VcIjogMSxcbiAgXCJpbm5lclwiOiAxLFxuICBcIm9wZW5cIjogMSxcbiAgXCJwdW5jdFwiOiAxLFxuICBcInJlbFwiOiAxXG59O1xudmFyIE5PTl9BVE9NUyA9IHtcbiAgXCJhY2NlbnQtdG9rZW5cIjogMSxcbiAgXCJtYXRob3JkXCI6IDEsXG4gIFwib3AtdG9rZW5cIjogMSxcbiAgXCJzcGFjaW5nXCI6IDEsXG4gIFwidGV4dG9yZFwiOiAxXG59O1xudmFyIHN5bWJvbHMgPSB7XG4gIFwibWF0aFwiOiB7fSxcbiAgXCJ0ZXh0XCI6IHt9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX3N5bWJvbHMgPSAoc3ltYm9scyk7XG4vKiogYGFjY2VwdFVuaWNvZGVDaGFyID0gdHJ1ZWAgaXMgb25seSBhcHBsaWNhYmxlIGlmIGByZXBsYWNlYCBpcyBzZXQuICovXG5cbmZ1bmN0aW9uIGRlZmluZVN5bWJvbChtb2RlLCBmb250LCBncm91cCwgcmVwbGFjZSwgbmFtZSwgYWNjZXB0VW5pY29kZUNoYXIpIHtcbiAgc3ltYm9sc1ttb2RlXVtuYW1lXSA9IHtcbiAgICBmb250OiBmb250LFxuICAgIGdyb3VwOiBncm91cCxcbiAgICByZXBsYWNlOiByZXBsYWNlXG4gIH07XG5cbiAgaWYgKGFjY2VwdFVuaWNvZGVDaGFyICYmIHJlcGxhY2UpIHtcbiAgICBzeW1ib2xzW21vZGVdW3JlcGxhY2VdID0gc3ltYm9sc1ttb2RlXVtuYW1lXTtcbiAgfVxufSAvLyBTb21lIGFiYnJldmlhdGlvbnMgZm9yIGNvbW1vbmx5IHVzZWQgc3RyaW5ncy5cbi8vIFRoaXMgaGVscHMgbWluaWZ5IHRoZSBjb2RlLCBhbmQgYWxzbyBzcG90dGluZyB0eXBvcyB1c2luZyBqc2hpbnQuXG4vLyBtb2RlczpcblxudmFyIHN5bWJvbHNfbWF0aCA9IFwibWF0aFwiO1xudmFyIHN5bWJvbHNfdGV4dCA9IFwidGV4dFwiOyAvLyBmb250czpcblxudmFyIG1haW4gPSBcIm1haW5cIjtcbnZhciBhbXMgPSBcImFtc1wiOyAvLyBncm91cHM6XG5cbnZhciBzeW1ib2xzX2FjY2VudCA9IFwiYWNjZW50LXRva2VuXCI7XG52YXIgYmluID0gXCJiaW5cIjtcbnZhciBzeW1ib2xzX2Nsb3NlID0gXCJjbG9zZVwiO1xudmFyIHN5bWJvbHNfaW5uZXIgPSBcImlubmVyXCI7XG52YXIgbWF0aG9yZCA9IFwibWF0aG9yZFwiO1xudmFyIG9wID0gXCJvcC10b2tlblwiO1xudmFyIHN5bWJvbHNfb3BlbiA9IFwib3BlblwiO1xudmFyIHB1bmN0ID0gXCJwdW5jdFwiO1xudmFyIHJlbCA9IFwicmVsXCI7XG52YXIgc3ltYm9sc19zcGFjaW5nID0gXCJzcGFjaW5nXCI7XG52YXIgc3ltYm9sc190ZXh0b3JkID0gXCJ0ZXh0b3JkXCI7IC8vIE5vdyBjb21lcyB0aGUgc3ltYm9sIHRhYmxlXG4vLyBSZWxhdGlvbiBTeW1ib2xzXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjYxXCIsIFwiXFxcXGVxdWl2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyN0FcIiwgXCJcXFxccHJlY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjdCXCIsIFwiXFxcXHN1Y2NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjIzQ1wiLCBcIlxcXFxzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjJBNVwiLCBcIlxcXFxwZXJwXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTJBQUZcIiwgXCJcXFxccHJlY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTJBQjBcIiwgXCJcXFxcc3VjY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDNcIiwgXCJcXFxcc2ltZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxtaWRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2QVwiLCBcIlxcXFxsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjZCXCIsIFwiXFxcXGdnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNERcIiwgXCJcXFxcYXN5bXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjIyNVwiLCBcIlxcXFxwYXJhbGxlbFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMkM4XCIsIFwiXFxcXGJvd3RpZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtaWxlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyOTFcIiwgXCJcXFxcc3FzdWJzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjkyXCIsIFwiXFxcXHNxc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjI1MFwiLCBcIlxcXFxkb3RlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMzIyXCIsIFwiXFxcXGZyb3duXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMEJcIiwgXCJcXFxcbmlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjIxRFwiLCBcIlxcXFxwcm9wdG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjJBMlwiLCBcIlxcXFx2ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMkEzXCIsIFwiXFxcXGRhc2h2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMEJcIiwgXCJcXFxcb3duc1wiKTsgLy8gUHVuY3R1YXRpb25cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcHVuY3QsIFwiLlwiLCBcIlxcXFxsZG90cFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHB1bmN0LCBcIlxcdTIyQzVcIiwgXCJcXFxcY2RvdHBcIik7IC8vIE1pc2MgU3ltYm9sc1xuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiI1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIiNcIiwgXCJcXFxcI1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCImXCIsIFwiXFxcXCZcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiJlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMzVcIiwgXCJcXFxcYWxlcGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIwMFwiLCBcIlxcXFxmb3JhbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjEwRlwiLCBcIlxcXFxoYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMDNcIiwgXCJcXFxcZXhpc3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMDdcIiwgXCJcXFxcbmFibGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjY2RFwiLCBcIlxcXFxmbGF0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMTNcIiwgXCJcXFxcZWxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTI2NkVcIiwgXCJcXFxcbmF0dXJhbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNjYzXCIsIFwiXFxcXGNsdWJzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMThcIiwgXCJcXFxcd3BcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjY2RlwiLCBcIlxcXFxzaGFycFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNjYyXCIsIFwiXFxcXGRpYW1vbmRzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMUNcIiwgXCJcXFxcUmVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjY2MVwiLCBcIlxcXFxoZWFydHN1aXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjExMVwiLCBcIlxcXFxJbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNjYwXCIsIFwiXFxcXHNwYWRlc3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhBN1wiLCBcIlxcXFxTXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxceEI2XCIsIFwiXFxcXFBcIiwgdHJ1ZSk7IC8vIE1hdGggYW5kIFRleHRcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcdGV4dGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDIxXCIsIFwiXFxcXGRkYWdcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMjFcIiwgXCJcXFxcdGV4dGRhZ2dlcmRibFwiKTsgLy8gTGFyZ2UgRGVsaW1pdGVyc1xuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIlxcdTIzQjFcIiwgXCJcXFxccm1vdXN0YWNoZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJcXHUyM0IwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIlxcdTI3RUZcIiwgXCJcXFxccmdyb3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIlxcdTI3RUVcIiwgXCJcXFxcbGdyb3VwXCIsIHRydWUpOyAvLyBCaW5hcnkgT3BlcmF0b3JzXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjEzXCIsIFwiXFxcXG1wXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTZcIiwgXCJcXFxcb21pbnVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOEVcIiwgXCJcXFxcdXBsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5M1wiLCBcIlxcXFxzcWNhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE3XCIsIFwiXFxcXGFzdFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk0XCIsIFwiXFxcXHNxY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1RUZcIiwgXCJcXFxcYmlnY2lyY1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE5XCIsIFwiXFxcXGJ1bGxldFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMDIxXCIsIFwiXFxcXGRkYWdnZXJcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI0MFwiLCBcIlxcXFx3clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyQTNGXCIsIFwiXFxcXGFtYWxnXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIiZcIiwgXCJcXFxcQW5kXCIpOyAvLyBmcm9tIGFtc21hdGhcbi8vIEFycm93IFN5bWJvbHNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3RjVcIiwgXCJcXFxcbG9uZ2xlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMUQwXCIsIFwiXFxcXExlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyN0Y4XCIsIFwiXFxcXExvbmdsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjdGNlwiLCBcIlxcXFxsb25ncmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMUQyXCIsIFwiXFxcXFJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjdGOVwiLCBcIlxcXFxMb25ncmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk0XCIsIFwiXFxcXGxlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3RjdcIiwgXCJcXFxcbG9uZ2xlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxRDRcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjdGQVwiLCBcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjFBNlwiLCBcIlxcXFxtYXBzdG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjdGQ1wiLCBcIlxcXFxsb25nbWFwc3RvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTdcIiwgXCJcXFxcbmVhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMUE5XCIsIFwiXFxcXGhvb2tsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjFBQVwiLCBcIlxcXFxob29rcmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk4XCIsIFwiXFxcXHNlYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjFCQ1wiLCBcIlxcXFxsZWZ0aGFycG9vbnVwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxQzBcIiwgXCJcXFxccmlnaHRoYXJwb29udXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5OVwiLCBcIlxcXFxzd2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxQkRcIiwgXCJcXFxcbGVmdGhhcnBvb25kb3duXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxQzFcIiwgXCJcXFxccmlnaHRoYXJwb29uZG93blwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk2XCIsIFwiXFxcXG53YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjFDQ1wiLCBcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLCB0cnVlKTsgLy8gQU1TIE5lZ2F0ZWQgQmluYXJ5IFJlbGF0aW9uc1xuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZFXCIsIFwiXFxcXG5sZXNzXCIsIHRydWUpOyAvLyBTeW1ib2wgbmFtZXMgcHJlY2VlZGVkIGJ5IFwiQFwiIGVhY2ggaGF2ZSBhIGNvcnJlc3BvbmRpbmcgbWFjcm8uXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMTBcIiwgXCJcXFxcQG5sZXFzbGFudFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMTFcIiwgXCJcXFxcQG5sZXFxXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkE4N1wiLCBcIlxcXFxsbmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2OFwiLCBcIlxcXFxsbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMENcIiwgXCJcXFxcQGx2ZXJ0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyRTZcIiwgXCJcXFxcbG5zaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQTg5XCIsIFwiXFxcXGxuYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4MFwiLCBcIlxcXFxucHJlY1wiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjJlMCB0byBcXG5wcmVjY3VybHllcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJFMFwiLCBcIlxcXFxucHJlY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJFOFwiLCBcIlxcXFxwcmVjbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBQjlcIiwgXCJcXFxccHJlY25hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQxXCIsIFwiXFxcXG5zaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDA2XCIsIFwiXFxcXEBuc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI0XCIsIFwiXFxcXG5taWRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkFDXCIsIFwiXFxcXG52ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQURcIiwgXCJcXFxcbnZEYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJFQVwiLCBcIlxcXFxudHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJFQ1wiLCBcIlxcXFxudHJpYW5nbGVsZWZ0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhBXCIsIFwiXFxcXHN1YnNldG5lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMUFcIiwgXCJcXFxcQHZhcnN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBQ0JcIiwgXCJcXFxcc3Vic2V0bmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMTdcIiwgXCJcXFxcQHZhcnN1YnNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZGXCIsIFwiXFxcXG5ndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDBGXCIsIFwiXFxcXEBuZ2Vxc2xhbnRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDBFXCIsIFwiXFxcXEBuZ2VxcVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBODhcIiwgXCJcXFxcZ25lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyNjlcIiwgXCJcXFxcZ25lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDBEXCIsIFwiXFxcXEBndmVydG5lcXFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkU3XCIsIFwiXFxcXGduc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkE4QVwiLCBcIlxcXFxnbmFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyODFcIiwgXCJcXFxcbnN1Y2NcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIyZTEgdG8gXFxuc3VjY2N1cmx5ZXEuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyRTFcIiwgXCJcXFxcbnN1Y2NlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyRTlcIiwgXCJcXFxcc3VjY25zaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQUJBXCIsIFwiXFxcXHN1Y2NuYXBwcm94XCIsIHRydWUpOyAvLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMjQ2IHRvIFxcc2ltbmVxcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0NlwiLCBcIlxcXFxuY29uZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMDdcIiwgXCJcXFxcQG5zaG9ydHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyNlwiLCBcIlxcXFxucGFyYWxsZWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkFGXCIsIFwiXFxcXG5WRGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyRUJcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkVEXCIsIFwiXFxcXG50cmlhbmdsZXJpZ2h0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDE4XCIsIFwiXFxcXEBuc3Vwc2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4QlwiLCBcIlxcXFxzdXBzZXRuZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDFCXCIsIFwiXFxcXEB2YXJzdXBzZXRuZXFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQUNDXCIsIFwiXFxcXHN1cHNldG5lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHVFMDE5XCIsIFwiXFxcXEB2YXJzdXBzZXRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJBRVwiLCBcIlxcXFxuVmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQUI1XCIsIFwiXFxcXHByZWNuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkFCNlwiLCBcIlxcXFxzdWNjbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdUUwMTZcIiwgXCJcXFxcQG5zdWJzZXRlcXFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyMkI0XCIsIFwiXFxcXHVubGhkXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJCNVwiLCBcIlxcXFx1bnJoZFwiKTsgLy8gQU1TIE5lZ2F0ZWQgQXJyb3dzXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxOUFcIiwgXCJcXFxcbmxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxOUJcIiwgXCJcXFxcbnJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUNEXCIsIFwiXFxcXG5MZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUNGXCIsIFwiXFxcXG5SaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFBRVwiLCBcIlxcXFxubGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUNFXCIsIFwiXFxcXG5MZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTsgLy8gQU1TIE1pc2NcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjVCM1wiLCBcIlxcXFx2YXJ0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMEZcIiwgXCJcXFxcaHNsYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjVCRFwiLCBcIlxcXFx0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNUNBXCIsIFwiXFxcXGxvemVuZ2VcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNEM4XCIsIFwiXFxcXGNpcmNsZWRTXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx4QUVcIiwgXCJcXFxcY2lyY2xlZFJcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhBRVwiLCBcIlxcXFxjaXJjbGVkUlwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMjFcIiwgXCJcXFxcbWVhc3VyZWRhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMDRcIiwgXCJcXFxcbmV4aXN0c1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMjdcIiwgXCJcXFxcbWhvXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjEzMlwiLCBcIlxcXFxGaW52XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjE0MVwiLCBcIlxcXFxHYW1lXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAzNVwiLCBcIlxcXFxiYWNrcHJpbWVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNUIyXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNUJDXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjVBMFwiLCBcIlxcXFxibGFja3NxdWFyZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTI5RUJcIiwgXCJcXFxcYmxhY2tsb3plbmdlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjYwNVwiLCBcIlxcXFxiaWdzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIyMlwiLCBcIlxcXFxzcGhlcmljYWxhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMDFcIiwgXCJcXFxcY29tcGxlbWVudFwiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgVStGMCAow7ApIHRvIFxcbWF0aGV0aC4gV2UgbWFwIHRvIEFNUyBmdW5jdGlvbiBcXGV0aFxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhGMFwiLCBcIlxcXFxldGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNTcxXCIsIFwiXFxcXGRpYWd1cFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTI1NzJcIiwgXCJcXFxcZGlhZ2Rvd25cIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNUExXCIsIFwiXFxcXHNxdWFyZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTI1QTFcIiwgXCJcXFxcQm94XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjVDQVwiLCBcIlxcXFxEaWFtb25kXCIpOyAvLyB1bmljb2RlLW1hdGggbWFwcyBVK0E1IHRvIFxcbWF0aHllbi4gV2UgbWFwIHRvIEFNUyBmdW5jdGlvbiBcXHllblxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhBNVwiLCBcIlxcXFx5ZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhBNVwiLCBcIlxcXFx5ZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNzEzXCIsIFwiXFxcXGNoZWNrbWFya1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTI3MTNcIiwgXCJcXFxcY2hlY2ttYXJrXCIpOyAvLyBBTVMgSGVicmV3XG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMzZcIiwgXCJcXFxcYmV0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIxMzhcIiwgXCJcXFxcZGFsZXRoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjEzN1wiLCBcIlxcXFxnaW1lbFwiLCB0cnVlKTsgLy8gQU1TIEdyZWVrXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzRERcIiwgXCJcXFxcZGlnYW1tYVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzRjBcIiwgXCJcXFxcdmFya2FwcGFcIik7IC8vIEFNUyBEZWxpbWl0ZXJzXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc19vcGVuLCBcIlxcdTI1MENcIiwgXCJcXFxcdWxjb3JuZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfY2xvc2UsIFwiXFx1MjUxMFwiLCBcIlxcXFx1cmNvcm5lclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc19vcGVuLCBcIlxcdTI1MTRcIiwgXCJcXFxcbGxjb3JuZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfY2xvc2UsIFwiXFx1MjUxOFwiLCBcIlxcXFxscmNvcm5lclwiLCB0cnVlKTsgLy8gQU1TIEJpbmFyeSBSZWxhdGlvbnNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2NlwiLCBcIlxcXFxsZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkE3RFwiLCBcIlxcXFxsZXFzbGFudFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBOTVcIiwgXCJcXFxcZXFzbGFudGxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcyXCIsIFwiXFxcXGxlc3NzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQTg1XCIsIFwiXFxcXGxlc3NhcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjRBXCIsIFwiXFxcXGFwcHJveGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJENlwiLCBcIlxcXFxsZXNzZG90XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJEOFwiLCBcIlxcXFxsbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjc2XCIsIFwiXFxcXGxlc3NndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkRBXCIsIFwiXFxcXGxlc3NlcWd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBOEJcIiwgXCJcXFxcbGVzc2VxcWd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTFcIiwgXCJcXFxcZG90ZXFkb3RcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUzXCIsIFwiXFxcXHJpc2luZ2RvdHNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTJcIiwgXCJcXFxcZmFsbGluZ2RvdHNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyM0RcIiwgXCJcXFxcYmFja3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQ0RcIiwgXCJcXFxcYmFja3NpbWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkFDNVwiLCBcIlxcXFxzdWJzZXRlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkQwXCIsIFwiXFxcXFN1YnNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyOEZcIiwgXCJcXFxcc3FzdWJzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjdDXCIsIFwiXFxcXHByZWNjdXJseWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJERVwiLCBcIlxcXFxjdXJseWVxcHJlY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyN0VcIiwgXCJcXFxccHJlY3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBQjdcIiwgXCJcXFxccHJlY2FwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQjJcIiwgXCJcXFxcdmFydHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJCNFwiLCBcIlxcXFx0cmlhbmdsZWxlZnRlcVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQThcIiwgXCJcXFxcdkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkFBXCIsIFwiXFxcXFZ2ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIzMjNcIiwgXCJcXFxcc21hbGxzbWlsZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIzMjJcIiwgXCJcXFxcc21hbGxmcm93blwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyNEZcIiwgXCJcXFxcYnVtcGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0RVwiLCBcIlxcXFxCdW1wZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjY3XCIsIFwiXFxcXGdlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQTdFXCIsIFwiXFxcXGdlcXNsYW50XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkE5NlwiLCBcIlxcXFxlcXNsYW50Z3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3M1wiLCBcIlxcXFxndHJzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyQTg2XCIsIFwiXFxcXGd0cmFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyRDdcIiwgXCJcXFxcZ3RyZG90XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJEOVwiLCBcIlxcXFxnZ2dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjc3XCIsIFwiXFxcXGd0cmxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkRCXCIsIFwiXFxcXGd0cmVxbGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBOENcIiwgXCJcXFxcZ3RyZXFxbGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTZcIiwgXCJcXFxcZXFjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1N1wiLCBcIlxcXFxjaXJjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjVDXCIsIFwiXFxcXHRyaWFuZ2xlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyM0NcIiwgXCJcXFxcdGhpY2tzaW1cIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQ4XCIsIFwiXFxcXHRoaWNrYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MkFDNlwiLCBcIlxcXFxzdXBzZXRlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkQxXCIsIFwiXFxcXFN1cHNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyOTBcIiwgXCJcXFxcc3FzdXBzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjdEXCIsIFwiXFxcXHN1Y2NjdXJseWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJERlwiLCBcIlxcXFxjdXJseWVxc3VjY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyN0ZcIiwgXCJcXFxcc3VjY3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTJBQjhcIiwgXCJcXFxcc3VjY2FwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQjNcIiwgXCJcXFxcdmFydHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQjVcIiwgXCJcXFxcdHJpYW5nbGVyaWdodGVxXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJBOVwiLCBcIlxcXFxWZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyMjNcIiwgXCJcXFxcc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI1XCIsIFwiXFxcXHNob3J0cGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZDXCIsIFwiXFxcXGJldHdlZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMkQ0XCIsIFwiXFxcXHBpdGNoZm9ya1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyMURcIiwgXCJcXFxcdmFycHJvcHRvXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjVDMFwiLCBcIlxcXFxibGFja3RyaWFuZ2xlbGVmdFwiKTsgLy8gdW5pY29kZS1tYXRoIHNheXMgdGhhdCBcXHRoZXJlZm9yZSBpcyBhIG1hdGhvcmQgYXRvbS5cbi8vIFdlIGtlcHQgdGhlIGFtc3N5bWIgYXRvbSB0eXBlLCB3aGljaCBpcyByZWwuXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyMzRcIiwgXCJcXFxcdGhlcmVmb3JlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjIwRFwiLCBcIlxcXFxiYWNrZXBzaWxvblwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTI1QjZcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZXJpZ2h0XCIpOyAvLyB1bmljb2RlLW1hdGggc2F5cyB0aGF0IFxcYmVjYXVzZSBpcyBhIG1hdGhvcmQgYXRvbS5cbi8vIFdlIGtlcHQgdGhlIGFtc3N5bWIgYXRvbSB0eXBlLCB3aGljaCBpcyByZWwuXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyMzVcIiwgXCJcXFxcYmVjYXVzZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyRDhcIiwgXCJcXFxcbGxsZXNzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjJEOVwiLCBcIlxcXFxnZ2d0clwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyQjJcIiwgXCJcXFxcbGhkXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJCM1wiLCBcIlxcXFxyaGRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQyXCIsIFwiXFxcXGVxc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyQzhcIiwgXCJcXFxcSm9pblwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTFcIiwgXCJcXFxcRG90ZXFcIiwgdHJ1ZSk7IC8vIEFNUyBCaW5hcnkgT3BlcmF0b3JzXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyMTRcIiwgXCJcXFxcZG90cGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc21hbGxzZXRtaW51c1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyRDJcIiwgXCJcXFxcQ2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJEM1wiLCBcIlxcXFxDdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyQTVFXCIsIFwiXFxcXGRvdWJsZWJhcndlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5RlwiLCBcIlxcXFxib3htaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyOUVcIiwgXCJcXFxcYm94cGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyQzdcIiwgXCJcXFxcZGl2aWRlb250aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyQzlcIiwgXCJcXFxcbHRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJDQVwiLCBcIlxcXFxydGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyMkNCXCIsIFwiXFxcXGxlZnR0aHJlZXRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJDQ1wiLCBcIlxcXFxyaWdodHRocmVldGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyMkNGXCIsIFwiXFxcXGN1cmx5d2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyMkNFXCIsIFwiXFxcXGN1cmx5dmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5RFwiLCBcIlxcXFxjaXJjbGVkZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyOUJcIiwgXCJcXFxcY2lyY2xlZGFzdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyQzVcIiwgXCJcXFxcY2VudGVyZG90XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJCQVwiLCBcIlxcXFxpbnRlcmNhbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyRDJcIiwgXCJcXFxcZG91YmxlY2FwXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJEM1wiLCBcIlxcXFxkb3VibGVjdXBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyMkEwXCIsIFwiXFxcXGJveHRpbWVzXCIsIHRydWUpOyAvLyBBTVMgQXJyb3dzXG4vLyBOb3RlOiB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWUyIHRvIHRoZWlyIG93biBmdW5jdGlvbiBcXHJpZ2h0ZGFzaGFycm93LlxuLy8gV2UnbGwgbWFwIGl0IHRvIEFNUyBmdW5jdGlvbiBcXGRhc2hyaWdodGFycm93LiBJdCBwcm9kdWNlcyB0aGUgc2FtZSBhdG9tLlxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUUyXCIsIFwiXFxcXGRhc2hyaWdodGFycm93XCIsIHRydWUpOyAvLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWUwIHRvIFxcbGVmdGRhc2hhcnJvdy4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFFMFwiLCBcIlxcXFxkYXNobGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFDN1wiLCBcIlxcXFxsZWZ0bGVmdGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQzZcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFEQVwiLCBcIlxcXFxMbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5RVwiLCBcIlxcXFx0d29oZWFkbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFBMlwiLCBcIlxcXFxsZWZ0YXJyb3d0YWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFBQlwiLCBcIlxcXFxsb29wYXJyb3dsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFDQlwiLCBcIlxcXFxsZWZ0cmlnaHRoYXJwb29uc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQjZcIiwgXCJcXFxcY3VydmVhcnJvd2xlZnRcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIxYmEgdG8gXFxhY3dvcGVuY2lyY2xlYXJyb3cuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQkFcIiwgXCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFCMFwiLCBcIlxcXFxMc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUM4XCIsIFwiXFxcXHVwdXBhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUJGXCIsIFwiXFxcXHVwaGFycG9vbmxlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUMzXCIsIFwiXFxcXGRvd25oYXJwb29ubGVmdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyQjhcIiwgXCJcXFxcbXVsdGltYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUFEXCIsIFwiXFxcXGxlZnRyaWdodHNxdWlnYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUM5XCIsIFwiXFxcXHJpZ2h0cmlnaHRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUM0XCIsIFwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQTBcIiwgXCJcXFxcdHdvaGVhZHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUEzXCIsIFwiXFxcXHJpZ2h0YXJyb3d0YWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFBQ1wiLCBcIlxcXFxsb29wYXJyb3dyaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQjdcIiwgXCJcXFxcY3VydmVhcnJvd3JpZ2h0XCIsIHRydWUpOyAvLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWJiIHRvIFxcY3dvcGVuY2lyY2xlYXJyb3cuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQkJcIiwgXCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQjFcIiwgXCJcXFxcUnNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjFDQVwiLCBcIlxcXFxkb3duZG93bmFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxQkVcIiwgXCJcXFxcdXBoYXJwb29ucmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUMyXCIsIFwiXFxcXGRvd25oYXJwb29ucmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUREXCIsIFwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxRERcIiwgXCJcXFxcbGVhZHN0b1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIxREJcIiwgXCJcXFxcUnJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHJlbCwgXCJcXHUyMUJFXCIsIFwiXFxcXHJlc3RyaWN0aW9uXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIiRcIiwgXCJcXFxcJFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCIkXCIsIFwiXFxcXCRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiJFwiLCBcIlxcXFx0ZXh0ZG9sbGFyXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIiVcIiwgXCJcXFxcJVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCIlXCIsIFwiXFxcXCVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIl9cIiwgXCJcXFxcX1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJfXCIsIFwiXFxcXHRleHR1bmRlcnNjb3JlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMjBcIiwgXCJcXFxcYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIxRVwiLCBcIlxcXFxpbmZ0eVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDMyXCIsIFwiXFxcXHByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTI1QjNcIiwgXCJcXFxcdHJpYW5nbGVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MDM5M1wiLCBcIlxcXFxHYW1tYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUwMzk0XCIsIFwiXFxcXERlbHRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzOThcIiwgXCJcXFxcVGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MDM5QlwiLCBcIlxcXFxMYW1iZGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MDM5RVwiLCBcIlxcXFxYaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUwM0EwXCIsIFwiXFxcXFBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzQTNcIiwgXCJcXFxcU2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MDNBNVwiLCBcIlxcXFxVcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzQTZcIiwgXCJcXFxcUGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzQThcIiwgXCJcXFxcUHNpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAzQTlcIiwgXCJcXFxcT21lZ2FcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiQVwiLCBcIlxcdTAzOTFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiQlwiLCBcIlxcdTAzOTJcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiRVwiLCBcIlxcdTAzOTVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiWlwiLCBcIlxcdTAzOTZcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiSFwiLCBcIlxcdTAzOTdcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiSVwiLCBcIlxcdTAzOTlcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiS1wiLCBcIlxcdTAzOUFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiTVwiLCBcIlxcdTAzOUNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiTlwiLCBcIlxcdTAzOURcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiT1wiLCBcIlxcdTAzOUZcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiUFwiLCBcIlxcdTAzQTFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiVFwiLCBcIlxcdTAzQTRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiWFwiLCBcIlxcdTAzQTdcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx4QUNcIiwgXCJcXFxcbmVnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxceEFDXCIsIFwiXFxcXGxub3RcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjJBNFwiLCBcIlxcXFx0b3BcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjJBNVwiLCBcIlxcXFxib3RcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIwNVwiLCBcIlxcXFxlbXB0eXNldFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMDVcIiwgXCJcXFxcdmFybm90aGluZ1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNCMVwiLCBcIlxcXFxhbHBoYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNCMlwiLCBcIlxcXFxiZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM0IzXCIsIFwiXFxcXGdhbW1hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM0I0XCIsIFwiXFxcXGRlbHRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM0Y1XCIsIFwiXFxcXGVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQjZcIiwgXCJcXFxcemV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNCN1wiLCBcIlxcXFxldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQjhcIiwgXCJcXFxcdGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQjlcIiwgXCJcXFxcaW90YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNCQVwiLCBcIlxcXFxrYXBwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNCQlwiLCBcIlxcXFxsYW1iZGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQkNcIiwgXCJcXFxcbXVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQkRcIiwgXCJcXFxcbnVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQkVcIiwgXCJcXFxceGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQkZcIiwgXCJcXFxcb21pY3JvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNDMFwiLCBcIlxcXFxwaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNDMVwiLCBcIlxcXFxyaG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQzNcIiwgXCJcXFxcc2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQzRcIiwgXCJcXFxcdGF1XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM0M1XCIsIFwiXFxcXHVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzRDVcIiwgXCJcXFxccGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM0M3XCIsIFwiXFxcXGNoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNDOFwiLCBcIlxcXFxwc2lcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQzlcIiwgXCJcXFxcb21lZ2FcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQjVcIiwgXCJcXFxcdmFyZXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNEMVwiLCBcIlxcXFx2YXJ0aGV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNENlwiLCBcIlxcXFx2YXJwaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNGMVwiLCBcIlxcXFx2YXJyaG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQzJcIiwgXCJcXFxcdmFyc2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzQzZcIiwgXCJcXFxcdmFycGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTdcIiwgXCIqXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIitcIiwgXCIrXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTJcIiwgXCItXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyQzVcIiwgXCJcXFxcY2RvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE4XCIsIFwiXFxcXGNpcmNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx4RjdcIiwgXCJcXFxcZGl2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxceEIxXCIsIFwiXFxcXHBtXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxceEQ3XCIsIFwiXFxcXHRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjlcIiwgXCJcXFxcY2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMkFcIiwgXCJcXFxcY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc2V0bWludXNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyN1wiLCBcIlxcXFxsYW5kXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjhcIiwgXCJcXFxcbG9yXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcd2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyOFwiLCBcIlxcXFx2ZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIxQVwiLCBcIlxcXFxzdXJkXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIihcIiwgXCIoXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIltcIiwgXCJbXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIlxcdTI3RThcIiwgXCJcXFxcbGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIlxcdTIyMjNcIiwgXCJcXFxcbHZlcnRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwiXFx1MjIyNVwiLCBcIlxcXFxsVmVydFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiKVwiLCBcIilcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIl1cIiwgXCJdXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCI/XCIsIFwiP1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiIVwiLCBcIiFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIlxcdTI3RTlcIiwgXCJcXFxccmFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyMjIzXCIsIFwiXFxcXHJ2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyMjI1XCIsIFwiXFxcXHJWZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIj1cIiwgXCI9XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIjxcIiwgXCI8XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIj5cIiwgXCI+XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIjpcIiwgXCI6XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDhcIiwgXCJcXFxcYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDVcIiwgXCJcXFxcY29uZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY1XCIsIFwiXFxcXGdlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNjVcIiwgXCJcXFxcZ2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcZ2V0c1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCI+XCIsIFwiXFxcXGd0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMDhcIiwgXCJcXFxcaW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1RTAyMFwiLCBcIlxcXFxAbm90XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODJcIiwgXCJcXFxcc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODNcIiwgXCJcXFxcc3Vwc2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODZcIiwgXCJcXFxcc3Vic2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4N1wiLCBcIlxcXFxzdXBzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgcmVsLCBcIlxcdTIyODhcIiwgXCJcXFxcbnN1YnNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4OVwiLCBcIlxcXFxuc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjJBOFwiLCBcIlxcXFxtb2RlbHNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MFwiLCBcIlxcXFxsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NFwiLCBcIlxcXFxsZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY0XCIsIFwiXFxcXGxlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCI8XCIsIFwiXFxcXGx0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTJcIiwgXCJcXFxccmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkyXCIsIFwiXFxcXHRvXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3MVwiLCBcIlxcXFxuZ2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3MFwiLCBcIlxcXFxubGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19zcGFjaW5nLCBcIlxceEEwXCIsIFwiXFxcXCBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3NwYWNpbmcsIFwiXFx4QTBcIiwgXCJ+XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19zcGFjaW5nLCBcIlxceEEwXCIsIFwiXFxcXHNwYWNlXCIpOyAvLyBSZWY6IExhVGVYIFNvdXJjZSAyZTogXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXG5vYnJlYWtzcGFjZX17JVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3NwYWNpbmcsIFwiXFx4QTBcIiwgXCJcXFxcbm9icmVha3NwYWNlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19zcGFjaW5nLCBcIlxceEEwXCIsIFwiXFxcXCBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3NwYWNpbmcsIFwiXFx4QTBcIiwgXCJ+XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19zcGFjaW5nLCBcIlxceEEwXCIsIFwiXFxcXHNwYWNlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19zcGFjaW5nLCBcIlxceEEwXCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfc3BhY2luZywgbnVsbCwgXCJcXFxcbm9icmVha1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfc3BhY2luZywgbnVsbCwgXCJcXFxcYWxsb3dicmVha1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHB1bmN0LCBcIixcIiwgXCIsXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcHVuY3QsIFwiO1wiLCBcIjtcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIGJpbiwgXCJcXHUyMkJDXCIsIFwiXFxcXGJhcndlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJCQlwiLCBcIlxcXFx2ZWViYXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5OVwiLCBcIlxcXFxvZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTVcIiwgXCJcXFxcb3BsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5N1wiLCBcIlxcXFxvdGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIwMlwiLCBcIlxcXFxwYXJ0aWFsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOThcIiwgXCJcXFxcb3NsYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5QVwiLCBcIlxcXFxjaXJjbGVkY2lyY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgYmluLCBcIlxcdTIyQTFcIiwgXCJcXFxcYm94ZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1QjNcIiwgXCJcXFxcYmlndHJpYW5nbGV1cFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyNUJEXCIsIFwiXFxcXGJpZ3RyaWFuZ2xlZG93blwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIGJpbiwgXCJcXHUyMkM0XCIsIFwiXFxcXGRpYW1vbmRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJDNlwiLCBcIlxcXFxzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1QzNcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1QjlcIiwgXCJcXFxcdHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwie1wiLCBcIlxcXFx7XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIntcIiwgXCJcXFxcdGV4dGJyYWNlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIn1cIiwgXCJcXFxcfVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJ9XCIsIFwiXFxcXHRleHRicmFjZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIntcIiwgXCJcXFxcbGJyYWNlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJ9XCIsIFwiXFxcXHJicmFjZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJbXCIsIFwiXFxcXGxicmFja1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJbXCIsIFwiXFxcXGxicmFja1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfY2xvc2UsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX29wZW4sIFwiKFwiLCBcIlxcXFxscGFyZW5cIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2Nsb3NlLCBcIilcIiwgXCJcXFxccnBhcmVuXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIjxcIiwgXCJcXFxcdGV4dGxlc3NcIik7IC8vIGluIFQxIGZvbnRlbmNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIj5cIiwgXCJcXFxcdGV4dGdyZWF0ZXJcIik7IC8vIGluIFQxIGZvbnRlbmNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19vcGVuLCBcIlxcdTIzMEFcIiwgXCJcXFxcbGZsb29yXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyMzBCXCIsIFwiXFxcXHJmbG9vclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfb3BlbiwgXCJcXHUyMzA4XCIsIFwiXFxcXGxjZWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19jbG9zZSwgXCJcXHUyMzA5XCIsIFwiXFxcXHJjZWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcXFxcIiwgXCJcXFxcYmFja3NsYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMjNcIiwgXCJ8XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMjNcIiwgXCJcXFxcdmVydFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJ8XCIsIFwiXFxcXHRleHRiYXJcIik7IC8vIGluIFQxIGZvbnRlbmNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcfFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMjI1XCIsIFwiXFxcXFZlcnRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjIyNVwiLCBcIlxcXFx0ZXh0YmFyZGJsXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIn5cIiwgXCJcXFxcdGV4dGFzY2lpdGlsZGVcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFxcXFwiLCBcIlxcXFx0ZXh0YmFja3NsYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIl5cIiwgXCJcXFxcdGV4dGFzY2lpY2lyY3VtXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTFcIiwgXCJcXFxcdXBhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMUQxXCIsIFwiXFxcXFVwYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5M1wiLCBcIlxcXFxkb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjFEM1wiLCBcIlxcXFxEb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5NVwiLCBcIlxcXFx1cGRvd25hcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHJlbCwgXCJcXHUyMUQ1XCIsIFwiXFxcXFVwZG93bmFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIxMFwiLCBcIlxcXFxjb3Byb2RcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyMkMxXCIsIFwiXFxcXGJpZ3ZlZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTIyQzBcIiwgXCJcXFxcYmlnd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyQTA0XCIsIFwiXFxcXGJpZ3VwbHVzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgb3AsIFwiXFx1MjJDMlwiLCBcIlxcXFxiaWdjYXBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyMkMzXCIsIFwiXFxcXGJpZ2N1cFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTIyMkJcIiwgXCJcXFxcaW50XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIyQlwiLCBcIlxcXFxpbnRvcFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTIyMkNcIiwgXCJcXFxcaWludFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTIyMkRcIiwgXCJcXFxcaWlpbnRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyMjBGXCIsIFwiXFxcXHByb2RcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyMjExXCIsIFwiXFxcXHN1bVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTJBMDJcIiwgXCJcXFxcYmlnb3RpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgb3AsIFwiXFx1MkEwMVwiLCBcIlxcXFxiaWdvcGx1c1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTJBMDBcIiwgXCJcXFxcYmlnb2RvdFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTIyMkVcIiwgXCJcXFxcb2ludFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTIyMkZcIiwgXCJcXFxcb2lpbnRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyMjMwXCIsIFwiXFxcXG9paWludFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG9wLCBcIlxcdTJBMDZcIiwgXCJcXFxcYmlnc3FjdXBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBvcCwgXCJcXHUyMjJCXCIsIFwiXFxcXHNtYWxsaW50XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19pbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXHRleHRlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfaW5uZXIsIFwiXFx1MjAyNlwiLCBcIlxcXFxtYXRoZWxsaXBzaXNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX2lubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2lubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2lubmVyLCBcIlxcdTIyRUZcIiwgXCJcXFxcQGNkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19pbm5lciwgXCJcXHUyMkYxXCIsIFwiXFxcXGRkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIyRUVcIiwgXCJcXFxcdmFydmRvdHNcIik7IC8vIFxcdmRvdHMgaXMgYSBtYWNyb1xuXG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUwMkNBXCIsIFwiXFxcXGFjdXRlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MDJDQlwiLCBcIlxcXFxncmF2ZVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIlxceEE4XCIsIFwiXFxcXGRkb3RcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJ+XCIsIFwiXFxcXHRpbGRlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MDJDOVwiLCBcIlxcXFxiYXJcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUwMkQ4XCIsIFwiXFxcXGJyZXZlXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MDJDN1wiLCBcIlxcXFxjaGVja1wiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIl5cIiwgXCJcXFxcaGF0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MjBEN1wiLCBcIlxcXFx2ZWNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUwMkQ5XCIsIFwiXFxcXGRvdFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIlxcdTAyREFcIiwgXCJcXFxcbWF0aHJpbmdcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAxMzFcIiwgXCJcXFxcaW1hdGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAyMzdcIiwgXCJcXFxcam1hdGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MDEzMVwiLCBcIlxcXFxpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTAyMzdcIiwgXCJcXFxcalwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhERlwiLCBcIlxcXFxzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhFNlwiLCBcIlxcXFxhZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhFNlwiLCBcIlxcXFxhZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUwMTUzXCIsIFwiXFxcXG9lXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxceEY4XCIsIFwiXFxcXG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx4QzZcIiwgXCJcXFxcQUVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MDE1MlwiLCBcIlxcXFxPRVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhEOFwiLCBcIlxcXFxPXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MDJDQVwiLCBcIlxcXFwnXCIpOyAvLyBhY3V0ZVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUwMkNCXCIsIFwiXFxcXGBcIik7IC8vIGdyYXZlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIlxcdTAyQzZcIiwgXCJcXFxcXlwiKTsgLy8gY2lyY3VtZmxleFxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUwMkRDXCIsIFwiXFxcXH5cIik7IC8vIHRpbGRlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIlxcdTAyQzlcIiwgXCJcXFxcPVwiKTsgLy8gbWFjcm9uXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIlxcdTAyRDhcIiwgXCJcXFxcdVwiKTsgLy8gYnJldmVcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MDJEOVwiLCBcIlxcXFwuXCIpOyAvLyBkb3QgYWJvdmVcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx1MDJEQVwiLCBcIlxcXFxyXCIpOyAvLyByaW5nIGFib3ZlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfYWNjZW50LCBcIlxcdTAyQzdcIiwgXCJcXFxcdlwiKTsgLy8gY2Fyb25cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc19hY2NlbnQsIFwiXFx4QThcIiwgJ1xcXFxcIicpOyAvLyBkaWFyZXNpc1xuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUwMkREXCIsIFwiXFxcXEhcIik7IC8vIGRvdWJsZSBhY3V0ZVxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX2FjY2VudCwgXCJcXHUyNUVGXCIsIFwiXFxcXHRleHRjaXJjbGVkXCIpOyAvLyBcXGJpZ2NpcmMgZ2x5cGhcbi8vIFRoZXNlIGxpZ2F0dXJlcyBhcmUgZGV0ZWN0ZWQgYW5kIGNyZWF0ZWQgaW4gUGFyc2VyLmpzJ3MgYGZvcm1MaWdhdHVyZXNgLlxuXG52YXIgbGlnYXR1cmVzID0ge1xuICBcIi0tXCI6IHRydWUsXG4gIFwiLS0tXCI6IHRydWUsXG4gIFwiYGBcIjogdHJ1ZSxcbiAgXCInJ1wiOiB0cnVlXG59O1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMTNcIiwgXCItLVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiXFxcXHRleHRlbmRhc2hcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxNFwiLCBcIi0tLVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiXFxcXHRleHRlbWRhc2hcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxOFwiLCBcImBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxOFwiLCBcIlxcXFx0ZXh0cXVvdGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCInXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCJcXFxcdGV4dHF1b3RlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxQ1wiLCBcImBgXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMUNcIiwgXCJcXFxcdGV4dHF1b3RlZGJsbGVmdFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDFEXCIsIFwiJydcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxRFwiLCBcIlxcXFx0ZXh0cXVvdGVkYmxyaWdodFwiKTsgLy8gIFxcZGVncmVlIGZyb20gZ2Vuc3ltYiBwYWNrYWdlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhCMFwiLCBcIlxcXFxkZWdyZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx4QjBcIiwgXCJcXFxcZGVncmVlXCIpOyAvLyBcXHRleHRkZWdyZWUgZnJvbSBpbnB1dGVuYyBwYWNrYWdlXG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHhCMFwiLCBcIlxcXFx0ZXh0ZGVncmVlXCIsIHRydWUpOyAvLyBUT0RPOiBJbiBMYVRlWCwgXFxwb3VuZHMgY2FuIGdlbmVyYXRlIGEgZGlmZmVyZW50IGNoYXJhY3RlciBpbiB0ZXh0IGFuZCBtYXRoXG4vLyBtb2RlLCBidXQgYW1vbmcgb3VyIGZvbnRzLCBvbmx5IE1haW4tSXRhbGljIGRlZmluZXMgdGhpcyBjaGFyYWN0ZXIgXCIxNjNcIi5cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHhBM1wiLCBcIlxcXFxwb3VuZHNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBcIlxceEEzXCIsIFwiXFxcXG1hdGhzdGVybGluZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIG1hdGhvcmQsIFwiXFx4QTNcIiwgXCJcXFxccG91bmRzXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgbWF0aG9yZCwgXCJcXHhBM1wiLCBcIlxcXFx0ZXh0c3RlcmxpbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNzIwXCIsIFwiXFxcXG1hbHRlc2VcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyNzIwXCIsIFwiXFxcXG1hbHRlc2VcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3NwYWNpbmcsIFwiXFx4QTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfc3BhY2luZywgXCJcXHhBMFwiLCBcIiBcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3NwYWNpbmcsIFwiXFx4QTBcIiwgXCJ+XCIpOyAvLyBUaGVyZSBhcmUgbG90cyBvZiBzeW1ib2xzIHdoaWNoIGFyZSB0aGUgc2FtZSwgc28gd2UgYWRkIHRoZW0gaW4gYWZ0ZXJ3YXJkcy5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gbWF0aCBtb2RlXG5cbnZhciBtYXRoVGV4dFN5bWJvbHMgPSBcIjAxMjM0NTY3ODkvQC5cXFwiXCI7XG5cbmZvciAodmFyIHN5bWJvbHNfaSA9IDA7IHN5bWJvbHNfaSA8IG1hdGhUZXh0U3ltYm9scy5sZW5ndGg7IHN5bWJvbHNfaSsrKSB7XG4gIHZhciBzeW1ib2xzX2NoID0gbWF0aFRleHRTeW1ib2xzLmNoYXJBdChzeW1ib2xzX2kpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIHN5bWJvbHNfY2gsIHN5bWJvbHNfY2gpO1xufSAvLyBBbGwgb2YgdGhlc2UgYXJlIHRleHRvcmRzIGluIHRleHQgbW9kZVxuXG5cbnZhciB0ZXh0U3ltYm9scyA9IFwiMDEyMzQ1Njc4OSFAKigpLT0rW108PnxcXFwiOzo/Ly4sXCI7XG5cbmZvciAodmFyIHNyY19zeW1ib2xzX2kgPSAwOyBzcmNfc3ltYm9sc19pIDwgdGV4dFN5bWJvbHMubGVuZ3RoOyBzcmNfc3ltYm9sc19pKyspIHtcbiAgdmFyIF9jaCA9IHRleHRTeW1ib2xzLmNoYXJBdChzcmNfc3ltYm9sc19pKTtcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIF9jaCwgX2NoKTtcbn0gLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGUsIGFuZCBtYXRob3JkcyBpbiBtYXRoIG1vZGVcblxuXG52YXIgbGV0dGVycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuXG5mb3IgKHZhciBzeW1ib2xzX2kyID0gMDsgc3ltYm9sc19pMiA8IGxldHRlcnMubGVuZ3RoOyBzeW1ib2xzX2kyKyspIHtcbiAgdmFyIF9jaDIgPSBsZXR0ZXJzLmNoYXJBdChzeW1ib2xzX2kyKTtcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gyLCBfY2gyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gyLCBfY2gyKTtcbn0gLy8gQmxhY2tib2FyZCBib2xkIGFuZCBzY3JpcHQgbGV0dGVycyBpbiBVbmljb2RlIHJhbmdlXG5cblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiQ1wiLCBcIlxcdTIxMDJcIik7IC8vIGJsYWNrYm9hcmQgYm9sZFxuXG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJDXCIsIFwiXFx1MjEwMlwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIkhcIiwgXCJcXHUyMTBEXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiSFwiLCBcIlxcdTIxMERcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJOXCIsIFwiXFx1MjExNVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIk5cIiwgXCJcXHUyMTE1XCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiUFwiLCBcIlxcdTIxMTlcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJQXCIsIFwiXFx1MjExOVwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlFcIiwgXCJcXHUyMTFBXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiUVwiLCBcIlxcdTIxMUFcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJSXCIsIFwiXFx1MjExRFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIGFtcywgc3ltYm9sc190ZXh0b3JkLCBcIlJcIiwgXCJcXHUyMTFEXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgYW1zLCBzeW1ib2xzX3RleHRvcmQsIFwiWlwiLCBcIlxcdTIxMjRcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBhbXMsIHN5bWJvbHNfdGV4dG9yZCwgXCJaXCIsIFwiXFx1MjEyNFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIFwiaFwiLCBcIlxcdTIxMEVcIik7IC8vIGl0YWxpYyBoLCBQbGFuY2sgY29uc3RhbnRcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgbWF0aG9yZCwgXCJoXCIsIFwiXFx1MjEwRVwiKTsgLy8gVGhlIG5leHQgbG9vcCBsb2FkcyB3aWRlIChzdXJyb2dhdGUgcGFpcikgY2hhcmFjdGVycy5cbi8vIFdlIHN1cHBvcnQgc29tZSBsZXR0ZXJzIGluIHRoZSBVbmljb2RlIHJhbmdlIFUrMUQ0MDAgdG8gVSsxRDdGRixcbi8vIE1hdGhlbWF0aWNhbCBBbHBoYW51bWVyaWMgU3ltYm9scy5cbi8vIFNvbWUgZWRpdG9ycyBkbyBub3QgZGVhbCB3ZWxsIHdpdGggd2lkZSBjaGFyYWN0ZXJzLiBTbyBkb24ndCB3cml0ZSB0aGVcbi8vIHN0cmluZyBpbnRvIHRoaXMgZmlsZS4gSW5zdGVhZCwgY3JlYXRlIHRoZSBzdHJpbmcgZnJvbSB0aGUgc3Vycm9nYXRlIHBhaXIuXG5cbnZhciBzeW1ib2xzX3dpZGVDaGFyID0gXCJcIjtcblxuZm9yICh2YXIgc3ltYm9sc19pMyA9IDA7IHN5bWJvbHNfaTMgPCBsZXR0ZXJzLmxlbmd0aDsgc3ltYm9sc19pMysrKSB7XG4gIHZhciBfY2gzID0gbGV0dGVycy5jaGFyQXQoc3ltYm9sc19pMyk7IC8vIFRoZSBoZXggbnVtYmVycyBpbiB0aGUgbmV4dCBsaW5lIGFyZSBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAvLyAweEQ4MzUgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIGZvciBhbGwgbGV0dGVycyBpbiB0aGUgcmFuZ2Ugd2Ugc3VwcG9ydC5cbiAgLy8gMHhEQzAwIGlzIHRoZSBsb3cgc3Vycm9nYXRlIGZvciBib2xkIEEuXG5cblxuICBzeW1ib2xzX3dpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REMwMCArIHN5bWJvbHNfaTMpOyAvLyBBLVogYS16IGJvbGRcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgc3ltYm9sc193aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERDMzQgKyBzeW1ib2xzX2kzKTsgLy8gQS1aIGEteiBpdGFsaWNcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgc3ltYm9sc193aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERDNjggKyBzeW1ib2xzX2kzKTsgLy8gQS1aIGEteiBib2xkIGl0YWxpY1xuXG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDMsIHN5bWJvbHNfd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIF9jaDMsIHN5bWJvbHNfd2lkZUNoYXIpO1xuICBzeW1ib2xzX3dpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REQwNCArIHN5bWJvbHNfaTMpOyAvLyBBLVogYS16IEZyYWN0dXJcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgc3ltYm9sc193aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweEREQTAgKyBzeW1ib2xzX2kzKTsgLy8gQS1aIGEteiBzYW5zLXNlcmlmXG5cbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgc3ltYm9sc193aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgX2NoMywgc3ltYm9sc193aWRlQ2hhcik7XG4gIHN5bWJvbHNfd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhEREQ0ICsgc3ltYm9sc19pMyk7IC8vIEEtWiBhLXogc2FucyBib2xkXG5cbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgc3ltYm9sc193aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgX2NoMywgc3ltYm9sc193aWRlQ2hhcik7XG4gIHN5bWJvbHNfd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERTA4ICsgc3ltYm9sc19pMyk7IC8vIEEtWiBhLXogc2FucyBpdGFsaWNcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgc3ltYm9sc193aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERFNzAgKyBzeW1ib2xzX2kzKTsgLy8gQS1aIGEteiBtb25vc3BhY2VcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcblxuICBpZiAoc3ltYm9sc19pMyA8IDI2KSB7XG4gICAgLy8gS2FUZVggZm9udHMgaGF2ZSBvbmx5IGNhcGl0YWwgbGV0dGVycyBmb3IgYmxhY2tib2FyZCBib2xkIGFuZCBzY3JpcHQuXG4gICAgLy8gU2VlIGV4Y2VwdGlvbiBmb3IgayBiZWxvdy5cbiAgICBzeW1ib2xzX3dpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REQzOCArIHN5bWJvbHNfaTMpOyAvLyBBLVogZG91YmxlIHN0cnVja1xuXG4gICAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgc3ltYm9sc193aWRlQ2hhcik7XG4gICAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgICBzeW1ib2xzX3dpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REM5QyArIHN5bWJvbHNfaTMpOyAvLyBBLVogc2NyaXB0XG5cbiAgICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIF9jaDMsIHN5bWJvbHNfd2lkZUNoYXIpO1xuICB9IC8vIFRPRE86IEFkZCBib2xkIHNjcmlwdCB3aGVuIGl0IGlzIHN1cHBvcnRlZCBieSBhIEthVGVYIGZvbnQuXG5cbn0gLy8gXCJrXCIgaXMgdGhlIG9ubHkgZG91YmxlIHN0cnVjayBsb3dlciBjYXNlIGxldHRlciBpbiB0aGUgS2FUZVggZm9udHMuXG5cblxuc3ltYm9sc193aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERENUMpOyAvLyBrIGRvdWJsZSBzdHJ1Y2tcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJrXCIsIHN5bWJvbHNfd2lkZUNoYXIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcImtcIiwgc3ltYm9sc193aWRlQ2hhcik7IC8vIE5leHQsIHNvbWUgd2lkZSBjaGFyYWN0ZXIgbnVtZXJhbHNcblxuZm9yICh2YXIgc3ltYm9sc19pNCA9IDA7IHN5bWJvbHNfaTQgPCAxMDsgc3ltYm9sc19pNCsrKSB7XG4gIHZhciBfY2g0ID0gc3ltYm9sc19pNC50b1N0cmluZygpO1xuXG4gIHN5bWJvbHNfd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERkNFICsgc3ltYm9sc19pNCk7IC8vIDAtOSBib2xkXG5cbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoNCwgc3ltYm9sc193aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgX2NoNCwgc3ltYm9sc193aWRlQ2hhcik7XG4gIHN5bWJvbHNfd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERkUyICsgc3ltYm9sc19pNCk7IC8vIDAtOSBzYW5zIHNlcmlmXG5cbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoNCwgc3ltYm9sc193aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgX2NoNCwgc3ltYm9sc193aWRlQ2hhcik7XG4gIHN5bWJvbHNfd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERkVDICsgc3ltYm9sc19pNCk7IC8vIDAtOSBib2xkIHNhbnNcblxuICBkZWZpbmVTeW1ib2woc3ltYm9sc19tYXRoLCBtYWluLCBtYXRob3JkLCBfY2g0LCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBfY2g0LCBzeW1ib2xzX3dpZGVDaGFyKTtcbiAgc3ltYm9sc193aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERGRjYgKyBzeW1ib2xzX2k0KTsgLy8gMC05IG1vbm9zcGFjZVxuXG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX21hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDQsIHN5bWJvbHNfd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIF9jaDQsIHN5bWJvbHNfd2lkZUNoYXIpO1xufSAvLyBXZSBhZGQgdGhlc2UgTGF0aW4tMSBsZXR0ZXJzIGFzIHN5bWJvbHMgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LFxuLy8gYnV0IHRoZXkgYXJlIG5vdCBhY3R1YWxseSBpbiB0aGUgZm9udCwgbm9yIGFyZSB0aGV5IHN1cHBvcnRlZCBieSB0aGVcbi8vIFVuaWNvZGUgYWNjZW50IG1lY2hhbmlzbSwgc28gdGhleSBmYWxsIGJhY2sgdG8gVGltZXMgZm9udCBhbmQgbG9vayB1Z2x5LlxuLy8gVE9ETyhlZGVtYWluZSk6IEZpeCB0aGlzLlxuXG5cbnZhciBleHRyYUxhdGluID0gXCLDh8OQw57Dp8O+XCI7XG5cbmZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGV4dHJhTGF0aW4ubGVuZ3RoOyBfaTUrKykge1xuICB2YXIgX2NoNSA9IGV4dHJhTGF0aW4uY2hhckF0KF9pNSk7XG5cbiAgZGVmaW5lU3ltYm9sKHN5bWJvbHNfbWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoNSwgX2NoNSk7XG4gIGRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgX2NoNSwgX2NoNSk7XG59XG5cbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCLDsFwiLCBcIsOwXCIpOyAvLyBVbmljb2RlIHZlcnNpb25zIG9mIGV4aXN0aW5nIGNoYXJhY3RlcnNcblxuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMTNcIiwgXCLigJNcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxNFwiLCBcIuKAlFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDE4XCIsIFwi4oCYXCIpO1xuZGVmaW5lU3ltYm9sKHN5bWJvbHNfdGV4dCwgbWFpbiwgc3ltYm9sc190ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCLigJlcIik7XG5kZWZpbmVTeW1ib2woc3ltYm9sc190ZXh0LCBtYWluLCBzeW1ib2xzX3RleHRvcmQsIFwiXFx1MjAxQ1wiLCBcIuKAnFwiKTtcbmRlZmluZVN5bWJvbChzeW1ib2xzX3RleHQsIG1haW4sIHN5bWJvbHNfdGV4dG9yZCwgXCJcXHUyMDFEXCIsIFwi4oCdXCIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvd2lkZS1jaGFyYWN0ZXIuanNcbi8qKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHN1cHBvcnQgZm9yIFVuaWNvZGUgcmFuZ2UgVSsxRDQwMCB0byBVKzFEN0ZGLFxuICogTWF0aGVtYXRpY2FsIEFscGhhbnVtZXJpYyBTeW1ib2xzLlxuICpcbiAqIEZ1bmN0aW9uIHdpZGVDaGFyYWN0ZXJGb250IHRha2VzIGEgd2lkZSBjaGFyYWN0ZXIgYXMgaW5wdXQgYW5kIHJldHVybnNcbiAqIHRoZSBmb250IGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byByZW5kZXIgaXQgcHJvcGVybHkuXG4gKi9cblxuLyoqXG4gKiBEYXRhIGJlbG93IGlzIGZyb20gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvY2hhcnRzL1BERi9VMUQ0MDAucGRmXG4gKiBUaGF0IGRvY3VtZW50IHNvcnRzIGNoYXJhY3RlcnMgaW50byBncm91cHMgYnkgZm9udCB0eXBlLCBzYXkgYm9sZCBvciBpdGFsaWMuXG4gKlxuICogSW4gdGhlIGFycmF5cyBiZWxvdywgZWFjaCBzdWJhcnJheSBjb25zaXN0cyB0aHJlZSBlbGVtZW50czpcbiAqICAgICAgKiBUaGUgQ1NTIGNsYXNzIG9mIHRoYXQgZ3JvdXAgd2hlbiBpbiBtYXRoIG1vZGUuXG4gKiAgICAgICogVGhlIENTUyBjbGFzcyBvZiB0aGF0IGdyb3VwIHdoZW4gaW4gdGV4dCBtb2RlLlxuICogICAgICAqIFRoZSBmb250IG5hbWUsIHNvIHRoYXQgS2FUZVggY2FuIGdldCBmb250IG1ldHJpY3MuXG4gKi9cblxudmFyIHdpZGVMYXRpbkxldHRlckRhdGEgPSBbW1wibWF0aGJmXCIsIFwidGV4dGJmXCIsIFwiTWFpbi1Cb2xkXCJdLCAvLyBBLVogYm9sZCB1cHJpZ2h0XG5bXCJtYXRoYmZcIiwgXCJ0ZXh0YmZcIiwgXCJNYWluLUJvbGRcIl0sIC8vIGEteiBib2xkIHVwcmlnaHRcbltcIm1hdGhkZWZhdWx0XCIsIFwidGV4dGl0XCIsIFwiTWF0aC1JdGFsaWNcIl0sIC8vIEEtWiBpdGFsaWNcbltcIm1hdGhkZWZhdWx0XCIsIFwidGV4dGl0XCIsIFwiTWF0aC1JdGFsaWNcIl0sIC8vIGEteiBpdGFsaWNcbltcImJvbGRzeW1ib2xcIiwgXCJib2xkc3ltYm9sXCIsIFwiTWFpbi1Cb2xkSXRhbGljXCJdLCAvLyBBLVogYm9sZCBpdGFsaWNcbltcImJvbGRzeW1ib2xcIiwgXCJib2xkc3ltYm9sXCIsIFwiTWFpbi1Cb2xkSXRhbGljXCJdLCAvLyBhLXogYm9sZCBpdGFsaWNcbi8vIE1hcCBmYW5jeSBBLVogbGV0dGVycyB0byBzY3JpcHQsIG5vdCBjYWxsaWdyYXBoaWMuXG4vLyBUaGlzIGFsaWducyB3aXRoIHVuaWNvZGUtbWF0aCBhbmQgbWF0aCBmb250cyAoZXhjZXB0IENhbWJyaWEgTWF0aCkuXG5bXCJtYXRoc2NyXCIsIFwidGV4dHNjclwiLCBcIlNjcmlwdC1SZWd1bGFyXCJdLCAvLyBBLVogc2NyaXB0XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIGEteiBzY3JpcHQuICBObyBmb250XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIEEtWiBib2xkIHNjcmlwdC4gTm8gZm9udFxuW1wiXCIsIFwiXCIsIFwiXCJdLCAvLyBhLXogYm9sZCBzY3JpcHQuIE5vIGZvbnRcbltcIm1hdGhmcmFrXCIsIFwidGV4dGZyYWtcIiwgXCJGcmFrdHVyLVJlZ3VsYXJcIl0sIC8vIEEtWiBGcmFrdHVyXG5bXCJtYXRoZnJha1wiLCBcInRleHRmcmFrXCIsIFwiRnJha3R1ci1SZWd1bGFyXCJdLCAvLyBhLXogRnJha3R1clxuW1wibWF0aGJiXCIsIFwidGV4dGJiXCIsIFwiQU1TLVJlZ3VsYXJcIl0sIC8vIEEtWiBkb3VibGUtc3RydWNrXG5bXCJtYXRoYmJcIiwgXCJ0ZXh0YmJcIiwgXCJBTVMtUmVndWxhclwiXSwgLy8gayBkb3VibGUtc3RydWNrXG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIEEtWiBib2xkIEZyYWt0dXIgTm8gZm9udCBtZXRyaWNzXG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIGEteiBib2xkIEZyYWt0dXIuICAgTm8gZm9udC5cbltcIm1hdGhzZlwiLCBcInRleHRzZlwiLCBcIlNhbnNTZXJpZi1SZWd1bGFyXCJdLCAvLyBBLVogc2Fucy1zZXJpZlxuW1wibWF0aHNmXCIsIFwidGV4dHNmXCIsIFwiU2Fuc1NlcmlmLVJlZ3VsYXJcIl0sIC8vIGEteiBzYW5zLXNlcmlmXG5bXCJtYXRoYm9sZHNmXCIsIFwidGV4dGJvbGRzZlwiLCBcIlNhbnNTZXJpZi1Cb2xkXCJdLCAvLyBBLVogYm9sZCBzYW5zLXNlcmlmXG5bXCJtYXRoYm9sZHNmXCIsIFwidGV4dGJvbGRzZlwiLCBcIlNhbnNTZXJpZi1Cb2xkXCJdLCAvLyBhLXogYm9sZCBzYW5zLXNlcmlmXG5bXCJtYXRoaXRzZlwiLCBcInRleHRpdHNmXCIsIFwiU2Fuc1NlcmlmLUl0YWxpY1wiXSwgLy8gQS1aIGl0YWxpYyBzYW5zLXNlcmlmXG5bXCJtYXRoaXRzZlwiLCBcInRleHRpdHNmXCIsIFwiU2Fuc1NlcmlmLUl0YWxpY1wiXSwgLy8gYS16IGl0YWxpYyBzYW5zLXNlcmlmXG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIEEtWiBib2xkIGl0YWxpYyBzYW5zLiBObyBmb250XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIGEteiBib2xkIGl0YWxpYyBzYW5zLiBObyBmb250XG5bXCJtYXRodHRcIiwgXCJ0ZXh0dHRcIiwgXCJUeXBld3JpdGVyLVJlZ3VsYXJcIl0sIC8vIEEtWiBtb25vc3BhY2VcbltcIm1hdGh0dFwiLCBcInRleHR0dFwiLCBcIlR5cGV3cml0ZXItUmVndWxhclwiXV07XG52YXIgd2lkZU51bWVyYWxEYXRhID0gW1tcIm1hdGhiZlwiLCBcInRleHRiZlwiLCBcIk1haW4tQm9sZFwiXSwgLy8gMC05IGJvbGRcbltcIlwiLCBcIlwiLCBcIlwiXSwgLy8gMC05IGRvdWJsZS1zdHJ1Y2suIE5vIEthVGVYIGZvbnQuXG5bXCJtYXRoc2ZcIiwgXCJ0ZXh0c2ZcIiwgXCJTYW5zU2VyaWYtUmVndWxhclwiXSwgLy8gMC05IHNhbnMtc2VyaWZcbltcIm1hdGhib2xkc2ZcIiwgXCJ0ZXh0Ym9sZHNmXCIsIFwiU2Fuc1NlcmlmLUJvbGRcIl0sIC8vIDAtOSBib2xkIHNhbnMtc2VyaWZcbltcIm1hdGh0dFwiLCBcInRleHR0dFwiLCBcIlR5cGV3cml0ZXItUmVndWxhclwiXV07XG52YXIgd2lkZV9jaGFyYWN0ZXJfd2lkZUNoYXJhY3RlckZvbnQgPSBmdW5jdGlvbiB3aWRlQ2hhcmFjdGVyRm9udCh3aWRlQ2hhciwgbW9kZSkge1xuICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgY29kZVBvaW50QXQoKS4gU28gd29yayB3aXRoIHRoZSBzdXJyb2dhdGUgcGFpci5cbiAgdmFyIEggPSB3aWRlQ2hhci5jaGFyQ29kZUF0KDApOyAvLyBoaWdoIHN1cnJvZ2F0ZVxuXG4gIHZhciBMID0gd2lkZUNoYXIuY2hhckNvZGVBdCgxKTsgLy8gbG93IHN1cnJvZ2F0ZVxuXG4gIHZhciBjb2RlUG9pbnQgPSAoSCAtIDB4RDgwMCkgKiAweDQwMCArIChMIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIHZhciBqID0gbW9kZSA9PT0gXCJtYXRoXCIgPyAwIDogMTsgLy8gY29sdW1uIGluZGV4IGZvciBDU1MgY2xhc3MuXG5cbiAgaWYgKDB4MUQ0MDAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4MUQ2QTQpIHtcbiAgICAvLyB3aWRlTGF0aW5MZXR0ZXJEYXRhIGNvbnRhaW5zIGV4YWN0bHkgMjYgY2hhcnMgb24gZWFjaCByb3cuXG4gICAgLy8gU28gd2UgY2FuIGNhbGN1bGF0ZSB0aGUgcmVsZXZhbnQgcm93LiBObyB0cmF2ZXJzZSBuZWNlc3NhcnkuXG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKChjb2RlUG9pbnQgLSAweDFENDAwKSAvIDI2KTtcbiAgICByZXR1cm4gW3dpZGVMYXRpbkxldHRlckRhdGFbaV1bMl0sIHdpZGVMYXRpbkxldHRlckRhdGFbaV1bal1dO1xuICB9IGVsc2UgaWYgKDB4MUQ3Q0UgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDFEN0ZGKSB7XG4gICAgLy8gTnVtZXJhbHMsIHRlbiBwZXIgcm93LlxuICAgIHZhciBfaSA9IE1hdGguZmxvb3IoKGNvZGVQb2ludCAtIDB4MUQ3Q0UpIC8gMTApO1xuXG4gICAgcmV0dXJuIFt3aWRlTnVtZXJhbERhdGFbX2ldWzJdLCB3aWRlTnVtZXJhbERhdGFbX2ldW2pdXTtcbiAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPT09IDB4MUQ2QTUgfHwgY29kZVBvaW50ID09PSAweDFENkE2KSB7XG4gICAgLy8gZG90bGVzcyBpIG9yIGpcbiAgICByZXR1cm4gW3dpZGVMYXRpbkxldHRlckRhdGFbMF1bMl0sIHdpZGVMYXRpbkxldHRlckRhdGFbMF1bal1dO1xuICB9IGVsc2UgaWYgKDB4MUQ2QTYgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgxRDdDRSkge1xuICAgIC8vIEdyZWVrIGxldHRlcnMuIE5vdCBzdXBwb3J0ZWQsIHlldC5cbiAgICByZXR1cm4gW1wiXCIsIFwiXCJdO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgYW55IHdpZGUgY2hhcmFjdGVycyBvdXRzaWRlIDFENDAw4oCTMUQ3RkYuXG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5zdXBwb3J0ZWQgY2hhcmFjdGVyOiBcIiArIHdpZGVDaGFyKTtcbiAgfVxufTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL09wdGlvbnMuanNcbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcHRpb25zIHRoYXQgdGhlIFBhcnNlciBjYXJyaWVzXG4gKiBhcm91bmQgd2l0aCBpdCB3aGlsZSBwYXJzaW5nLiBEYXRhIGlzIGhlbGQgaW4gYW4gYE9wdGlvbnNgIG9iamVjdCwgYW5kIHdoZW5cbiAqIHJlY3Vyc2luZywgYSBuZXcgYE9wdGlvbnNgIG9iamVjdCBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZSBgLndpdGgqYCBhbmRcbiAqIGAucmVzZXRgIGZ1bmN0aW9ucy5cbiAqL1xuXG52YXIgc2l6ZVN0eWxlTWFwID0gWy8vIEVhY2ggZWxlbWVudCBjb250YWlucyBbdGV4dHNpemUsIHNjcmlwdHNpemUsIHNjcmlwdHNjcmlwdHNpemVdLlxuLy8gVGhlIHNpemUgbWFwcGluZ3MgYXJlIHRha2VuIGZyb20gVGVYIHdpdGggXFxub3JtYWxzaXplPTEwcHQuXG5bMSwgMSwgMV0sIC8vIHNpemUxOiBbNSwgNSwgNV0gICAgICAgICAgICAgIFxcdGlueVxuWzIsIDEsIDFdLCAvLyBzaXplMjogWzYsIDUsIDVdXG5bMywgMSwgMV0sIC8vIHNpemUzOiBbNywgNSwgNV0gICAgICAgICAgICAgIFxcc2NyaXB0c2l6ZVxuWzQsIDIsIDFdLCAvLyBzaXplNDogWzgsIDYsIDVdICAgICAgICAgICAgICBcXGZvb3Rub3Rlc2l6ZVxuWzUsIDIsIDFdLCAvLyBzaXplNTogWzksIDYsIDVdICAgICAgICAgICAgICBcXHNtYWxsXG5bNiwgMywgMV0sIC8vIHNpemU2OiBbMTAsIDcsIDVdICAgICAgICAgICAgIFxcbm9ybWFsc2l6ZVxuWzcsIDQsIDJdLCAvLyBzaXplNzogWzEyLCA4LCA2XSAgICAgICAgICAgICBcXGxhcmdlXG5bOCwgNiwgM10sIC8vIHNpemU4OiBbMTQuNCwgMTAsIDddICAgICAgICAgIFxcTGFyZ2Vcbls5LCA3LCA2XSwgLy8gc2l6ZTk6IFsxNy4yOCwgMTIsIDEwXSAgICAgICAgXFxMQVJHRVxuWzEwLCA4LCA3XSwgLy8gc2l6ZTEwOiBbMjAuNzQsIDE0LjQsIDEyXSAgICAgXFxodWdlXG5bMTEsIDEwLCA5XV07XG52YXIgc2l6ZU11bHRpcGxpZXJzID0gWy8vIGZvbnRNZXRyaWNzLmpzOmdldEdsb2JhbE1ldHJpY3MgYWxzbyB1c2VzIHNpemUgaW5kZXhlcywgc28gaWZcbi8vIHlvdSBjaGFuZ2Ugc2l6ZSBpbmRleGVzLCBjaGFuZ2UgdGhhdCBmdW5jdGlvbi5cbjAuNSwgMC42LCAwLjcsIDAuOCwgMC45LCAxLjAsIDEuMiwgMS40NCwgMS43MjgsIDIuMDc0LCAyLjQ4OF07XG5cbnZhciBzaXplQXRTdHlsZSA9IGZ1bmN0aW9uIHNpemVBdFN0eWxlKHNpemUsIHN0eWxlKSB7XG4gIHJldHVybiBzdHlsZS5zaXplIDwgMiA/IHNpemUgOiBzaXplU3R5bGVNYXBbc2l6ZSAtIDFdW3N0eWxlLnNpemUgLSAxXTtcbn07IC8vIEluIHRoZXNlIHR5cGVzLCBcIlwiIChlbXB0eSBzdHJpbmcpIG1lYW5zIFwibm8gY2hhbmdlXCIuXG5cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIG9wdGlvbnMgY2xhc3MuIEl0IGNvbnRhaW5zIHRoZSBjdXJyZW50IHN0eWxlLCBzaXplLCBjb2xvcixcbiAqIGFuZCBmb250LlxuICpcbiAqIE9wdGlvbnMgb2JqZWN0cyBzaG91bGQgbm90IGJlIG1vZGlmaWVkLiBUbyBjcmVhdGUgYSBuZXcgT3B0aW9ucyB3aXRoXG4gKiBkaWZmZXJlbnQgcHJvcGVydGllcywgY2FsbCBhIGAuaGF2aW5nKmAgbWV0aG9kLlxuICovXG52YXIgT3B0aW9uc19PcHRpb25zID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gQSBmb250IGZhbWlseSBhcHBsaWVzIHRvIGEgZ3JvdXAgb2YgZm9udHMgKGkuZS4gU2Fuc1NlcmlmKSwgd2hpbGUgYSBmb250XG4gIC8vIHJlcHJlc2VudHMgYSBzcGVjaWZpYyBmb250IChpLmUuIFNhbnNTZXJpZiBCb2xkKS5cbiAgLy8gU2VlOiBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMjIzNTAvZGlmZmVyZW5jZS1iZXR3ZWVuLXRleHRybS1hbmQtbWF0aHJtXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIHNpemUgaW5kZXguXG4gICAqL1xuICBmdW5jdGlvbiBPcHRpb25zKGRhdGEpIHtcbiAgICB0aGlzLnN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMuY29sb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5zaXplID0gdm9pZCAwO1xuICAgIHRoaXMudGV4dFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5waGFudG9tID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFNoYXBlID0gdm9pZCAwO1xuICAgIHRoaXMuc2l6ZU11bHRpcGxpZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXhTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuX2ZvbnRNZXRyaWNzID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSBkYXRhLnN0eWxlO1xuICAgIHRoaXMuY29sb3IgPSBkYXRhLmNvbG9yO1xuICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZSB8fCBPcHRpb25zLkJBU0VTSVpFO1xuICAgIHRoaXMudGV4dFNpemUgPSBkYXRhLnRleHRTaXplIHx8IHRoaXMuc2l6ZTtcbiAgICB0aGlzLnBoYW50b20gPSAhIWRhdGEucGhhbnRvbTtcbiAgICB0aGlzLmZvbnQgPSBkYXRhLmZvbnQgfHwgXCJcIjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBkYXRhLmZvbnRGYW1pbHkgfHwgXCJcIjtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBkYXRhLmZvbnRXZWlnaHQgfHwgJyc7XG4gICAgdGhpcy5mb250U2hhcGUgPSBkYXRhLmZvbnRTaGFwZSB8fCAnJztcbiAgICB0aGlzLnNpemVNdWx0aXBsaWVyID0gc2l6ZU11bHRpcGxpZXJzW3RoaXMuc2l6ZSAtIDFdO1xuICAgIHRoaXMubWF4U2l6ZSA9IGRhdGEubWF4U2l6ZTtcbiAgICB0aGlzLl9mb250TWV0cmljcyA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgXCJ0aGlzXCIuICBQcm9wZXJ0aWVzXG4gICAqIGZyb20gXCJleHRlbnNpb25cIiB3aWxsIGJlIGNvcGllZCB0byB0aGUgbmV3IG9wdGlvbnMgb2JqZWN0LlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBPcHRpb25zLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKGV4dGVuc2lvbikge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgc3R5bGU6IHRoaXMuc3R5bGUsXG4gICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICB0ZXh0U2l6ZTogdGhpcy50ZXh0U2l6ZSxcbiAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgcGhhbnRvbTogdGhpcy5waGFudG9tLFxuICAgICAgZm9udDogdGhpcy5mb250LFxuICAgICAgZm9udEZhbWlseTogdGhpcy5mb250RmFtaWx5LFxuICAgICAgZm9udFdlaWdodDogdGhpcy5mb250V2VpZ2h0LFxuICAgICAgZm9udFNoYXBlOiB0aGlzLmZvbnRTaGFwZSxcbiAgICAgIG1heFNpemU6IHRoaXMubWF4U2l6ZVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgICBpZiAoZXh0ZW5zaW9uLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gZXh0ZW5zaW9uW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBPcHRpb25zKGRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUuIElmIGB0aGlzLnN0eWxlID09PSBzdHlsZWAsXG4gICAqIHJldHVybnMgYHRoaXNgLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5oYXZpbmdTdHlsZSA9IGZ1bmN0aW9uIGhhdmluZ1N0eWxlKHN0eWxlKSB7XG4gICAgaWYgKHRoaXMuc3R5bGUgPT09IHN0eWxlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBzaXplOiBzaXplQXRTdHlsZSh0aGlzLnRleHRTaXplLCBzdHlsZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggYSBjcmFtcGVkIHZlcnNpb24gb2YgdGhlIGN1cnJlbnQgc3R5bGUuIElmXG4gICAqIHRoZSBjdXJyZW50IHN0eWxlIGlzIGNyYW1wZWQsIHJldHVybnMgYHRoaXNgLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5oYXZpbmdDcmFtcGVkU3R5bGUgPSBmdW5jdGlvbiBoYXZpbmdDcmFtcGVkU3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGF2aW5nU3R5bGUodGhpcy5zdHlsZS5jcmFtcCgpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIHNpemUgYW5kIGluIGF0IGxlYXN0IGBcXHRleHRzdHlsZWAuXG4gICAqIFJldHVybnMgYHRoaXNgIGlmIGFwcHJvcHJpYXRlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5oYXZpbmdTaXplID0gZnVuY3Rpb24gaGF2aW5nU2l6ZShzaXplKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gc2l6ZSAmJiB0aGlzLnRleHRTaXplID09PSBzaXplKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgICAgc3R5bGU6IHRoaXMuc3R5bGUudGV4dCgpLFxuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICB0ZXh0U2l6ZTogc2l6ZSxcbiAgICAgICAgc2l6ZU11bHRpcGxpZXI6IHNpemVNdWx0aXBsaWVyc1tzaXplIC0gMV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTGlrZSBgdGhpcy5oYXZpbmdTaXplKEJBU0VTSVpFKS5oYXZpbmdTdHlsZShzdHlsZSlgLiBJZiBgc3R5bGVgIGlzIG9taXR0ZWQsXG4gICAqIGNoYW5nZXMgdG8gYXQgbGVhc3QgYFxcdGV4dHN0eWxlYC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaGF2aW5nQmFzZVN0eWxlID0gZnVuY3Rpb24gaGF2aW5nQmFzZVN0eWxlKHN0eWxlKSB7XG4gICAgc3R5bGUgPSBzdHlsZSB8fCB0aGlzLnN0eWxlLnRleHQoKTtcbiAgICB2YXIgd2FudFNpemUgPSBzaXplQXRTdHlsZShPcHRpb25zLkJBU0VTSVpFLCBzdHlsZSk7XG5cbiAgICBpZiAodGhpcy5zaXplID09PSB3YW50U2l6ZSAmJiB0aGlzLnRleHRTaXplID09PSBPcHRpb25zLkJBU0VTSVpFICYmIHRoaXMuc3R5bGUgPT09IHN0eWxlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBzaXplOiB3YW50U2l6ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGVmZmVjdCBvZiBzaXppbmcgY2hhbmdlcyBzdWNoIGFzIFxcSHVnZS5cbiAgICogS2VlcCB0aGUgZWZmZWN0IG9mIHRoZSBjdXJyZW50IHN0eWxlLCBzdWNoIGFzIFxcc2NyaXB0c3R5bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmhhdmluZ0Jhc2VTaXppbmcgPSBmdW5jdGlvbiBoYXZpbmdCYXNlU2l6aW5nKCkge1xuICAgIHZhciBzaXplO1xuXG4gICAgc3dpdGNoICh0aGlzLnN0eWxlLmlkKSB7XG4gICAgICBjYXNlIDQ6XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHNpemUgPSAzOyAvLyBub3JtYWxzaXplIGluIHNjcmlwdHN0eWxlXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgc2l6ZSA9IDE7IC8vIG5vcm1hbHNpemUgaW4gc2NyaXB0c2NyaXB0c3R5bGVcblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2l6ZSA9IDY7XG4gICAgICAvLyBub3JtYWxzaXplIGluIHRleHRzdHlsZSBvciBkaXNwbGF5c3R5bGVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgc3R5bGU6IHRoaXMuc3R5bGUudGV4dCgpLFxuICAgICAgc2l6ZTogc2l6ZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29sb3IuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLndpdGhDb2xvciA9IGZ1bmN0aW9uIHdpdGhDb2xvcihjb2xvcikge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBjb2xvcjogY29sb3JcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggXCJwaGFudG9tXCIgc2V0IHRvIHRydWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLndpdGhQaGFudG9tID0gZnVuY3Rpb24gd2l0aFBoYW50b20oKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIHBoYW50b206IHRydWVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBtYXRoIGZvbnQgb3Igb2xkIHRleHQgZm9udC5cbiAgICogQHR5cGUge1t0eXBlXX1cbiAgICovXG4gIDtcblxuICBfcHJvdG8ud2l0aEZvbnQgPSBmdW5jdGlvbiB3aXRoRm9udChmb250KSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnQ6IGZvbnRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0cyB3aXRoIHRoZSBnaXZlbiBmb250RmFtaWx5LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by53aXRoVGV4dEZvbnRGYW1pbHkgPSBmdW5jdGlvbiB3aXRoVGV4dEZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250RmFtaWx5OiBmb250RmFtaWx5LFxuICAgICAgZm9udDogXCJcIlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGZvbnQgd2VpZ2h0XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLndpdGhUZXh0Rm9udFdlaWdodCA9IGZ1bmN0aW9uIHdpdGhUZXh0Rm9udFdlaWdodChmb250V2VpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQsXG4gICAgICBmb250OiBcIlwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gZm9udCB3ZWlnaHRcbiAgICovXG4gIDtcblxuICBfcHJvdG8ud2l0aFRleHRGb250U2hhcGUgPSBmdW5jdGlvbiB3aXRoVGV4dEZvbnRTaGFwZShmb250U2hhcGUpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udFNoYXBlOiBmb250U2hhcGUsXG4gICAgICBmb250OiBcIlwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgQ1NTIHNpemluZyBjbGFzc2VzIHJlcXVpcmVkIHRvIHN3aXRjaCBmcm9tIGVuY2xvc2luZyBvcHRpb25zXG4gICAqIGBvbGRPcHRpb25zYCB0byBgdGhpc2AuIFJldHVybnMgYW4gYXJyYXkgb2YgY2xhc3Nlcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2l6aW5nQ2xhc3NlcyA9IGZ1bmN0aW9uIHNpemluZ0NsYXNzZXMob2xkT3B0aW9ucykge1xuICAgIGlmIChvbGRPcHRpb25zLnNpemUgIT09IHRoaXMuc2l6ZSkge1xuICAgICAgcmV0dXJuIFtcInNpemluZ1wiLCBcInJlc2V0LXNpemVcIiArIG9sZE9wdGlvbnMuc2l6ZSwgXCJzaXplXCIgKyB0aGlzLnNpemVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIENTUyBzaXppbmcgY2xhc3NlcyByZXF1aXJlZCB0byBzd2l0Y2ggdG8gdGhlIGJhc2Ugc2l6ZS4gTGlrZVxuICAgKiBgdGhpcy5oYXZpbmdTaXplKEJBU0VTSVpFKS5zaXppbmdDbGFzc2VzKHRoaXMpYC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYmFzZVNpemluZ0NsYXNzZXMgPSBmdW5jdGlvbiBiYXNlU2l6aW5nQ2xhc3NlcygpIHtcbiAgICBpZiAodGhpcy5zaXplICE9PSBPcHRpb25zLkJBU0VTSVpFKSB7XG4gICAgICByZXR1cm4gW1wic2l6aW5nXCIsIFwicmVzZXQtc2l6ZVwiICsgdGhpcy5zaXplLCBcInNpemVcIiArIE9wdGlvbnMuQkFTRVNJWkVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGZvbnQgbWV0cmljcyBmb3IgdGhpcyBzaXplLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5mb250TWV0cmljcyA9IGZ1bmN0aW9uIGZvbnRNZXRyaWNzKCkge1xuICAgIGlmICghdGhpcy5fZm9udE1ldHJpY3MpIHtcbiAgICAgIHRoaXMuX2ZvbnRNZXRyaWNzID0gZ2V0R2xvYmFsTWV0cmljcyh0aGlzLnNpemUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9mb250TWV0cmljcztcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgQ1NTIGNvbG9yIG9mIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldENvbG9yID0gZnVuY3Rpb24gZ2V0Q29sb3IoKSB7XG4gICAgaWYgKHRoaXMucGhhbnRvbSkge1xuICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY29sb3I7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBPcHRpb25zO1xufSgpO1xuXG5PcHRpb25zX09wdGlvbnMuQkFTRVNJWkUgPSA2O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX09wdGlvbnMgPSAoT3B0aW9uc19PcHRpb25zKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3VuaXRzLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBkb2VzIGNvbnZlcnNpb24gYmV0d2VlbiB1bml0cy4gIEluIHBhcnRpY3VsYXIsIGl0IHByb3ZpZGVzXG4gKiBjYWxjdWxhdGVTaXplIHRvIGNvbnZlcnQgb3RoZXIgdW5pdHMgaW50byBlbXMuXG4gKi9cblxuIC8vIFRoaXMgdGFibGUgZ2l2ZXMgdGhlIG51bWJlciBvZiBUZVggcHRzIGluIG9uZSBvZiBlYWNoICphYnNvbHV0ZSogVGVYIHVuaXQuXG4vLyBUaHVzLCBtdWx0aXBseWluZyBhIGxlbmd0aCBieSB0aGlzIG51bWJlciBjb252ZXJ0cyB0aGUgbGVuZ3RoIGZyb20gdW5pdHNcbi8vIGludG8gcHRzLiAgRGl2aWRpbmcgdGhlIHJlc3VsdCBieSBwdFBlckVtIGdpdmVzIHRoZSBudW1iZXIgb2YgZW1zXG4vLyAqYXNzdW1pbmcqIGEgZm9udCBzaXplIG9mIHB0UGVyRW0gKG5vcm1hbCBzaXplLCBub3JtYWwgc3R5bGUpLlxuXG52YXIgcHRQZXJVbml0ID0ge1xuICAvLyBodHRwczovL2VuLndpa2lib29rcy5vcmcvd2lraS9MYVRlWC9MZW5ndGhzIGFuZFxuICAvLyBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9hLzgyNjNcbiAgXCJwdFwiOiAxLFxuICAvLyBUZVggcG9pbnRcbiAgXCJtbVwiOiA3MjI3IC8gMjU0MCxcbiAgLy8gbWlsbGltZXRlclxuICBcImNtXCI6IDcyMjcgLyAyNTQsXG4gIC8vIGNlbnRpbWV0ZXJcbiAgXCJpblwiOiA3Mi4yNyxcbiAgLy8gaW5jaFxuICBcImJwXCI6IDgwMyAvIDgwMCxcbiAgLy8gYmlnIChQb3N0U2NyaXB0KSBwb2ludHNcbiAgXCJwY1wiOiAxMixcbiAgLy8gcGljYVxuICBcImRkXCI6IDEyMzggLyAxMTU3LFxuICAvLyBkaWRvdFxuICBcImNjXCI6IDE0ODU2IC8gMTE1NyxcbiAgLy8gY2ljZXJvICgxMiBkaWRvdClcbiAgXCJuZFwiOiA2ODUgLyA2NDIsXG4gIC8vIG5ldyBkaWRvdFxuICBcIm5jXCI6IDEzNzAgLyAxMDcsXG4gIC8vIG5ldyBjaWNlcm8gKDEyIG5ldyBkaWRvdClcbiAgXCJzcFwiOiAxIC8gNjU1MzYsXG4gIC8vIHNjYWxlZCBwb2ludCAoVGVYJ3MgaW50ZXJuYWwgc21hbGxlc3QgdW5pdClcbiAgLy8gaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vYS80MTM3MVxuICBcInB4XCI6IDgwMyAvIDgwMCAvLyBcXHBkZnB4ZGltZW4gZGVmYXVsdHMgdG8gMSBicCBpbiBwZGZUZVggYW5kIEx1YVRlWFxuXG59OyAvLyBEaWN0aW9uYXJ5IG9mIHJlbGF0aXZlIHVuaXRzLCBmb3IgZmFzdCB2YWxpZGl0eSB0ZXN0aW5nLlxuXG52YXIgcmVsYXRpdmVVbml0ID0ge1xuICBcImV4XCI6IHRydWUsXG4gIFwiZW1cIjogdHJ1ZSxcbiAgXCJtdVwiOiB0cnVlXG59O1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgdW5pdCAoZWl0aGVyIGEgc3RyaW5nIGRlZmluaW5nIHRoZSB1bml0XG4gKiBvciBhIFwic2l6ZVwiIHBhcnNlIG5vZGUgY29udGFpbmluZyBhIHVuaXQgZmllbGQpIGlzIHZhbGlkLlxuICovXG52YXIgdmFsaWRVbml0ID0gZnVuY3Rpb24gdmFsaWRVbml0KHVuaXQpIHtcbiAgaWYgKHR5cGVvZiB1bml0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdW5pdCA9IHVuaXQudW5pdDtcbiAgfVxuXG4gIHJldHVybiB1bml0IGluIHB0UGVyVW5pdCB8fCB1bml0IGluIHJlbGF0aXZlVW5pdCB8fCB1bml0ID09PSBcImV4XCI7XG59O1xuLypcbiAqIENvbnZlcnQgYSBcInNpemVcIiBwYXJzZSBub2RlICh3aXRoIG51bWVyaWMgXCJudW1iZXJcIiBhbmQgc3RyaW5nIFwidW5pdFwiIGZpZWxkcyxcbiAqIGFzIHBhcnNlZCBieSBmdW5jdGlvbnMuanMgYXJnVHlwZSBcInNpemVcIikgaW50byBhIENTUyBlbSB2YWx1ZSBmb3IgdGhlXG4gKiBjdXJyZW50IHN0eWxlL3NjYWxlLiAgYG9wdGlvbnNgIGdpdmVzIHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gKi9cblxudmFyIHVuaXRzX2NhbGN1bGF0ZVNpemUgPSBmdW5jdGlvbiBjYWxjdWxhdGVTaXplKHNpemVWYWx1ZSwgb3B0aW9ucykge1xuICB2YXIgc2NhbGU7XG5cbiAgaWYgKHNpemVWYWx1ZS51bml0IGluIHB0UGVyVW5pdCkge1xuICAgIC8vIEFic29sdXRlIHVuaXRzXG4gICAgc2NhbGUgPSBwdFBlclVuaXRbc2l6ZVZhbHVlLnVuaXRdIC8vIENvbnZlcnQgdW5pdCB0byBwdFxuICAgIC8gb3B0aW9ucy5mb250TWV0cmljcygpLnB0UGVyRW0gLy8gQ29udmVydCBwdCB0byBDU1MgZW1cbiAgICAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7IC8vIFVuc2NhbGUgdG8gbWFrZSBhYnNvbHV0ZSB1bml0c1xuICB9IGVsc2UgaWYgKHNpemVWYWx1ZS51bml0ID09PSBcIm11XCIpIHtcbiAgICAvLyBgbXVgIHVuaXRzIHNjYWxlIHdpdGggc2NyaXB0c3R5bGUvc2NyaXB0c2NyaXB0c3R5bGUuXG4gICAgc2NhbGUgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuY3NzRW1QZXJNdTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlciByZWxhdGl2ZSB1bml0cyBhbHdheXMgcmVmZXIgdG8gdGhlICp0ZXh0c3R5bGUqIGZvbnRcbiAgICAvLyBpbiB0aGUgY3VycmVudCBzaXplLlxuICAgIHZhciB1bml0T3B0aW9ucztcblxuICAgIGlmIChvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgLy8gaXNUaWdodCgpIG1lYW5zIGN1cnJlbnQgc3R5bGUgaXMgc2NyaXB0L3NjcmlwdHNjcmlwdC5cbiAgICAgIHVuaXRPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnRleHQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRPcHRpb25zID0gb3B0aW9ucztcbiAgICB9IC8vIFRPRE86IEluIFRlWCB0aGVzZSB1bml0cyBhcmUgcmVsYXRpdmUgdG8gdGhlIHF1YWQgb2YgdGhlIGN1cnJlbnRcbiAgICAvLyAqdGV4dCogZm9udCwgZS5nLiBjbXIxMC4gS2FUZVggaW5zdGVhZCB1c2VzIHZhbHVlcyBmcm9tIHRoZVxuICAgIC8vIGNvbXBhcmFibHktc2l6ZWQgKkNvbXB1dGVyIE1vZGVybiBzeW1ib2wqIGZvbnQuIEF0IDEwcHQsIHRoZXNlXG4gICAgLy8gbWF0Y2guIEF0IDdwdCBhbmQgNXB0LCB0aGV5IGRpZmZlcjogY21yNz0xLjEzODg5NCwgY21zeTc9MS4xNzA2NDE7XG4gICAgLy8gY21yNT0xLjM2MTEzMywgY21zeTU9MS40NzIyNDEuIENvbnNpZGVyICRcXHNjcmlwdHNpemUgYVxca2VybjFlbWIkLlxuICAgIC8vIFRlWCBcXHNob3dsaXN0cyBzaG93cyBhIGtlcm4gb2YgMS4xMzg4OSAqIGZvbnRzaXplO1xuICAgIC8vIEthVGVYIHNob3dzIGEga2VybiBvZiAxLjE3MSAqIGZvbnRzaXplLlxuXG5cbiAgICBpZiAoc2l6ZVZhbHVlLnVuaXQgPT09IFwiZXhcIikge1xuICAgICAgc2NhbGUgPSB1bml0T3B0aW9ucy5mb250TWV0cmljcygpLnhIZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChzaXplVmFsdWUudW5pdCA9PT0gXCJlbVwiKSB7XG4gICAgICBzY2FsZSA9IHVuaXRPcHRpb25zLmZvbnRNZXRyaWNzKCkucXVhZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBzaXplVmFsdWUudW5pdCArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICBpZiAodW5pdE9wdGlvbnMgIT09IG9wdGlvbnMpIHtcbiAgICAgIHNjYWxlICo9IHVuaXRPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTWF0aC5taW4oc2l6ZVZhbHVlLm51bWJlciAqIHNjYWxlLCBvcHRpb25zLm1heFNpemUpO1xufTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2J1aWxkQ29tbW9uLmpzXG4vKiBlc2xpbnQgbm8tY29uc29sZTowICovXG5cbi8qKlxuICogVGhpcyBtb2R1bGUgY29udGFpbnMgZ2VuZXJhbCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYnVpbGRpbmdcbiAqIGRpZmZlcmVudCBraW5kcyBvZiBkb21UcmVlIG5vZGVzIGluIGEgY29uc2lzdGVudCBtYW5uZXIuXG4gKi9cblxuXG5cblxuXG5cblxuLy8gVGhlIGZvbGxvd2luZyBoYXZlIHRvIGJlIGxvYWRlZCBmcm9tIE1haW4tSXRhbGljIGZvbnQsIHVzaW5nIGNsYXNzIG1hdGhpdFxudmFyIG1hdGhpdExldHRlcnMgPSBbXCJcXFxcaW1hdGhcIiwgXCLEsVwiLCAvLyBkb3RsZXNzIGlcblwiXFxcXGptYXRoXCIsIFwiyLdcIiwgLy8gZG90bGVzcyBqXG5cIlxcXFxwb3VuZHNcIiwgXCJcXFxcbWF0aHN0ZXJsaW5nXCIsIFwiXFxcXHRleHRzdGVybGluZ1wiLCBcIsKjXCJdO1xuLyoqXG4gKiBMb29rcyB1cCB0aGUgZ2l2ZW4gc3ltYm9sIGluIGZvbnRNZXRyaWNzLCBhZnRlciBhcHBseWluZyBhbnkgc3ltYm9sXG4gKiByZXBsYWNlbWVudHMgZGVmaW5lZCBpbiBzeW1ib2wuanNcbiAqL1xuXG52YXIgYnVpbGRDb21tb25fbG9va3VwU3ltYm9sID0gZnVuY3Rpb24gbG9va3VwU3ltYm9sKHZhbHVlLCAvLyBUT0RPKCM5NjMpOiBVc2UgYSB1bmlvbiB0eXBlIGZvciB0aGlzLlxuZm9udE5hbWUsIG1vZGUpIHtcbiAgLy8gUmVwbGFjZSB0aGUgdmFsdWUgd2l0aCBpdHMgcmVwbGFjZWQgdmFsdWUgZnJvbSBzeW1ib2wuanNcbiAgaWYgKHNyY19zeW1ib2xzW21vZGVdW3ZhbHVlXSAmJiBzcmNfc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZSkge1xuICAgIHZhbHVlID0gc3JjX3N5bWJvbHNbbW9kZV1bdmFsdWVdLnJlcGxhY2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBtZXRyaWNzOiBnZXRDaGFyYWN0ZXJNZXRyaWNzKHZhbHVlLCBmb250TmFtZSwgbW9kZSlcbiAgfTtcbn07XG4vKipcbiAqIE1ha2VzIGEgc3ltYm9sTm9kZSBhZnRlciB0cmFuc2xhdGlvbiB2aWEgdGhlIGxpc3Qgb2Ygc3ltYm9scyBpbiBzeW1ib2xzLmpzLlxuICogQ29ycmVjdGx5IHB1bGxzIG91dCBtZXRyaWNzIGZvciB0aGUgY2hhcmFjdGVyLCBhbmQgb3B0aW9uYWxseSB0YWtlcyBhIGxpc3Qgb2ZcbiAqIGNsYXNzZXMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIG5vZGUuXG4gKlxuICogVE9ETzogbWFrZSBhcmd1bWVudCBvcmRlciBjbG9zZXIgdG8gbWFrZVNwYW5cbiAqIFRPRE86IGFkZCBhIHNlcGFyYXRlIGFyZ3VtZW50IGZvciBtYXRoIGNsYXNzIChlLmcuIGBtb3BgLCBgbWJpbmApLCB3aGljaFxuICogc2hvdWxkIGlmIHByZXNlbnQgY29tZSBmaXJzdCBpbiBgY2xhc3Nlc2AuXG4gKiBUT0RPKCM5NTMpOiBNYWtlIGBvcHRpb25zYCBtYW5kYXRvcnkgYW5kIGFsd2F5cyBwYXNzIGl0IGluLlxuICovXG5cblxudmFyIGJ1aWxkQ29tbW9uX21ha2VTeW1ib2wgPSBmdW5jdGlvbiBtYWtlU3ltYm9sKHZhbHVlLCBmb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICB2YXIgbG9va3VwID0gYnVpbGRDb21tb25fbG9va3VwU3ltYm9sKHZhbHVlLCBmb250TmFtZSwgbW9kZSk7XG4gIHZhciBtZXRyaWNzID0gbG9va3VwLm1ldHJpY3M7XG4gIHZhbHVlID0gbG9va3VwLnZhbHVlO1xuICB2YXIgc3ltYm9sTm9kZTtcblxuICBpZiAobWV0cmljcykge1xuICAgIHZhciBpdGFsaWMgPSBtZXRyaWNzLml0YWxpYztcblxuICAgIGlmIChtb2RlID09PSBcInRleHRcIiB8fCBvcHRpb25zICYmIG9wdGlvbnMuZm9udCA9PT0gXCJtYXRoaXRcIikge1xuICAgICAgaXRhbGljID0gMDtcbiAgICB9XG5cbiAgICBzeW1ib2xOb2RlID0gbmV3IGRvbVRyZWVfU3ltYm9sTm9kZSh2YWx1ZSwgbWV0cmljcy5oZWlnaHQsIG1ldHJpY3MuZGVwdGgsIGl0YWxpYywgbWV0cmljcy5za2V3LCBtZXRyaWNzLndpZHRoLCBjbGFzc2VzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPKGVtaWx5KTogRmlndXJlIG91dCBhIGdvb2Qgd2F5IHRvIG9ubHkgcHJpbnQgdGhpcyBpbiBkZXZlbG9wbWVudFxuICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihcIk5vIGNoYXJhY3RlciBtZXRyaWNzIGZvciAnXCIgKyB2YWx1ZSArIFwiJyBpbiBzdHlsZSAnXCIgKyBmb250TmFtZSArIFwiJ1wiKTtcbiAgICBzeW1ib2xOb2RlID0gbmV3IGRvbVRyZWVfU3ltYm9sTm9kZSh2YWx1ZSwgMCwgMCwgMCwgMCwgMCwgY2xhc3Nlcyk7XG4gIH1cblxuICBpZiAob3B0aW9ucykge1xuICAgIHN5bWJvbE5vZGUubWF4Rm9udFNpemUgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgaWYgKG9wdGlvbnMuc3R5bGUuaXNUaWdodCgpKSB7XG4gICAgICBzeW1ib2xOb2RlLmNsYXNzZXMucHVzaChcIm10aWdodFwiKTtcbiAgICB9XG5cbiAgICB2YXIgY29sb3IgPSBvcHRpb25zLmdldENvbG9yKCk7XG5cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHN5bWJvbE5vZGUuc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ltYm9sTm9kZTtcbn07XG4vKipcbiAqIE1ha2VzIGEgc3ltYm9sIGluIE1haW4tUmVndWxhciBvciBBTVMtUmVndWxhci5cbiAqIFVzZWQgZm9yIHJlbCwgYmluLCBvcGVuLCBjbG9zZSwgaW5uZXIsIGFuZCBwdW5jdC5cbiAqXG4gKiBUT0RPKCM5NTMpOiBNYWtlIGBvcHRpb25zYCBtYW5kYXRvcnkgYW5kIGFsd2F5cyBwYXNzIGl0IGluLlxuICovXG5cblxudmFyIGJ1aWxkQ29tbW9uX21hdGhzeW0gPSBmdW5jdGlvbiBtYXRoc3ltKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gIGlmIChjbGFzc2VzID09PSB2b2lkIDApIHtcbiAgICBjbGFzc2VzID0gW107XG4gIH1cblxuICAvLyBEZWNpZGUgd2hhdCBmb250IHRvIHJlbmRlciB0aGUgc3ltYm9sIGluIGJ5IGl0cyBlbnRyeSBpbiB0aGUgc3ltYm9sc1xuICAvLyB0YWJsZS5cbiAgLy8gSGF2ZSBhIHNwZWNpYWwgY2FzZSBmb3Igd2hlbiB0aGUgdmFsdWUgPSBcXCBiZWNhdXNlIHRoZSBcXCBpcyB1c2VkIGFzIGFcbiAgLy8gdGV4dG9yZCBpbiB1bnN1cHBvcnRlZCBjb21tYW5kIGVycm9ycyBidXQgY2Fubm90IGJlIHBhcnNlZCBhcyBhIHJlZ3VsYXJcbiAgLy8gdGV4dCBvcmRpbmFsIGFuZCBpcyB0aGVyZWZvcmUgbm90IHByZXNlbnQgYXMgYSBzeW1ib2wgaW4gdGhlIHN5bWJvbHNcbiAgLy8gdGFibGUgZm9yIHRleHQsIGFzIHdlbGwgYXMgYSBzcGVjaWFsIGNhc2UgZm9yIGJvbGRzeW1ib2wgYmVjYXVzZSBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgYm9sZCArIGFuZCAtXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZm9udCAmJiBvcHRpb25zLmZvbnQgPT09IFwiYm9sZHN5bWJvbFwiICYmIGJ1aWxkQ29tbW9uX2xvb2t1cFN5bWJvbCh2YWx1ZSwgXCJNYWluLUJvbGRcIiwgbW9kZSkubWV0cmljcykge1xuICAgIHJldHVybiBidWlsZENvbW1vbl9tYWtlU3ltYm9sKHZhbHVlLCBcIk1haW4tQm9sZFwiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYXRoYmZcIl0pKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJcXFxcXCIgfHwgc3JjX3N5bWJvbHNbbW9kZV1bdmFsdWVdLmZvbnQgPT09IFwibWFpblwiKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uX21ha2VTeW1ib2wodmFsdWUsIFwiTWFpbi1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWlsZENvbW1vbl9tYWtlU3ltYm9sKHZhbHVlLCBcIkFNUy1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFtcImFtc3JtXCJdKSk7XG4gIH1cbn07XG4vKipcbiAqIERldGVybWluZXMgd2hpY2ggb2YgdGhlIHR3byBmb250IG5hbWVzIChNYWluLUl0YWxpYyBhbmQgTWF0aC1JdGFsaWMpIGFuZFxuICogY29ycmVzcG9uZGluZyBzdHlsZSB0YWdzIChtYWluZGVmYXVsdCBvciBtYXRoaXQpIHRvIHVzZSBmb3IgZGVmYXVsdCBtYXRoIGZvbnQsXG4gKiBkZXBlbmRpbmcgb24gdGhlIHN5bWJvbC5cbiAqL1xuXG5cbnZhciBidWlsZENvbW1vbl9tYXRoZGVmYXVsdCA9IGZ1bmN0aW9uIG1hdGhkZWZhdWx0KHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gIGlmICgvWzAtOV0vLnRlc3QodmFsdWUuY2hhckF0KDApKSB8fCAvLyBnbHlwaHMgZm9yIFxcaW1hdGggYW5kIFxcam1hdGggZG8gbm90IGV4aXN0IGluIE1hdGgtSXRhbGljIHNvIHdlXG4gIC8vIG5lZWQgdG8gdXNlIE1haW4tSXRhbGljIGluc3RlYWRcbiAgdXRpbHMuY29udGFpbnMobWF0aGl0TGV0dGVycywgdmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbnROYW1lOiBcIk1haW4tSXRhbGljXCIsXG4gICAgICBmb250Q2xhc3M6IFwibWF0aGl0XCJcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBmb250TmFtZTogXCJNYXRoLUl0YWxpY1wiLFxuICAgICAgZm9udENsYXNzOiBcIm1hdGhkZWZhdWx0XCJcbiAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoaWNoIG9mIHRoZSBmb250IG5hbWVzIChNYWluLUl0YWxpYywgTWF0aC1JdGFsaWMsIGFuZCBDYWxpZ3JhcGhpYylcbiAqIGFuZCBjb3JyZXNwb25kaW5nIHN0eWxlIHRhZ3MgKG1hdGhpdCwgbWF0aGRlZmF1bHQsIG9yIG1hdGhjYWwpIHRvIHVzZSBmb3IgZm9udFxuICogXCJtYXRobm9ybWFsXCIsIGRlcGVuZGluZyBvbiB0aGUgc3ltYm9sLiAgVXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBmb250TWFwIGZvclxuICogZm9udCBcIm1hdGhub3JtYWxcIi5cbiAqL1xuXG5cbnZhciBidWlsZENvbW1vbl9tYXRobm9ybWFsID0gZnVuY3Rpb24gbWF0aG5vcm1hbCh2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICBpZiAodXRpbHMuY29udGFpbnMobWF0aGl0TGV0dGVycywgdmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbnROYW1lOiBcIk1haW4tSXRhbGljXCIsXG4gICAgICBmb250Q2xhc3M6IFwibWF0aGl0XCJcbiAgICB9O1xuICB9IGVsc2UgaWYgKC9bMC05XS8udGVzdCh2YWx1ZS5jaGFyQXQoMCkpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbnROYW1lOiBcIkNhbGlncmFwaGljLVJlZ3VsYXJcIixcbiAgICAgIGZvbnRDbGFzczogXCJtYXRoY2FsXCJcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBmb250TmFtZTogXCJNYXRoLUl0YWxpY1wiLFxuICAgICAgZm9udENsYXNzOiBcIm1hdGhkZWZhdWx0XCJcbiAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoaWNoIG9mIHRoZSB0d28gZm9udCBuYW1lcyAoTWFpbi1Cb2xkIGFuZCBNYXRoLUJvbGRJdGFsaWMpIGFuZFxuICogY29ycmVzcG9uZGluZyBzdHlsZSB0YWdzIChtYXRoYmYgb3IgYm9sZHN5bWJvbCkgdG8gdXNlIGZvciBmb250IFwiYm9sZHN5bWJvbFwiLFxuICogZGVwZW5kaW5nIG9uIHRoZSBzeW1ib2wuICBVc2UgdGhpcyBmdW5jdGlvbiBpbnN0ZWFkIG9mIGZvbnRNYXAgZm9yIGZvbnRcbiAqIFwiYm9sZHN5bWJvbFwiLlxuICovXG5cblxudmFyIGJvbGRzeW1ib2wgPSBmdW5jdGlvbiBib2xkc3ltYm9sKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gIGlmIChidWlsZENvbW1vbl9sb29rdXBTeW1ib2wodmFsdWUsIFwiTWF0aC1Cb2xkSXRhbGljXCIsIG1vZGUpLm1ldHJpY3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9udE5hbWU6IFwiTWF0aC1Cb2xkSXRhbGljXCIsXG4gICAgICBmb250Q2xhc3M6IFwiYm9sZHN5bWJvbFwiXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTb21lIGdseXBocyBkbyBub3QgZXhpc3QgaW4gTWF0aC1Cb2xkSXRhbGljIHNvIHdlIG5lZWQgdG8gdXNlXG4gICAgLy8gTWFpbi1Cb2xkIGluc3RlYWQuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbnROYW1lOiBcIk1haW4tQm9sZFwiLFxuICAgICAgZm9udENsYXNzOiBcIm1hdGhiZlwiXG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogTWFrZXMgZWl0aGVyIGEgbWF0aG9yZCBvciB0ZXh0b3JkIGluIHRoZSBjb3JyZWN0IGZvbnQgYW5kIGNvbG9yLlxuICovXG5cblxudmFyIGJ1aWxkQ29tbW9uX21ha2VPcmQgPSBmdW5jdGlvbiBtYWtlT3JkKGdyb3VwLCBvcHRpb25zLCB0eXBlKSB7XG4gIHZhciBtb2RlID0gZ3JvdXAubW9kZTtcbiAgdmFyIHRleHQgPSBncm91cC50ZXh0O1xuICB2YXIgY2xhc3NlcyA9IFtcIm1vcmRcIl07IC8vIE1hdGggbW9kZSBvciBPbGQgZm9udCAoaS5lLiBcXHJtKVxuXG4gIHZhciBpc0ZvbnQgPSBtb2RlID09PSBcIm1hdGhcIiB8fCBtb2RlID09PSBcInRleHRcIiAmJiBvcHRpb25zLmZvbnQ7XG4gIHZhciBmb250T3JGYW1pbHkgPSBpc0ZvbnQgPyBvcHRpb25zLmZvbnQgOiBvcHRpb25zLmZvbnRGYW1pbHk7XG5cbiAgaWYgKHRleHQuY2hhckNvZGVBdCgwKSA9PT0gMHhEODM1KSB7XG4gICAgLy8gc3Vycm9nYXRlIHBhaXJzIGdldCBzcGVjaWFsIHRyZWF0bWVudFxuICAgIHZhciBfd2lkZUNoYXJhY3RlckZvbnQgPSB3aWRlX2NoYXJhY3Rlcl93aWRlQ2hhcmFjdGVyRm9udCh0ZXh0LCBtb2RlKSxcbiAgICAgICAgd2lkZUZvbnROYW1lID0gX3dpZGVDaGFyYWN0ZXJGb250WzBdLFxuICAgICAgICB3aWRlRm9udENsYXNzID0gX3dpZGVDaGFyYWN0ZXJGb250WzFdO1xuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uX21ha2VTeW1ib2wodGV4dCwgd2lkZUZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdCh3aWRlRm9udENsYXNzKSk7XG4gIH0gZWxzZSBpZiAoZm9udE9yRmFtaWx5KSB7XG4gICAgdmFyIGZvbnROYW1lO1xuICAgIHZhciBmb250Q2xhc3NlcztcblxuICAgIGlmIChmb250T3JGYW1pbHkgPT09IFwiYm9sZHN5bWJvbFwiIHx8IGZvbnRPckZhbWlseSA9PT0gXCJtYXRobm9ybWFsXCIpIHtcbiAgICAgIHZhciBmb250RGF0YSA9IGZvbnRPckZhbWlseSA9PT0gXCJib2xkc3ltYm9sXCIgPyBib2xkc3ltYm9sKHRleHQsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpIDogYnVpbGRDb21tb25fbWF0aG5vcm1hbCh0ZXh0LCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKTtcbiAgICAgIGZvbnROYW1lID0gZm9udERhdGEuZm9udE5hbWU7XG4gICAgICBmb250Q2xhc3NlcyA9IFtmb250RGF0YS5mb250Q2xhc3NdO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuY29udGFpbnMobWF0aGl0TGV0dGVycywgdGV4dCkpIHtcbiAgICAgIGZvbnROYW1lID0gXCJNYWluLUl0YWxpY1wiO1xuICAgICAgZm9udENsYXNzZXMgPSBbXCJtYXRoaXRcIl07XG4gICAgfSBlbHNlIGlmIChpc0ZvbnQpIHtcbiAgICAgIGZvbnROYW1lID0gZm9udE1hcFtmb250T3JGYW1pbHldLmZvbnROYW1lO1xuICAgICAgZm9udENsYXNzZXMgPSBbZm9udE9yRmFtaWx5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9udE5hbWUgPSByZXRyaWV2ZVRleHRGb250TmFtZShmb250T3JGYW1pbHksIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpO1xuICAgICAgZm9udENsYXNzZXMgPSBbZm9udE9yRmFtaWx5LCBvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlXTtcbiAgICB9XG5cbiAgICBpZiAoYnVpbGRDb21tb25fbG9va3VwU3ltYm9sKHRleHQsIGZvbnROYW1lLCBtb2RlKS5tZXRyaWNzKSB7XG4gICAgICByZXR1cm4gYnVpbGRDb21tb25fbWFrZVN5bWJvbCh0ZXh0LCBmb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoZm9udENsYXNzZXMpKTtcbiAgICB9IGVsc2UgaWYgKGxpZ2F0dXJlcy5oYXNPd25Qcm9wZXJ0eSh0ZXh0KSAmJiBmb250TmFtZS5zdWJzdHIoMCwgMTApID09PSBcIlR5cGV3cml0ZXJcIikge1xuICAgICAgLy8gRGVjb25zdHJ1Y3QgbGlnYXR1cmVzIGluIG1vbm9zcGFjZSBmb250cyAoXFx0ZXh0dHQsIFxcdHQpLlxuICAgICAgdmFyIHBhcnRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGJ1aWxkQ29tbW9uX21ha2VTeW1ib2wodGV4dFtpXSwgZm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KGZvbnRDbGFzc2VzKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVpbGRDb21tb25fbWFrZUZyYWdtZW50KHBhcnRzKTtcbiAgICB9XG4gIH0gLy8gTWFrZXMgYSBzeW1ib2wgaW4gdGhlIGRlZmF1bHQgZm9udCBmb3IgbWF0aG9yZHMgYW5kIHRleHRvcmRzLlxuXG5cbiAgaWYgKHR5cGUgPT09IFwibWF0aG9yZFwiKSB7XG4gICAgdmFyIGZvbnRMb29rdXAgPSBidWlsZENvbW1vbl9tYXRoZGVmYXVsdCh0ZXh0LCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb25fbWFrZVN5bWJvbCh0ZXh0LCBmb250TG9va3VwLmZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbZm9udExvb2t1cC5mb250Q2xhc3NdKSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ0ZXh0b3JkXCIpIHtcbiAgICB2YXIgZm9udCA9IHNyY19zeW1ib2xzW21vZGVdW3RleHRdICYmIHNyY19zeW1ib2xzW21vZGVdW3RleHRdLmZvbnQ7XG5cbiAgICBpZiAoZm9udCA9PT0gXCJhbXNcIikge1xuICAgICAgdmFyIF9mb250TmFtZSA9IHJldHJpZXZlVGV4dEZvbnROYW1lKFwiYW1zcm1cIiwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSk7XG5cbiAgICAgIHJldHVybiBidWlsZENvbW1vbl9tYWtlU3ltYm9sKHRleHQsIF9mb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoXCJhbXNybVwiLCBvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlKSk7XG4gICAgfSBlbHNlIGlmIChmb250ID09PSBcIm1haW5cIiB8fCAhZm9udCkge1xuICAgICAgdmFyIF9mb250TmFtZTIgPSByZXRyaWV2ZVRleHRGb250TmFtZShcInRleHRybVwiLCBvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlKTtcblxuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uX21ha2VTeW1ib2wodGV4dCwgX2ZvbnROYW1lMiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQob3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb250cyBhZGRlZCBieSBwbHVnaW5zXG4gICAgICB2YXIgX2ZvbnROYW1lMyA9IHJldHJpZXZlVGV4dEZvbnROYW1lKGZvbnQsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpOyAvLyBXZSBhZGQgZm9udCBuYW1lIGFzIGEgY3NzIGNsYXNzXG5cblxuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uX21ha2VTeW1ib2wodGV4dCwgX2ZvbnROYW1lMywgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoX2ZvbnROYW1lMywgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIHR5cGU6IFwiICsgdHlwZSArIFwiIGluIG1ha2VPcmRcIik7XG4gIH1cbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBzdWJzZXF1ZW50IHN5bWJvbE5vZGVzIGhhdmUgdGhlIHNhbWUgY2xhc3Nlcywgc2tldywgbWF4Rm9udCxcbiAqIGFuZCBzdHlsZXMuXG4gKi9cblxuXG52YXIgYnVpbGRDb21tb25fY2FuQ29tYmluZSA9IGZ1bmN0aW9uIGNhbkNvbWJpbmUocHJldiwgbmV4dCkge1xuICBpZiAoY3JlYXRlQ2xhc3MocHJldi5jbGFzc2VzKSAhPT0gY3JlYXRlQ2xhc3MobmV4dC5jbGFzc2VzKSB8fCBwcmV2LnNrZXcgIT09IG5leHQuc2tldyB8fCBwcmV2Lm1heEZvbnRTaXplICE9PSBuZXh0Lm1heEZvbnRTaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgc3R5bGUgaW4gcHJldi5zdHlsZSkge1xuICAgIGlmIChwcmV2LnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSAmJiBwcmV2LnN0eWxlW3N0eWxlXSAhPT0gbmV4dC5zdHlsZVtzdHlsZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfc3R5bGUgaW4gbmV4dC5zdHlsZSkge1xuICAgIGlmIChuZXh0LnN0eWxlLmhhc093blByb3BlcnR5KF9zdHlsZSkgJiYgcHJldi5zdHlsZVtfc3R5bGVdICE9PSBuZXh0LnN0eWxlW19zdHlsZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIENvbWJpbmUgY29uc2VxdWV0aXZlIGRvbVRyZWUuc3ltYm9sTm9kZXMgaW50byBhIHNpbmdsZSBzeW1ib2xOb2RlLlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBhcmd1bWVudC5cbiAqL1xuXG5cbnZhciBidWlsZENvbW1vbl90cnlDb21iaW5lQ2hhcnMgPSBmdW5jdGlvbiB0cnlDb21iaW5lQ2hhcnMoY2hhcnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB2YXIgcHJldiA9IGNoYXJzW2ldO1xuICAgIHZhciBuZXh0ID0gY2hhcnNbaSArIDFdO1xuXG4gICAgaWYgKHByZXYgaW5zdGFuY2VvZiBkb21UcmVlX1N5bWJvbE5vZGUgJiYgbmV4dCBpbnN0YW5jZW9mIGRvbVRyZWVfU3ltYm9sTm9kZSAmJiBidWlsZENvbW1vbl9jYW5Db21iaW5lKHByZXYsIG5leHQpKSB7XG4gICAgICBwcmV2LnRleHQgKz0gbmV4dC50ZXh0O1xuICAgICAgcHJldi5oZWlnaHQgPSBNYXRoLm1heChwcmV2LmhlaWdodCwgbmV4dC5oZWlnaHQpO1xuICAgICAgcHJldi5kZXB0aCA9IE1hdGgubWF4KHByZXYuZGVwdGgsIG5leHQuZGVwdGgpOyAvLyBVc2UgdGhlIGxhc3QgY2hhcmFjdGVyJ3MgaXRhbGljIGNvcnJlY3Rpb24gc2luY2Ugd2UgdXNlXG4gICAgICAvLyBpdCB0byBhZGQgcGFkZGluZyB0byB0aGUgcmlnaHQgb2YgdGhlIHNwYW4gY3JlYXRlZCBmcm9tXG4gICAgICAvLyB0aGUgY29tYmluZWQgY2hhcmFjdGVycy5cblxuICAgICAgcHJldi5pdGFsaWMgPSBuZXh0Lml0YWxpYztcbiAgICAgIGNoYXJzLnNwbGljZShpICsgMSwgMSk7XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoYXJzO1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBoZWlnaHQsIGRlcHRoLCBhbmQgbWF4Rm9udFNpemUgb2YgYW4gZWxlbWVudCBiYXNlZCBvbiBpdHNcbiAqIGNoaWxkcmVuLlxuICovXG5cblxudmFyIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuID0gZnVuY3Rpb24gc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oZWxlbSkge1xuICB2YXIgaGVpZ2h0ID0gMDtcbiAgdmFyIGRlcHRoID0gMDtcbiAgdmFyIG1heEZvbnRTaXplID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW0uY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBlbGVtLmNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKGNoaWxkLmhlaWdodCA+IGhlaWdodCkge1xuICAgICAgaGVpZ2h0ID0gY2hpbGQuaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChjaGlsZC5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IGNoaWxkLmRlcHRoO1xuICAgIH1cblxuICAgIGlmIChjaGlsZC5tYXhGb250U2l6ZSA+IG1heEZvbnRTaXplKSB7XG4gICAgICBtYXhGb250U2l6ZSA9IGNoaWxkLm1heEZvbnRTaXplO1xuICAgIH1cbiAgfVxuXG4gIGVsZW0uaGVpZ2h0ID0gaGVpZ2h0O1xuICBlbGVtLmRlcHRoID0gZGVwdGg7XG4gIGVsZW0ubWF4Rm9udFNpemUgPSBtYXhGb250U2l6ZTtcbn07XG4vKipcbiAqIE1ha2VzIGEgc3BhbiB3aXRoIHRoZSBnaXZlbiBsaXN0IG9mIGNsYXNzZXMsIGxpc3Qgb2YgY2hpbGRyZW4sIGFuZCBvcHRpb25zLlxuICpcbiAqIFRPRE8oIzk1Myk6IEVuc3VyZSB0aGF0IGBvcHRpb25zYCBpcyBhbHdheXMgcHJvdmlkZWQgKGN1cnJlbnRseSBzb21lIGNhbGxcbiAqIHNpdGVzIGRvbid0IHBhc3MgaXQpIGFuZCBtYWtlIHRoZSB0eXBlIGJlbG93IG1hbmRhdG9yeS5cbiAqIFRPRE86IGFkZCBhIHNlcGFyYXRlIGFyZ3VtZW50IGZvciBtYXRoIGNsYXNzIChlLmcuIGBtb3BgLCBgbWJpbmApLCB3aGljaFxuICogc2hvdWxkIGlmIHByZXNlbnQgY29tZSBmaXJzdCBpbiBgY2xhc3Nlc2AuXG4gKi9cblxuXG52YXIgYnVpbGRDb21tb25fbWFrZVNwYW4gPSBmdW5jdGlvbiBtYWtlU3BhbihjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucywgc3R5bGUpIHtcbiAgdmFyIHNwYW4gPSBuZXcgZG9tVHJlZV9TcGFuKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSk7XG4gIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKHNwYW4pO1xuICByZXR1cm4gc3Bhbjtcbn07IC8vIFNWRyBvbmUgaXMgc2ltcGxlciAtLSBkb2Vzbid0IHJlcXVpcmUgaGVpZ2h0LCBkZXB0aCwgbWF4LWZvbnQgc2V0dGluZy5cbi8vIFRoaXMgaXMgYWxzbyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgdHlwZXNhZmV0eS5cblxuXG52YXIgYnVpbGRDb21tb25fbWFrZVN2Z1NwYW4gPSBmdW5jdGlvbiBtYWtlU3ZnU3BhbihjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucywgc3R5bGUpIHtcbiAgcmV0dXJuIG5ldyBkb21UcmVlX1NwYW4oY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMsIHN0eWxlKTtcbn07XG5cbnZhciBtYWtlTGluZVNwYW4gPSBmdW5jdGlvbiBtYWtlTGluZVNwYW4oY2xhc3NOYW1lLCBvcHRpb25zLCB0aGlja25lc3MpIHtcbiAgdmFyIGxpbmUgPSBidWlsZENvbW1vbl9tYWtlU3BhbihbY2xhc3NOYW1lXSwgW10sIG9wdGlvbnMpO1xuICBsaW5lLmhlaWdodCA9IHRoaWNrbmVzcyB8fCBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3M7XG4gIGxpbmUuc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBsaW5lLmhlaWdodCArIFwiZW1cIjtcbiAgbGluZS5tYXhGb250U2l6ZSA9IDEuMDtcbiAgcmV0dXJuIGxpbmU7XG59O1xuLyoqXG4gKiBNYWtlcyBhbiBhbmNob3Igd2l0aCB0aGUgZ2l2ZW4gaHJlZiwgbGlzdCBvZiBjbGFzc2VzLCBsaXN0IG9mIGNoaWxkcmVuLFxuICogYW5kIG9wdGlvbnMuXG4gKi9cblxuXG52YXIgYnVpbGRDb21tb25fbWFrZUFuY2hvciA9IGZ1bmN0aW9uIG1ha2VBbmNob3IoaHJlZiwgY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgdmFyIGFuY2hvciA9IG5ldyBkb21UcmVlX0FuY2hvcihocmVmLCBjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucyk7XG4gIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKGFuY2hvcik7XG4gIHJldHVybiBhbmNob3I7XG59O1xuLyoqXG4gKiBNYWtlcyBhIGRvY3VtZW50IGZyYWdtZW50IHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG52YXIgYnVpbGRDb21tb25fbWFrZUZyYWdtZW50ID0gZnVuY3Rpb24gbWFrZUZyYWdtZW50KGNoaWxkcmVuKSB7XG4gIHZhciBmcmFnbWVudCA9IG5ldyB0cmVlX0RvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pO1xuICBzaXplRWxlbWVudEZyb21DaGlsZHJlbihmcmFnbWVudCk7XG4gIHJldHVybiBmcmFnbWVudDtcbn07XG4vKipcbiAqIFdyYXBzIGdyb3VwIGluIGEgc3BhbiBpZiBpdCdzIGEgZG9jdW1lbnQgZnJhZ21lbnQsIGFsbG93aW5nIHRvIGFwcGx5IGNsYXNzZXNcbiAqIGFuZCBzdHlsZXNcbiAqL1xuXG5cbnZhciBidWlsZENvbW1vbl93cmFwRnJhZ21lbnQgPSBmdW5jdGlvbiB3cmFwRnJhZ21lbnQoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgaWYgKGdyb3VwIGluc3RhbmNlb2YgdHJlZV9Eb2N1bWVudEZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uX21ha2VTcGFuKFtdLCBbZ3JvdXBdLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBncm91cDtcbn07IC8vIFRoZXNlIGFyZSBleGFjdCBvYmplY3QgdHlwZXMgdG8gY2F0Y2ggdHlwb3MgaW4gdGhlIG5hbWVzIG9mIHRoZSBvcHRpb25hbCBmaWVsZHMuXG5cblxuLy8gQ29tcHV0ZXMgdGhlIHVwZGF0ZWQgYGNoaWxkcmVuYCBsaXN0IGFuZCB0aGUgb3ZlcmFsbCBkZXB0aC5cbi8vXG4vLyBUaGlzIGhlbHBlciBmdW5jdGlvbiBmb3IgbWFrZVZMaXN0IG1ha2VzIGl0IGVhc2llciB0byBlbmZvcmNlIHR5cGUgc2FmZXR5IGJ5XG4vLyBhbGxvd2luZyBlYXJseSBleGl0cyAocmV0dXJucykgaW4gdGhlIGxvZ2ljLlxudmFyIGdldFZMaXN0Q2hpbGRyZW5BbmREZXB0aCA9IGZ1bmN0aW9uIGdldFZMaXN0Q2hpbGRyZW5BbmREZXB0aChwYXJhbXMpIHtcbiAgaWYgKHBhcmFtcy5wb3NpdGlvblR5cGUgPT09IFwiaW5kaXZpZHVhbFNoaWZ0XCIpIHtcbiAgICB2YXIgb2xkQ2hpbGRyZW4gPSBwYXJhbXMuY2hpbGRyZW47XG4gICAgdmFyIGNoaWxkcmVuID0gW29sZENoaWxkcmVuWzBdXTsgLy8gQWRkIGluIGtlcm5zIHRvIHRoZSBsaXN0IG9mIHBhcmFtcy5jaGlsZHJlbiB0byBnZXQgZWFjaCBlbGVtZW50IHRvIGJlXG4gICAgLy8gc2hpZnRlZCB0byB0aGUgY29ycmVjdCBzcGVjaWZpZWQgc2hpZnRcblxuICAgIHZhciBfZGVwdGggPSAtb2xkQ2hpbGRyZW5bMF0uc2hpZnQgLSBvbGRDaGlsZHJlblswXS5lbGVtLmRlcHRoO1xuXG4gICAgdmFyIGN1cnJQb3MgPSBfZGVwdGg7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGlmZiA9IC1vbGRDaGlsZHJlbltpXS5zaGlmdCAtIGN1cnJQb3MgLSBvbGRDaGlsZHJlbltpXS5lbGVtLmRlcHRoO1xuICAgICAgdmFyIHNpemUgPSBkaWZmIC0gKG9sZENoaWxkcmVuW2kgLSAxXS5lbGVtLmhlaWdodCArIG9sZENoaWxkcmVuW2kgLSAxXS5lbGVtLmRlcHRoKTtcbiAgICAgIGN1cnJQb3MgPSBjdXJyUG9zICsgZGlmZjtcbiAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgfSk7XG4gICAgICBjaGlsZHJlbi5wdXNoKG9sZENoaWxkcmVuW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgZGVwdGg6IF9kZXB0aFxuICAgIH07XG4gIH1cblxuICB2YXIgZGVwdGg7XG5cbiAgaWYgKHBhcmFtcy5wb3NpdGlvblR5cGUgPT09IFwidG9wXCIpIHtcbiAgICAvLyBXZSBhbHdheXMgc3RhcnQgYXQgdGhlIGJvdHRvbSwgc28gY2FsY3VsYXRlIHRoZSBib3R0b20gYnkgYWRkaW5nIHVwXG4gICAgLy8gYWxsIHRoZSBzaXplc1xuICAgIHZhciBib3R0b20gPSBwYXJhbXMucG9zaXRpb25EYXRhO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBhcmFtcy5jaGlsZHJlbi5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmFtcy5jaGlsZHJlbltfaV07XG4gICAgICBib3R0b20gLT0gY2hpbGQudHlwZSA9PT0gXCJrZXJuXCIgPyBjaGlsZC5zaXplIDogY2hpbGQuZWxlbS5oZWlnaHQgKyBjaGlsZC5lbGVtLmRlcHRoO1xuICAgIH1cblxuICAgIGRlcHRoID0gYm90dG9tO1xuICB9IGVsc2UgaWYgKHBhcmFtcy5wb3NpdGlvblR5cGUgPT09IFwiYm90dG9tXCIpIHtcbiAgICBkZXB0aCA9IC1wYXJhbXMucG9zaXRpb25EYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaXJzdENoaWxkID0gcGFyYW1zLmNoaWxkcmVuWzBdO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQudHlwZSAhPT0gXCJlbGVtXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgY2hpbGQgbXVzdCBoYXZlIHR5cGUgXCJlbGVtXCIuJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5wb3NpdGlvblR5cGUgPT09IFwic2hpZnRcIikge1xuICAgICAgZGVwdGggPSAtZmlyc3RDaGlsZC5lbGVtLmRlcHRoIC0gcGFyYW1zLnBvc2l0aW9uRGF0YTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5wb3NpdGlvblR5cGUgPT09IFwiZmlyc3RCYXNlbGluZVwiKSB7XG4gICAgICBkZXB0aCA9IC1maXJzdENoaWxkLmVsZW0uZGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcG9zaXRpb25UeXBlIFwiICsgcGFyYW1zLnBvc2l0aW9uVHlwZSArIFwiLlwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNoaWxkcmVuOiBwYXJhbXMuY2hpbGRyZW4sXG4gICAgZGVwdGg6IGRlcHRoXG4gIH07XG59O1xuLyoqXG4gKiBNYWtlcyBhIHZlcnRpY2FsIGxpc3QgYnkgc3RhY2tpbmcgZWxlbWVudHMgYW5kIGtlcm5zIG9uIHRvcCBvZiBlYWNoIG90aGVyLlxuICogQWxsb3dzIGZvciBtYW55IGRpZmZlcmVudCB3YXlzIG9mIHNwZWNpZnlpbmcgdGhlIHBvc2l0aW9uaW5nIG1ldGhvZC5cbiAqXG4gKiBTZWUgVkxpc3RQYXJhbSBkb2N1bWVudGF0aW9uIGFib3ZlLlxuICovXG5cblxudmFyIGJ1aWxkQ29tbW9uX21ha2VWTGlzdCA9IGZ1bmN0aW9uIG1ha2VWTGlzdChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgdmFyIF9nZXRWTGlzdENoaWxkcmVuQW5kRCA9IGdldFZMaXN0Q2hpbGRyZW5BbmREZXB0aChwYXJhbXMpLFxuICAgICAgY2hpbGRyZW4gPSBfZ2V0Vkxpc3RDaGlsZHJlbkFuZEQuY2hpbGRyZW4sXG4gICAgICBkZXB0aCA9IF9nZXRWTGlzdENoaWxkcmVuQW5kRC5kZXB0aDsgLy8gQ3JlYXRlIGEgc3RydXQgdGhhdCBpcyB0YWxsZXIgdGhhbiBhbnkgbGlzdCBpdGVtLiBUaGUgc3RydXQgaXMgYWRkZWQgdG9cbiAgLy8gZWFjaCBpdGVtLCB3aGVyZSBpdCB3aWxsIGRldGVybWluZSB0aGUgaXRlbSdzIGJhc2VsaW5lLiBTaW5jZSBpdCBoYXNcbiAgLy8gYG92ZXJmbG93OmhpZGRlbmAsIHRoZSBzdHJ1dCdzIHRvcCBlZGdlIHdpbGwgc2l0IG9uIHRoZSBpdGVtJ3MgbGluZSBib3gnc1xuICAvLyB0b3AgZWRnZSBhbmQgdGhlIHN0cnV0J3MgYm90dG9tIGVkZ2Ugd2lsbCBzaXQgb24gdGhlIGl0ZW0ncyBiYXNlbGluZSxcbiAgLy8gd2l0aCBubyBhZGRpdGlvbmFsIGxpbmUtaGVpZ2h0IHNwYWNpbmcuIFRoaXMgYWxsb3dzIHRoZSBpdGVtIGJhc2VsaW5lIHRvXG4gIC8vIGJlIHBvc2l0aW9uZWQgcHJlY2lzZWx5IHdpdGhvdXQgd29ycnlpbmcgYWJvdXQgZm9udCBhc2NlbnQgYW5kXG4gIC8vIGxpbmUtaGVpZ2h0LlxuXG5cbiAgdmFyIHBzdHJ1dFNpemUgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgIGlmIChjaGlsZC50eXBlID09PSBcImVsZW1cIikge1xuICAgICAgdmFyIGVsZW0gPSBjaGlsZC5lbGVtO1xuICAgICAgcHN0cnV0U2l6ZSA9IE1hdGgubWF4KHBzdHJ1dFNpemUsIGVsZW0ubWF4Rm9udFNpemUsIGVsZW0uaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBwc3RydXRTaXplICs9IDI7XG4gIHZhciBwc3RydXQgPSBidWlsZENvbW1vbl9tYWtlU3BhbihbXCJwc3RydXRcIl0sIFtdKTtcbiAgcHN0cnV0LnN0eWxlLmhlaWdodCA9IHBzdHJ1dFNpemUgKyBcImVtXCI7IC8vIENyZWF0ZSBhIG5ldyBsaXN0IG9mIGFjdHVhbCBjaGlsZHJlbiBhdCB0aGUgY29ycmVjdCBvZmZzZXRzXG5cbiAgdmFyIHJlYWxDaGlsZHJlbiA9IFtdO1xuICB2YXIgbWluUG9zID0gZGVwdGg7XG4gIHZhciBtYXhQb3MgPSBkZXB0aDtcbiAgdmFyIGN1cnJQb3MgPSBkZXB0aDtcblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBjaGlsZHJlbi5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9jaGlsZCA9IGNoaWxkcmVuW19pMl07XG5cbiAgICBpZiAoX2NoaWxkLnR5cGUgPT09IFwia2VyblwiKSB7XG4gICAgICBjdXJyUG9zICs9IF9jaGlsZC5zaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2VsZW0gPSBfY2hpbGQuZWxlbTtcbiAgICAgIHZhciBjbGFzc2VzID0gX2NoaWxkLndyYXBwZXJDbGFzc2VzIHx8IFtdO1xuICAgICAgdmFyIHN0eWxlID0gX2NoaWxkLndyYXBwZXJTdHlsZSB8fCB7fTtcbiAgICAgIHZhciBjaGlsZFdyYXAgPSBidWlsZENvbW1vbl9tYWtlU3BhbihjbGFzc2VzLCBbcHN0cnV0LCBfZWxlbV0sIHVuZGVmaW5lZCwgc3R5bGUpO1xuICAgICAgY2hpbGRXcmFwLnN0eWxlLnRvcCA9IC1wc3RydXRTaXplIC0gY3VyclBvcyAtIF9lbGVtLmRlcHRoICsgXCJlbVwiO1xuXG4gICAgICBpZiAoX2NoaWxkLm1hcmdpbkxlZnQpIHtcbiAgICAgICAgY2hpbGRXcmFwLnN0eWxlLm1hcmdpbkxlZnQgPSBfY2hpbGQubWFyZ2luTGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKF9jaGlsZC5tYXJnaW5SaWdodCkge1xuICAgICAgICBjaGlsZFdyYXAuc3R5bGUubWFyZ2luUmlnaHQgPSBfY2hpbGQubWFyZ2luUmlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHJlYWxDaGlsZHJlbi5wdXNoKGNoaWxkV3JhcCk7XG4gICAgICBjdXJyUG9zICs9IF9lbGVtLmhlaWdodCArIF9lbGVtLmRlcHRoO1xuICAgIH1cblxuICAgIG1pblBvcyA9IE1hdGgubWluKG1pblBvcywgY3VyclBvcyk7XG4gICAgbWF4UG9zID0gTWF0aC5tYXgobWF4UG9zLCBjdXJyUG9zKTtcbiAgfSAvLyBUaGUgdmxpc3QgY29udGVudHMgZ28gaW4gYSB0YWJsZS1jZWxsIHdpdGggYHZlcnRpY2FsLWFsaWduOmJvdHRvbWAuXG4gIC8vIFRoaXMgY2VsbCdzIGJvdHRvbSBlZGdlIHdpbGwgZGV0ZXJtaW5lIHRoZSBjb250YWluaW5nIHRhYmxlJ3MgYmFzZWxpbmVcbiAgLy8gd2l0aG91dCBvdmVybHkgZXhwYW5kaW5nIHRoZSBjb250YWluaW5nIGxpbmUtYm94LlxuXG5cbiAgdmFyIHZsaXN0ID0gYnVpbGRDb21tb25fbWFrZVNwYW4oW1widmxpc3RcIl0sIHJlYWxDaGlsZHJlbik7XG4gIHZsaXN0LnN0eWxlLmhlaWdodCA9IG1heFBvcyArIFwiZW1cIjsgLy8gQSBzZWNvbmQgcm93IGlzIHVzZWQgaWYgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgdmxpc3QncyBkZXB0aC5cblxuICB2YXIgcm93cztcblxuICBpZiAobWluUG9zIDwgMCkge1xuICAgIC8vIFdlIHdpbGwgZGVmaW5lIGRlcHRoIGluIGFuIGVtcHR5IHNwYW4gd2l0aCBkaXNwbGF5OiB0YWJsZS1jZWxsLlxuICAgIC8vIEl0IHNob3VsZCByZW5kZXIgd2l0aCB0aGUgaGVpZ2h0IHRoYXQgd2UgZGVmaW5lLiBCdXQgQ2hyb21lLCBpblxuICAgIC8vIGNvbnRlbnRlZGl0YWJsZSBtb2RlIG9ubHksIHRyZWF0cyB0aGF0IHNwYW4gYXMgaWYgaXQgY29udGFpbnMgc29tZVxuICAgIC8vIHRleHQgY29udGVudC4gQW5kIHRoYXQgbWluLWhlaWdodCBvdmVyLXJpZGVzIG91ciBkZXNpcmVkIGhlaWdodC5cbiAgICAvLyBTbyB3ZSBwdXQgYW5vdGhlciBlbXB0eSBzcGFuIGluc2lkZSB0aGUgZGVwdGggc3RydXQgc3Bhbi5cbiAgICB2YXIgZW1wdHlTcGFuID0gYnVpbGRDb21tb25fbWFrZVNwYW4oW10sIFtdKTtcbiAgICB2YXIgZGVwdGhTdHJ1dCA9IGJ1aWxkQ29tbW9uX21ha2VTcGFuKFtcInZsaXN0XCJdLCBbZW1wdHlTcGFuXSk7XG4gICAgZGVwdGhTdHJ1dC5zdHlsZS5oZWlnaHQgPSAtbWluUG9zICsgXCJlbVwiOyAvLyBTYWZhcmkgd2FudHMgdGhlIGZpcnN0IHJvdyB0byBoYXZlIGlubGluZSBjb250ZW50OyBvdGhlcndpc2UgaXRcbiAgICAvLyBwdXRzIHRoZSBib3R0b20gb2YgdGhlICpzZWNvbmQqIHJvdyBvbiB0aGUgYmFzZWxpbmUuXG5cbiAgICB2YXIgdG9wU3RydXQgPSBidWlsZENvbW1vbl9tYWtlU3BhbihbXCJ2bGlzdC1zXCJdLCBbbmV3IGRvbVRyZWVfU3ltYm9sTm9kZShcIlxcdTIwMEJcIildKTtcbiAgICByb3dzID0gW2J1aWxkQ29tbW9uX21ha2VTcGFuKFtcInZsaXN0LXJcIl0sIFt2bGlzdCwgdG9wU3RydXRdKSwgYnVpbGRDb21tb25fbWFrZVNwYW4oW1widmxpc3QtclwiXSwgW2RlcHRoU3RydXRdKV07XG4gIH0gZWxzZSB7XG4gICAgcm93cyA9IFtidWlsZENvbW1vbl9tYWtlU3BhbihbXCJ2bGlzdC1yXCJdLCBbdmxpc3RdKV07XG4gIH1cblxuICB2YXIgdnRhYmxlID0gYnVpbGRDb21tb25fbWFrZVNwYW4oW1widmxpc3QtdFwiXSwgcm93cyk7XG5cbiAgaWYgKHJvd3MubGVuZ3RoID09PSAyKSB7XG4gICAgdnRhYmxlLmNsYXNzZXMucHVzaChcInZsaXN0LXQyXCIpO1xuICB9XG5cbiAgdnRhYmxlLmhlaWdodCA9IG1heFBvcztcbiAgdnRhYmxlLmRlcHRoID0gLW1pblBvcztcbiAgcmV0dXJuIHZ0YWJsZTtcbn07IC8vIEdsdWUgaXMgYSBjb25jZXB0IGZyb20gVGVYIHdoaWNoIGlzIGEgZmxleGlibGUgc3BhY2UgYmV0d2VlbiBlbGVtZW50cyBpblxuLy8gZWl0aGVyIGEgdmVydGljYWwgb3IgaG9yaXpvbnRhbCBsaXN0LiBJbiBLYVRlWCwgYXQgbGVhc3QgZm9yIG5vdywgaXQnc1xuLy8gc3RhdGljIHNwYWNlIGJldHdlZW4gZWxlbWVudHMgaW4gYSBob3Jpem9udGFsIGxheW91dC5cblxuXG52YXIgYnVpbGRDb21tb25fbWFrZUdsdWUgPSBmdW5jdGlvbiBtYWtlR2x1ZShtZWFzdXJlbWVudCwgb3B0aW9ucykge1xuICAvLyBNYWtlIGFuIGVtcHR5IHNwYW4gZm9yIHRoZSBzcGFjZVxuICB2YXIgcnVsZSA9IGJ1aWxkQ29tbW9uX21ha2VTcGFuKFtcIm1zcGFjZVwiXSwgW10sIG9wdGlvbnMpO1xuICB2YXIgc2l6ZSA9IHVuaXRzX2NhbGN1bGF0ZVNpemUobWVhc3VyZW1lbnQsIG9wdGlvbnMpO1xuICBydWxlLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2l6ZSArIFwiZW1cIjtcbiAgcmV0dXJuIHJ1bGU7XG59OyAvLyBUYWtlcyBmb250IG9wdGlvbnMsIGFuZCByZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSBmb250TG9va3VwIG5hbWVcblxuXG52YXIgcmV0cmlldmVUZXh0Rm9udE5hbWUgPSBmdW5jdGlvbiByZXRyaWV2ZVRleHRGb250TmFtZShmb250RmFtaWx5LCBmb250V2VpZ2h0LCBmb250U2hhcGUpIHtcbiAgdmFyIGJhc2VGb250TmFtZSA9IFwiXCI7XG5cbiAgc3dpdGNoIChmb250RmFtaWx5KSB7XG4gICAgY2FzZSBcImFtc3JtXCI6XG4gICAgICBiYXNlRm9udE5hbWUgPSBcIkFNU1wiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dHJtXCI6XG4gICAgICBiYXNlRm9udE5hbWUgPSBcIk1haW5cIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHRzZlwiOlxuICAgICAgYmFzZUZvbnROYW1lID0gXCJTYW5zU2VyaWZcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHR0dFwiOlxuICAgICAgYmFzZUZvbnROYW1lID0gXCJUeXBld3JpdGVyXCI7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBiYXNlRm9udE5hbWUgPSBmb250RmFtaWx5O1xuICAgIC8vIHVzZSBmb250cyBhZGRlZCBieSBhIHBsdWdpblxuICB9XG5cbiAgdmFyIGZvbnRTdHlsZXNOYW1lO1xuXG4gIGlmIChmb250V2VpZ2h0ID09PSBcInRleHRiZlwiICYmIGZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIikge1xuICAgIGZvbnRTdHlsZXNOYW1lID0gXCJCb2xkSXRhbGljXCI7XG4gIH0gZWxzZSBpZiAoZm9udFdlaWdodCA9PT0gXCJ0ZXh0YmZcIikge1xuICAgIGZvbnRTdHlsZXNOYW1lID0gXCJCb2xkXCI7XG4gIH0gZWxzZSBpZiAoZm9udFdlaWdodCA9PT0gXCJ0ZXh0aXRcIikge1xuICAgIGZvbnRTdHlsZXNOYW1lID0gXCJJdGFsaWNcIjtcbiAgfSBlbHNlIHtcbiAgICBmb250U3R5bGVzTmFtZSA9IFwiUmVndWxhclwiO1xuICB9XG5cbiAgcmV0dXJuIGJhc2VGb250TmFtZSArIFwiLVwiICsgZm9udFN0eWxlc05hbWU7XG59O1xuLyoqXG4gKiBNYXBzIFRlWCBmb250IGNvbW1hbmRzIHRvIG9iamVjdHMgY29udGFpbmluZzpcbiAqIC0gdmFyaWFudDogc3RyaW5nIHVzZWQgZm9yIFwibWF0aHZhcmlhbnRcIiBhdHRyaWJ1dGUgaW4gYnVpbGRNYXRoTUwuanNcbiAqIC0gZm9udE5hbWU6IHRoZSBcInN0eWxlXCIgcGFyYW1ldGVyIHRvIGZvbnRNZXRyaWNzLmdldENoYXJhY3Rlck1ldHJpY3NcbiAqL1xuLy8gQSBtYXAgYmV0d2VlbiB0ZXggZm9udCBjb21tYW5kcyBhbiBNYXRoTUwgbWF0aHZhcmlhbnQgYXR0cmlidXRlIHZhbHVlc1xuXG5cbnZhciBmb250TWFwID0ge1xuICAvLyBzdHlsZXNcbiAgXCJtYXRoYmZcIjoge1xuICAgIHZhcmlhbnQ6IFwiYm9sZFwiLFxuICAgIGZvbnROYW1lOiBcIk1haW4tQm9sZFwiXG4gIH0sXG4gIFwibWF0aHJtXCI6IHtcbiAgICB2YXJpYW50OiBcIm5vcm1hbFwiLFxuICAgIGZvbnROYW1lOiBcIk1haW4tUmVndWxhclwiXG4gIH0sXG4gIFwidGV4dGl0XCI6IHtcbiAgICB2YXJpYW50OiBcIml0YWxpY1wiLFxuICAgIGZvbnROYW1lOiBcIk1haW4tSXRhbGljXCJcbiAgfSxcbiAgXCJtYXRoaXRcIjoge1xuICAgIHZhcmlhbnQ6IFwiaXRhbGljXCIsXG4gICAgZm9udE5hbWU6IFwiTWFpbi1JdGFsaWNcIlxuICB9LFxuICAvLyBEZWZhdWx0IG1hdGggZm9udCwgXCJtYXRobm9ybWFsXCIgYW5kIFwiYm9sZHN5bWJvbFwiIGFyZSBtaXNzaW5nIGJlY2F1c2UgdGhleVxuICAvLyByZXF1aXJlIHRoZSB1c2Ugb2Ygc2V2ZXJhbCBmb250czogTWFpbi1JdGFsaWMgYW5kIE1hdGgtSXRhbGljIGZvciBkZWZhdWx0XG4gIC8vIG1hdGggZm9udCwgTWFpbi1JdGFsaWMsIE1hdGgtSXRhbGljLCBDYWxpZ3JhcGhpYyBmb3IgXCJtYXRobm9ybWFsXCIsIGFuZFxuICAvLyBNYXRoLUJvbGRJdGFsaWMgYW5kIE1haW4tQm9sZCBmb3IgXCJib2xkc3ltYm9sXCIuICBUaGlzIGlzIGhhbmRsZWQgYnkgYVxuICAvLyBzcGVjaWFsIGNhc2UgaW4gbWFrZU9yZCB3aGljaCBlbmRzIHVwIGNhbGxpbmcgbWF0aGRlZmF1bHQsIG1hdGhub3JtYWwsXG4gIC8vIGFuZCBib2xkc3ltYm9sLlxuICAvLyBmYW1pbGllc1xuICBcIm1hdGhiYlwiOiB7XG4gICAgdmFyaWFudDogXCJkb3VibGUtc3RydWNrXCIsXG4gICAgZm9udE5hbWU6IFwiQU1TLVJlZ3VsYXJcIlxuICB9LFxuICBcIm1hdGhjYWxcIjoge1xuICAgIHZhcmlhbnQ6IFwic2NyaXB0XCIsXG4gICAgZm9udE5hbWU6IFwiQ2FsaWdyYXBoaWMtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aGZyYWtcIjoge1xuICAgIHZhcmlhbnQ6IFwiZnJha3R1clwiLFxuICAgIGZvbnROYW1lOiBcIkZyYWt0dXItUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aHNjclwiOiB7XG4gICAgdmFyaWFudDogXCJzY3JpcHRcIixcbiAgICBmb250TmFtZTogXCJTY3JpcHQtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aHNmXCI6IHtcbiAgICB2YXJpYW50OiBcInNhbnMtc2VyaWZcIixcbiAgICBmb250TmFtZTogXCJTYW5zU2VyaWYtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aHR0XCI6IHtcbiAgICB2YXJpYW50OiBcIm1vbm9zcGFjZVwiLFxuICAgIGZvbnROYW1lOiBcIlR5cGV3cml0ZXItUmVndWxhclwiXG4gIH1cbn07XG52YXIgc3ZnRGF0YSA9IHtcbiAgLy8gICBwYXRoLCB3aWR0aCwgaGVpZ2h0XG4gIHZlYzogW1widmVjXCIsIDAuNDcxLCAwLjcxNF0sXG4gIC8vIHZhbHVlcyBmcm9tIHRoZSBmb250IGdseXBoXG4gIG9paW50U2l6ZTE6IFtcIm9paW50U2l6ZTFcIiwgMC45NTcsIDAuNDk5XSxcbiAgLy8gb3ZhbCB0byBvdmVybGF5IHRoZSBpbnRlZ3JhbmRcbiAgb2lpbnRTaXplMjogW1wib2lpbnRTaXplMlwiLCAxLjQ3MiwgMC42NTldLFxuICBvaWlpbnRTaXplMTogW1wib2lpaW50U2l6ZTFcIiwgMS4zMDQsIDAuNDk5XSxcbiAgb2lpaW50U2l6ZTI6IFtcIm9paWludFNpemUyXCIsIDEuOTgsIDAuNjU5XVxufTtcblxudmFyIGJ1aWxkQ29tbW9uX3N0YXRpY1N2ZyA9IGZ1bmN0aW9uIHN0YXRpY1N2Zyh2YWx1ZSwgb3B0aW9ucykge1xuICAvLyBDcmVhdGUgYSBzcGFuIHdpdGggaW5saW5lIFNWRyBmb3IgdGhlIGVsZW1lbnQuXG4gIHZhciBfc3ZnRGF0YSR2YWx1ZSA9IHN2Z0RhdGFbdmFsdWVdLFxuICAgICAgcGF0aE5hbWUgPSBfc3ZnRGF0YSR2YWx1ZVswXSxcbiAgICAgIHdpZHRoID0gX3N2Z0RhdGEkdmFsdWVbMV0sXG4gICAgICBoZWlnaHQgPSBfc3ZnRGF0YSR2YWx1ZVsyXTtcbiAgdmFyIHBhdGggPSBuZXcgZG9tVHJlZV9QYXRoTm9kZShwYXRoTmFtZSk7XG4gIHZhciBzdmdOb2RlID0gbmV3IFN2Z05vZGUoW3BhdGhdLCB7XG4gICAgXCJ3aWR0aFwiOiB3aWR0aCArIFwiZW1cIixcbiAgICBcImhlaWdodFwiOiBoZWlnaHQgKyBcImVtXCIsXG4gICAgLy8gT3ZlcnJpZGUgQ1NTIHJ1bGUgYC5rYXRleCBzdmcgeyB3aWR0aDogMTAwJSB9YFxuICAgIFwic3R5bGVcIjogXCJ3aWR0aDpcIiArIHdpZHRoICsgXCJlbVwiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCBcIiArIDEwMDAgKiB3aWR0aCArIFwiIFwiICsgMTAwMCAqIGhlaWdodCxcbiAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIjogXCJ4TWluWU1pblwiXG4gIH0pO1xuICB2YXIgc3BhbiA9IGJ1aWxkQ29tbW9uX21ha2VTdmdTcGFuKFtcIm92ZXJsYXlcIl0sIFtzdmdOb2RlXSwgb3B0aW9ucyk7XG4gIHNwYW4uaGVpZ2h0ID0gaGVpZ2h0O1xuICBzcGFuLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwiZW1cIjtcbiAgc3Bhbi5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJlbVwiO1xuICByZXR1cm4gc3Bhbjtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJ1aWxkQ29tbW9uID0gKHtcbiAgZm9udE1hcDogZm9udE1hcCxcbiAgbWFrZVN5bWJvbDogYnVpbGRDb21tb25fbWFrZVN5bWJvbCxcbiAgbWF0aHN5bTogYnVpbGRDb21tb25fbWF0aHN5bSxcbiAgbWFrZVNwYW46IGJ1aWxkQ29tbW9uX21ha2VTcGFuLFxuICBtYWtlU3ZnU3BhbjogYnVpbGRDb21tb25fbWFrZVN2Z1NwYW4sXG4gIG1ha2VMaW5lU3BhbjogbWFrZUxpbmVTcGFuLFxuICBtYWtlQW5jaG9yOiBidWlsZENvbW1vbl9tYWtlQW5jaG9yLFxuICBtYWtlRnJhZ21lbnQ6IGJ1aWxkQ29tbW9uX21ha2VGcmFnbWVudCxcbiAgd3JhcEZyYWdtZW50OiBidWlsZENvbW1vbl93cmFwRnJhZ21lbnQsXG4gIG1ha2VWTGlzdDogYnVpbGRDb21tb25fbWFrZVZMaXN0LFxuICBtYWtlT3JkOiBidWlsZENvbW1vbl9tYWtlT3JkLFxuICBtYWtlR2x1ZTogYnVpbGRDb21tb25fbWFrZUdsdWUsXG4gIHN0YXRpY1N2ZzogYnVpbGRDb21tb25fc3RhdGljU3ZnLFxuICBzdmdEYXRhOiBzdmdEYXRhLFxuICB0cnlDb21iaW5lQ2hhcnM6IGJ1aWxkQ29tbW9uX3RyeUNvbWJpbmVDaGFyc1xufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9wYXJzZU5vZGUuanNcblxuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgbm9kZSBpcyBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgcmV0dXJucyBpdCB3aXRoIHN0cmljdGVyXG4gKiB0eXBpbmcuIFRocm93cyBpZiB0aGUgbm9kZSdzIHR5cGUgZG9lcyBub3QgbWF0Y2guXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE5vZGVUeXBlKG5vZGUsIHR5cGUpIHtcbiAgdmFyIHR5cGVkTm9kZSA9IGNoZWNrTm9kZVR5cGUobm9kZSwgdHlwZSk7XG5cbiAgaWYgKCF0eXBlZE5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBub2RlIG9mIHR5cGUgXCIgKyB0eXBlICsgXCIsIGJ1dCBnb3QgXCIgKyAobm9kZSA/IFwibm9kZSBvZiB0eXBlIFwiICsgbm9kZS50eXBlIDogU3RyaW5nKG5vZGUpKSk7XG4gIH0gLy8gJEZsb3dGaXhNZTogVW5zdXJlIHdoeS5cblxuXG4gIHJldHVybiB0eXBlZE5vZGU7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5vZGUgbW9yZSBzdHJpY3RseSB0eXBlZCBpZmYgaXQgaXMgb2YgdGhlIGdpdmVuIHR5cGUuIE90aGVyd2lzZSxcbiAqIHJldHVybnMgbnVsbC5cbiAqL1xuXG5mdW5jdGlvbiBjaGVja05vZGVUeXBlKG5vZGUsIHR5cGUpIHtcbiAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSB0eXBlKSB7XG4gICAgLy8gVGhlIGRlZmluaXRpb24gb2YgUGFyc2VOb2RlPFRZUEU+IGRvZXNuJ3QgY29tbXVuaWNhdGUgdG8gZmxvdyB0aGF0XG4gICAgLy8gYHR5cGU6IFRZUEVgIChhcyB0aGF0J3Mgbm90IGV4cGxpY2l0bHkgbWVudGlvbmVkIGFueXdoZXJlKSwgdGhvdWdoIHRoYXRcbiAgICAvLyBoYXBwZW5zIHRvIGJlIHRydWUgZm9yIGFsbCBvdXIgdmFsdWUgdHlwZXMuXG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgbm9kZSBpcyBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgcmV0dXJucyBpdCB3aXRoIHN0cmljdGVyXG4gKiB0eXBpbmcuIFRocm93cyBpZiB0aGUgbm9kZSdzIHR5cGUgZG9lcyBub3QgbWF0Y2guXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0QXRvbUZhbWlseShub2RlLCBmYW1pbHkpIHtcbiAgdmFyIHR5cGVkTm9kZSA9IGNoZWNrQXRvbUZhbWlseShub2RlLCBmYW1pbHkpO1xuXG4gIGlmICghdHlwZWROb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbm9kZSBvZiB0eXBlIFxcXCJhdG9tXFxcIiBhbmQgZmFtaWx5IFxcXCJcIiArIGZhbWlseSArIFwiXFxcIiwgYnV0IGdvdCBcIiArIChub2RlID8gbm9kZS50eXBlID09PSBcImF0b21cIiA/IFwiYXRvbSBvZiBmYW1pbHkgXCIgKyBub2RlLmZhbWlseSA6IFwibm9kZSBvZiB0eXBlIFwiICsgbm9kZS50eXBlIDogU3RyaW5nKG5vZGUpKSk7XG4gIH1cblxuICByZXR1cm4gdHlwZWROb2RlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBub2RlIG1vcmUgc3RyaWN0bHkgdHlwZWQgaWZmIGl0IGlzIG9mIHRoZSBnaXZlbiB0eXBlLiBPdGhlcndpc2UsXG4gKiByZXR1cm5zIG51bGwuXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tBdG9tRmFtaWx5KG5vZGUsIGZhbWlseSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLnR5cGUgPT09IFwiYXRvbVwiICYmIG5vZGUuZmFtaWx5ID09PSBmYW1pbHkgPyBub2RlIDogbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZSBtb3JlIHN0cmljdGx5IHR5cGVkIGlmZiBpdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4gT3RoZXJ3aXNlLFxuICogcmV0dXJucyBudWxsLlxuICovXG5cbmZ1bmN0aW9uIGFzc2VydFN5bWJvbE5vZGVUeXBlKG5vZGUpIHtcbiAgdmFyIHR5cGVkTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUobm9kZSk7XG5cbiAgaWYgKCF0eXBlZE5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBub2RlIG9mIHN5bWJvbCBncm91cCB0eXBlLCBidXQgZ290IFwiICsgKG5vZGUgPyBcIm5vZGUgb2YgdHlwZSBcIiArIG5vZGUudHlwZSA6IFN0cmluZyhub2RlKSkpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVkTm9kZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZSBtb3JlIHN0cmljdGx5IHR5cGVkIGlmZiBpdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4gT3RoZXJ3aXNlLFxuICogcmV0dXJucyBudWxsLlxuICovXG5cbmZ1bmN0aW9uIGNoZWNrU3ltYm9sTm9kZVR5cGUobm9kZSkge1xuICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSBcImF0b21cIiB8fCBOT05fQVRPTVMuaGFzT3duUHJvcGVydHkobm9kZS50eXBlKSkpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3NwYWNpbmdEYXRhLmpzXG4vKipcbiAqIERlc2NyaWJlcyBzcGFjZXMgYmV0d2VlbiBkaWZmZXJlbnQgY2xhc3NlcyBvZiBhdG9tcy5cbiAqL1xudmFyIHRoaW5zcGFjZSA9IHtcbiAgbnVtYmVyOiAzLFxuICB1bml0OiBcIm11XCJcbn07XG52YXIgbWVkaXVtc3BhY2UgPSB7XG4gIG51bWJlcjogNCxcbiAgdW5pdDogXCJtdVwiXG59O1xudmFyIHRoaWNrc3BhY2UgPSB7XG4gIG51bWJlcjogNSxcbiAgdW5pdDogXCJtdVwiXG59OyAvLyBNYWtpbmcgdGhlIHR5cGUgYmVsb3cgZXhhY3Qgd2l0aCBhbGwgb3B0aW9uYWwgZmllbGRzIGRvZXNuJ3Qgd29yayBkdWUgdG9cbi8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzQ1ODJcbi8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzU2ODhcbi8vIEhvd2V2ZXIsIHNpbmNlICphbGwqIGZpZWxkcyBhcmUgb3B0aW9uYWwsICRTaGFwZTw+IHdvcmtzIGFzIHN1Z2dlc3RlZCBpbiA1Njg4XG4vLyBhYm92ZS5cblxuLy8gU3BhY2luZyByZWxhdGlvbnNoaXBzIGZvciBkaXNwbGF5IGFuZCB0ZXh0IHN0eWxlc1xudmFyIHNwYWNpbmdzID0ge1xuICBtb3JkOiB7XG4gICAgbW9wOiB0aGluc3BhY2UsXG4gICAgbWJpbjogbWVkaXVtc3BhY2UsXG4gICAgbXJlbDogdGhpY2tzcGFjZSxcbiAgICBtaW5uZXI6IHRoaW5zcGFjZVxuICB9LFxuICBtb3A6IHtcbiAgICBtb3JkOiB0aGluc3BhY2UsXG4gICAgbW9wOiB0aGluc3BhY2UsXG4gICAgbXJlbDogdGhpY2tzcGFjZSxcbiAgICBtaW5uZXI6IHRoaW5zcGFjZVxuICB9LFxuICBtYmluOiB7XG4gICAgbW9yZDogbWVkaXVtc3BhY2UsXG4gICAgbW9wOiBtZWRpdW1zcGFjZSxcbiAgICBtb3BlbjogbWVkaXVtc3BhY2UsXG4gICAgbWlubmVyOiBtZWRpdW1zcGFjZVxuICB9LFxuICBtcmVsOiB7XG4gICAgbW9yZDogdGhpY2tzcGFjZSxcbiAgICBtb3A6IHRoaWNrc3BhY2UsXG4gICAgbW9wZW46IHRoaWNrc3BhY2UsXG4gICAgbWlubmVyOiB0aGlja3NwYWNlXG4gIH0sXG4gIG1vcGVuOiB7fSxcbiAgbWNsb3NlOiB7XG4gICAgbW9wOiB0aGluc3BhY2UsXG4gICAgbWJpbjogbWVkaXVtc3BhY2UsXG4gICAgbXJlbDogdGhpY2tzcGFjZSxcbiAgICBtaW5uZXI6IHRoaW5zcGFjZVxuICB9LFxuICBtcHVuY3Q6IHtcbiAgICBtb3JkOiB0aGluc3BhY2UsXG4gICAgbW9wOiB0aGluc3BhY2UsXG4gICAgbXJlbDogdGhpY2tzcGFjZSxcbiAgICBtb3BlbjogdGhpbnNwYWNlLFxuICAgIG1jbG9zZTogdGhpbnNwYWNlLFxuICAgIG1wdW5jdDogdGhpbnNwYWNlLFxuICAgIG1pbm5lcjogdGhpbnNwYWNlXG4gIH0sXG4gIG1pbm5lcjoge1xuICAgIG1vcmQ6IHRoaW5zcGFjZSxcbiAgICBtb3A6IHRoaW5zcGFjZSxcbiAgICBtYmluOiBtZWRpdW1zcGFjZSxcbiAgICBtcmVsOiB0aGlja3NwYWNlLFxuICAgIG1vcGVuOiB0aGluc3BhY2UsXG4gICAgbXB1bmN0OiB0aGluc3BhY2UsXG4gICAgbWlubmVyOiB0aGluc3BhY2VcbiAgfVxufTsgLy8gU3BhY2luZyByZWxhdGlvbnNoaXBzIGZvciBzY3JpcHQgYW5kIHNjcmlwdHNjcmlwdCBzdHlsZXNcblxudmFyIHRpZ2h0U3BhY2luZ3MgPSB7XG4gIG1vcmQ6IHtcbiAgICBtb3A6IHRoaW5zcGFjZVxuICB9LFxuICBtb3A6IHtcbiAgICBtb3JkOiB0aGluc3BhY2UsXG4gICAgbW9wOiB0aGluc3BhY2VcbiAgfSxcbiAgbWJpbjoge30sXG4gIG1yZWw6IHt9LFxuICBtb3Blbjoge30sXG4gIG1jbG9zZToge1xuICAgIG1vcDogdGhpbnNwYWNlXG4gIH0sXG4gIG1wdW5jdDoge30sXG4gIG1pbm5lcjoge1xuICAgIG1vcDogdGhpbnNwYWNlXG4gIH1cbn07XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kZWZpbmVGdW5jdGlvbi5qc1xuXG5cbi8qKlxuICogQWxsIHJlZ2lzdGVyZWQgZnVuY3Rpb25zLlxuICogYGZ1bmN0aW9ucy5qc2AganVzdCBleHBvcnRzIHRoaXMgc2FtZSBkaWN0aW9uYXJ5IGFnYWluIGFuZCBtYWtlcyBpdCBwdWJsaWMuXG4gKiBgUGFyc2VyLmpzYCByZXF1aXJlcyB0aGlzIGRpY3Rpb25hcnkuXG4gKi9cbnZhciBfZnVuY3Rpb25zID0ge307XG4vKipcbiAqIEFsbCBIVE1MIGJ1aWxkZXJzLiBTaG91bGQgYmUgb25seSB1c2VkIGluIHRoZSBgZGVmaW5lKmAgYW5kIHRoZSBgYnVpbGQqTUxgXG4gKiBmdW5jdGlvbnMuXG4gKi9cblxudmFyIF9odG1sR3JvdXBCdWlsZGVycyA9IHt9O1xuLyoqXG4gKiBBbGwgTWF0aE1MIGJ1aWxkZXJzLiBTaG91bGQgYmUgb25seSB1c2VkIGluIHRoZSBgZGVmaW5lKmAgYW5kIHRoZSBgYnVpbGQqTUxgXG4gKiBmdW5jdGlvbnMuXG4gKi9cblxudmFyIF9tYXRobWxHcm91cEJ1aWxkZXJzID0ge307XG5mdW5jdGlvbiBkZWZpbmVGdW5jdGlvbihfcmVmKSB7XG4gIHZhciB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgbm9kZVR5cGUgPSBfcmVmLm5vZGVUeXBlLFxuICAgICAgbmFtZXMgPSBfcmVmLm5hbWVzLFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgaGFuZGxlciA9IF9yZWYuaGFuZGxlcixcbiAgICAgIGh0bWxCdWlsZGVyID0gX3JlZi5odG1sQnVpbGRlcixcbiAgICAgIG1hdGhtbEJ1aWxkZXIgPSBfcmVmLm1hdGhtbEJ1aWxkZXI7XG4gIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBvZiBmdW5jdGlvbnNcbiAgdmFyIGRhdGEgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBudW1BcmdzOiBwcm9wcy5udW1BcmdzLFxuICAgIGFyZ1R5cGVzOiBwcm9wcy5hcmdUeXBlcyxcbiAgICBncmVlZGluZXNzOiBwcm9wcy5ncmVlZGluZXNzID09PSB1bmRlZmluZWQgPyAxIDogcHJvcHMuZ3JlZWRpbmVzcyxcbiAgICBhbGxvd2VkSW5UZXh0OiAhIXByb3BzLmFsbG93ZWRJblRleHQsXG4gICAgYWxsb3dlZEluTWF0aDogcHJvcHMuYWxsb3dlZEluTWF0aCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHByb3BzLmFsbG93ZWRJbk1hdGgsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiBwcm9wcy5udW1PcHRpb25hbEFyZ3MgfHwgMCxcbiAgICBpbmZpeDogISFwcm9wcy5pbmZpeCxcbiAgICBjb25zdW1lTW9kZTogcHJvcHMuY29uc3VtZU1vZGUsXG4gICAgaGFuZGxlcjogaGFuZGxlclxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBUT0RPOiBUaGUgdmFsdWUgdHlwZSBvZiBfZnVuY3Rpb25zIHNob3VsZCBiZSBhIHR5cGUgdW5pb24gb2YgYWxsXG4gICAgLy8gcG9zc2libGUgYEZ1bmN0aW9uU3BlYzw+YCBwb3NzaWJpbGl0aWVzIGluc3RlYWQgb2YgYEZ1bmN0aW9uU3BlYzwqPmAsXG4gICAgLy8gd2hpY2ggaXMgYW4gZXhpc3RlbnRpYWwgdHlwZS5cbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgX2Z1bmN0aW9uc1tuYW1lc1tpXV0gPSBkYXRhO1xuICB9XG5cbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoaHRtbEJ1aWxkZXIpIHtcbiAgICAgIF9odG1sR3JvdXBCdWlsZGVyc1t0eXBlXSA9IGh0bWxCdWlsZGVyO1xuICAgIH1cblxuICAgIGlmIChtYXRobWxCdWlsZGVyKSB7XG4gICAgICBfbWF0aG1sR3JvdXBCdWlsZGVyc1t0eXBlXSA9IG1hdGhtbEJ1aWxkZXI7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFVzZSB0aGlzIHRvIHJlZ2lzdGVyIG9ubHkgdGhlIEhUTUwgYW5kIE1hdGhNTCBidWlsZGVycyBmb3IgYSBmdW5jdGlvbiAoZS5nLlxuICogaWYgdGhlIGZ1bmN0aW9uJ3MgUGFyc2VOb2RlIGlzIGdlbmVyYXRlZCBpbiBQYXJzZXIuanMgcmF0aGVyIHRoYW4gdmlhIGFcbiAqIHN0YW5kLWFsb25lIGhhbmRsZXIgcHJvdmlkZWQgdG8gYGRlZmluZUZ1bmN0aW9uYCkuXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lRnVuY3Rpb25CdWlsZGVycyhfcmVmMikge1xuICB2YXIgdHlwZSA9IF9yZWYyLnR5cGUsXG4gICAgICBodG1sQnVpbGRlciA9IF9yZWYyLmh0bWxCdWlsZGVyLFxuICAgICAgbWF0aG1sQnVpbGRlciA9IF9yZWYyLm1hdGhtbEJ1aWxkZXI7XG4gIGRlZmluZUZ1bmN0aW9uKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIG5hbWVzOiBbXSxcbiAgICBwcm9wczoge1xuICAgICAgbnVtQXJnczogMFxuICAgIH0sXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGJlIGNhbGxlZC4nKTtcbiAgICB9LFxuICAgIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlcixcbiAgICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyXG4gIH0pO1xufSAvLyBTaW5jZSB0aGUgY29ycmVzcG9uZGluZyBidWlsZEhUTUwvYnVpbGRNYXRoTUwgZnVuY3Rpb24gZXhwZWN0cyBhXG4vLyBsaXN0IG9mIGVsZW1lbnRzLCB3ZSBub3JtYWxpemUgZm9yIGRpZmZlcmVudCBraW5kcyBvZiBhcmd1bWVudHNcblxudmFyIGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50ID0gZnVuY3Rpb24gb3JkYXJndW1lbnQoYXJnKSB7XG4gIHZhciBub2RlID0gY2hlY2tOb2RlVHlwZShhcmcsIFwib3JkZ3JvdXBcIik7XG4gIHJldHVybiBub2RlID8gbm9kZS5ib2R5IDogW2FyZ107XG59O1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYnVpbGRIVE1MLmpzXG4vKipcbiAqIFRoaXMgZmlsZSBkb2VzIHRoZSBtYWluIHdvcmsgb2YgYnVpbGRpbmcgYSBkb21UcmVlIHN0cnVjdHVyZSBmcm9tIGEgcGFyc2VcbiAqIHRyZWUuIFRoZSBlbnRyeSBwb2ludCBpcyB0aGUgYGJ1aWxkSFRNTGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGEgcGFyc2UgdHJlZS5cbiAqIFRoZW4sIHRoZSBidWlsZEV4cHJlc3Npb24sIGJ1aWxkR3JvdXAsIGFuZCB2YXJpb3VzIGdyb3VwQnVpbGRlcnMgZnVuY3Rpb25zXG4gKiBhcmUgY2FsbGVkLCB0byBwcm9kdWNlIGEgZmluYWwgSFRNTCB0cmVlLlxuICovXG5cblxuXG5cblxuXG5cblxuXG52YXIgYnVpbGRIVE1MX21ha2VTcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW47IC8vIEJpbmFyeSBhdG9tcyAoZmlyc3QgY2xhc3MgYG1iaW5gKSBjaGFuZ2UgaW50byBvcmRpbmFyeSBhdG9tcyAoYG1vcmRgKVxuLy8gZGVwZW5kaW5nIG9uIHRoZWlyIHN1cnJvdW5kaW5ncy4gU2VlIFRlWGJvb2sgcGcuIDQ0Mi00NDYsIFJ1bGVzIDUgYW5kIDYsXG4vLyBhbmQgdGhlIHRleHQgYmVmb3JlIFJ1bGUgMTkuXG5cbnZhciBiaW5MZWZ0Q2FuY2VsbGVyID0gW1wibGVmdG1vc3RcIiwgXCJtYmluXCIsIFwibW9wZW5cIiwgXCJtcmVsXCIsIFwibW9wXCIsIFwibXB1bmN0XCJdO1xudmFyIGJpblJpZ2h0Q2FuY2VsbGVyID0gW1wicmlnaHRtb3N0XCIsIFwibXJlbFwiLCBcIm1jbG9zZVwiLCBcIm1wdW5jdFwiXTtcbnZhciBidWlsZEhUTUxfc3R5bGVNYXAgPSB7XG4gIFwiZGlzcGxheVwiOiBzcmNfU3R5bGUuRElTUExBWSxcbiAgXCJ0ZXh0XCI6IHNyY19TdHlsZS5URVhULFxuICBcInNjcmlwdFwiOiBzcmNfU3R5bGUuU0NSSVBULFxuICBcInNjcmlwdHNjcmlwdFwiOiBzcmNfU3R5bGUuU0NSSVBUU0NSSVBUXG59O1xudmFyIERvbUVudW0gPSB7XG4gIG1vcmQ6IFwibW9yZFwiLFxuICBtb3A6IFwibW9wXCIsXG4gIG1iaW46IFwibWJpblwiLFxuICBtcmVsOiBcIm1yZWxcIixcbiAgbW9wZW46IFwibW9wZW5cIixcbiAgbWNsb3NlOiBcIm1jbG9zZVwiLFxuICBtcHVuY3Q6IFwibXB1bmN0XCIsXG4gIG1pbm5lcjogXCJtaW5uZXJcIlxufTtcblxuLyoqXG4gKiBUYWtlIGEgbGlzdCBvZiBub2RlcywgYnVpbGQgdGhlbSBpbiBvcmRlciwgYW5kIHJldHVybiBhIGxpc3Qgb2YgdGhlIGJ1aWx0XG4gKiBub2Rlcy4gZG9jdW1lbnRGcmFnbWVudHMgYXJlIGZsYXR0ZW5lZCBpbnRvIHRoZWlyIGNvbnRlbnRzLCBzbyB0aGVcbiAqIHJldHVybmVkIGxpc3QgY29udGFpbnMgbm8gZnJhZ21lbnRzLiBgaXNSZWFsR3JvdXBgIGlzIHRydWUgaWYgYGV4cHJlc3Npb25gXG4gKiBpcyBhIHJlYWwgZ3JvdXAgKG5vIGF0b21zIHdpbGwgYmUgYWRkZWQgb24gZWl0aGVyIHNpZGUpLCBhcyBvcHBvc2VkIHRvXG4gKiBhIHBhcnRpYWwgZ3JvdXAgKGUuZy4gb25lIGNyZWF0ZWQgYnkgXFxjb2xvcikuIGBzdXJyb3VuZGluZ2AgaXMgYW4gYXJyYXlcbiAqIGNvbnNpc3RpbmcgdHlwZSBvZiBub2RlcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0LlxuICovXG52YXIgYnVpbGRIVE1MX2J1aWxkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIGJ1aWxkRXhwcmVzc2lvbihleHByZXNzaW9uLCBvcHRpb25zLCBpc1JlYWxHcm91cCwgc3Vycm91bmRpbmcpIHtcbiAgaWYgKHN1cnJvdW5kaW5nID09PSB2b2lkIDApIHtcbiAgICBzdXJyb3VuZGluZyA9IFtudWxsLCBudWxsXTtcbiAgfVxuXG4gIC8vIFBhcnNlIGV4cHJlc3Npb25zIGludG8gYGdyb3Vwc2AuXG4gIHZhciBncm91cHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb3V0cHV0ID0gYnVpbGRIVE1MX2J1aWxkR3JvdXAoZXhwcmVzc2lvbltpXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgdHJlZV9Eb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBvdXRwdXQuY2hpbGRyZW47XG4gICAgICBncm91cHMucHVzaC5hcHBseShncm91cHMsIGNoaWxkcmVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXBzLnB1c2gob3V0cHV0KTtcbiAgICB9XG4gIH0gLy8gSWYgYGV4cHJlc3Npb25gIGlzIGEgcGFydGlhbCBncm91cCwgbGV0IHRoZSBwYXJlbnQgaGFuZGxlIHNwYWNpbmdzXG4gIC8vIHRvIGF2b2lkIHByb2Nlc3NpbmcgZ3JvdXBzIG11bHRpcGxlIHRpbWVzLlxuXG5cbiAgaWYgKCFpc1JlYWxHcm91cCkge1xuICAgIHJldHVybiBncm91cHM7XG4gIH1cblxuICB2YXIgZ2x1ZU9wdGlvbnMgPSBvcHRpb25zO1xuXG4gIGlmIChleHByZXNzaW9uLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBub2RlID0gY2hlY2tOb2RlVHlwZShleHByZXNzaW9uWzBdLCBcInNpemluZ1wiKSB8fCBjaGVja05vZGVUeXBlKGV4cHJlc3Npb25bMF0sIFwic3R5bGluZ1wiKTtcblxuICAgIGlmICghbm9kZSkgey8vIE5vIG1hdGNoLlxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcInNpemluZ1wiKSB7XG4gICAgICBnbHVlT3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU2l6ZShub2RlLnNpemUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcInN0eWxpbmdcIikge1xuICAgICAgZ2x1ZU9wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKGJ1aWxkSFRNTF9zdHlsZU1hcFtub2RlLnN0eWxlXSk7XG4gICAgfVxuICB9IC8vIER1bW15IHNwYW5zIGZvciBkZXRlcm1pbmluZyBzcGFjaW5ncyBiZXR3ZWVuIHN1cnJvdW5kaW5nIGF0b21zLlxuICAvLyBJZiBgZXhwcmVzc2lvbmAgaGFzIG5vIGF0b21zIG9uIHRoZSBsZWZ0IG9yIHJpZ2h0LCBjbGFzcyBcImxlZnRtb3N0XCJcbiAgLy8gb3IgXCJyaWdodG1vc3RcIiwgcmVzcGVjdGl2ZWx5LCBpcyB1c2VkIHRvIGluZGljYXRlIGl0LlxuXG5cbiAgdmFyIGR1bW15UHJldiA9IGJ1aWxkSFRNTF9tYWtlU3Bhbihbc3Vycm91bmRpbmdbMF0gfHwgXCJsZWZ0bW9zdFwiXSwgW10sIG9wdGlvbnMpO1xuICB2YXIgZHVtbXlOZXh0ID0gYnVpbGRIVE1MX21ha2VTcGFuKFtzdXJyb3VuZGluZ1sxXSB8fCBcInJpZ2h0bW9zdFwiXSwgW10sIG9wdGlvbnMpOyAvLyBUT0RPOiBUaGVzZSBjb2RlIGFzc3VtZXMgdGhhdCBhIG5vZGUncyBtYXRoIGNsYXNzIGlzIHRoZSBmaXJzdCBlbGVtZW50XG4gIC8vIG9mIGl0cyBgY2xhc3Nlc2AgYXJyYXkuIEEgbGF0ZXIgY2xlYW51cCBzaG91bGQgZW5zdXJlIHRoaXMsIGZvclxuICAvLyBpbnN0YW5jZSBieSBjaGFuZ2luZyB0aGUgc2lnbmF0dXJlIG9mIGBtYWtlU3BhbmAuXG4gIC8vIEJlZm9yZSBkZXRlcm1pbmluZyB3aGF0IHNwYWNlcyB0byBpbnNlcnQsIHBlcmZvcm0gYmluIGNhbmNlbGxhdGlvbi5cbiAgLy8gQmluYXJ5IG9wZXJhdG9ycyBjaGFuZ2UgdG8gb3JkaW5hcnkgc3ltYm9scyBpbiBzb21lIGNvbnRleHRzLlxuXG4gIHRyYXZlcnNlTm9uU3BhY2VOb2Rlcyhncm91cHMsIGZ1bmN0aW9uIChub2RlLCBwcmV2KSB7XG4gICAgdmFyIHByZXZUeXBlID0gcHJldi5jbGFzc2VzWzBdO1xuICAgIHZhciB0eXBlID0gbm9kZS5jbGFzc2VzWzBdO1xuXG4gICAgaWYgKHByZXZUeXBlID09PSBcIm1iaW5cIiAmJiB1dGlscy5jb250YWlucyhiaW5SaWdodENhbmNlbGxlciwgdHlwZSkpIHtcbiAgICAgIHByZXYuY2xhc3Nlc1swXSA9IFwibW9yZFwiO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJtYmluXCIgJiYgdXRpbHMuY29udGFpbnMoYmluTGVmdENhbmNlbGxlciwgcHJldlR5cGUpKSB7XG4gICAgICBub2RlLmNsYXNzZXNbMF0gPSBcIm1vcmRcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBub2RlOiBkdW1teVByZXZcbiAgfSwgZHVtbXlOZXh0KTtcbiAgdHJhdmVyc2VOb25TcGFjZU5vZGVzKGdyb3VwcywgZnVuY3Rpb24gKG5vZGUsIHByZXYpIHtcbiAgICB2YXIgcHJldlR5cGUgPSBnZXRUeXBlT2ZEb21UcmVlKHByZXYpO1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZU9mRG9tVHJlZShub2RlKTsgLy8gJ210aWdodCcgaW5kaWNhdGVzIHRoYXQgdGhlIG5vZGUgaXMgc2NyaXB0IG9yIHNjcmlwdHNjcmlwdCBzdHlsZS5cblxuICAgIHZhciBzcGFjZSA9IHByZXZUeXBlICYmIHR5cGUgPyBub2RlLmhhc0NsYXNzKFwibXRpZ2h0XCIpID8gdGlnaHRTcGFjaW5nc1twcmV2VHlwZV1bdHlwZV0gOiBzcGFjaW5nc1twcmV2VHlwZV1bdHlwZV0gOiBudWxsO1xuXG4gICAgaWYgKHNwYWNlKSB7XG4gICAgICAvLyBJbnNlcnQgZ2x1ZSAoc3BhY2luZykgYWZ0ZXIgdGhlIGBwcmV2YC5cbiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlR2x1ZShzcGFjZSwgZ2x1ZU9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIG5vZGU6IGR1bW15UHJldlxuICB9LCBkdW1teU5leHQpO1xuICByZXR1cm4gZ3JvdXBzO1xufTsgLy8gRGVwdGgtZmlyc3QgdHJhdmVyc2Ugbm9uLXNwYWNlIGBub2Rlc2AsIGNhbGxpbmcgYGNhbGxiYWNrYCB3aXRoIHRoZSBjdXJyZW50IGFuZFxuLy8gcHJldmlvdXMgbm9kZSBhcyBhcmd1bWVudHMsIG9wdGlvbmFsbHkgcmV0dXJuaW5nIGEgbm9kZSB0byBpbnNlcnQgYWZ0ZXIgdGhlXG4vLyBwcmV2aW91cyBub2RlLiBgcHJldmAgaXMgYW4gb2JqZWN0IHdpdGggdGhlIHByZXZpb3VzIG5vZGUgYW5kIGBpbnNlcnRBZnRlcmBcbi8vIGZ1bmN0aW9uIHRvIGluc2VydCBhZnRlciBpdC4gYG5leHRgIGlzIGEgbm9kZSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHJpZ2h0LlxuLy8gVXNlZCBmb3IgYmluIGNhbmNlbGxhdGlvbiBhbmQgaW5zZXJ0aW5nIHNwYWNpbmdzLlxuXG52YXIgdHJhdmVyc2VOb25TcGFjZU5vZGVzID0gZnVuY3Rpb24gdHJhdmVyc2VOb25TcGFjZU5vZGVzKG5vZGVzLCBjYWxsYmFjaywgcHJldiwgbmV4dCkge1xuICBpZiAobmV4dCkge1xuICAgIC8vIHRlbXBvcmFyaWx5IGFwcGVuZCB0aGUgcmlnaHQgbm9kZSwgaWYgZXhpc3RzXG4gICAgbm9kZXMucHVzaChuZXh0KTtcbiAgfVxuXG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICB2YXIgcGFydGlhbEdyb3VwID0gYnVpbGRIVE1MX2NoZWNrUGFydGlhbEdyb3VwKG5vZGUpO1xuXG4gICAgaWYgKHBhcnRpYWxHcm91cCkge1xuICAgICAgLy8gUmVjdXJzaXZlIERGU1xuICAgICAgdHJhdmVyc2VOb25TcGFjZU5vZGVzKHBhcnRpYWxHcm91cC5jaGlsZHJlbiwgY2FsbGJhY2ssIHByZXYpO1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBJZ25vcmUgZXhwbGljaXQgc3BhY2VzIChlLmcuLCBcXDssIFxcLCkgd2hlbiBkZXRlcm1pbmluZyB3aGF0IGltcGxpY2l0XG4gICAgLy8gc3BhY2luZyBzaG91bGQgZ28gYmV0d2VlbiBhdG9tcyBvZiBkaWZmZXJlbnQgY2xhc3Nlc1xuXG5cbiAgICBpZiAobm9kZS5jbGFzc2VzWzBdID09PSBcIm1zcGFjZVwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2sobm9kZSwgcHJldi5ub2RlKTtcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChwcmV2Lmluc2VydEFmdGVyKSB7XG4gICAgICAgIHByZXYuaW5zZXJ0QWZ0ZXIocmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluc2VydCBhdCBmcm9udFxuICAgICAgICBub2Rlcy51bnNoaWZ0KHJlc3VsdCk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2Lm5vZGUgPSBub2RlO1xuXG4gICAgcHJldi5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIG5vZGVzLnNwbGljZShpbmRleCArIDEsIDAsIG4pO1xuICAgICAgICBpKys7XG4gICAgICB9O1xuICAgIH0oaSk7XG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5vZGVzLnBvcCgpO1xuICB9XG59OyAvLyBDaGVjayBpZiBnaXZlbiBub2RlIGlzIGEgcGFydGlhbCBncm91cCwgaS5lLiwgZG9lcyBub3QgYWZmZWN0IHNwYWNpbmcgYXJvdW5kLlxuXG5cbnZhciBidWlsZEhUTUxfY2hlY2tQYXJ0aWFsR3JvdXAgPSBmdW5jdGlvbiBjaGVja1BhcnRpYWxHcm91cChub2RlKSB7XG4gIGlmIChub2RlIGluc3RhbmNlb2YgdHJlZV9Eb2N1bWVudEZyYWdtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBkb21UcmVlX0FuY2hvcikge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59OyAvLyBSZXR1cm4gdGhlIG91dGVybW9zdCBub2RlIG9mIGEgZG9tVHJlZS5cblxuXG52YXIgZ2V0T3V0ZXJtb3N0Tm9kZSA9IGZ1bmN0aW9uIGdldE91dGVybW9zdE5vZGUobm9kZSwgc2lkZSkge1xuICB2YXIgcGFydGlhbEdyb3VwID0gYnVpbGRIVE1MX2NoZWNrUGFydGlhbEdyb3VwKG5vZGUpO1xuXG4gIGlmIChwYXJ0aWFsR3JvdXApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJ0aWFsR3JvdXAuY2hpbGRyZW47XG5cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBpZiAoc2lkZSA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRPdXRlcm1vc3ROb2RlKGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLCBcInJpZ2h0XCIpO1xuICAgICAgfSBlbHNlIGlmIChzaWRlID09PSBcImxlZnRcIikge1xuICAgICAgICByZXR1cm4gZ2V0T3V0ZXJtb3N0Tm9kZShjaGlsZHJlblswXSwgXCJsZWZ0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTsgLy8gUmV0dXJuIG1hdGggYXRvbSBjbGFzcyAobWNsYXNzKSBvZiBhIGRvbVRyZWUuXG4vLyBJZiBgc2lkZWAgaXMgZ2l2ZW4sIGl0IHdpbGwgZ2V0IHRoZSB0eXBlIG9mIHRoZSBvdXRlcm1vc3Qgbm9kZSBhdCBnaXZlbiBzaWRlLlxuXG5cbnZhciBnZXRUeXBlT2ZEb21UcmVlID0gZnVuY3Rpb24gZ2V0VHlwZU9mRG9tVHJlZShub2RlLCBzaWRlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHNpZGUpIHtcbiAgICBub2RlID0gZ2V0T3V0ZXJtb3N0Tm9kZShub2RlLCBzaWRlKTtcbiAgfSAvLyBUaGlzIG1ha2VzIGEgbG90IG9mIGFzc3VtcHRpb25zIGFzIHRvIHdoZXJlIHRoZSB0eXBlIG9mIGF0b21cbiAgLy8gYXBwZWFycy4gIFdlIHNob3VsZCBkbyBhIGJldHRlciBqb2Igb2YgZW5mb3JjaW5nIHRoaXMuXG5cblxuICByZXR1cm4gRG9tRW51bVtub2RlLmNsYXNzZXNbMF1dIHx8IG51bGw7XG59O1xudmFyIG1ha2VOdWxsRGVsaW1pdGVyID0gZnVuY3Rpb24gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgY2xhc3Nlcykge1xuICB2YXIgbW9yZUNsYXNzZXMgPSBbXCJudWxsZGVsaW1pdGVyXCJdLmNvbmNhdChvcHRpb25zLmJhc2VTaXppbmdDbGFzc2VzKCkpO1xuICByZXR1cm4gYnVpbGRIVE1MX21ha2VTcGFuKGNsYXNzZXMuY29uY2F0KG1vcmVDbGFzc2VzKSk7XG59O1xuLyoqXG4gKiBidWlsZEdyb3VwIGlzIHRoZSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgZ3JvdXAgYW5kIGNhbGxzIHRoZSBjb3JyZWN0IGdyb3VwVHlwZVxuICogZnVuY3Rpb24gZm9yIGl0LiBJdCBhbHNvIGhhbmRsZXMgdGhlIGludGVyYWN0aW9uIG9mIHNpemUgYW5kIHN0eWxlIGNoYW5nZXNcbiAqIGJldHdlZW4gcGFyZW50cyBhbmQgY2hpbGRyZW4uXG4gKi9cblxudmFyIGJ1aWxkSFRNTF9idWlsZEdyb3VwID0gZnVuY3Rpb24gYnVpbGRHcm91cChncm91cCwgb3B0aW9ucywgYmFzZU9wdGlvbnMpIHtcbiAgaWYgKCFncm91cCkge1xuICAgIHJldHVybiBidWlsZEhUTUxfbWFrZVNwYW4oKTtcbiAgfVxuXG4gIGlmIChfaHRtbEdyb3VwQnVpbGRlcnNbZ3JvdXAudHlwZV0pIHtcbiAgICAvLyBDYWxsIHRoZSBncm91cEJ1aWxkZXJzIGZ1bmN0aW9uXG4gICAgdmFyIGdyb3VwTm9kZSA9IF9odG1sR3JvdXBCdWlsZGVyc1tncm91cC50eXBlXShncm91cCwgb3B0aW9ucyk7IC8vIElmIHRoZSBzaXplIGNoYW5nZWQgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY3VycmVudCBncm91cCwgYWNjb3VudFxuICAgIC8vIGZvciB0aGF0IHNpemUgZGlmZmVyZW5jZS5cblxuICAgIGlmIChiYXNlT3B0aW9ucyAmJiBvcHRpb25zLnNpemUgIT09IGJhc2VPcHRpb25zLnNpemUpIHtcbiAgICAgIGdyb3VwTm9kZSA9IGJ1aWxkSFRNTF9tYWtlU3BhbihvcHRpb25zLnNpemluZ0NsYXNzZXMoYmFzZU9wdGlvbnMpLCBbZ3JvdXBOb2RlXSwgb3B0aW9ucyk7XG4gICAgICB2YXIgbXVsdGlwbGllciA9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBiYXNlT3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICAgIGdyb3VwTm9kZS5oZWlnaHQgKj0gbXVsdGlwbGllcjtcbiAgICAgIGdyb3VwTm9kZS5kZXB0aCAqPSBtdWx0aXBsaWVyO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cE5vZGU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiR290IGdyb3VwIG9mIHVua25vd24gdHlwZTogJ1wiICsgZ3JvdXAudHlwZSArIFwiJ1wiKTtcbiAgfVxufTtcbi8qKlxuICogQ29tYmluZSBhbiBhcnJheSBvZiBIVE1MIERPTSBub2RlcyAoZS5nLiwgdGhlIG91dHB1dCBvZiBgYnVpbGRFeHByZXNzaW9uYClcbiAqIGludG8gYW4gdW5icmVha2FibGUgSFRNTCBub2RlIG9mIGNsYXNzIC5iYXNlLCB3aXRoIHByb3BlciBzdHJ1dHMgdG9cbiAqIGd1YXJhbnRlZSBjb3JyZWN0IHZlcnRpY2FsIGV4dGVudC4gIGBidWlsZEhUTUxgIGNhbGxzIHRoaXMgcmVwZWF0ZWRseSB0b1xuICogbWFrZSB1cCB0aGUgZW50aXJlIGV4cHJlc3Npb24gYXMgYSBzZXF1ZW5jZSBvZiB1bmJyZWFrYWJsZSB1bml0cy5cbiAqL1xuXG5mdW5jdGlvbiBidWlsZEhUTUxVbmJyZWFrYWJsZShjaGlsZHJlbiwgb3B0aW9ucykge1xuICAvLyBDb21wdXRlIGhlaWdodCBhbmQgZGVwdGggb2YgdGhpcyBjaHVuay5cbiAgdmFyIGJvZHkgPSBidWlsZEhUTUxfbWFrZVNwYW4oW1wiYmFzZVwiXSwgY2hpbGRyZW4sIG9wdGlvbnMpOyAvLyBBZGQgc3RydXQsIHdoaWNoIGVuc3VyZXMgdGhhdCB0aGUgdG9wIG9mIHRoZSBIVE1MIGVsZW1lbnQgZmFsbHMgYXRcbiAgLy8gdGhlIGhlaWdodCBvZiB0aGUgZXhwcmVzc2lvbiwgYW5kIHRoZSBib3R0b20gb2YgdGhlIEhUTUwgZWxlbWVudFxuICAvLyBmYWxscyBhdCB0aGUgZGVwdGggb2YgdGhlIGV4cHJlc3Npb24uXG4gIC8vIFdlIHVzZWQgdG8gaGF2ZSBzZXBhcmF0ZSB0b3AgYW5kIGJvdHRvbSBzdHJ1dHMsIHdoZXJlIHRoZSBib3R0b20gc3RydXRcbiAgLy8gd291bGQgbGlrZSB0byB1c2UgYHZlcnRpY2FsLWFsaWduOiB0b3BgLCBidXQgaW4gSUUgOSB0aGlzIGxvd2VycyB0aGVcbiAgLy8gYmFzZWxpbmUgb2YgdGhlIGJveCB0byB0aGUgYm90dG9tIG9mIHRoaXMgc3RydXQgKGluc3RlYWQgb2Ygc3RheWluZyBpblxuICAvLyB0aGUgbm9ybWFsIHBsYWNlKSBzbyB3ZSB1c2UgYW4gYWJzb2x1dGUgdmFsdWUgZm9yIHZlcnRpY2FsLWFsaWduIGluc3RlYWQuXG5cbiAgdmFyIHN0cnV0ID0gYnVpbGRIVE1MX21ha2VTcGFuKFtcInN0cnV0XCJdKTtcbiAgc3RydXQuc3R5bGUuaGVpZ2h0ID0gYm9keS5oZWlnaHQgKyBib2R5LmRlcHRoICsgXCJlbVwiO1xuICBzdHJ1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gLWJvZHkuZGVwdGggKyBcImVtXCI7XG4gIGJvZHkuY2hpbGRyZW4udW5zaGlmdChzdHJ1dCk7XG4gIHJldHVybiBib2R5O1xufVxuLyoqXG4gKiBUYWtlIGFuIGVudGlyZSBwYXJzZSB0cmVlLCBhbmQgYnVpbGQgaXQgaW50byBhbiBhcHByb3ByaWF0ZSBzZXQgb2YgSFRNTFxuICogbm9kZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBidWlsZEhUTUwodHJlZSwgb3B0aW9ucykge1xuICAvLyBTdHJpcCBvZmYgb3V0ZXIgdGFnIHdyYXBwZXIgZm9yIHByb2Nlc3NpbmcgYmVsb3cuXG4gIHZhciB0YWcgPSBudWxsO1xuXG4gIGlmICh0cmVlLmxlbmd0aCA9PT0gMSAmJiB0cmVlWzBdLnR5cGUgPT09IFwidGFnXCIpIHtcbiAgICB0YWcgPSB0cmVlWzBdLnRhZztcbiAgICB0cmVlID0gdHJlZVswXS5ib2R5O1xuICB9IC8vIEJ1aWxkIHRoZSBleHByZXNzaW9uIGNvbnRhaW5lZCBpbiB0aGUgdHJlZVxuXG5cbiAgdmFyIGV4cHJlc3Npb24gPSBidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKHRyZWUsIG9wdGlvbnMsIHRydWUpO1xuICB2YXIgY2hpbGRyZW4gPSBbXTsgLy8gQ3JlYXRlIG9uZSBiYXNlIG5vZGUgZm9yIGVhY2ggY2h1bmsgYmV0d2VlbiBwb3RlbnRpYWwgbGluZSBicmVha3MuXG4gIC8vIFRoZSBUZVhCb29rIFtwLjE3M10gc2F5cyBcIkEgZm9ybXVsYSB3aWxsIGJlIGJyb2tlbiBvbmx5IGFmdGVyIGFcbiAgLy8gcmVsYXRpb24gc3ltYm9sIGxpa2UgJD0kIG9yICQ8JCBvciAkXFxyaWdodGFycm93JCwgb3IgYWZ0ZXIgYSBiaW5hcnlcbiAgLy8gb3BlcmF0aW9uIHN5bWJvbCBsaWtlICQrJCBvciAkLSQgb3IgJFxcdGltZXMkLCB3aGVyZSB0aGUgcmVsYXRpb24gb3JcbiAgLy8gYmluYXJ5IG9wZXJhdGlvbiBpcyBvbiB0aGUgYGBvdXRlciBsZXZlbCcnIG9mIHRoZSBmb3JtdWxhIChpLmUuLCBub3RcbiAgLy8gZW5jbG9zZWQgaW4gey4uLn0gYW5kIG5vdCBwYXJ0IG9mIGFuIFxcb3ZlciBjb25zdHJ1Y3Rpb24pLlwiXG5cbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChleHByZXNzaW9uW2ldKTtcblxuICAgIGlmIChleHByZXNzaW9uW2ldLmhhc0NsYXNzKFwibWJpblwiKSB8fCBleHByZXNzaW9uW2ldLmhhc0NsYXNzKFwibXJlbFwiKSB8fCBleHByZXNzaW9uW2ldLmhhc0NsYXNzKFwiYWxsb3dicmVha1wiKSkge1xuICAgICAgLy8gUHV0IGFueSBwb3N0LW9wZXJhdG9yIGdsdWUgb24gc2FtZSBsaW5lIGFzIG9wZXJhdG9yLlxuICAgICAgLy8gV2F0Y2ggZm9yIFxcbm9icmVhayBhbG9uZyB0aGUgd2F5LCBhbmQgc3RvcCBhdCBcXG5ld2xpbmUuXG4gICAgICB2YXIgbm9icmVhayA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAoaSA8IGV4cHJlc3Npb24ubGVuZ3RoIC0gMSAmJiBleHByZXNzaW9uW2kgKyAxXS5oYXNDbGFzcyhcIm1zcGFjZVwiKSAmJiAhZXhwcmVzc2lvbltpICsgMV0uaGFzQ2xhc3MoXCJuZXdsaW5lXCIpKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgcGFydHMucHVzaChleHByZXNzaW9uW2ldKTtcblxuICAgICAgICBpZiAoZXhwcmVzc2lvbltpXS5oYXNDbGFzcyhcIm5vYnJlYWtcIikpIHtcbiAgICAgICAgICBub2JyZWFrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBEb24ndCBhbGxvdyBicmVhayBpZiBcXG5vYnJlYWsgYW1vbmcgdGhlIHBvc3Qtb3BlcmF0b3IgZ2x1ZS5cblxuXG4gICAgICBpZiAoIW5vYnJlYWspIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChidWlsZEhUTUxVbmJyZWFrYWJsZShwYXJ0cywgb3B0aW9ucykpO1xuICAgICAgICBwYXJ0cyA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbltpXS5oYXNDbGFzcyhcIm5ld2xpbmVcIikpIHtcbiAgICAgIC8vIFdyaXRlIHRoZSBsaW5lIGV4Y2VwdCB0aGUgbmV3bGluZVxuICAgICAgcGFydHMucG9wKCk7XG5cbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRIVE1MVW5icmVha2FibGUocGFydHMsIG9wdGlvbnMpKTtcbiAgICAgICAgcGFydHMgPSBbXTtcbiAgICAgIH0gLy8gUHV0IHRoZSBuZXdsaW5lIGF0IHRoZSB0b3AgbGV2ZWxcblxuXG4gICAgICBjaGlsZHJlbi5wdXNoKGV4cHJlc3Npb25baV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgY2hpbGRyZW4ucHVzaChidWlsZEhUTUxVbmJyZWFrYWJsZShwYXJ0cywgb3B0aW9ucykpO1xuICB9IC8vIE5vdywgaWYgdGhlcmUgd2FzIGEgdGFnLCBidWlsZCBpdCB0b28gYW5kIGFwcGVuZCBpdCBhcyBhIGZpbmFsIGNoaWxkLlxuXG5cbiAgdmFyIHRhZ0NoaWxkO1xuXG4gIGlmICh0YWcpIHtcbiAgICB0YWdDaGlsZCA9IGJ1aWxkSFRNTFVuYnJlYWthYmxlKGJ1aWxkSFRNTF9idWlsZEV4cHJlc3Npb24odGFnLCBvcHRpb25zLCB0cnVlKSk7XG4gICAgdGFnQ2hpbGQuY2xhc3NlcyA9IFtcInRhZ1wiXTtcbiAgICBjaGlsZHJlbi5wdXNoKHRhZ0NoaWxkKTtcbiAgfVxuXG4gIHZhciBodG1sTm9kZSA9IGJ1aWxkSFRNTF9tYWtlU3BhbihbXCJrYXRleC1odG1sXCJdLCBjaGlsZHJlbik7XG4gIGh0bWxOb2RlLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTsgLy8gQWRqdXN0IHRoZSBzdHJ1dCBvZiB0aGUgdGFnIHRvIGJlIHRoZSBtYXhpbXVtIGhlaWdodCBvZiBhbGwgY2hpbGRyZW5cbiAgLy8gKHRoZSBoZWlnaHQgb2YgdGhlIGVuY2xvc2luZyBodG1sTm9kZSkgZm9yIHByb3BlciB2ZXJ0aWNhbCBhbGlnbm1lbnQuXG5cbiAgaWYgKHRhZ0NoaWxkKSB7XG4gICAgdmFyIHN0cnV0ID0gdGFnQ2hpbGQuY2hpbGRyZW5bMF07XG4gICAgc3RydXQuc3R5bGUuaGVpZ2h0ID0gaHRtbE5vZGUuaGVpZ2h0ICsgaHRtbE5vZGUuZGVwdGggKyBcImVtXCI7XG4gICAgc3RydXQuc3R5bGUudmVydGljYWxBbGlnbiA9IC1odG1sTm9kZS5kZXB0aCArIFwiZW1cIjtcbiAgfVxuXG4gIHJldHVybiBodG1sTm9kZTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21hdGhNTFRyZWUuanNcbi8qKlxuICogVGhlc2Ugb2JqZWN0cyBzdG9yZSBkYXRhIGFib3V0IE1hdGhNTCBub2Rlcy4gVGhpcyBpcyB0aGUgTWF0aE1MIGVxdWl2YWxlbnRcbiAqIG9mIHRoZSB0eXBlcyBpbiBkb21UcmVlLmpzLiBTaW5jZSBNYXRoTUwgaGFuZGxlcyBpdHMgb3duIHJlbmRlcmluZywgYW5kXG4gKiBzaW5jZSB3ZSdyZSBtYWlubHkgdXNpbmcgTWF0aE1MIHRvIGltcHJvdmUgYWNjZXNzaWJpbGl0eSwgd2UgZG9uJ3QgbWFuYWdlXG4gKiBhbnkgb2YgdGhlIHN0eWxpbmcgc3RhdGUgdGhhdCB0aGUgcGxhaW4gRE9NIG5vZGVzIGRvLlxuICpcbiAqIFRoZSBgdG9Ob2RlYCBhbmQgYHRvTWFya3VwYCBmdW5jdGlvbnMgd29yayBzaW1sYXJseSB0byBob3cgdGhleSBkbyBpblxuICogZG9tVHJlZS5qcywgY3JlYXRpbmcgbmFtZXNwYWNlZCBET00gbm9kZXMgYW5kIEhUTUwgdGV4dCBtYXJrdXAgcmVzcGVjdGl2ZWx5LlxuICovXG5cblxuZnVuY3Rpb24gbmV3RG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbikge1xuICByZXR1cm4gbmV3IHRyZWVfRG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbik7XG59XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZ2VuZXJhbCBwdXJwb3NlIE1hdGhNTCBub2RlIG9mIGFueSB0eXBlLiBUaGVcbiAqIGNvbnN0cnVjdG9yIHJlcXVpcmVzIHRoZSB0eXBlIG9mIG5vZGUgdG8gY3JlYXRlIChmb3IgZXhhbXBsZSwgYFwibW9cImAgb3JcbiAqIGBcIm1zcGFjZVwiYCwgY29ycmVzcG9uZGluZyB0byBgPG1vPmAgYW5kIGA8bXNwYWNlPmAgdGFncykuXG4gKi9cblxudmFyIG1hdGhNTFRyZWVfTWF0aE5vZGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXRoTm9kZSh0eXBlLCBjaGlsZHJlbikge1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gYSBNYXRoTUwgbm9kZS4gTWF0aE1MIGRlcGVuZHMgb24gYXR0cmlidXRlcyB0byBjb252ZXkgYVxuICAgKiBzZW1hbnRpYyBjb250ZW50LCBzbyB0aGlzIGlzIHVzZWQgaGVhdmlseS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gTWF0aE5vZGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbiBhdHRyaWJ1dGUgb24gYSBNYXRoTUwgbm9kZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBNYXRoTUwtbmFtZXNwYWNlZCBET00gZWxlbWVudC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9Ob2RlID0gZnVuY3Rpb24gdG9Ob2RlKCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCB0aGlzLnR5cGUpO1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGFuIEhUTUwgbWFya3VwIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCgpIHtcbiAgICB2YXIgbWFya3VwID0gXCI8XCIgKyB0aGlzLnR5cGU7IC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBtYXJrdXAgKz0gXCIgXCIgKyBhdHRyICsgXCI9XFxcIlwiO1xuICAgICAgICBtYXJrdXAgKz0gdXRpbHMuZXNjYXBlKHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI+XCI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPC9cIiArIHRoaXMudHlwZSArIFwiPlwiO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIHN0cmluZywgc2ltaWxhciB0byBpbm5lclRleHQsIGJ1dCBlc2NhcGVkLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1RleHQgPSBmdW5jdGlvbiB0b1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnRvVGV4dCgpO1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgcmV0dXJuIE1hdGhOb2RlO1xufSgpO1xuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHBpZWNlIG9mIHRleHQuXG4gKi9cblxudmFyIG1hdGhNTFRyZWVfVGV4dE5vZGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZXh0Tm9kZSh0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0IG5vZGUgaW50byBhIERPTSB0ZXh0IG5vZGUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90bzIgPSBUZXh0Tm9kZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50b05vZGUgPSBmdW5jdGlvbiB0b05vZGUoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0IG5vZGUgaW50byBlc2NhcGVkIEhUTUwgbWFya3VwXG4gICAqIChyZXByZXNlbnRpbmcgdGhlIHRleHQgaXRzZWxmKS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8yLnRvTWFya3VwID0gZnVuY3Rpb24gdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVzY2FwZSh0aGlzLnRvVGV4dCgpKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGEgc3RyaW5nXG4gICAqIChyZXByZXNlbnRpbmcgdGhlIHRleHQgaXRlc2VsZikuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMi50b1RleHQgPSBmdW5jdGlvbiB0b1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfTtcblxuICByZXR1cm4gVGV4dE5vZGU7XG59KCk7XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgc3BhY2UsIGJ1dCBtYXkgcmVuZGVyIGFzIDxtc3BhY2UuLi4vPiBvciBhcyB0ZXh0LFxuICogZGVwZW5kaW5nIG9uIHRoZSB3aWR0aC5cbiAqL1xuXG52YXIgU3BhY2VOb2RlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIFNwYWNlIG5vZGUgd2l0aCB3aWR0aCBnaXZlbiBpbiBDU1MgZW1zLlxuICAgKi9cbiAgZnVuY3Rpb24gU3BhY2VOb2RlKHdpZHRoKSB7XG4gICAgdGhpcy53aWR0aCA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYXJhY3RlciA9IHZvaWQgMDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7IC8vIFNlZSBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMC9XRC1NYXRoTUwyLTIwMDAwMzI4L2NoYXB0ZXI2Lmh0bWxcbiAgICAvLyBmb3IgYSB0YWJsZSBvZiBzcGFjZS1saWtlIGNoYXJhY3RlcnMuICBXZSB1c2UgVW5pY29kZVxuICAgIC8vIHJlcHJlc2VudGF0aW9ucyBpbnN0ZWFkIG9mICZMb25nTmFtZXM7IGFzIGl0J3Mgbm90IGNsZWFyIGhvdyB0b1xuICAgIC8vIG1ha2UgdGhlIGxhdHRlciB2aWEgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUuXG5cbiAgICBpZiAod2lkdGggPj0gMC4wNTU1NSAmJiB3aWR0aCA8PSAwLjA1NTU2KSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwQVwiOyAvLyAmVmVyeVRoaW5TcGFjZTtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID49IDAuMTY2NiAmJiB3aWR0aCA8PSAwLjE2NjcpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDA5XCI7IC8vICZUaGluU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAwLjIyMjIgJiYgd2lkdGggPD0gMC4yMjIzKSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwNVwiOyAvLyAmTWVkaXVtU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAwLjI3NzcgJiYgd2lkdGggPD0gMC4yNzc4KSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwNVxcdTIwMEFcIjsgLy8gJlRoaWNrU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAtMC4wNTU1NiAmJiB3aWR0aCA8PSAtMC4wNTU1NSkge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMEFcXHUyMDYzXCI7IC8vICZOZWdhdGl2ZVZlcnlUaGluU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAtMC4xNjY3ICYmIHdpZHRoIDw9IC0wLjE2NjYpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDA5XFx1MjA2M1wiOyAvLyAmTmVnYXRpdmVUaGluU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAtMC4yMjIzICYmIHdpZHRoIDw9IC0wLjIyMjIpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDVGXFx1MjA2M1wiOyAvLyAmTmVnYXRpdmVNZWRpdW1TcGFjZTtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID49IC0wLjI3NzggJiYgd2lkdGggPD0gLTAuMjc3Nykge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMDVcXHUyMDYzXCI7IC8vICZOZWdhdGl2ZVRoaWNrU3BhY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIE1hdGhNTC1uYW1lc3BhY2VkIERPTSBlbGVtZW50LlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8zID0gU3BhY2VOb2RlLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZSgpIHtcbiAgICBpZiAodGhpcy5jaGFyYWN0ZXIpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLmNoYXJhY3Rlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCBcIm1zcGFjZVwiKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdGhpcy53aWR0aCArIFwiZW1cIik7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMy50b01hcmt1cCA9IGZ1bmN0aW9uIHRvTWFya3VwKCkge1xuICAgIGlmICh0aGlzLmNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIFwiPG10ZXh0PlwiICsgdGhpcy5jaGFyYWN0ZXIgKyBcIjwvbXRleHQ+XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIjxtc3BhY2Ugd2lkdGg9XFxcIlwiICsgdGhpcy53aWR0aCArIFwiZW1cXFwiLz5cIjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIHN0cmluZywgc2ltaWxhciB0byBpbm5lclRleHQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMy50b1RleHQgPSBmdW5jdGlvbiB0b1RleHQoKSB7XG4gICAgaWYgKHRoaXMuY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFyYWN0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIiBcIjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNwYWNlTm9kZTtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbWF0aE1MVHJlZSA9ICh7XG4gIE1hdGhOb2RlOiBtYXRoTUxUcmVlX01hdGhOb2RlLFxuICBUZXh0Tm9kZTogbWF0aE1MVHJlZV9UZXh0Tm9kZSxcbiAgU3BhY2VOb2RlOiBTcGFjZU5vZGUsXG4gIG5ld0RvY3VtZW50RnJhZ21lbnQ6IG5ld0RvY3VtZW50RnJhZ21lbnRcbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYnVpbGRNYXRoTUwuanNcbi8qKlxuICogVGhpcyBmaWxlIGNvbnZlcnRzIGEgcGFyc2UgdHJlZSBpbnRvIGEgY29vcmVzcG9uZGluZyBNYXRoTUwgdHJlZS4gVGhlIG1haW5cbiAqIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRNYXRoTUxgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBhcnNlIHRyZWUgZnJvbSB0aGVcbiAqIHBhcnNlci5cbiAqL1xuXG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBUYWtlcyBhIHN5bWJvbCBhbmQgY29udmVydHMgaXQgaW50byBhIE1hdGhNTCB0ZXh0IG5vZGUgYWZ0ZXIgcGVyZm9ybWluZ1xuICogb3B0aW9uYWwgcmVwbGFjZW1lbnQgZnJvbSBzeW1ib2xzLmpzLlxuICovXG52YXIgYnVpbGRNYXRoTUxfbWFrZVRleHQgPSBmdW5jdGlvbiBtYWtlVGV4dCh0ZXh0LCBtb2RlLCBvcHRpb25zKSB7XG4gIGlmIChzcmNfc3ltYm9sc1ttb2RlXVt0ZXh0XSAmJiBzcmNfc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlICYmIHRleHQuY2hhckNvZGVBdCgwKSAhPT0gMHhEODM1ICYmICEobGlnYXR1cmVzLmhhc093blByb3BlcnR5KHRleHQpICYmIG9wdGlvbnMgJiYgKG9wdGlvbnMuZm9udEZhbWlseSAmJiBvcHRpb25zLmZvbnRGYW1pbHkuc3Vic3RyKDQsIDIpID09PSBcInR0XCIgfHwgb3B0aW9ucy5mb250ICYmIG9wdGlvbnMuZm9udC5zdWJzdHIoNCwgMikgPT09IFwidHRcIikpKSB7XG4gICAgdGV4dCA9IHNyY19zeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2U7XG4gIH1cblxuICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4dCk7XG59O1xuLyoqXG4gKiBXcmFwIHRoZSBnaXZlbiBhcnJheSBvZiBub2RlcyBpbiBhbiA8bXJvdz4gbm9kZSBpZiBuZWVkZWQsIGkuZS4sXG4gKiB1bmxlc3MgdGhlIGFycmF5IGhhcyBsZW5ndGggMS4gIEFsd2F5cyByZXR1cm5zIGEgc2luZ2xlIG5vZGUuXG4gKi9cblxudmFyIGJ1aWxkTWF0aE1MX21ha2VSb3cgPSBmdW5jdGlvbiBtYWtlUm93KGJvZHkpIHtcbiAgaWYgKGJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGJvZHlbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBib2R5KTtcbiAgfVxufTtcbi8qKlxuICogUmV0dXJucyB0aGUgbWF0aCB2YXJpYW50IGFzIGEgc3RyaW5nIG9yIG51bGwgaWYgbm9uZSBpcyByZXF1aXJlZC5cbiAqL1xuXG52YXIgYnVpbGRNYXRoTUxfZ2V0VmFyaWFudCA9IGZ1bmN0aW9uIGdldFZhcmlhbnQoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgLy8gSGFuZGxlIFxcdGV4dC4uLiBmb250IHNwZWNpZmllcnMgYXMgYmVzdCB3ZSBjYW4uXG4gIC8vIE1hdGhNTCBoYXMgYSBsaW1pdGVkIGxpc3Qgb2YgYWxsb3dhYmxlIG1hdGh2YXJpYW50IHNwZWNpZmllcnM7IHNlZVxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvTWF0aE1MMy9jaGFwdGVyMy5odG1sI3ByZXNtLmNvbW1hdHRcbiAgaWYgKG9wdGlvbnMuZm9udEZhbWlseSA9PT0gXCJ0ZXh0dHRcIikge1xuICAgIHJldHVybiBcIm1vbm9zcGFjZVwiO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udEZhbWlseSA9PT0gXCJ0ZXh0c2ZcIikge1xuICAgIGlmIChvcHRpb25zLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIiAmJiBvcHRpb25zLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmLWl0YWxpY1wiO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgICByZXR1cm4gXCJib2xkLXNhbnMtc2VyaWZcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZlwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIiAmJiBvcHRpb25zLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICByZXR1cm4gXCJib2xkLWl0YWxpY1wiO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgcmV0dXJuIFwiaXRhbGljXCI7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgcmV0dXJuIFwiYm9sZFwiO1xuICB9XG5cbiAgdmFyIGZvbnQgPSBvcHRpb25zLmZvbnQ7XG5cbiAgaWYgKCFmb250IHx8IGZvbnQgPT09IFwibWF0aG5vcm1hbFwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbW9kZSA9IGdyb3VwLm1vZGU7XG5cbiAgaWYgKGZvbnQgPT09IFwibWF0aGl0XCIpIHtcbiAgICByZXR1cm4gXCJpdGFsaWNcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcImJvbGRzeW1ib2xcIikge1xuICAgIHJldHVybiBcImJvbGQtaXRhbGljXCI7XG4gIH1cblxuICB2YXIgdGV4dCA9IGdyb3VwLnRleHQ7XG5cbiAgaWYgKHV0aWxzLmNvbnRhaW5zKFtcIlxcXFxpbWF0aFwiLCBcIlxcXFxqbWF0aFwiXSwgdGV4dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzcmNfc3ltYm9sc1ttb2RlXVt0ZXh0XSAmJiBzcmNfc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlKSB7XG4gICAgdGV4dCA9IHNyY19zeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2U7XG4gIH1cblxuICB2YXIgZm9udE5hbWUgPSBidWlsZENvbW1vbi5mb250TWFwW2ZvbnRdLmZvbnROYW1lO1xuXG4gIGlmIChnZXRDaGFyYWN0ZXJNZXRyaWNzKHRleHQsIGZvbnROYW1lLCBtb2RlKSkge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5mb250TWFwW2ZvbnRdLnZhcmlhbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBub2RlcywgYnVpbGRzIHRoZW0sIGFuZCByZXR1cm5zIGEgbGlzdCBvZiB0aGUgZ2VuZXJhdGVkXG4gKiBNYXRoTUwgbm9kZXMuICBBbHNvIGNvbWJpbmUgY29uc2VjdXRpdmUgPG10ZXh0PiBvdXRwdXRzIGludG8gYSBzaW5nbGVcbiAqIDxtdGV4dD4gdGFnLlxuICovXG5cbnZhciBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24gPSBmdW5jdGlvbiBidWlsZEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICB2YXIgZ3JvdXBzID0gW107XG4gIHZhciBsYXN0R3JvdXA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyb3VwID0gYnVpbGRNYXRoTUxfYnVpbGRHcm91cChleHByZXNzaW9uW2ldLCBvcHRpb25zKTtcblxuICAgIGlmIChncm91cCBpbnN0YW5jZW9mIG1hdGhNTFRyZWVfTWF0aE5vZGUgJiYgbGFzdEdyb3VwIGluc3RhbmNlb2YgbWF0aE1MVHJlZV9NYXRoTm9kZSkge1xuICAgICAgLy8gQ29uY2F0ZW5hdGUgYWRqYWNlbnQgPG10ZXh0PnNcbiAgICAgIGlmIChncm91cC50eXBlID09PSAnbXRleHQnICYmIGxhc3RHcm91cC50eXBlID09PSAnbXRleHQnICYmIGdyb3VwLmdldEF0dHJpYnV0ZSgnbWF0aHZhcmlhbnQnKSA9PT0gbGFzdEdyb3VwLmdldEF0dHJpYnV0ZSgnbWF0aHZhcmlhbnQnKSkge1xuICAgICAgICB2YXIgX2xhc3RHcm91cCRjaGlsZHJlbjtcblxuICAgICAgICAoX2xhc3RHcm91cCRjaGlsZHJlbiA9IGxhc3RHcm91cC5jaGlsZHJlbikucHVzaC5hcHBseShfbGFzdEdyb3VwJGNoaWxkcmVuLCBncm91cC5jaGlsZHJlbik7XG5cbiAgICAgICAgY29udGludWU7IC8vIENvbmNhdGVuYXRlIGFkamFjZW50IDxtbj5zXG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09ICdtbicgJiYgbGFzdEdyb3VwLnR5cGUgPT09ICdtbicpIHtcbiAgICAgICAgdmFyIF9sYXN0R3JvdXAkY2hpbGRyZW4yO1xuXG4gICAgICAgIChfbGFzdEdyb3VwJGNoaWxkcmVuMiA9IGxhc3RHcm91cC5jaGlsZHJlbikucHVzaC5hcHBseShfbGFzdEdyb3VwJGNoaWxkcmVuMiwgZ3JvdXAuY2hpbGRyZW4pO1xuXG4gICAgICAgIGNvbnRpbnVlOyAvLyBDb25jYXRlbmF0ZSA8bW4+Li4uPC9tbj4gZm9sbG93ZWQgYnkgPG1pPi48L21pPlxuICAgICAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSAnbWknICYmIGdyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBsYXN0R3JvdXAudHlwZSA9PT0gJ21uJykge1xuICAgICAgICB2YXIgY2hpbGQgPSBncm91cC5jaGlsZHJlblswXTtcblxuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBtYXRoTUxUcmVlX1RleHROb2RlICYmIGNoaWxkLnRleHQgPT09ICcuJykge1xuICAgICAgICAgIHZhciBfbGFzdEdyb3VwJGNoaWxkcmVuMztcblxuICAgICAgICAgIChfbGFzdEdyb3VwJGNoaWxkcmVuMyA9IGxhc3RHcm91cC5jaGlsZHJlbikucHVzaC5hcHBseShfbGFzdEdyb3VwJGNoaWxkcmVuMywgZ3JvdXAuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGFzdEdyb3VwLnR5cGUgPT09ICdtaScgJiYgbGFzdEdyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgbGFzdENoaWxkID0gbGFzdEdyb3VwLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgIGlmIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBtYXRoTUxUcmVlX1RleHROb2RlICYmIGxhc3RDaGlsZC50ZXh0ID09PSBcIlxcdTAzMzhcIiAmJiAoZ3JvdXAudHlwZSA9PT0gJ21vJyB8fCBncm91cC50eXBlID09PSAnbWknIHx8IGdyb3VwLnR5cGUgPT09ICdtbicpKSB7XG4gICAgICAgICAgdmFyIF9jaGlsZCA9IGdyb3VwLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgaWYgKF9jaGlsZCBpbnN0YW5jZW9mIG1hdGhNTFRyZWVfVGV4dE5vZGUgJiYgX2NoaWxkLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gT3ZlcmxheSB3aXRoIGNvbWJpbmluZyBjaGFyYWN0ZXIgbG9uZyBzb2xpZHVzXG4gICAgICAgICAgICBfY2hpbGQudGV4dCA9IF9jaGlsZC50ZXh0LnNsaWNlKDAsIDEpICsgXCJcXHUwMzM4XCIgKyBfY2hpbGQudGV4dC5zbGljZSgxKTtcbiAgICAgICAgICAgIGdyb3Vwcy5wb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgbGFzdEdyb3VwID0gZ3JvdXA7XG4gIH1cblxuICByZXR1cm4gZ3JvdXBzO1xufTtcbi8qKlxuICogRXF1aXZhbGVudCB0byBidWlsZEV4cHJlc3Npb24sIGJ1dCB3cmFwcyB0aGUgZWxlbWVudHMgaW4gYW4gPG1yb3c+XG4gKiBpZiB0aGVyZSdzIG1vcmUgdGhhbiBvbmUuICBSZXR1cm5zIGEgc2luZ2xlIG5vZGUgaW5zdGVhZCBvZiBhbiBhcnJheS5cbiAqL1xuXG52YXIgYnVpbGRFeHByZXNzaW9uUm93ID0gZnVuY3Rpb24gYnVpbGRFeHByZXNzaW9uUm93KGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJ1aWxkTWF0aE1MX21ha2VSb3coYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGV4cHJlc3Npb24sIG9wdGlvbnMpKTtcbn07XG4vKipcbiAqIFRha2VzIGEgZ3JvdXAgZnJvbSB0aGUgcGFyc2VyIGFuZCBjYWxscyB0aGUgYXBwcm9wcmlhdGUgZ3JvdXBCdWlsZGVycyBmdW5jdGlvblxuICogb24gaXQgdG8gcHJvZHVjZSBhIE1hdGhNTCBub2RlLlxuICovXG5cbnZhciBidWlsZE1hdGhNTF9idWlsZEdyb3VwID0gZnVuY3Rpb24gYnVpbGRHcm91cChncm91cCwgb3B0aW9ucykge1xuICBpZiAoIWdyb3VwKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcbiAgfVxuXG4gIGlmIChfbWF0aG1sR3JvdXBCdWlsZGVyc1tncm91cC50eXBlXSkge1xuICAgIC8vIENhbGwgdGhlIGdyb3VwQnVpbGRlcnMgZnVuY3Rpb25cbiAgICB2YXIgcmVzdWx0ID0gX21hdGhtbEdyb3VwQnVpbGRlcnNbZ3JvdXAudHlwZV0oZ3JvdXAsIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiR290IGdyb3VwIG9mIHVua25vd24gdHlwZTogJ1wiICsgZ3JvdXAudHlwZSArIFwiJ1wiKTtcbiAgfVxufTtcbi8qKlxuICogVGFrZXMgYSBmdWxsIHBhcnNlIHRyZWUgYW5kIHNldHRpbmdzIGFuZCBidWlsZHMgYSBNYXRoTUwgcmVwcmVzZW50YXRpb24gb2ZcbiAqIGl0LiBJbiBwYXJ0aWN1bGFyLCB3ZSBwdXQgdGhlIGVsZW1lbnRzIGZyb20gYnVpbGRpbmcgdGhlIHBhcnNlIHRyZWUgaW50byBhXG4gKiA8c2VtYW50aWNzPiB0YWcgc28gd2UgY2FuIGFsc28gaW5jbHVkZSB0aGF0IFRlWCBzb3VyY2UgYXMgYW4gYW5ub3RhdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgd2UgYWN0dWFsbHkgcmV0dXJuIGEgZG9tVHJlZSBlbGVtZW50IHdpdGggYSBgPG1hdGg+YCBpbnNpZGUgaXQgc29cbiAqIHdlIGNhbiBkbyBhcHByb3ByaWF0ZSBzdHlsaW5nLlxuICovXG5cbmZ1bmN0aW9uIGJ1aWxkTWF0aE1MKHRyZWUsIHRleEV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgdmFyIGV4cHJlc3Npb24gPSBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24odHJlZSwgb3B0aW9ucyk7IC8vIFdyYXAgdXAgdGhlIGV4cHJlc3Npb24gaW4gYW4gbXJvdyBzbyBpdCBpcyBwcmVzZW50ZWQgaW4gdGhlIHNlbWFudGljc1xuICAvLyB0YWcgY29ycmVjdGx5LCB1bmxlc3MgaXQncyBhIHNpbmdsZSA8bXJvdz4gb3IgPG10YWJsZT4uXG5cbiAgdmFyIHdyYXBwZXI7XG5cbiAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAxICYmIGV4cHJlc3Npb25bMF0gaW5zdGFuY2VvZiBtYXRoTUxUcmVlX01hdGhOb2RlICYmIHV0aWxzLmNvbnRhaW5zKFtcIm1yb3dcIiwgXCJtdGFibGVcIl0sIGV4cHJlc3Npb25bMF0udHlwZSkpIHtcbiAgICB3cmFwcGVyID0gZXhwcmVzc2lvblswXTtcbiAgfSBlbHNlIHtcbiAgICB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGV4cHJlc3Npb24pO1xuICB9IC8vIEJ1aWxkIGEgVGVYIGFubm90YXRpb24gb2YgdGhlIHNvdXJjZVxuXG5cbiAgdmFyIGFubm90YXRpb24gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcImFubm90YXRpb25cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKHRleEV4cHJlc3Npb24pXSk7XG4gIGFubm90YXRpb24uc2V0QXR0cmlidXRlKFwiZW5jb2RpbmdcIiwgXCJhcHBsaWNhdGlvbi94LXRleFwiKTtcbiAgdmFyIHNlbWFudGljcyA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwic2VtYW50aWNzXCIsIFt3cmFwcGVyLCBhbm5vdGF0aW9uXSk7XG4gIHZhciBtYXRoID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtYXRoXCIsIFtzZW1hbnRpY3NdKTsgLy8gWW91IGNhbid0IHN0eWxlIDxtYXRoPiBub2Rlcywgc28gd2Ugd3JhcCB0aGUgbm9kZSBpbiBhIHNwYW4uXG4gIC8vIE5PVEU6IFRoZSBzcGFuIGNsYXNzIGlzIG5vdCB0eXBlZCB0byBoYXZlIDxtYXRoPiBub2RlcyBhcyBjaGlsZHJlbiwgYW5kXG4gIC8vIHdlIGRvbid0IHdhbnQgdG8gbWFrZSB0aGUgY2hpbGRyZW4gdHlwZSBtb3JlIGdlbmVyaWMgc2luY2UgdGhlIGNoaWxkcmVuXG4gIC8vIG9mIHNwYW4gYXJlIGV4cGVjdGVkIHRvIGhhdmUgbW9yZSBmaWVsZHMgaW4gYGJ1aWxkSHRtbGAgY29udGV4dHMuXG4gIC8vICRGbG93Rml4TWVcblxuICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wia2F0ZXgtbWF0aG1sXCJdLCBbbWF0aF0pO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYnVpbGRUcmVlLmpzXG5cblxuXG5cblxuXG5cbnZhciBidWlsZFRyZWVfb3B0aW9uc0Zyb21TZXR0aW5ncyA9IGZ1bmN0aW9uIG9wdGlvbnNGcm9tU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgcmV0dXJuIG5ldyBzcmNfT3B0aW9ucyh7XG4gICAgc3R5bGU6IHNldHRpbmdzLmRpc3BsYXlNb2RlID8gc3JjX1N0eWxlLkRJU1BMQVkgOiBzcmNfU3R5bGUuVEVYVCxcbiAgICBtYXhTaXplOiBzZXR0aW5ncy5tYXhTaXplXG4gIH0pO1xufTtcblxudmFyIGJ1aWxkVHJlZV9kaXNwbGF5V3JhcCA9IGZ1bmN0aW9uIGRpc3BsYXlXcmFwKG5vZGUsIHNldHRpbmdzKSB7XG4gIGlmIChzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgIHZhciBjbGFzc2VzID0gW1wia2F0ZXgtZGlzcGxheVwiXTtcblxuICAgIGlmIChzZXR0aW5ncy5sZXFubykge1xuICAgICAgY2xhc3Nlcy5wdXNoKFwibGVxbm9cIik7XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLmZsZXFuKSB7XG4gICAgICBjbGFzc2VzLnB1c2goXCJmbGVxblwiKTtcbiAgICB9XG5cbiAgICBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oY2xhc3NlcywgW25vZGVdKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIGJ1aWxkVHJlZV9idWlsZFRyZWUgPSBmdW5jdGlvbiBidWlsZFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpIHtcbiAgdmFyIG9wdGlvbnMgPSBidWlsZFRyZWVfb3B0aW9uc0Zyb21TZXR0aW5ncyhzZXR0aW5ncyk7XG4gIHZhciBtYXRoTUxOb2RlID0gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgb3B0aW9ucyk7XG4gIHZhciBodG1sTm9kZSA9IGJ1aWxkSFRNTCh0cmVlLCBvcHRpb25zKTtcbiAgdmFyIGthdGV4Tm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImthdGV4XCJdLCBbbWF0aE1MTm9kZSwgaHRtbE5vZGVdKTtcbiAgcmV0dXJuIGJ1aWxkVHJlZV9kaXNwbGF5V3JhcChrYXRleE5vZGUsIHNldHRpbmdzKTtcbn07XG52YXIgYnVpbGRUcmVlX2J1aWxkSFRNTFRyZWUgPSBmdW5jdGlvbiBidWlsZEhUTUxUcmVlKHRyZWUsIGV4cHJlc3Npb24sIHNldHRpbmdzKSB7XG4gIHZhciBvcHRpb25zID0gYnVpbGRUcmVlX29wdGlvbnNGcm9tU2V0dGluZ3Moc2V0dGluZ3MpO1xuICB2YXIgaHRtbE5vZGUgPSBidWlsZEhUTUwodHJlZSwgb3B0aW9ucyk7XG4gIHZhciBrYXRleE5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJrYXRleFwiXSwgW2h0bWxOb2RlXSk7XG4gIHJldHVybiBidWlsZFRyZWVfZGlzcGxheVdyYXAoa2F0ZXhOb2RlLCBzZXR0aW5ncyk7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2J1aWxkVHJlZSA9IChidWlsZFRyZWVfYnVpbGRUcmVlKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3N0cmV0Y2h5LmpzXG4vKipcbiAqIFRoaXMgZmlsZSBwcm92aWRlcyBzdXBwb3J0IHRvIGJ1aWxkTWF0aE1MLmpzIGFuZCBidWlsZEhUTUwuanNcbiAqIGZvciBzdHJldGNoeSB3aWRlIGVsZW1lbnRzIHJlbmRlcmVkIGZyb20gU1ZHIGZpbGVzXG4gKiBhbmQgb3RoZXIgQ1NTIHRyaWNrZXJ5LlxuICovXG5cblxuXG5cbnZhciBzdHJldGNoeUNvZGVQb2ludCA9IHtcbiAgd2lkZWhhdDogXCJeXCIsXG4gIHdpZGVjaGVjazogXCLLh1wiLFxuICB3aWRldGlsZGU6IFwiflwiLFxuICB1dGlsZGU6IFwiflwiLFxuICBvdmVybGVmdGFycm93OiBcIlxcdTIxOTBcIixcbiAgdW5kZXJsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICB4bGVmdGFycm93OiBcIlxcdTIxOTBcIixcbiAgb3ZlcnJpZ2h0YXJyb3c6IFwiXFx1MjE5MlwiLFxuICB1bmRlcnJpZ2h0YXJyb3c6IFwiXFx1MjE5MlwiLFxuICB4cmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHVuZGVyYnJhY2U6IFwiXFx1MjNERlwiLFxuICBvdmVyYnJhY2U6IFwiXFx1MjNERVwiLFxuICBvdmVyZ3JvdXA6IFwiXFx1MjNFMFwiLFxuICB1bmRlcmdyb3VwOiBcIlxcdTIzRTFcIixcbiAgb3ZlcmxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgdW5kZXJsZWZ0cmlnaHRhcnJvdzogXCJcXHUyMTk0XCIsXG4gIHhsZWZ0cmlnaHRhcnJvdzogXCJcXHUyMTk0XCIsXG4gIE92ZXJyaWdodGFycm93OiBcIlxcdTIxRDJcIixcbiAgeFJpZ2h0YXJyb3c6IFwiXFx1MjFEMlwiLFxuICBvdmVybGVmdGhhcnBvb246IFwiXFx1MjFCQ1wiLFxuICB4bGVmdGhhcnBvb251cDogXCJcXHUyMUJDXCIsXG4gIG92ZXJyaWdodGhhcnBvb246IFwiXFx1MjFDMFwiLFxuICB4cmlnaHRoYXJwb29udXA6IFwiXFx1MjFDMFwiLFxuICB4TGVmdGFycm93OiBcIlxcdTIxRDBcIixcbiAgeExlZnRyaWdodGFycm93OiBcIlxcdTIxRDRcIixcbiAgeGhvb2tsZWZ0YXJyb3c6IFwiXFx1MjFBOVwiLFxuICB4aG9va3JpZ2h0YXJyb3c6IFwiXFx1MjFBQVwiLFxuICB4bWFwc3RvOiBcIlxcdTIxQTZcIixcbiAgeHJpZ2h0aGFycG9vbmRvd246IFwiXFx1MjFDMVwiLFxuICB4bGVmdGhhcnBvb25kb3duOiBcIlxcdTIxQkRcIixcbiAgeHJpZ2h0bGVmdGhhcnBvb25zOiBcIlxcdTIxQ0NcIixcbiAgeGxlZnRyaWdodGhhcnBvb25zOiBcIlxcdTIxQ0JcIixcbiAgeHR3b2hlYWRsZWZ0YXJyb3c6IFwiXFx1MjE5RVwiLFxuICB4dHdvaGVhZHJpZ2h0YXJyb3c6IFwiXFx1MjFBMFwiLFxuICB4bG9uZ2VxdWFsOiBcIj1cIixcbiAgeHRvZnJvbTogXCJcXHUyMUM0XCIsXG4gIHhyaWdodGxlZnRhcnJvd3M6IFwiXFx1MjFDNFwiLFxuICB4cmlnaHRlcXVpbGlicml1bTogXCJcXHUyMUNDXCIsXG4gIC8vIE5vdCBhIHBlcmZlY3QgbWF0Y2guXG4gIHhsZWZ0ZXF1aWxpYnJpdW06IFwiXFx1MjFDQlwiIC8vIE5vbmUgYmV0dGVyIGF2YWlsYWJsZS5cblxufTtcblxudmFyIHN0cmV0Y2h5X21hdGhNTG5vZGUgPSBmdW5jdGlvbiBtYXRoTUxub2RlKGxhYmVsKSB7XG4gIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoc3RyZXRjaHlDb2RlUG9pbnRbbGFiZWwuc3Vic3RyKDEpXSldKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gIHJldHVybiBub2RlO1xufTsgLy8gTWFueSBvZiB0aGUgS2FUZVggU1ZHIGltYWdlcyBoYXZlIGJlZW4gYWRhcHRlZCBmcm9tIGdseXBocyBpbiBLYVRlWCBmb250cy5cbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBEZXNpZ24gU2NpZW5jZSwgSW5jLiAoPHd3dy5tYXRoamF4Lm9yZz4pXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNyBLaGFuIEFjYWRlbXkgKDx3d3cua2hhbmFjYWRlbXkub3JnPilcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBTSUwgT3BlbiBGb250IExpY2Vuc2UsIFZlcnNpb24gMS4xLlxuLy8gU2VlIFxcbmh0dHA6Ly9zY3JpcHRzLnNpbC5vcmcvT0ZMXG4vLyBWZXJ5IExvbmcgU1ZHc1xuLy8gICAgTWFueSBvZiB0aGUgS2FUZVggc3RyZXRjaHkgd2lkZSBlbGVtZW50cyB1c2UgYSBsb25nIFNWRyBpbWFnZSBhbmQgYW5cbi8vICAgIG92ZXJmbG93OiBoaWRkZW4gdGFjdGljIHRvIGFjaGlldmUgYSBzdHJldGNoeSBpbWFnZSB3aGlsZSBhdm9pZGluZ1xuLy8gICAgZGlzdG9ydGlvbiBvZiBhcnJvd2hlYWRzIG9yIGJyYWNlIGNvcm5lcnMuXG4vLyAgICBUaGUgU1ZHIHR5cGljYWxseSBjb250YWlucyBhIHZlcnkgbG9uZyAoNDAwIGVtKSBhcnJvdy5cbi8vICAgIFRoZSBTVkcgaXMgaW4gYSBjb250YWluZXIgc3BhbiB0aGF0IGhhcyBvdmVyZmxvdzogaGlkZGVuLCBzbyB0aGUgc3BhblxuLy8gICAgYWN0cyBsaWtlIGEgd2luZG93IHRoYXQgZXhwb3NlcyBvbmx5IHBhcnQgb2YgdGhlICBTVkcuXG4vLyAgICBUaGUgU1ZHIGFsd2F5cyBoYXMgYSBsb25nZXIsIHRoaW5uZXIgYXNwZWN0IHJhdGlvIHRoYW4gdGhlIGNvbnRhaW5lciBzcGFuLlxuLy8gICAgQWZ0ZXIgdGhlIFNWRyBmaWxscyAxMDAlIG9mIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lciBzcGFuLFxuLy8gICAgdGhlcmUgaXMgYSBsb25nIGFycm93IHNoYWZ0IGxlZnQgb3Zlci4gVGhhdCBsZWZ0LW92ZXIgc2hhZnQgaXMgbm90IHNob3duLlxuLy8gICAgSW5zdGVhZCwgaXQgaXMgc2xpY2VkIG9mZiBiZWNhdXNlIHRoZSBzcGFuJ3MgQ1NTIGhhcyBvdmVyZmxvdzogaGlkZGVuLlxuLy8gICAgVGh1cywgdGhlIHJlYWRlciBzZWVzIGFuIGFycm93IHRoYXQgbWF0Y2hlcyB0aGUgc3ViamVjdCBtYXR0ZXIgd2lkdGhcbi8vICAgIHdpdGhvdXQgZGlzdG9ydGlvbi5cbi8vICAgIFNvbWUgZnVuY3Rpb25zLCBzdWNoIGFzIFxcY2FuY2VsLCBuZWVkIHRvIHZhcnkgdGhlaXIgYXNwZWN0IHJhdGlvLiBUaGVzZVxuLy8gICAgZnVuY3Rpb25zIGRvIG5vdCBnZXQgdGhlIG92ZXJmbG93IFNWRyB0cmVhdG1lbnQuXG4vLyBTZWNvbmQgQnJ1c2ggU3Ryb2tlXG4vLyAgICBMb3cgcmVzb2x1dGlvbiBtb25pdG9ycyBzdHJ1Z2dsZSB0byBkaXNwbGF5IGltYWdlcyBpbiBmaW5lIGRldGFpbC5cbi8vICAgIFNvIGJyb3dzZXJzIGFwcGx5IGFudGktYWxpYXNpbmcuIEEgbG9uZyBzdHJhaWdodCBhcnJvdyBzaGFmdCB0aGVyZWZvcmVcbi8vICAgIHdpbGwgc29tZXRpbWVzIGFwcGVhciBhcyBpZiBpdCBoYXMgYSBibHVycmVkIGVkZ2UuXG4vLyAgICBUbyBtaXRpZ2F0ZSB0aGlzLCB0aGVzZSBTVkcgZmlsZXMgY29udGFpbiBhIHNlY29uZCBcImJydXNoLXN0cm9rZVwiIG9uIHRoZVxuLy8gICAgYXJyb3cgc2hhZnRzLiBUaGF0IGlzLCBhIHNlY29uZCBsb25nIHRoaW4gcmVjdGFuZ3VsYXIgU1ZHIHBhdGggaGFzIGJlZW5cbi8vICAgIHdyaXR0ZW4gZGlyZWN0bHkgb24gdG9wIG9mIGVhY2ggYXJyb3cgc2hhZnQuIFRoaXMgcmVpbmZvcmNlbWVudCBjYXVzZXNcbi8vICAgIHNvbWUgb2YgdGhlIHNjcmVlbiBwaXhlbHMgdG8gZGlzcGxheSBhcyBibGFjayBpbnN0ZWFkIG9mIHRoZSBhbnRpLWFsaWFzZWRcbi8vICAgIGdyYXkgcGl4ZWwgdGhhdCBhICBzaW5nbGUgcGF0aCB3b3VsZCBnZW5lcmF0ZS4gU28gd2UgZ2V0IGFycm93IHNoYWZ0c1xuLy8gICAgd2hvc2UgZWRnZXMgYXBwZWFyIHRvIGJlIHNoYXJwZXIuXG4vLyBJbiB0aGUga2F0ZXhJbWFnZXNEYXRhIG9iamVjdCBqdXN0IGJlbG93LCB0aGUgZGltZW5zaW9ucyBhbGxcbi8vIGNvcnJlc3BvbmQgdG8gcGF0aCBnZW9tZXRyeSBpbnNpZGUgdGhlIHJlbGV2YW50IFNWRy5cbi8vIEZvciBleGFtcGxlLCBcXG92ZXJyaWdodGFycm93IHVzZXMgdGhlIHNhbWUgYXJyb3doZWFkIGFzIGdseXBoIFUrMjE5MlxuLy8gZnJvbSB0aGUgS2FUZVggTWFpbiBmb250LiBUaGUgc2NhbGluZyBmYWN0b3IgaXMgMTAwMC5cbi8vIFRoYXQgaXMsIGluc2lkZSB0aGUgZm9udCwgdGhhdCBhcnJvd2hlYWQgaXMgNTIyIHVuaXRzIHRhbGwsIHdoaWNoXG4vLyBjb3JyZXNwb25kcyB0byAwLjUyMiBlbSBpbnNpZGUgdGhlIGRvY3VtZW50LlxuXG5cbnZhciBrYXRleEltYWdlc0RhdGEgPSB7XG4gIC8vICAgcGF0aChzKSwgbWluV2lkdGgsIGhlaWdodCwgYWxpZ25cbiAgb3ZlcnJpZ2h0YXJyb3c6IFtbXCJyaWdodGFycm93XCJdLCAwLjg4OCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICBvdmVybGVmdGFycm93OiBbW1wibGVmdGFycm93XCJdLCAwLjg4OCwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICB1bmRlcnJpZ2h0YXJyb3c6IFtbXCJyaWdodGFycm93XCJdLCAwLjg4OCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICB1bmRlcmxlZnRhcnJvdzogW1tcImxlZnRhcnJvd1wiXSwgMC44ODgsIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgeHJpZ2h0YXJyb3c6IFtbXCJyaWdodGFycm93XCJdLCAxLjQ2OSwgNTIyLCBcInhNYXhZTWluXCJdLFxuICB4bGVmdGFycm93OiBbW1wibGVmdGFycm93XCJdLCAxLjQ2OSwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICBPdmVycmlnaHRhcnJvdzogW1tcImRvdWJsZXJpZ2h0YXJyb3dcIl0sIDAuODg4LCA1NjAsIFwieE1heFlNaW5cIl0sXG4gIHhSaWdodGFycm93OiBbW1wiZG91YmxlcmlnaHRhcnJvd1wiXSwgMS41MjYsIDU2MCwgXCJ4TWF4WU1pblwiXSxcbiAgeExlZnRhcnJvdzogW1tcImRvdWJsZWxlZnRhcnJvd1wiXSwgMS41MjYsIDU2MCwgXCJ4TWluWU1pblwiXSxcbiAgb3ZlcmxlZnRoYXJwb29uOiBbW1wibGVmdGhhcnBvb25cIl0sIDAuODg4LCA1MjIsIFwieE1pbllNaW5cIl0sXG4gIHhsZWZ0aGFycG9vbnVwOiBbW1wibGVmdGhhcnBvb25cIl0sIDAuODg4LCA1MjIsIFwieE1pbllNaW5cIl0sXG4gIHhsZWZ0aGFycG9vbmRvd246IFtbXCJsZWZ0aGFycG9vbmRvd25cIl0sIDAuODg4LCA1MjIsIFwieE1pbllNaW5cIl0sXG4gIG92ZXJyaWdodGhhcnBvb246IFtbXCJyaWdodGhhcnBvb25cIl0sIDAuODg4LCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIHhyaWdodGhhcnBvb251cDogW1tcInJpZ2h0aGFycG9vblwiXSwgMC44ODgsIDUyMiwgXCJ4TWF4WU1pblwiXSxcbiAgeHJpZ2h0aGFycG9vbmRvd246IFtbXCJyaWdodGhhcnBvb25kb3duXCJdLCAwLjg4OCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICB4bG9uZ2VxdWFsOiBbW1wibG9uZ2VxdWFsXCJdLCAwLjg4OCwgMzM0LCBcInhNaW5ZTWluXCJdLFxuICB4dHdvaGVhZGxlZnRhcnJvdzogW1tcInR3b2hlYWRsZWZ0YXJyb3dcIl0sIDAuODg4LCAzMzQsIFwieE1pbllNaW5cIl0sXG4gIHh0d29oZWFkcmlnaHRhcnJvdzogW1tcInR3b2hlYWRyaWdodGFycm93XCJdLCAwLjg4OCwgMzM0LCBcInhNYXhZTWluXCJdLFxuICBvdmVybGVmdHJpZ2h0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIiwgXCJyaWdodGFycm93XCJdLCAwLjg4OCwgNTIyXSxcbiAgb3ZlcmJyYWNlOiBbW1wibGVmdGJyYWNlXCIsIFwibWlkYnJhY2VcIiwgXCJyaWdodGJyYWNlXCJdLCAxLjYsIDU0OF0sXG4gIHVuZGVyYnJhY2U6IFtbXCJsZWZ0YnJhY2V1bmRlclwiLCBcIm1pZGJyYWNldW5kZXJcIiwgXCJyaWdodGJyYWNldW5kZXJcIl0sIDEuNiwgNTQ4XSxcbiAgdW5kZXJsZWZ0cmlnaHRhcnJvdzogW1tcImxlZnRhcnJvd1wiLCBcInJpZ2h0YXJyb3dcIl0sIDAuODg4LCA1MjJdLFxuICB4bGVmdHJpZ2h0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIiwgXCJyaWdodGFycm93XCJdLCAxLjc1LCA1MjJdLFxuICB4TGVmdHJpZ2h0YXJyb3c6IFtbXCJkb3VibGVsZWZ0YXJyb3dcIiwgXCJkb3VibGVyaWdodGFycm93XCJdLCAxLjc1LCA1NjBdLFxuICB4cmlnaHRsZWZ0aGFycG9vbnM6IFtbXCJsZWZ0aGFycG9vbmRvd25wbHVzXCIsIFwicmlnaHRoYXJwb29ucGx1c1wiXSwgMS43NSwgNzE2XSxcbiAgeGxlZnRyaWdodGhhcnBvb25zOiBbW1wibGVmdGhhcnBvb25wbHVzXCIsIFwicmlnaHRoYXJwb29uZG93bnBsdXNcIl0sIDEuNzUsIDcxNl0sXG4gIHhob29rbGVmdGFycm93OiBbW1wibGVmdGFycm93XCIsIFwicmlnaHRob29rXCJdLCAxLjA4LCA1MjJdLFxuICB4aG9va3JpZ2h0YXJyb3c6IFtbXCJsZWZ0aG9va1wiLCBcInJpZ2h0YXJyb3dcIl0sIDEuMDgsIDUyMl0sXG4gIG92ZXJsaW5lc2VnbWVudDogW1tcImxlZnRsaW5lc2VnbWVudFwiLCBcInJpZ2h0bGluZXNlZ21lbnRcIl0sIDAuODg4LCA1MjJdLFxuICB1bmRlcmxpbmVzZWdtZW50OiBbW1wibGVmdGxpbmVzZWdtZW50XCIsIFwicmlnaHRsaW5lc2VnbWVudFwiXSwgMC44ODgsIDUyMl0sXG4gIG92ZXJncm91cDogW1tcImxlZnRncm91cFwiLCBcInJpZ2h0Z3JvdXBcIl0sIDAuODg4LCAzNDJdLFxuICB1bmRlcmdyb3VwOiBbW1wibGVmdGdyb3VwdW5kZXJcIiwgXCJyaWdodGdyb3VwdW5kZXJcIl0sIDAuODg4LCAzNDJdLFxuICB4bWFwc3RvOiBbW1wibGVmdG1hcHN0b1wiLCBcInJpZ2h0YXJyb3dcIl0sIDEuNSwgNTIyXSxcbiAgeHRvZnJvbTogW1tcImxlZnRUb0Zyb21cIiwgXCJyaWdodFRvRnJvbVwiXSwgMS43NSwgNTI4XSxcbiAgLy8gVGhlIG5leHQgdGhyZWUgYXJyb3dzIGFyZSBmcm9tIHRoZSBtaGNoZW0gcGFja2FnZS5cbiAgLy8gSW4gbWhjaGVtLnN0eSwgbWluLWxlbmd0aCBpcyAyLjBlbS4gQnV0IHRoZXNlIGFycm93cyBtaWdodCBhcHBlYXIgaW4gdGhlXG4gIC8vIGRvY3VtZW50IGFzIFxceHJpZ2h0YXJyb3cgb3IgXFx4cmlnaHRsZWZ0aGFycG9vbnMuIFRob3NlIGhhdmVcbiAgLy8gbWluLWxlbmd0aCA9IDEuNzVlbSwgc28gd2Ugc2V0IG1pbi1sZW5ndGggb24gdGhlc2UgbmV4dCB0aHJlZSB0byBtYXRjaC5cbiAgeHJpZ2h0bGVmdGFycm93czogW1tcImJhcmFib3ZlbGVmdGFycm93XCIsIFwicmlnaHRhcnJvd2Fib3ZlYmFyXCJdLCAxLjc1LCA5MDFdLFxuICB4cmlnaHRlcXVpbGlicml1bTogW1tcImJhcmFib3Zlc2hvcnRsZWZ0aGFycG9vblwiLCBcInJpZ2h0aGFycG9vbmFib3Zlc2hvcnRiYXJcIl0sIDEuNzUsIDcxNl0sXG4gIHhsZWZ0ZXF1aWxpYnJpdW06IFtbXCJzaG9ydGJhcmFib3ZlbGVmdGhhcnBvb25cIiwgXCJzaG9ydHJpZ2h0aGFycG9vbmFib3ZlYmFyXCJdLCAxLjc1LCA3MTZdXG59O1xuXG52YXIgZ3JvdXBMZW5ndGggPSBmdW5jdGlvbiBncm91cExlbmd0aChhcmcpIHtcbiAgaWYgKGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICByZXR1cm4gYXJnLmJvZHkubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxO1xuICB9XG59O1xuXG52YXIgc3RyZXRjaHlfc3ZnU3BhbiA9IGZ1bmN0aW9uIHN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgLy8gQ3JlYXRlIGEgc3BhbiB3aXRoIGlubGluZSBTVkcgZm9yIHRoZSBlbGVtZW50LlxuICBmdW5jdGlvbiBidWlsZFN2Z1NwYW5fKCkge1xuICAgIHZhciB2aWV3Qm94V2lkdGggPSA0MDAwMDA7IC8vIGRlZmF1bHRcblxuICAgIHZhciBsYWJlbCA9IGdyb3VwLmxhYmVsLnN1YnN0cigxKTtcblxuICAgIGlmICh1dGlscy5jb250YWlucyhbXCJ3aWRlaGF0XCIsIFwid2lkZWNoZWNrXCIsIFwid2lkZXRpbGRlXCIsIFwidXRpbGRlXCJdLCBsYWJlbCkpIHtcbiAgICAgIC8vIEVhY2ggdHlwZSBpbiB0aGUgYGlmYCBzdGF0ZW1lbnQgY29ycmVzcG9uZHMgdG8gb25lIG9mIHRoZSBQYXJzZU5vZGVcbiAgICAgIC8vIHR5cGVzIGJlbG93LiBUaGlzIG5hcnJvd2luZyBpcyByZXF1aXJlZCB0byBhY2Nlc3MgYGdycC5iYXNlYC5cbiAgICAgIHZhciBncnAgPSBncm91cDsgLy8gVGhlcmUgYXJlIGZvdXIgU1ZHIGltYWdlcyBhdmFpbGFibGUgZm9yIGVhY2ggZnVuY3Rpb24uXG4gICAgICAvLyBDaG9vc2UgYSB0YWxsZXIgaW1hZ2Ugd2hlbiB0aGVyZSBhcmUgbW9yZSBjaGFyYWN0ZXJzLlxuXG4gICAgICB2YXIgbnVtQ2hhcnMgPSBncm91cExlbmd0aChncnAuYmFzZSk7XG4gICAgICB2YXIgdmlld0JveEhlaWdodDtcbiAgICAgIHZhciBwYXRoTmFtZTtcblxuICAgICAgdmFyIF9oZWlnaHQ7XG5cbiAgICAgIGlmIChudW1DaGFycyA+IDUpIHtcbiAgICAgICAgaWYgKGxhYmVsID09PSBcIndpZGVoYXRcIiB8fCBsYWJlbCA9PT0gXCJ3aWRlY2hlY2tcIikge1xuICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSA0MjA7XG4gICAgICAgICAgdmlld0JveFdpZHRoID0gMjM2NDtcbiAgICAgICAgICBfaGVpZ2h0ID0gMC40MjtcbiAgICAgICAgICBwYXRoTmFtZSA9IGxhYmVsICsgXCI0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlld0JveEhlaWdodCA9IDMxMjtcbiAgICAgICAgICB2aWV3Qm94V2lkdGggPSAyMzQwO1xuICAgICAgICAgIF9oZWlnaHQgPSAwLjM0O1xuICAgICAgICAgIHBhdGhOYW1lID0gXCJ0aWxkZTRcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGltZ0luZGV4ID0gWzEsIDEsIDIsIDIsIDMsIDNdW251bUNoYXJzXTtcblxuICAgICAgICBpZiAobGFiZWwgPT09IFwid2lkZWhhdFwiIHx8IGxhYmVsID09PSBcIndpZGVjaGVja1wiKSB7XG4gICAgICAgICAgdmlld0JveFdpZHRoID0gWzAsIDEwNjIsIDIzNjQsIDIzNjQsIDIzNjRdW2ltZ0luZGV4XTtcbiAgICAgICAgICB2aWV3Qm94SGVpZ2h0ID0gWzAsIDIzOSwgMzAwLCAzNjAsIDQyMF1baW1nSW5kZXhdO1xuICAgICAgICAgIF9oZWlnaHQgPSBbMCwgMC4yNCwgMC4zLCAwLjMsIDAuMzYsIDAuNDJdW2ltZ0luZGV4XTtcbiAgICAgICAgICBwYXRoTmFtZSA9IGxhYmVsICsgaW1nSW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlld0JveFdpZHRoID0gWzAsIDYwMCwgMTAzMywgMjMzOSwgMjM0MF1baW1nSW5kZXhdO1xuICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSBbMCwgMjYwLCAyODYsIDMwNiwgMzEyXVtpbWdJbmRleF07XG4gICAgICAgICAgX2hlaWdodCA9IFswLCAwLjI2LCAwLjI4NiwgMC4zLCAwLjMwNiwgMC4zNF1baW1nSW5kZXhdO1xuICAgICAgICAgIHBhdGhOYW1lID0gXCJ0aWxkZVwiICsgaW1nSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGggPSBuZXcgZG9tVHJlZV9QYXRoTm9kZShwYXRoTmFtZSk7XG4gICAgICB2YXIgc3ZnTm9kZSA9IG5ldyBTdmdOb2RlKFtwYXRoXSwge1xuICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxuICAgICAgICBcImhlaWdodFwiOiBfaGVpZ2h0ICsgXCJlbVwiLFxuICAgICAgICBcInZpZXdCb3hcIjogXCIwIDAgXCIgKyB2aWV3Qm94V2lkdGggKyBcIiBcIiArIHZpZXdCb3hIZWlnaHQsXG4gICAgICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBcIm5vbmVcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzcGFuOiBidWlsZENvbW1vbi5tYWtlU3ZnU3BhbihbXSwgW3N2Z05vZGVdLCBvcHRpb25zKSxcbiAgICAgICAgbWluV2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogX2hlaWdodFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNwYW5zID0gW107XG4gICAgICB2YXIgZGF0YSA9IGthdGV4SW1hZ2VzRGF0YVtsYWJlbF07XG4gICAgICB2YXIgcGF0aHMgPSBkYXRhWzBdLFxuICAgICAgICAgIF9taW5XaWR0aCA9IGRhdGFbMV0sXG4gICAgICAgICAgX3ZpZXdCb3hIZWlnaHQgPSBkYXRhWzJdO1xuXG4gICAgICB2YXIgX2hlaWdodDIgPSBfdmlld0JveEhlaWdodCAvIDEwMDA7XG5cbiAgICAgIHZhciBudW1TdmdDaGlsZHJlbiA9IHBhdGhzLmxlbmd0aDtcbiAgICAgIHZhciB3aWR0aENsYXNzZXM7XG4gICAgICB2YXIgYWxpZ25zO1xuXG4gICAgICBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDEpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZTogQWxsIHRoZXNlIGNhc2VzIG11c3QgYmUgb2YgdGhlIDQtdHVwbGUgdHlwZS5cbiAgICAgICAgdmFyIGFsaWduMSA9IGRhdGFbM107XG4gICAgICAgIHdpZHRoQ2xhc3NlcyA9IFtcImhpZGUtdGFpbFwiXTtcbiAgICAgICAgYWxpZ25zID0gW2FsaWduMV07XG4gICAgICB9IGVsc2UgaWYgKG51bVN2Z0NoaWxkcmVuID09PSAyKSB7XG4gICAgICAgIHdpZHRoQ2xhc3NlcyA9IFtcImhhbGZhcnJvdy1sZWZ0XCIsIFwiaGFsZmFycm93LXJpZ2h0XCJdO1xuICAgICAgICBhbGlnbnMgPSBbXCJ4TWluWU1pblwiLCBcInhNYXhZTWluXCJdO1xuICAgICAgfSBlbHNlIGlmIChudW1TdmdDaGlsZHJlbiA9PT0gMykge1xuICAgICAgICB3aWR0aENsYXNzZXMgPSBbXCJicmFjZS1sZWZ0XCIsIFwiYnJhY2UtY2VudGVyXCIsIFwiYnJhY2UtcmlnaHRcIl07XG4gICAgICAgIGFsaWducyA9IFtcInhNaW5ZTWluXCIsIFwieE1pZFlNaW5cIiwgXCJ4TWF4WU1pblwiXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJlY3Qga2F0ZXhJbWFnZXNEYXRhIG9yIHVwZGF0ZSBjb2RlIGhlcmUgdG8gc3VwcG9ydFxcbiAgICAgICAgICAgICAgICAgICAgXCIgKyBudW1TdmdDaGlsZHJlbiArIFwiIGNoaWxkcmVuLlwiKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TdmdDaGlsZHJlbjsgaSsrKSB7XG4gICAgICAgIHZhciBfcGF0aCA9IG5ldyBkb21UcmVlX1BhdGhOb2RlKHBhdGhzW2ldKTtcblxuICAgICAgICB2YXIgX3N2Z05vZGUgPSBuZXcgU3ZnTm9kZShbX3BhdGhdLCB7XG4gICAgICAgICAgXCJ3aWR0aFwiOiBcIjQwMGVtXCIsXG4gICAgICAgICAgXCJoZWlnaHRcIjogX2hlaWdodDIgKyBcImVtXCIsXG4gICAgICAgICAgXCJ2aWV3Qm94XCI6IFwiMCAwIFwiICsgdmlld0JveFdpZHRoICsgXCIgXCIgKyBfdmlld0JveEhlaWdodCxcbiAgICAgICAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIjogYWxpZ25zW2ldICsgXCIgc2xpY2VcIlxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgX3NwYW4gPSBidWlsZENvbW1vbi5tYWtlU3ZnU3Bhbihbd2lkdGhDbGFzc2VzW2ldXSwgW19zdmdOb2RlXSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG51bVN2Z0NoaWxkcmVuID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYW46IF9zcGFuLFxuICAgICAgICAgICAgbWluV2lkdGg6IF9taW5XaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogX2hlaWdodDJcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zcGFuLnN0eWxlLmhlaWdodCA9IF9oZWlnaHQyICsgXCJlbVwiO1xuICAgICAgICAgIHNwYW5zLnB1c2goX3NwYW4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNwYW46IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInN0cmV0Y2h5XCJdLCBzcGFucywgb3B0aW9ucyksXG4gICAgICAgIG1pbldpZHRoOiBfbWluV2lkdGgsXG4gICAgICAgIGhlaWdodDogX2hlaWdodDJcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIGJ1aWxkU3ZnU3Bhbl8oKVxuXG5cbiAgdmFyIF9idWlsZFN2Z1NwYW5fID0gYnVpbGRTdmdTcGFuXygpLFxuICAgICAgc3BhbiA9IF9idWlsZFN2Z1NwYW5fLnNwYW4sXG4gICAgICBtaW5XaWR0aCA9IF9idWlsZFN2Z1NwYW5fLm1pbldpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2J1aWxkU3ZnU3Bhbl8uaGVpZ2h0OyAvLyBOb3RlIHRoYXQgd2UgYXJlIHJldHVybmluZyBzcGFuLmRlcHRoID0gMC5cbiAgLy8gQW55IGFkanVzdG1lbnRzIHJlbGF0aXZlIHRvIHRoZSBiYXNlbGluZSBtdXN0IGJlIGRvbmUgaW4gYnVpbGRIVE1MLlxuXG5cbiAgc3Bhbi5oZWlnaHQgPSBoZWlnaHQ7XG4gIHNwYW4uc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJlbVwiO1xuXG4gIGlmIChtaW5XaWR0aCA+IDApIHtcbiAgICBzcGFuLnN0eWxlLm1pbldpZHRoID0gbWluV2lkdGggKyBcImVtXCI7XG4gIH1cblxuICByZXR1cm4gc3Bhbjtcbn07XG5cbnZhciBzdHJldGNoeV9lbmNsb3NlU3BhbiA9IGZ1bmN0aW9uIGVuY2xvc2VTcGFuKGlubmVyLCBsYWJlbCwgcGFkLCBvcHRpb25zKSB7XG4gIC8vIFJldHVybiBhbiBpbWFnZSBzcGFuIGZvciBcXGNhbmNlbCwgXFxiY2FuY2VsLCBcXHhjYW5jZWwsIG9yIFxcZmJveFxuICB2YXIgaW1nO1xuICB2YXIgdG90YWxIZWlnaHQgPSBpbm5lci5oZWlnaHQgKyBpbm5lci5kZXB0aCArIDIgKiBwYWQ7XG5cbiAgaWYgKC9mYm94fGNvbG9yLy50ZXN0KGxhYmVsKSkge1xuICAgIGltZyA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInN0cmV0Y2h5XCIsIGxhYmVsXSwgW10sIG9wdGlvbnMpO1xuXG4gICAgaWYgKGxhYmVsID09PSBcImZib3hcIikge1xuICAgICAgdmFyIGNvbG9yID0gb3B0aW9ucy5jb2xvciAmJiBvcHRpb25zLmdldENvbG9yKCk7XG5cbiAgICAgIGlmIChjb2xvcikge1xuICAgICAgICBpbWcuc3R5bGUuYm9yZGVyQ29sb3IgPSBjb2xvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gXFxjYW5jZWwsIFxcYmNhbmNlbCwgb3IgXFx4Y2FuY2VsXG4gICAgLy8gU2luY2UgXFxjYW5jZWwncyBTVkcgaXMgaW5saW5lIGFuZCBpdCBvbWl0cyB0aGUgdmlld0JveCBhdHRyaWJ1dGUsXG4gICAgLy8gaXRzIHN0cm9rZS13aWR0aCB3aWxsIG5vdCB2YXJ5IHdpdGggc3BhbiBhcmVhLlxuICAgIHZhciBsaW5lcyA9IFtdO1xuXG4gICAgaWYgKC9eW2J4XWNhbmNlbCQvLnRlc3QobGFiZWwpKSB7XG4gICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lTm9kZSh7XG4gICAgICAgIFwieDFcIjogXCIwXCIsXG4gICAgICAgIFwieTFcIjogXCIwXCIsXG4gICAgICAgIFwieDJcIjogXCIxMDAlXCIsXG4gICAgICAgIFwieTJcIjogXCIxMDAlXCIsXG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IFwiMC4wNDZlbVwiXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgaWYgKC9eeD9jYW5jZWwkLy50ZXN0KGxhYmVsKSkge1xuICAgICAgbGluZXMucHVzaChuZXcgTGluZU5vZGUoe1xuICAgICAgICBcIngxXCI6IFwiMFwiLFxuICAgICAgICBcInkxXCI6IFwiMTAwJVwiLFxuICAgICAgICBcIngyXCI6IFwiMTAwJVwiLFxuICAgICAgICBcInkyXCI6IFwiMFwiLFxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBcIjAuMDQ2ZW1cIlxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHZhciBzdmdOb2RlID0gbmV3IFN2Z05vZGUobGluZXMsIHtcbiAgICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXG4gICAgICBcImhlaWdodFwiOiB0b3RhbEhlaWdodCArIFwiZW1cIlxuICAgIH0pO1xuICAgIGltZyA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtdLCBbc3ZnTm9kZV0sIG9wdGlvbnMpO1xuICB9XG5cbiAgaW1nLmhlaWdodCA9IHRvdGFsSGVpZ2h0O1xuICBpbWcuc3R5bGUuaGVpZ2h0ID0gdG90YWxIZWlnaHQgKyBcImVtXCI7XG4gIHJldHVybiBpbWc7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzdHJldGNoeSA9ICh7XG4gIGVuY2xvc2VTcGFuOiBzdHJldGNoeV9lbmNsb3NlU3BhbixcbiAgbWF0aE1Mbm9kZTogc3RyZXRjaHlfbWF0aE1Mbm9kZSxcbiAgc3ZnU3Bhbjogc3RyZXRjaHlfc3ZnU3BhblxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvYWNjZW50LmpzXG5cblxuXG5cblxuXG5cblxuXG4vLyBOT1RFOiBVbmxpa2UgbW9zdCBgaHRtbEJ1aWxkZXJgcywgdGhpcyBvbmUgaGFuZGxlcyBub3Qgb25seSBcImFjY2VudFwiLCBidXRcbnZhciBhY2NlbnRfaHRtbEJ1aWxkZXIgPSBmdW5jdGlvbiBodG1sQnVpbGRlcihncnAsIG9wdGlvbnMpIHtcbiAgLy8gQWNjZW50cyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBwZy4gNDQzLCBydWxlIDEyLlxuICB2YXIgYmFzZTtcbiAgdmFyIGdyb3VwO1xuICB2YXIgc3VwU3ViID0gY2hlY2tOb2RlVHlwZShncnAsIFwic3Vwc3ViXCIpO1xuICB2YXIgc3VwU3ViR3JvdXA7XG5cbiAgaWYgKHN1cFN1Yikge1xuICAgIC8vIElmIG91ciBiYXNlIGlzIGEgY2hhcmFjdGVyIGJveCwgYW5kIHdlIGhhdmUgc3VwZXJzY3JpcHRzIGFuZFxuICAgIC8vIHN1YnNjcmlwdHMsIHRoZSBzdXBzdWIgd2lsbCBkZWZlciB0byB1cy4gSW4gcGFydGljdWxhciwgd2Ugd2FudFxuICAgIC8vIHRvIGF0dGFjaCB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIHRvIHRoZSBpbm5lciBib2R5IChzb1xuICAgIC8vIHRoYXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBzdXBlcnNjcmlwdHMgYW5kIHN1YnNjcmlwdHMgd29uJ3QgYmVcbiAgICAvLyBhZmZlY3RlZCBieSB0aGUgaGVpZ2h0IG9mIHRoZSBhY2NlbnQpLiBXZSBhY2NvbXBsaXNoIHRoaXMgYnlcbiAgICAvLyBzdGlja2luZyB0aGUgYmFzZSBvZiB0aGUgYWNjZW50IGludG8gdGhlIGJhc2Ugb2YgdGhlIHN1cHN1YiwgYW5kXG4gICAgLy8gcmVuZGVyaW5nIHRoYXQsIHdoaWxlIGtlZXBpbmcgdHJhY2sgb2Ygd2hlcmUgdGhlIGFjY2VudCBpcy5cbiAgICAvLyBUaGUgcmVhbCBhY2NlbnQgZ3JvdXAgaXMgdGhlIGJhc2Ugb2YgdGhlIHN1cHN1YiBncm91cFxuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoc3VwU3ViLmJhc2UsIFwiYWNjZW50XCIpOyAvLyBUaGUgY2hhcmFjdGVyIGJveCBpcyB0aGUgYmFzZSBvZiB0aGUgYWNjZW50IGdyb3VwXG5cbiAgICBiYXNlID0gZ3JvdXAuYmFzZTsgLy8gU3RpY2sgdGhlIGNoYXJhY3RlciBib3ggaW50byB0aGUgYmFzZSBvZiB0aGUgc3Vwc3ViIGdyb3VwXG5cbiAgICBzdXBTdWIuYmFzZSA9IGJhc2U7IC8vIFJlcmVuZGVyIHRoZSBzdXBzdWIgZ3JvdXAgd2l0aCBpdHMgbmV3IGJhc2UsIGFuZCBzdG9yZSB0aGF0XG4gICAgLy8gcmVzdWx0LlxuXG4gICAgc3VwU3ViR3JvdXAgPSBhc3NlcnRTcGFuKGJ1aWxkSFRNTF9idWlsZEdyb3VwKHN1cFN1Yiwgb3B0aW9ucykpOyAvLyByZXNldCBvcmlnaW5hbCBiYXNlXG5cbiAgICBzdXBTdWIuYmFzZSA9IGdyb3VwO1xuICB9IGVsc2Uge1xuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLCBcImFjY2VudFwiKTtcbiAgICBiYXNlID0gZ3JvdXAuYmFzZTtcbiAgfSAvLyBCdWlsZCB0aGUgYmFzZSBncm91cFxuXG5cbiAgdmFyIGJvZHkgPSBidWlsZEhUTUxfYnVpbGRHcm91cChiYXNlLCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTsgLy8gRG9lcyB0aGUgYWNjZW50IG5lZWQgdG8gc2hpZnQgZm9yIHRoZSBza2V3IG9mIGEgY2hhcmFjdGVyP1xuXG4gIHZhciBtdXN0U2hpZnQgPSBncm91cC5pc1NoaWZ0eSAmJiB1dGlscy5pc0NoYXJhY3RlckJveChiYXNlKTsgLy8gQ2FsY3VsYXRlIHRoZSBza2V3IG9mIHRoZSBhY2NlbnQuIFRoaXMgaXMgYmFzZWQgb24gdGhlIGxpbmUgXCJJZiB0aGVcbiAgLy8gbnVjbGV1cyBpcyBub3QgYSBzaW5nbGUgY2hhcmFjdGVyLCBsZXQgcyA9IDA7IG90aGVyd2lzZSBzZXQgcyB0byB0aGVcbiAgLy8ga2VybiBhbW91bnQgZm9yIHRoZSBudWNsZXVzIGZvbGxvd2VkIGJ5IHRoZSBcXHNrZXdjaGFyIG9mIGl0cyBmb250LlwiXG4gIC8vIE5vdGUgdGhhdCBvdXIgc2tldyBtZXRyaWNzIGFyZSBqdXN0IHRoZSBrZXJuIGJldHdlZW4gZWFjaCBjaGFyYWN0ZXJcbiAgLy8gYW5kIHRoZSBza2V3Y2hhci5cblxuICB2YXIgc2tldyA9IDA7XG5cbiAgaWYgKG11c3RTaGlmdCkge1xuICAgIC8vIElmIHRoZSBiYXNlIGlzIGEgY2hhcmFjdGVyIGJveCwgdGhlbiB3ZSB3YW50IHRoZSBza2V3IG9mIHRoZVxuICAgIC8vIGlubmVybW9zdCBjaGFyYWN0ZXIuIFRvIGRvIHRoYXQsIHdlIGZpbmQgdGhlIGlubmVybW9zdCBjaGFyYWN0ZXI6XG4gICAgdmFyIGJhc2VDaGFyID0gdXRpbHMuZ2V0QmFzZUVsZW0oYmFzZSk7IC8vIFRoZW4sIHdlIHJlbmRlciBpdHMgZ3JvdXAgdG8gZ2V0IHRoZSBzeW1ib2wgaW5zaWRlIGl0XG5cbiAgICB2YXIgYmFzZUdyb3VwID0gYnVpbGRIVE1MX2J1aWxkR3JvdXAoYmFzZUNoYXIsIG9wdGlvbnMuaGF2aW5nQ3JhbXBlZFN0eWxlKCkpOyAvLyBGaW5hbGx5LCB3ZSBwdWxsIHRoZSBza2V3IG9mZiBvZiB0aGUgc3ltYm9sLlxuXG4gICAgc2tldyA9IGFzc2VydFN5bWJvbERvbU5vZGUoYmFzZUdyb3VwKS5za2V3OyAvLyBOb3RlIHRoYXQgd2Ugbm93IHRocm93IGF3YXkgYmFzZUdyb3VwLCBiZWNhdXNlIHRoZSBsYXllcnMgd2VcbiAgICAvLyByZW1vdmVkIHdpdGggZ2V0QmFzZUVsZW0gbWlnaHQgY29udGFpbiB0aGluZ3MgbGlrZSBcXGNvbG9yIHdoaWNoXG4gICAgLy8gd2UgY2FuJ3QgZ2V0IHJpZCBvZi5cbiAgICAvLyBUT0RPKGVtaWx5KTogRmluZCBhIGJldHRlciB3YXkgdG8gZ2V0IHRoZSBza2V3XG4gIH0gLy8gY2FsY3VsYXRlIHRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiB0aGUgYm9keSBhbmQgdGhlIGFjY2VudFxuXG5cbiAgdmFyIGNsZWFyYW5jZSA9IE1hdGgubWluKGJvZHkuaGVpZ2h0LCBvcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodCk7IC8vIEJ1aWxkIHRoZSBhY2NlbnRcblxuICB2YXIgYWNjZW50Qm9keTtcblxuICBpZiAoIWdyb3VwLmlzU3RyZXRjaHkpIHtcbiAgICB2YXIgYWNjZW50O1xuICAgIHZhciB3aWR0aDtcblxuICAgIGlmIChncm91cC5sYWJlbCA9PT0gXCJcXFxcdmVjXCIpIHtcbiAgICAgIC8vIEJlZm9yZSB2ZXJzaW9uIDAuOSwgXFx2ZWMgdXNlZCB0aGUgY29tYmluaW5nIGZvbnQgZ2x5cGggVSsyMEQ3LlxuICAgICAgLy8gQnV0IGJyb3dzZXJzLCBlc3BlY2lhbGx5IFNhZmFyaSwgYXJlIG5vdCBjb25zaXN0ZW50IGluIGhvdyB0aGV5XG4gICAgICAvLyByZW5kZXIgY29tYmluaW5nIGNoYXJhY3RlcnMgd2hlbiBub3QgcHJlY2VkZWQgYnkgYSBjaGFyYWN0ZXIuXG4gICAgICAvLyBTbyBub3cgd2UgdXNlIGFuIFNWRy5cbiAgICAgIC8vIElmIFNhZmFyaSByZWZvcm1zLCB3ZSBzaG91bGQgY29uc2lkZXIgcmV2ZXJ0aW5nIHRvIHRoZSBnbHlwaC5cbiAgICAgIGFjY2VudCA9IGJ1aWxkQ29tbW9uLnN0YXRpY1N2ZyhcInZlY1wiLCBvcHRpb25zKTtcbiAgICAgIHdpZHRoID0gYnVpbGRDb21tb24uc3ZnRGF0YS52ZWNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY2VudCA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woZ3JvdXAubGFiZWwsIFwiTWFpbi1SZWd1bGFyXCIsIGdyb3VwLm1vZGUsIG9wdGlvbnMpOyAvLyBSZW1vdmUgdGhlIGl0YWxpYyBjb3JyZWN0aW9uIG9mIHRoZSBhY2NlbnQsIGJlY2F1c2UgaXQgb25seSBzZXJ2ZXMgdG9cbiAgICAgIC8vIHNoaWZ0IHRoZSBhY2NlbnQgb3ZlciB0byBhIHBsYWNlIHdlIGRvbid0IHdhbnQuXG5cbiAgICAgIGFjY2VudC5pdGFsaWMgPSAwO1xuICAgICAgd2lkdGggPSBhY2NlbnQud2lkdGg7XG4gICAgfVxuXG4gICAgYWNjZW50Qm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImFjY2VudC1ib2R5XCJdLCBbYWNjZW50XSk7IC8vIFwiRnVsbFwiIGFjY2VudHMgZXhwYW5kIHRoZSB3aWR0aCBvZiB0aGUgcmVzdWx0aW5nIHN5bWJvbCB0byBiZVxuICAgIC8vIGF0IGxlYXN0IHRoZSB3aWR0aCBvZiB0aGUgYWNjZW50LCBhbmQgb3ZlcmxhcCBkaXJlY3RseSBvbnRvIHRoZVxuICAgIC8vIGNoYXJhY3RlciB3aXRob3V0IGFueSB2ZXJ0aWNhbCBvZmZzZXQuXG5cbiAgICB2YXIgYWNjZW50RnVsbCA9IGdyb3VwLmxhYmVsID09PSBcIlxcXFx0ZXh0Y2lyY2xlZFwiO1xuXG4gICAgaWYgKGFjY2VudEZ1bGwpIHtcbiAgICAgIGFjY2VudEJvZHkuY2xhc3Nlcy5wdXNoKCdhY2NlbnQtZnVsbCcpO1xuICAgICAgY2xlYXJhbmNlID0gYm9keS5oZWlnaHQ7XG4gICAgfSAvLyBTaGlmdCB0aGUgYWNjZW50IG92ZXIgYnkgdGhlIHNrZXcuXG5cblxuICAgIHZhciBsZWZ0ID0gc2tldzsgLy8gQ1NTIGRlZmluZXMgYC5rYXRleCAuYWNjZW50IC5hY2NlbnQtYm9keTpub3QoLmFjY2VudC1mdWxsKSB7IHdpZHRoOiAwIH1gXG4gICAgLy8gc28gdGhhdCB0aGUgYWNjZW50IGRvZXNuJ3QgY29udHJpYnV0ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuICAgIC8vIFdlIG5lZWQgdG8gc2hpZnQgdGhlIGNoYXJhY3RlciBieSBpdHMgd2lkdGggKGVmZmVjdGl2ZWx5IGhhbGZcbiAgICAvLyBpdHMgd2lkdGgpIHRvIGNvbXBlbnNhdGUuXG5cbiAgICBpZiAoIWFjY2VudEZ1bGwpIHtcbiAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgIH1cblxuICAgIGFjY2VudEJvZHkuc3R5bGUubGVmdCA9IGxlZnQgKyBcImVtXCI7IC8vIFxcdGV4dGNpcmNsZWQgdXNlcyB0aGUgXFxiaWdjaXJjIGdseXBoLCBzbyBpdCBuZWVkcyBzb21lXG4gICAgLy8gdmVydGljYWwgYWRqdXN0bWVudCB0byBtYXRjaCBMYVRlWC5cblxuICAgIGlmIChncm91cC5sYWJlbCA9PT0gXCJcXFxcdGV4dGNpcmNsZWRcIikge1xuICAgICAgYWNjZW50Qm9keS5zdHlsZS50b3AgPSBcIi4yZW1cIjtcbiAgICB9XG5cbiAgICBhY2NlbnRCb2R5ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJvZHlcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IC1jbGVhcmFuY2VcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGFjY2VudEJvZHlcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgYWNjZW50Qm9keSA9IHN0cmV0Y2h5LnN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpO1xuICAgIGFjY2VudEJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYWNjZW50Qm9keSxcbiAgICAgICAgd3JhcHBlckNsYXNzZXM6IFtcInN2Zy1hbGlnblwiXSxcbiAgICAgICAgd3JhcHBlclN0eWxlOiBza2V3ID4gMCA/IHtcbiAgICAgICAgICB3aWR0aDogXCJjYWxjKDEwMCUgLSBcIiArIDIgKiBza2V3ICsgXCJlbSlcIixcbiAgICAgICAgICBtYXJnaW5MZWZ0OiAyICogc2tldyArIFwiZW1cIlxuICAgICAgICB9IDogdW5kZWZpbmVkXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIGFjY2VudFdyYXAgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwiYWNjZW50XCJdLCBbYWNjZW50Qm9keV0sIG9wdGlvbnMpO1xuXG4gIGlmIChzdXBTdWJHcm91cCkge1xuICAgIC8vIEhlcmUsIHdlIHJlcGxhY2UgdGhlIFwiYmFzZVwiIGNoaWxkIG9mIHRoZSBzdXBzdWIgd2l0aCBvdXIgbmV3bHlcbiAgICAvLyBnZW5lcmF0ZWQgYWNjZW50LlxuICAgIHN1cFN1Ykdyb3VwLmNoaWxkcmVuWzBdID0gYWNjZW50V3JhcDsgLy8gU2luY2Ugd2UgZG9uJ3QgcmVydW4gdGhlIGhlaWdodCBjYWxjdWxhdGlvbiBhZnRlciByZXBsYWNpbmcgdGhlXG4gICAgLy8gYWNjZW50LCB3ZSBtYW51YWxseSByZWNhbGN1bGF0ZSBoZWlnaHQuXG5cbiAgICBzdXBTdWJHcm91cC5oZWlnaHQgPSBNYXRoLm1heChhY2NlbnRXcmFwLmhlaWdodCwgc3VwU3ViR3JvdXAuaGVpZ2h0KTsgLy8gQWNjZW50cyBzaG91bGQgYWx3YXlzIGJlIG9yZHMsIGV2ZW4gd2hlbiB0aGVpciBpbm5hcmRzIGFyZSBub3QuXG5cbiAgICBzdXBTdWJHcm91cC5jbGFzc2VzWzBdID0gXCJtb3JkXCI7XG4gICAgcmV0dXJuIHN1cFN1Ykdyb3VwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhY2NlbnRXcmFwO1xuICB9XG59O1xuXG52YXIgYWNjZW50X21hdGhtbEJ1aWxkZXIgPSBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBhY2NlbnROb2RlID0gZ3JvdXAuaXNTdHJldGNoeSA/IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpIDogbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbYnVpbGRNYXRoTUxfbWFrZVRleHQoZ3JvdXAubGFiZWwsIGdyb3VwLm1vZGUpXSk7XG4gIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5iYXNlLCBvcHRpb25zKSwgYWNjZW50Tm9kZV0pO1xuICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudFwiLCBcInRydWVcIik7XG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIE5PTl9TVFJFVENIWV9BQ0NFTlRfUkVHRVggPSBuZXcgUmVnRXhwKFtcIlxcXFxhY3V0ZVwiLCBcIlxcXFxncmF2ZVwiLCBcIlxcXFxkZG90XCIsIFwiXFxcXHRpbGRlXCIsIFwiXFxcXGJhclwiLCBcIlxcXFxicmV2ZVwiLCBcIlxcXFxjaGVja1wiLCBcIlxcXFxoYXRcIiwgXCJcXFxcdmVjXCIsIFwiXFxcXGRvdFwiLCBcIlxcXFxtYXRocmluZ1wiXS5tYXAoZnVuY3Rpb24gKGFjY2VudCkge1xuICByZXR1cm4gXCJcXFxcXCIgKyBhY2NlbnQ7XG59KS5qb2luKFwifFwiKSk7IC8vIEFjY2VudHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImFjY2VudFwiLFxuICBuYW1lczogW1wiXFxcXGFjdXRlXCIsIFwiXFxcXGdyYXZlXCIsIFwiXFxcXGRkb3RcIiwgXCJcXFxcdGlsZGVcIiwgXCJcXFxcYmFyXCIsIFwiXFxcXGJyZXZlXCIsIFwiXFxcXGNoZWNrXCIsIFwiXFxcXGhhdFwiLCBcIlxcXFx2ZWNcIiwgXCJcXFxcZG90XCIsIFwiXFxcXG1hdGhyaW5nXCIsIFwiXFxcXHdpZGVjaGVja1wiLCBcIlxcXFx3aWRlaGF0XCIsIFwiXFxcXHdpZGV0aWxkZVwiLCBcIlxcXFxvdmVycmlnaHRhcnJvd1wiLCBcIlxcXFxvdmVybGVmdGFycm93XCIsIFwiXFxcXE92ZXJyaWdodGFycm93XCIsIFwiXFxcXG92ZXJsZWZ0cmlnaHRhcnJvd1wiLCBcIlxcXFxvdmVyZ3JvdXBcIiwgXCJcXFxcb3ZlcmxpbmVzZWdtZW50XCIsIFwiXFxcXG92ZXJsZWZ0aGFycG9vblwiLCBcIlxcXFxvdmVycmlnaHRoYXJwb29uXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJhc2UgPSBhcmdzWzBdO1xuICAgIHZhciBpc1N0cmV0Y2h5ID0gIU5PTl9TVFJFVENIWV9BQ0NFTlRfUkVHRVgudGVzdChjb250ZXh0LmZ1bmNOYW1lKTtcbiAgICB2YXIgaXNTaGlmdHkgPSAhaXNTdHJldGNoeSB8fCBjb250ZXh0LmZ1bmNOYW1lID09PSBcIlxcXFx3aWRlaGF0XCIgfHwgY29udGV4dC5mdW5jTmFtZSA9PT0gXCJcXFxcd2lkZXRpbGRlXCIgfHwgY29udGV4dC5mdW5jTmFtZSA9PT0gXCJcXFxcd2lkZWNoZWNrXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYWNjZW50XCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGNvbnRleHQuZnVuY05hbWUsXG4gICAgICBpc1N0cmV0Y2h5OiBpc1N0cmV0Y2h5LFxuICAgICAgaXNTaGlmdHk6IGlzU2hpZnR5LFxuICAgICAgYmFzZTogYmFzZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBhY2NlbnRfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGFjY2VudF9tYXRobWxCdWlsZGVyXG59KTsgLy8gVGV4dC1tb2RlIGFjY2VudHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImFjY2VudFwiLFxuICBuYW1lczogW1wiXFxcXCdcIiwgXCJcXFxcYFwiLCBcIlxcXFxeXCIsIFwiXFxcXH5cIiwgXCJcXFxcPVwiLCBcIlxcXFx1XCIsIFwiXFxcXC5cIiwgJ1xcXFxcIicsIFwiXFxcXHJcIiwgXCJcXFxcSFwiLCBcIlxcXFx2XCIsIFwiXFxcXHRleHRjaXJjbGVkXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiBmYWxzZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgYmFzZSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYWNjZW50XCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGNvbnRleHQuZnVuY05hbWUsXG4gICAgICBpc1N0cmV0Y2h5OiBmYWxzZSxcbiAgICAgIGlzU2hpZnR5OiB0cnVlLFxuICAgICAgYmFzZTogYmFzZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBhY2NlbnRfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGFjY2VudF9tYXRobWxCdWlsZGVyXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9hY2NlbnR1bmRlci5qc1xuLy8gSG9yaXpvbnRhbCBvdmVybGFwIGZ1bmN0aW9uc1xuXG5cblxuXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImFjY2VudFVuZGVyXCIsXG4gIG5hbWVzOiBbXCJcXFxcdW5kZXJsZWZ0YXJyb3dcIiwgXCJcXFxcdW5kZXJyaWdodGFycm93XCIsIFwiXFxcXHVuZGVybGVmdHJpZ2h0YXJyb3dcIiwgXCJcXFxcdW5kZXJncm91cFwiLCBcIlxcXFx1bmRlcmxpbmVzZWdtZW50XCIsIFwiXFxcXHV0aWxkZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lO1xuICAgIHZhciBiYXNlID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhY2NlbnRVbmRlclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBiYXNlOiBiYXNlXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gVHJlYXQgdW5kZXIgYWNjZW50cyBtdWNoIGxpa2UgdW5kZXJsaW5lcy5cbiAgICB2YXIgaW5uZXJHcm91cCA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmJhc2UsIG9wdGlvbnMpO1xuICAgIHZhciBhY2NlbnRCb2R5ID0gc3RyZXRjaHkuc3ZnU3Bhbihncm91cCwgb3B0aW9ucyk7XG4gICAgdmFyIGtlcm4gPSBncm91cC5sYWJlbCA9PT0gXCJcXFxcdXRpbGRlXCIgPyAwLjEyIDogMDsgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJuc1xuXG4gICAgdmFyIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJib3R0b21cIixcbiAgICAgIHBvc2l0aW9uRGF0YTogYWNjZW50Qm9keS5oZWlnaHQgKyBrZXJuLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBhY2NlbnRCb2R5LFxuICAgICAgICB3cmFwcGVyQ2xhc3NlczogW1wic3ZnLWFsaWduXCJdXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBrZXJuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lckdyb3VwXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwiYWNjZW50dW5kZXJcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGFjY2VudE5vZGUgPSBzdHJldGNoeS5tYXRoTUxub2RlKGdyb3VwLmxhYmVsKTtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXVuZGVyXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJhc2UsIG9wdGlvbnMpLCBhY2NlbnROb2RlXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhY2NlbnR1bmRlclwiLCBcInRydWVcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2Fycm93LmpzXG5cblxuXG5cblxuXG5cbi8vIEhlbHBlciBmdW5jdGlvblxudmFyIGFycm93X3BhZGRlZE5vZGUgPSBmdW5jdGlvbiBwYWRkZWROb2RlKGdyb3VwKSB7XG4gIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIGdyb3VwID8gW2dyb3VwXSA6IFtdKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIiswLjZlbVwiKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwLjNlbVwiKTtcbiAgcmV0dXJuIG5vZGU7XG59OyAvLyBTdHJldGNoeSBhcnJvd3Mgd2l0aCBhbiBvcHRpb25hbCBhcmd1bWVudFxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ4QXJyb3dcIixcbiAgbmFtZXM6IFtcIlxcXFx4bGVmdGFycm93XCIsIFwiXFxcXHhyaWdodGFycm93XCIsIFwiXFxcXHhMZWZ0YXJyb3dcIiwgXCJcXFxceFJpZ2h0YXJyb3dcIiwgXCJcXFxceGxlZnRyaWdodGFycm93XCIsIFwiXFxcXHhMZWZ0cmlnaHRhcnJvd1wiLCBcIlxcXFx4aG9va2xlZnRhcnJvd1wiLCBcIlxcXFx4aG9va3JpZ2h0YXJyb3dcIiwgXCJcXFxceG1hcHN0b1wiLCBcIlxcXFx4cmlnaHRoYXJwb29uZG93blwiLCBcIlxcXFx4cmlnaHRoYXJwb29udXBcIiwgXCJcXFxceGxlZnRoYXJwb29uZG93blwiLCBcIlxcXFx4bGVmdGhhcnBvb251cFwiLCBcIlxcXFx4cmlnaHRsZWZ0aGFycG9vbnNcIiwgXCJcXFxceGxlZnRyaWdodGhhcnBvb25zXCIsIFwiXFxcXHhsb25nZXF1YWxcIiwgXCJcXFxceHR3b2hlYWRyaWdodGFycm93XCIsIFwiXFxcXHh0d29oZWFkbGVmdGFycm93XCIsIFwiXFxcXHh0b2Zyb21cIiwgLy8gVGhlIG5leHQgMyBmdW5jdGlvbnMgYXJlIGhlcmUgdG8gc3VwcG9ydCB0aGUgbWhjaGVtIGV4dGVuc2lvbi5cbiAgLy8gRGlyZWN0IHVzZSBvZiB0aGVzZSBmdW5jdGlvbnMgaXMgZGlzY291cmFnZWQgYW5kIG1heSBicmVhayBzb21lZGF5LlxuICBcIlxcXFx4cmlnaHRsZWZ0YXJyb3dzXCIsIFwiXFxcXHhyaWdodGVxdWlsaWJyaXVtXCIsIFwiXFxcXHhsZWZ0ZXF1aWxpYnJpdW1cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWYuZnVuY05hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwieEFycm93XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJvZHk6IGFyZ3NbMF0sXG4gICAgICBiZWxvdzogb3B0QXJnc1swXVxuICAgIH07XG4gIH0sXG4gIC8vIEZsb3cgaXMgdW5hYmxlIHRvIGNvcnJlY3RseSBpbmZlciB0aGUgdHlwZSBvZiBgZ3JvdXBgLCBldmVuIHRob3VnaCBpdCdzXG4gIC8vIHVuYW1pYmlndW91c2x5IGRldGVybWluZWQgZnJvbSB0aGUgcGFzc2VkLWluIGB0eXBlYCBhYm92ZS5cbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTsgLy8gQnVpbGQgdGhlIGFyZ3VtZW50IGdyb3VwcyBpbiB0aGUgYXBwcm9wcmlhdGUgc3R5bGUuXG4gICAgLy8gUmVmOiBhbXNtYXRoLmR0eDogICBcXGhib3h7JFxcc2NyaXB0c3R5bGVcXG1rZXJuIzNtdXsjNn1cXG1rZXJuIzRtdSR9JVxuICAgIC8vIFNvbWUgZ3JvdXBzIGNhbiByZXR1cm4gZG9jdW1lbnQgZnJhZ21lbnRzLiAgSGFuZGxlIHRob3NlIGJ5IHdyYXBwaW5nXG4gICAgLy8gdGhlbSBpbiBhIHNwYW4uXG5cbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3VwKCkpO1xuICAgIHZhciB1cHBlckdyb3VwID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG5ld09wdGlvbnMsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB1cHBlckdyb3VwLmNsYXNzZXMucHVzaChcIngtYXJyb3ctcGFkXCIpO1xuICAgIHZhciBsb3dlckdyb3VwO1xuXG4gICAgaWYgKGdyb3VwLmJlbG93KSB7XG4gICAgICAvLyBCdWlsZCB0aGUgbG93ZXIgZ3JvdXBcbiAgICAgIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1YigpKTtcbiAgICAgIGxvd2VyR3JvdXAgPSBidWlsZENvbW1vbi53cmFwRnJhZ21lbnQoYnVpbGRIVE1MX2J1aWxkR3JvdXAoZ3JvdXAuYmVsb3csIG5ld09wdGlvbnMsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgIGxvd2VyR3JvdXAuY2xhc3Nlcy5wdXNoKFwieC1hcnJvdy1wYWRcIik7XG4gICAgfVxuXG4gICAgdmFyIGFycm93Qm9keSA9IHN0cmV0Y2h5LnN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpOyAvLyBSZSBzaGlmdDogTm90ZSB0aGF0IHN0cmV0Y2h5LnN2Z1NwYW4gcmV0dXJuZWQgYXJyb3dCb2R5LmRlcHRoID0gMC5cbiAgICAvLyBUaGUgcG9pbnQgd2Ugd2FudCBvbiB0aGUgbWF0aCBheGlzIGlzIGF0IDAuNSAqIGFycm93Qm9keS5oZWlnaHQuXG5cbiAgICB2YXIgYXJyb3dTaGlmdCA9IC1vcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodCArIDAuNSAqIGFycm93Qm9keS5oZWlnaHQ7IC8vIDIgbXUga2Vybi4gUmVmOiBhbXNtYXRoLmR0eDogIzdcXGlmMCMyXFxlbHNlXFxta2VybiMybXVcXGZpXG5cbiAgICB2YXIgdXBwZXJTaGlmdCA9IC1vcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodCAtIDAuNSAqIGFycm93Qm9keS5oZWlnaHQgLSAwLjExMTsgLy8gMC4xMTEgZW0gPSAyIG11XG5cbiAgICBpZiAodXBwZXJHcm91cC5kZXB0aCA+IDAuMjUgfHwgZ3JvdXAubGFiZWwgPT09IFwiXFxcXHhsZWZ0ZXF1aWxpYnJpdW1cIikge1xuICAgICAgdXBwZXJTaGlmdCAtPSB1cHBlckdyb3VwLmRlcHRoOyAvLyBzaGlmdCB1cCBpZiBkZXB0aCBlbmNyb2FjaGVzXG4gICAgfSAvLyBHZW5lcmF0ZSB0aGUgdmxpc3RcblxuXG4gICAgdmFyIHZsaXN0O1xuXG4gICAgaWYgKGxvd2VyR3JvdXApIHtcbiAgICAgIHZhciBsb3dlclNoaWZ0ID0gLW9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0ICsgbG93ZXJHcm91cC5oZWlnaHQgKyAwLjUgKiBhcnJvd0JvZHkuaGVpZ2h0ICsgMC4xMTE7XG4gICAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogdXBwZXJHcm91cCxcbiAgICAgICAgICBzaGlmdDogdXBwZXJTaGlmdFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogYXJyb3dCb2R5LFxuICAgICAgICAgIHNoaWZ0OiBhcnJvd1NoaWZ0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBsb3dlckdyb3VwLFxuICAgICAgICAgIHNoaWZ0OiBsb3dlclNoaWZ0XG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHVwcGVyR3JvdXAsXG4gICAgICAgICAgc2hpZnQ6IHVwcGVyU2hpZnRcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IGFycm93Qm9keSxcbiAgICAgICAgICBzaGlmdDogYXJyb3dTaGlmdFxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSAvLyAkRmxvd0ZpeE1lOiBSZXBsYWNlIHRoaXMgd2l0aCBwYXNzaW5nIFwic3ZnLWFsaWduXCIgaW50byBtYWtlVkxpc3QuXG5cblxuICAgIHZsaXN0LmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzFdLmNsYXNzZXMucHVzaChcInN2Zy1hbGlnblwiKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibXJlbFwiLCBcIngtYXJyb3dcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGFycm93Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpO1xuICAgIHZhciBub2RlO1xuXG4gICAgaWYgKGdyb3VwLmJvZHkpIHtcbiAgICAgIHZhciB1cHBlck5vZGUgPSBhcnJvd19wYWRkZWROb2RlKGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucykpO1xuXG4gICAgICBpZiAoZ3JvdXAuYmVsb3cpIHtcbiAgICAgICAgdmFyIGxvd2VyTm9kZSA9IGFycm93X3BhZGRlZE5vZGUoYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5iZWxvdywgb3B0aW9ucykpO1xuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJvdmVyXCIsIFthcnJvd05vZGUsIGxvd2VyTm9kZSwgdXBwZXJOb2RlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbYXJyb3dOb2RlLCB1cHBlck5vZGVdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLmJlbG93KSB7XG4gICAgICB2YXIgX2xvd2VyTm9kZSA9IGFycm93X3BhZGRlZE5vZGUoYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5iZWxvdywgb3B0aW9ucykpO1xuXG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW2Fycm93Tm9kZSwgX2xvd2VyTm9kZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uXG4gICAgICAvLyBQYXJzZXIuanMgdGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGlzIG5vIGFyZ3VtZW50LlxuICAgICAgbm9kZSA9IGFycm93X3BhZGRlZE5vZGUoKTtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vdmVyXCIsIFthcnJvd05vZGUsIG5vZGVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvY2hhci5qc1xuXG5cbiAvLyBcXEBjaGFyIGlzIGFuIGludGVybmFsIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBncm91cGVkIGRlY2ltYWwgYXJndW1lbnQgbGlrZVxuLy8gezEyM30gYW5kIGNvbnZlcnRzIGludG8gc3ltYm9sIHdpdGggY29kZSAxMjMuICBJdCBpcyB1c2VkIGJ5IHRoZSAqbWFjcm8qXG4vLyBcXGNoYXIgZGVmaW5lZCBpbiBtYWNyb3MuanMuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gIG5hbWVzOiBbXCJcXFxcQGNoYXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgYXJnID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKTtcbiAgICB2YXIgZ3JvdXAgPSBhcmcuYm9keTtcbiAgICB2YXIgbnVtYmVyID0gXCJcIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gYXNzZXJ0Tm9kZVR5cGUoZ3JvdXBbaV0sIFwidGV4dG9yZFwiKTtcbiAgICAgIG51bWJlciArPSBub2RlLnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNvZGUgPSBwYXJzZUludChudW1iZXIpO1xuXG4gICAgaWYgKGlzTmFOKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcQGNoYXIgaGFzIG5vbi1udW1lcmljIGFyZ3VtZW50IFwiICsgbnVtYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHRleHQ6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcbiAgICB9O1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9jb2xvci5qc1xuXG5cblxuXG5cblxuXG52YXIgY29sb3JfaHRtbEJ1aWxkZXIgPSBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICB2YXIgZWxlbWVudHMgPSBidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMud2l0aENvbG9yKGdyb3VwLmNvbG9yKSwgZmFsc2UpOyAvLyBcXGNvbG9yIGlzbid0IHN1cHBvc2VkIHRvIGFmZmVjdCB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudHMgaXQgY29udGFpbnMuXG4gIC8vIFRvIGFjY29tcGxpc2ggdGhpcywgd2Ugd3JhcCB0aGUgcmVzdWx0cyBpbiBhIGZyYWdtZW50LCBzbyB0aGUgaW5uZXJcbiAgLy8gZWxlbWVudHMgd2lsbCBiZSBhYmxlIHRvIGRpcmVjdGx5IGludGVyYWN0IHdpdGggdGhlaXIgbmVpZ2hib3JzLiBGb3JcbiAgLy8gZXhhbXBsZSwgYFxcY29sb3J7cmVkfXsyICt9IDNgIGhhcyB0aGUgc2FtZSBzcGFjaW5nIGFzIGAyICsgM2BcblxuICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGVsZW1lbnRzKTtcbn07XG5cbnZhciBjb2xvcl9tYXRobWxCdWlsZGVyID0gZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICB2YXIgaW5uZXIgPSBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoQ29sb3IoZ3JvdXAuY29sb3IpKTtcbiAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aGNvbG9yXCIsIGdyb3VwLmNvbG9yKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY29sb3JcIixcbiAgbmFtZXM6IFtcIlxcXFx0ZXh0Y29sb3JcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGdyZWVkaW5lc3M6IDMsXG4gICAgYXJnVHlwZXM6IFtcImNvbG9yXCIsIFwib3JpZ2luYWxcIl1cbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyO1xuICAgIHZhciBjb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwiY29sb3ItdG9rZW5cIikuY29sb3I7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIGJvZHk6IGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGNvbG9yX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBjb2xvcl9tYXRobWxCdWlsZGVyXG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjb2xvclwiLFxuICBuYW1lczogW1wiXFxcXGNvbG9yXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBncmVlZGluZXNzOiAzLFxuICAgIGFyZ1R5cGVzOiBbXCJjb2xvclwiXVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYyLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYyLnBhcnNlcixcbiAgICAgICAgYnJlYWtPblRva2VuVGV4dCA9IF9yZWYyLmJyZWFrT25Ub2tlblRleHQ7XG4gICAgdmFyIGNvbG9yID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJjb2xvci10b2tlblwiKS5jb2xvcjsgLy8gSWYgd2Ugc2VlIGEgc3R5bGluZyBmdW5jdGlvbiwgcGFyc2Ugb3V0IHRoZSBpbXBsaWNpdCBib2R5XG5cbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgYm9keTogYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBjb2xvcl9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogY29sb3JfbWF0aG1sQnVpbGRlclxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvY3IuanNcbi8vIFJvdyBicmVha3Mgd2l0aGluIHRhYnVsYXIgZW52aXJvbm1lbnRzLCBhbmQgbGluZSBicmVha3MgYXQgdG9wIGxldmVsXG5cblxuXG5cblxuIC8vIFxcXFwgaXMgYSBtYWNybyBtYXBwaW5nIHRvIGVpdGhlciBcXGNyIG9yIFxcbmV3bGluZS4gIEJlY2F1c2UgdGhleSBoYXZlIHRoZVxuLy8gc2FtZSBzaWduYXR1cmUsIHdlIGltcGxlbWVudCB0aGVtIGFzIG9uZSBtZWdhZnVuY3Rpb24sIHdpdGggbmV3Um93XG4vLyBpbmRpY2F0aW5nIHdoZXRoZXIgd2UncmUgaW4gdGhlIFxcY3IgY2FzZSwgYW5kIG5ld0xpbmUgaW5kaWNhdGluZyB3aGV0aGVyXG4vLyB0byBicmVhayB0aGUgbGluZSBpbiB0aGUgXFxuZXdsaW5lIGNhc2UuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjclwiLFxuICBuYW1lczogW1wiXFxcXGNyXCIsIFwiXFxcXG5ld2xpbmVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZi5mdW5jTmFtZTtcbiAgICB2YXIgc2l6ZSA9IG9wdEFyZ3NbMF07XG4gICAgdmFyIG5ld1JvdyA9IGZ1bmNOYW1lID09PSBcIlxcXFxjclwiO1xuICAgIHZhciBuZXdMaW5lID0gZmFsc2U7XG5cbiAgICBpZiAoIW5ld1Jvdykge1xuICAgICAgaWYgKHBhcnNlci5zZXR0aW5ncy5kaXNwbGF5TW9kZSAmJiBwYXJzZXIuc2V0dGluZ3MudXNlU3RyaWN0QmVoYXZpb3IoXCJuZXdMaW5lSW5EaXNwbGF5TW9kZVwiLCBcIkluIExhVGVYLCBcXFxcXFxcXCBvciBcXFxcbmV3bGluZSBcIiArIFwiZG9lcyBub3RoaW5nIGluIGRpc3BsYXkgbW9kZVwiKSkge1xuICAgICAgICBuZXdMaW5lID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdMaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBuZXdMaW5lOiBuZXdMaW5lLFxuICAgICAgbmV3Um93OiBuZXdSb3csXG4gICAgICBzaXplOiBzaXplICYmIGFzc2VydE5vZGVUeXBlKHNpemUsIFwic2l6ZVwiKS52YWx1ZVxuICAgIH07XG4gIH0sXG4gIC8vIFRoZSBmb2xsb3dpbmcgYnVpbGRlcnMgYXJlIGNhbGxlZCBvbmx5IGF0IHRoZSB0b3AgbGV2ZWwsXG4gIC8vIG5vdCB3aXRoaW4gdGFidWxhci9hcnJheSBlbnZpcm9ubWVudHMuXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChncm91cC5uZXdSb3cpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFxjciB2YWxpZCBvbmx5IHdpdGhpbiBhIHRhYnVsYXIvYXJyYXkgZW52aXJvbm1lbnRcIik7XG4gICAgfVxuXG4gICAgdmFyIHNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtc3BhY2VcIl0sIFtdLCBvcHRpb25zKTtcblxuICAgIGlmIChncm91cC5uZXdMaW5lKSB7XG4gICAgICBzcGFuLmNsYXNzZXMucHVzaChcIm5ld2xpbmVcIik7XG5cbiAgICAgIGlmIChncm91cC5zaXplKSB7XG4gICAgICAgIHNwYW4uc3R5bGUubWFyZ2luVG9wID0gdW5pdHNfY2FsY3VsYXRlU2l6ZShncm91cC5zaXplLCBvcHRpb25zKSArIFwiZW1cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3BhbjtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG5cbiAgICBpZiAoZ3JvdXAubmV3TGluZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5lYnJlYWtcIiwgXCJuZXdsaW5lXCIpO1xuXG4gICAgICBpZiAoZ3JvdXAuc2l6ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLnNpemUsIG9wdGlvbnMpICsgXCJlbVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kZWxpbWl0ZXIuanNcbi8qKlxuICogVGhpcyBmaWxlIGRlYWxzIHdpdGggY3JlYXRpbmcgZGVsaW1pdGVycyBvZiB2YXJpb3VzIHNpemVzLiBUaGUgVGVYYm9va1xuICogZGlzY3Vzc2VzIHRoZXNlIHJvdXRpbmVzIG9uIHBhZ2UgNDQxLTQ0MiwgaW4gdGhlIFwiQW5vdGhlciBzdWJyb3V0aW5lIHNldHMgYm94XG4gKiB4IHRvIGEgc3BlY2lmaWVkIHZhcmlhYmxlIGRlbGltaXRlclwiIHBhcmFncmFwaC5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgbWFpbiByb3V0aW5lcyBoZXJlLiBgbWFrZVNtYWxsRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIGluIHRoZVxuICogbm9ybWFsIGZvbnQsIGJ1dCBpbiBlaXRoZXIgdGV4dCwgc2NyaXB0LCBvciBzY3JpcHRzY3JpcHQgc3R5bGUuXG4gKiBgbWFrZUxhcmdlRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIGluIHRleHRzdHlsZSwgYnV0IGluIG9uZSBvZiB0aGUgU2l6ZTEsXG4gKiBTaXplMiwgU2l6ZTMsIG9yIFNpemU0IGZvbnRzLiBgbWFrZVN0YWNrZWREZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgb3V0IG9mXG4gKiBzbWFsbGVyIHBpZWNlcyB0aGF0IGFyZSBzdGFja2VkIG9uIHRvcCBvZiBvbmUgYW5vdGhlci5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIHRha2UgYSBwYXJhbWV0ZXIgYGNlbnRlcmAsIHdoaWNoIGRldGVybWluZXMgaWYgdGhlIGRlbGltaXRlclxuICogc2hvdWxkIGJlIGNlbnRlcmVkIGFyb3VuZCB0aGUgYXhpcy5cbiAqXG4gKiBUaGVuLCB0aGVyZSBhcmUgdGhyZWUgZXhwb3NlZCBmdW5jdGlvbnMuIGBzaXplZERlbGltYCBtYWtlcyBhIGRlbGltaXRlciBpblxuICogb25lIG9mIHRoZSBnaXZlbiBzaXplcy4gVGhpcyBpcyB1c2VkIGZvciB0aGluZ3MgbGlrZSBgXFxiaWdsYC5cbiAqIGBjdXN0b21TaXplZERlbGltYCBtYWtlcyBhIGRlbGltaXRlciB3aXRoIGEgZ2l2ZW4gdG90YWwgaGVpZ2h0K2RlcHRoLiBJdCBpc1xuICogY2FsbGVkIGluIHBsYWNlcyBsaWtlIGBcXHNxcnRgLiBgbGVmdFJpZ2h0RGVsaW1gIG1ha2VzIGFuIGFwcHJvcHJpYXRlXG4gKiBkZWxpbWl0ZXIgd2hpY2ggc3Vycm91bmRzIGFuIGV4cHJlc3Npb24gb2YgYSBnaXZlbiBoZWlnaHQgYW4gZGVwdGguIEl0IGlzXG4gKiB1c2VkIGluIGBcXGxlZnRgIGFuZCBgXFxyaWdodGAuXG4gKi9cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIEdldCB0aGUgbWV0cmljcyBmb3IgYSBnaXZlbiBzeW1ib2wgYW5kIGZvbnQsIGFmdGVyIHRyYW5zZm9ybWF0aW9uIChpLmUuXG4gKiBhZnRlciBmb2xsb3dpbmcgcmVwbGFjZW1lbnQgZnJvbSBzeW1ib2xzLmpzKVxuICovXG52YXIgZGVsaW1pdGVyX2dldE1ldHJpY3MgPSBmdW5jdGlvbiBnZXRNZXRyaWNzKHN5bWJvbCwgZm9udCwgbW9kZSkge1xuICB2YXIgcmVwbGFjZSA9IHNyY19zeW1ib2xzLm1hdGhbc3ltYm9sXSAmJiBzcmNfc3ltYm9scy5tYXRoW3N5bWJvbF0ucmVwbGFjZTtcbiAgdmFyIG1ldHJpY3MgPSBnZXRDaGFyYWN0ZXJNZXRyaWNzKHJlcGxhY2UgfHwgc3ltYm9sLCBmb250LCBtb2RlKTtcblxuICBpZiAoIW1ldHJpY3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzeW1ib2wgXCIgKyBzeW1ib2wgKyBcIiBhbmQgZm9udCBzaXplIFwiICsgZm9udCArIFwiLlwiKTtcbiAgfVxuXG4gIHJldHVybiBtZXRyaWNzO1xufTtcbi8qKlxuICogUHV0cyBhIGRlbGltaXRlciBzcGFuIGluIGEgZ2l2ZW4gc3R5bGUsIGFuZCBhZGRzIGFwcHJvcHJpYXRlIGhlaWdodCwgZGVwdGgsXG4gKiBhbmQgbWF4Rm9udFNpemVzLlxuICovXG5cblxudmFyIGRlbGltaXRlcl9zdHlsZVdyYXAgPSBmdW5jdGlvbiBzdHlsZVdyYXAoZGVsaW0sIHRvU3R5bGUsIG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZSh0b1N0eWxlKTtcbiAgdmFyIHNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihjbGFzc2VzLmNvbmNhdChuZXdPcHRpb25zLnNpemluZ0NsYXNzZXMob3B0aW9ucykpLCBbZGVsaW1dLCBvcHRpb25zKTtcbiAgdmFyIGRlbGltU2l6ZU11bHRpcGxpZXIgPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgc3Bhbi5oZWlnaHQgKj0gZGVsaW1TaXplTXVsdGlwbGllcjtcbiAgc3Bhbi5kZXB0aCAqPSBkZWxpbVNpemVNdWx0aXBsaWVyO1xuICBzcGFuLm1heEZvbnRTaXplID0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgcmV0dXJuIHNwYW47XG59O1xuXG52YXIgY2VudGVyU3BhbiA9IGZ1bmN0aW9uIGNlbnRlclNwYW4oc3Bhbiwgb3B0aW9ucywgc3R5bGUpIHtcbiAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShzdHlsZSk7XG4gIHZhciBzaGlmdCA9ICgxIC0gb3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIpICogb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQ7XG4gIHNwYW4uY2xhc3Nlcy5wdXNoKFwiZGVsaW1jZW50ZXJcIik7XG4gIHNwYW4uc3R5bGUudG9wID0gc2hpZnQgKyBcImVtXCI7XG4gIHNwYW4uaGVpZ2h0IC09IHNoaWZ0O1xuICBzcGFuLmRlcHRoICs9IHNoaWZ0O1xufTtcbi8qKlxuICogTWFrZXMgYSBzbWFsbCBkZWxpbWl0ZXIuIFRoaXMgaXMgYSBkZWxpbWl0ZXIgdGhhdCBjb21lcyBpbiB0aGUgTWFpbi1SZWd1bGFyXG4gKiBmb250LCBidXQgaXMgcmVzdHlsZWQgdG8gZWl0aGVyIGJlIGluIHRleHRzdHlsZSwgc2NyaXB0c3R5bGUsIG9yXG4gKiBzY3JpcHRzY3JpcHRzdHlsZS5cbiAqL1xuXG5cbnZhciBkZWxpbWl0ZXJfbWFrZVNtYWxsRGVsaW0gPSBmdW5jdGlvbiBtYWtlU21hbGxEZWxpbShkZWxpbSwgc3R5bGUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICB2YXIgdGV4dCA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woZGVsaW0sIFwiTWFpbi1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMpO1xuICB2YXIgc3BhbiA9IGRlbGltaXRlcl9zdHlsZVdyYXAodGV4dCwgc3R5bGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuXG4gIGlmIChjZW50ZXIpIHtcbiAgICBjZW50ZXJTcGFuKHNwYW4sIG9wdGlvbnMsIHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzcGFuO1xufTtcbi8qKlxuICogQnVpbGRzIGEgc3ltYm9sIGluIHRoZSBnaXZlbiBmb250IHNpemUgKG5vdGUgc2l6ZSBpcyBhbiBpbnRlZ2VyKVxuICovXG5cblxudmFyIGRlbGltaXRlcl9tYXRocm1TaXplID0gZnVuY3Rpb24gbWF0aHJtU2l6ZSh2YWx1ZSwgc2l6ZSwgbW9kZSwgb3B0aW9ucykge1xuICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVN5bWJvbCh2YWx1ZSwgXCJTaXplXCIgKyBzaXplICsgXCItUmVndWxhclwiLCBtb2RlLCBvcHRpb25zKTtcbn07XG4vKipcbiAqIE1ha2VzIGEgbGFyZ2UgZGVsaW1pdGVyLiBUaGlzIGlzIGEgZGVsaW1pdGVyIHRoYXQgY29tZXMgaW4gdGhlIFNpemUxLCBTaXplMixcbiAqIFNpemUzLCBvciBTaXplNCBmb250cy4gSXQgaXMgYWx3YXlzIHJlbmRlcmVkIGluIHRleHRzdHlsZS5cbiAqL1xuXG5cbnZhciBkZWxpbWl0ZXJfbWFrZUxhcmdlRGVsaW0gPSBmdW5jdGlvbiBtYWtlTGFyZ2VEZWxpbShkZWxpbSwgc2l6ZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gIHZhciBpbm5lciA9IGRlbGltaXRlcl9tYXRocm1TaXplKGRlbGltLCBzaXplLCBtb2RlLCBvcHRpb25zKTtcbiAgdmFyIHNwYW4gPSBkZWxpbWl0ZXJfc3R5bGVXcmFwKGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImRlbGltc2l6aW5nXCIsIFwic2l6ZVwiICsgc2l6ZV0sIFtpbm5lcl0sIG9wdGlvbnMpLCBzcmNfU3R5bGUuVEVYVCwgb3B0aW9ucywgY2xhc3Nlcyk7XG5cbiAgaWYgKGNlbnRlcikge1xuICAgIGNlbnRlclNwYW4oc3Bhbiwgb3B0aW9ucywgc3JjX1N0eWxlLlRFWFQpO1xuICB9XG5cbiAgcmV0dXJuIHNwYW47XG59O1xuLyoqXG4gKiBNYWtlIGFuIGlubmVyIHNwYW4gd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCBpbiB0aGUgZ2l2ZW4gZm9udC4gVGhpcyBpcyB1c2VkXG4gKiBpbiBgbWFrZVN0YWNrZWREZWxpbWAgdG8gbWFrZSB0aGUgc3RhY2tpbmcgcGllY2VzIGZvciB0aGUgZGVsaW1pdGVyLlxuICovXG5cblxudmFyIGRlbGltaXRlcl9tYWtlSW5uZXIgPSBmdW5jdGlvbiBtYWtlSW5uZXIoc3ltYm9sLCBmb250LCBtb2RlKSB7XG4gIHZhciBzaXplQ2xhc3M7IC8vIEFwcGx5IHRoZSBjb3JyZWN0IENTUyBjbGFzcyB0byBjaG9vc2UgdGhlIHJpZ2h0IGZvbnQuXG5cbiAgaWYgKGZvbnQgPT09IFwiU2l6ZTEtUmVndWxhclwiKSB7XG4gICAgc2l6ZUNsYXNzID0gXCJkZWxpbS1zaXplMVwiO1xuICB9IGVsc2VcbiAgICAvKiBpZiAoZm9udCA9PT0gXCJTaXplNC1SZWd1bGFyXCIpICovXG4gICAge1xuICAgICAgc2l6ZUNsYXNzID0gXCJkZWxpbS1zaXplNFwiO1xuICAgIH1cblxuICB2YXIgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJkZWxpbXNpemluZ2lubmVyXCIsIHNpemVDbGFzc10sIFtidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW2J1aWxkQ29tbW9uLm1ha2VTeW1ib2woc3ltYm9sLCBmb250LCBtb2RlKV0pXSk7IC8vIFNpbmNlIHRoaXMgd2lsbCBiZSBwYXNzZWQgaW50byBgbWFrZVZMaXN0YCBpbiB0aGUgZW5kLCB3cmFwIHRoZSBlbGVtZW50XG4gIC8vIGluIHRoZSBhcHByb3ByaWF0ZSB0YWcgdGhhdCBWTGlzdCB1c2VzLlxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbGVtXCIsXG4gICAgZWxlbTogaW5uZXJcbiAgfTtcbn07XG4vKipcbiAqIE1ha2UgYSBzdGFja2VkIGRlbGltaXRlciBvdXQgb2YgYSBnaXZlbiBkZWxpbWl0ZXIsIHdpdGggdGhlIHRvdGFsIGhlaWdodCBhdFxuICogbGVhc3QgYGhlaWdodFRvdGFsYC4gVGhpcyByb3V0aW5lIGlzIG1lbnRpb25lZCBvbiBwYWdlIDQ0MiBvZiB0aGUgVGVYYm9vay5cbiAqL1xuXG5cbnZhciBkZWxpbWl0ZXJfbWFrZVN0YWNrZWREZWxpbSA9IGZ1bmN0aW9uIG1ha2VTdGFja2VkRGVsaW0oZGVsaW0sIGhlaWdodFRvdGFsLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHtcbiAgLy8gVGhlcmUgYXJlIGZvdXIgcGFydHMsIHRoZSB0b3AsIGFuIG9wdGlvbmFsIG1pZGRsZSwgYSByZXBlYXRlZCBwYXJ0LCBhbmQgYVxuICAvLyBib3R0b20uXG4gIHZhciB0b3A7XG4gIHZhciBtaWRkbGU7XG4gIHZhciByZXBlYXQ7XG4gIHZhciBib3R0b207XG4gIHRvcCA9IHJlcGVhdCA9IGJvdHRvbSA9IGRlbGltO1xuICBtaWRkbGUgPSBudWxsOyAvLyBBbHNvIGtlZXAgdHJhY2sgb2Ygd2hhdCBmb250IHRoZSBkZWxpbWl0ZXJzIGFyZSBpblxuXG4gIHZhciBmb250ID0gXCJTaXplMS1SZWd1bGFyXCI7IC8vIFdlIHNldCB0aGUgcGFydHMgYW5kIGZvbnQgYmFzZWQgb24gdGhlIHN5bWJvbC4gTm90ZSB0aGF0IHdlIHVzZVxuICAvLyAnXFx1MjNkMCcgaW5zdGVhZCBvZiAnfCcgYW5kICdcXHUyMDE2JyBpbnN0ZWFkIG9mICdcXFxcfCcgZm9yIHRoZVxuICAvLyByZXBlYXRzIG9mIHRoZSBhcnJvd3NcblxuICBpZiAoZGVsaW0gPT09IFwiXFxcXHVwYXJyb3dcIikge1xuICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNEMFwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxVcGFycm93XCIpIHtcbiAgICByZXBlYXQgPSBib3R0b20gPSBcIlxcdTIwMTZcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcZG93bmFycm93XCIpIHtcbiAgICB0b3AgPSByZXBlYXQgPSBcIlxcdTIzRDBcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcRG93bmFycm93XCIpIHtcbiAgICB0b3AgPSByZXBlYXQgPSBcIlxcdTIwMTZcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcdXBkb3duYXJyb3dcIikge1xuICAgIHRvcCA9IFwiXFxcXHVwYXJyb3dcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzRDBcIjtcbiAgICBib3R0b20gPSBcIlxcXFxkb3duYXJyb3dcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcVXBkb3duYXJyb3dcIikge1xuICAgIHRvcCA9IFwiXFxcXFVwYXJyb3dcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIwMTZcIjtcbiAgICBib3R0b20gPSBcIlxcXFxEb3duYXJyb3dcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJbXCIgfHwgZGVsaW0gPT09IFwiXFxcXGxicmFja1wiKSB7XG4gICAgdG9wID0gXCJcXHUyM0ExXCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM0EyXCI7XG4gICAgYm90dG9tID0gXCJcXHUyM0EzXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIl1cIiB8fCBkZWxpbSA9PT0gXCJcXFxccmJyYWNrXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzQTRcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzQTVcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzQTZcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxmbG9vclwiIHx8IGRlbGltID09PSBcIlxcdTIzMEFcIikge1xuICAgIHJlcGVhdCA9IHRvcCA9IFwiXFx1MjNBMlwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNBM1wiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcbGNlaWxcIiB8fCBkZWxpbSA9PT0gXCJcXHUyMzA4XCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzQTFcIjtcbiAgICByZXBlYXQgPSBib3R0b20gPSBcIlxcdTIzQTJcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJmbG9vclwiIHx8IGRlbGltID09PSBcIlxcdTIzMEJcIikge1xuICAgIHJlcGVhdCA9IHRvcCA9IFwiXFx1MjNBNVwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNBNlwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmNlaWxcIiB8fCBkZWxpbSA9PT0gXCJcXHUyMzA5XCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzQTRcIjtcbiAgICByZXBlYXQgPSBib3R0b20gPSBcIlxcdTIzQTVcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiKFwiIHx8IGRlbGltID09PSBcIlxcXFxscGFyZW5cIikge1xuICAgIHRvcCA9IFwiXFx1MjM5QlwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjM5Q1wiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjM5RFwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCIpXCIgfHwgZGVsaW0gPT09IFwiXFxcXHJwYXJlblwiKSB7XG4gICAgdG9wID0gXCJcXHUyMzlFXCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyMzlGXCI7XG4gICAgYm90dG9tID0gXCJcXHUyM0EwXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx7XCIgfHwgZGVsaW0gPT09IFwiXFxcXGxicmFjZVwiKSB7XG4gICAgdG9wID0gXCJcXHUyM0E3XCI7XG4gICAgbWlkZGxlID0gXCJcXHUyM0E4XCI7XG4gICAgYm90dG9tID0gXCJcXHUyM0E5XCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM0FBXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx9XCIgfHwgZGVsaW0gPT09IFwiXFxcXHJicmFjZVwiKSB7XG4gICAgdG9wID0gXCJcXHUyM0FCXCI7XG4gICAgbWlkZGxlID0gXCJcXHUyM0FDXCI7XG4gICAgYm90dG9tID0gXCJcXHUyM0FEXCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM0FBXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxsZ3JvdXBcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN0VFXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzQTdcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzQTlcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzQUFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJncm91cFwiIHx8IGRlbGltID09PSBcIlxcdTI3RUZcIikge1xuICAgIHRvcCA9IFwiXFx1MjNBQlwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNBRFwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNBQVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcbG1vdXN0YWNoZVwiIHx8IGRlbGltID09PSBcIlxcdTIzQjBcIikge1xuICAgIHRvcCA9IFwiXFx1MjNBN1wiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNBRFwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNBQVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccm1vdXN0YWNoZVwiIHx8IGRlbGltID09PSBcIlxcdTIzQjFcIikge1xuICAgIHRvcCA9IFwiXFx1MjNBQlwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNBOVwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNBQVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSAvLyBHZXQgdGhlIG1ldHJpY3Mgb2YgdGhlIGZvdXIgc2VjdGlvbnNcblxuXG4gIHZhciB0b3BNZXRyaWNzID0gZGVsaW1pdGVyX2dldE1ldHJpY3ModG9wLCBmb250LCBtb2RlKTtcbiAgdmFyIHRvcEhlaWdodFRvdGFsID0gdG9wTWV0cmljcy5oZWlnaHQgKyB0b3BNZXRyaWNzLmRlcHRoO1xuICB2YXIgcmVwZWF0TWV0cmljcyA9IGRlbGltaXRlcl9nZXRNZXRyaWNzKHJlcGVhdCwgZm9udCwgbW9kZSk7XG4gIHZhciByZXBlYXRIZWlnaHRUb3RhbCA9IHJlcGVhdE1ldHJpY3MuaGVpZ2h0ICsgcmVwZWF0TWV0cmljcy5kZXB0aDtcbiAgdmFyIGJvdHRvbU1ldHJpY3MgPSBkZWxpbWl0ZXJfZ2V0TWV0cmljcyhib3R0b20sIGZvbnQsIG1vZGUpO1xuICB2YXIgYm90dG9tSGVpZ2h0VG90YWwgPSBib3R0b21NZXRyaWNzLmhlaWdodCArIGJvdHRvbU1ldHJpY3MuZGVwdGg7XG4gIHZhciBtaWRkbGVIZWlnaHRUb3RhbCA9IDA7XG4gIHZhciBtaWRkbGVGYWN0b3IgPSAxO1xuXG4gIGlmIChtaWRkbGUgIT09IG51bGwpIHtcbiAgICB2YXIgbWlkZGxlTWV0cmljcyA9IGRlbGltaXRlcl9nZXRNZXRyaWNzKG1pZGRsZSwgZm9udCwgbW9kZSk7XG4gICAgbWlkZGxlSGVpZ2h0VG90YWwgPSBtaWRkbGVNZXRyaWNzLmhlaWdodCArIG1pZGRsZU1ldHJpY3MuZGVwdGg7XG4gICAgbWlkZGxlRmFjdG9yID0gMjsgLy8gcmVwZWF0IHN5bW1ldHJpY2FsbHkgYWJvdmUgYW5kIGJlbG93IG1pZGRsZVxuICB9IC8vIENhbGN1YXRlIHRoZSBtaW5pbWFsIGhlaWdodCB0aGF0IHRoZSBkZWxpbWl0ZXIgY2FuIGhhdmUuXG4gIC8vIEl0IGlzIGF0IGxlYXN0IHRoZSBzaXplIG9mIHRoZSB0b3AsIGJvdHRvbSwgYW5kIG9wdGlvbmFsIG1pZGRsZSBjb21iaW5lZC5cblxuXG4gIHZhciBtaW5IZWlnaHQgPSB0b3BIZWlnaHRUb3RhbCArIGJvdHRvbUhlaWdodFRvdGFsICsgbWlkZGxlSGVpZ2h0VG90YWw7IC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiBjb3BpZXMgb2YgdGhlIHJlcGVhdCBzeW1ib2wgd2Ugd2lsbCBuZWVkXG5cbiAgdmFyIHJlcGVhdENvdW50ID0gTWF0aC5jZWlsKChoZWlnaHRUb3RhbCAtIG1pbkhlaWdodCkgLyAobWlkZGxlRmFjdG9yICogcmVwZWF0SGVpZ2h0VG90YWwpKTsgLy8gQ29tcHV0ZSB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBkZWxpbWl0ZXIgaW5jbHVkaW5nIGFsbCB0aGUgc3ltYm9sc1xuXG4gIHZhciByZWFsSGVpZ2h0VG90YWwgPSBtaW5IZWlnaHQgKyByZXBlYXRDb3VudCAqIG1pZGRsZUZhY3RvciAqIHJlcGVhdEhlaWdodFRvdGFsOyAvLyBUaGUgY2VudGVyIG9mIHRoZSBkZWxpbWl0ZXIgaXMgcGxhY2VkIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGF4aXMuIE5vdGVcbiAgLy8gdGhhdCBpbiB0aGlzIGNvbnRleHQsIFwiY2VudGVyXCIgbWVhbnMgdGhhdCB0aGUgZGVsaW1pdGVyIHNob3VsZCBiZVxuICAvLyBjZW50ZXJlZCBhcm91bmQgdGhlIGF4aXMgaW4gdGhlIGN1cnJlbnQgc3R5bGUsIHdoaWxlIG5vcm1hbGx5IGl0IGlzXG4gIC8vIGNlbnRlcmVkIGFyb3VuZCB0aGUgYXhpcyBpbiB0ZXh0c3R5bGUuXG5cbiAgdmFyIGF4aXNIZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDtcblxuICBpZiAoY2VudGVyKSB7XG4gICAgYXhpc0hlaWdodCAqPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICB9IC8vIENhbGN1bGF0ZSB0aGUgZGVwdGhcblxuXG4gIHZhciBkZXB0aCA9IHJlYWxIZWlnaHRUb3RhbCAvIDIgLSBheGlzSGVpZ2h0OyAvLyBOb3csIHdlIHN0YXJ0IGJ1aWxkaW5nIHRoZSBwaWVjZXMgdGhhdCB3aWxsIGdvIGludG8gdGhlIHZsaXN0XG4gIC8vIEtlZXAgYSBsaXN0IG9mIHRoZSBpbm5lciBwaWVjZXNcblxuICB2YXIgaW5uZXJzID0gW107IC8vIEFkZCB0aGUgYm90dG9tIHN5bWJvbFxuXG4gIGlubmVycy5wdXNoKGRlbGltaXRlcl9tYWtlSW5uZXIoYm90dG9tLCBmb250LCBtb2RlKSk7XG5cbiAgaWYgKG1pZGRsZSA9PT0gbnVsbCkge1xuICAgIC8vIEFkZCB0aGF0IG1hbnkgc3ltYm9sc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwZWF0Q291bnQ7IGkrKykge1xuICAgICAgaW5uZXJzLnB1c2goZGVsaW1pdGVyX21ha2VJbm5lcihyZXBlYXQsIGZvbnQsIG1vZGUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBhIG1pZGRsZSBiaXQsIHdlIG5lZWQgdGhlIG1pZGRsZSBwYXJ0IGFuZCB0d28gcmVwZWF0ZWRcbiAgICAvLyBzZWN0aW9uc1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCByZXBlYXRDb3VudDsgX2krKykge1xuICAgICAgaW5uZXJzLnB1c2goZGVsaW1pdGVyX21ha2VJbm5lcihyZXBlYXQsIGZvbnQsIG1vZGUpKTtcbiAgICB9XG5cbiAgICBpbm5lcnMucHVzaChkZWxpbWl0ZXJfbWFrZUlubmVyKG1pZGRsZSwgZm9udCwgbW9kZSkpO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcmVwZWF0Q291bnQ7IF9pMisrKSB7XG4gICAgICBpbm5lcnMucHVzaChkZWxpbWl0ZXJfbWFrZUlubmVyKHJlcGVhdCwgZm9udCwgbW9kZSkpO1xuICAgIH1cbiAgfSAvLyBBZGQgdGhlIHRvcCBzeW1ib2xcblxuXG4gIGlubmVycy5wdXNoKGRlbGltaXRlcl9tYWtlSW5uZXIodG9wLCBmb250LCBtb2RlKSk7IC8vIEZpbmFsbHksIGJ1aWxkIHRoZSB2bGlzdFxuXG4gIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUoc3JjX1N0eWxlLlRFWFQpO1xuICB2YXIgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgIHBvc2l0aW9uVHlwZTogXCJib3R0b21cIixcbiAgICBwb3NpdGlvbkRhdGE6IGRlcHRoLFxuICAgIGNoaWxkcmVuOiBpbm5lcnNcbiAgfSwgbmV3T3B0aW9ucyk7XG4gIHJldHVybiBkZWxpbWl0ZXJfc3R5bGVXcmFwKGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImRlbGltc2l6aW5nXCIsIFwibXVsdFwiXSwgW2lubmVyXSwgbmV3T3B0aW9ucyksIHNyY19TdHlsZS5URVhULCBvcHRpb25zLCBjbGFzc2VzKTtcbn07IC8vIEFsbCBzdXJkcyBoYXZlIDAuMDhlbSBwYWRkaW5nIGFib3ZlIHRoZSB2aW5pY3VsdW0gaW5zaWRlIHRoZSBTVkcuXG4vLyBUaGF0IGtlZXBzIGJyb3dzZXIgc3BhbiBoZWlnaHQgcm91bmRpbmcgZXJyb3IgZnJvbSBwaW5jaGluZyB0aGUgbGluZS5cblxuXG52YXIgdmJQYWQgPSA4MDsgLy8gcGFkZGluZyBhYm92ZSB0aGUgc3VyZCwgbWVhc3VyZWQgaW5zaWRlIHRoZSB2aWV3Qm94LlxuXG52YXIgZW1QYWQgPSAwLjA4OyAvLyBwYWRkaW5nLCBpbiBlbXMsIG1lYXN1cmVkIGluIHRoZSBkb2N1bWVudC5cblxudmFyIGRlbGltaXRlcl9zcXJ0U3ZnID0gZnVuY3Rpb24gc3FydFN2ZyhzcXJ0TmFtZSwgaGVpZ2h0LCB2aWV3Qm94SGVpZ2h0LCBvcHRpb25zKSB7XG4gIHZhciBhbHRlcm5hdGU7XG5cbiAgaWYgKHNxcnROYW1lID09PSBcInNxcnRUYWxsXCIpIHtcbiAgICAvLyBzcXJ0VGFsbCBpcyBmcm9tIGdseXBoIFUyM0I3IGluIHRoZSBmb250IEthVGVYX1NpemU0LVJlZ3VsYXJcbiAgICAvLyBPbmUgcGF0aCBlZGdlIGhhcyBhIHZhcmlhYmxlIGxlbmd0aC4gSXQgcnVucyBmcm9tIHRoZSB2aW5pY3VsdW1uXG4gICAgLy8gdG8gYSBwb2ludCBuZWFyICgxNCB1bml0cykgdGhlIGJvdHRvbSBvZiB0aGUgc3VyZC4gVGhlIHZpbmljdWx1bVxuICAgIC8vIGlzIDQwIHVuaXRzIHRoaWNrLiBTbyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIGluIHF1ZXN0aW9uIGlzOlxuICAgIHZhciB2ZXJ0U2VnbWVudCA9IHZpZXdCb3hIZWlnaHQgLSA1NCAtIHZiUGFkO1xuICAgIGFsdGVybmF0ZSA9IFwiTTcwMiBcIiArIHZiUGFkICsgXCJINDAwMDAwdjQwSDc0MnZcIiArIHZlcnRTZWdtZW50ICsgXCJsLTQgNC00IDRjLS42NjcuN1xcbi0yIDEuNS00IDIuNXMtNC4xNjcgMS44MzMtNi41IDIuNS01LjUgMS05LjUgMWgtMTJsLTI4LTg0Yy0xNi42NjctNTItOTYuNjY3XFxuLTI5NC4zMzMtMjQwLTcyN2wtMjEyIC02NDMgLTg1IDE3MGMtNC0zLjMzMy04LjMzMy03LjY2Ny0xMyAtMTNsLTEzLTEzbDc3LTE1NVxcbiA3Ny0xNTZjNjYgMTk5LjMzMyAxMzkgNDE5LjY2NyAyMTkgNjYxIGwyMTggNjYxek03MDIgXCIgKyB2YlBhZCArIFwiSDQwMDAwMHY0MEg3NDJ6XCI7XG4gIH1cblxuICB2YXIgcGF0aE5vZGUgPSBuZXcgZG9tVHJlZV9QYXRoTm9kZShzcXJ0TmFtZSwgYWx0ZXJuYXRlKTtcbiAgdmFyIHN2ZyA9IG5ldyBTdmdOb2RlKFtwYXRoTm9kZV0sIHtcbiAgICAvLyBOb3RlOiAxMDAwOjEgcmF0aW8gb2Ygdmlld0JveCB0byBkb2N1bWVudCBlbSB3aWR0aC5cbiAgICBcIndpZHRoXCI6IFwiNDAwZW1cIixcbiAgICBcImhlaWdodFwiOiBoZWlnaHQgKyBcImVtXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDQwMDAwMCBcIiArIHZpZXdCb3hIZWlnaHQsXG4gICAgXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCI6IFwieE1pbllNaW4gc2xpY2VcIlxuICB9KTtcbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtcImhpZGUtdGFpbFwiXSwgW3N2Z10sIG9wdGlvbnMpO1xufTtcbi8qKlxuICogTWFrZSBhIHNxcnQgaW1hZ2Ugb2YgdGhlIGdpdmVuIGhlaWdodCxcbiAqL1xuXG5cbnZhciBtYWtlU3FydEltYWdlID0gZnVuY3Rpb24gbWFrZVNxcnRJbWFnZShoZWlnaHQsIG9wdGlvbnMpIHtcbiAgLy8gRGVmaW5lIGEgbmV3T3B0aW9ucyB0aGF0IHJlbW92ZXMgdGhlIGVmZmVjdCBvZiBzaXplIGNoYW5nZXMgc3VjaCBhcyBcXEh1Z2UuXG4gIC8vIFdlIGRvbid0IHBpY2sgZGlmZmVyZW50IGEgaGVpZ2h0IHN1cmQgZm9yIFxcSHVnZS4gRm9yIGl0LCB3ZSBzY2FsZSB1cC5cbiAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTaXppbmcoKTsgLy8gUGljayB0aGUgZGVzaXJlZCBzdXJkIGdseXBoIGZyb20gYSBzZXF1ZW5jZSBvZiBzdXJkcy5cblxuICB2YXIgZGVsaW0gPSB0cmF2ZXJzZVNlcXVlbmNlKFwiXFxcXHN1cmRcIiwgaGVpZ2h0ICogbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciwgc3RhY2tMYXJnZURlbGltaXRlclNlcXVlbmNlLCBuZXdPcHRpb25zKTtcbiAgdmFyIHNpemVNdWx0aXBsaWVyID0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcjsgLy8gZGVmYXVsdFxuICAvLyBDcmVhdGUgYSBzcGFuIGNvbnRhaW5pbmcgYW4gU1ZHIGltYWdlIG9mIGEgc3FydCBzeW1ib2wuXG5cbiAgdmFyIHNwYW47XG4gIHZhciBzcGFuSGVpZ2h0ID0gMDtcbiAgdmFyIHRleEhlaWdodCA9IDA7XG4gIHZhciB2aWV3Qm94SGVpZ2h0ID0gMDtcbiAgdmFyIGFkdmFuY2VXaWR0aDsgLy8gV2UgY3JlYXRlIHZpZXdCb3hlcyB3aXRoIDgwIHVuaXRzIG9mIFwicGFkZGluZ1wiIGFib3ZlIGVhY2ggc3VyZC5cbiAgLy8gVGhlbiBicm93c2VyIHJvdW5kaW5nIGVycm9yIG9uIHRoZSBwYXJlbnQgc3BhbiBoZWlnaHQgd2lsbCBub3RcbiAgLy8gZW5jcm9hY2ggb24gdGhlIGluayBvZiB0aGUgdmluaWN1bHVtLiBCdXQgdGhhdCBwYWRkaW5nIGlzIG5vdFxuICAvLyBpbmNsdWRlZCBpbiB0aGUgVGVYLWxpa2UgYGhlaWdodGAgdXNlZCBmb3IgY2FsY3VsYXRpb24gb2ZcbiAgLy8gdmVydGljYWwgYWxpZ25tZW50LiBTbyB0ZXhIZWlnaHQgPSBzcGFuLmhlaWdodCA8IHNwYW4uc3R5bGUuaGVpZ2h0LlxuXG4gIGlmIChkZWxpbS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAvLyBHZXQgYW4gU1ZHIHRoYXQgaXMgZGVyaXZlZCBmcm9tIGdseXBoIFUrMjIxQSBpbiBmb250IEthVGVYLU1haW4uXG4gICAgdmlld0JveEhlaWdodCA9IDEwMDAgKyB2YlBhZDsgLy8gMTAwMCB1bml0IGdseXBoIGhlaWdodC5cblxuICAgIGlmIChoZWlnaHQgPCAxLjApIHtcbiAgICAgIHNpemVNdWx0aXBsaWVyID0gMS4wOyAvLyBtaW1pYyBhIFxcdGV4dGZvbnQgcmFkaWNhbFxuICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMS40KSB7XG4gICAgICBzaXplTXVsdGlwbGllciA9IDAuNzsgLy8gbWltaWMgYSBcXHNjcmlwdGZvbnQgcmFkaWNhbFxuICAgIH1cblxuICAgIHNwYW5IZWlnaHQgPSAoMS4wICsgZW1QYWQpIC8gc2l6ZU11bHRpcGxpZXI7XG4gICAgdGV4SGVpZ2h0ID0gMS4wMCAvIHNpemVNdWx0aXBsaWVyO1xuICAgIHNwYW4gPSBkZWxpbWl0ZXJfc3FydFN2ZyhcInNxcnRNYWluXCIsIHNwYW5IZWlnaHQsIHZpZXdCb3hIZWlnaHQsIG9wdGlvbnMpO1xuICAgIHNwYW4uc3R5bGUubWluV2lkdGggPSBcIjAuODUzZW1cIjtcbiAgICBhZHZhbmNlV2lkdGggPSAwLjgzMyAvIHNpemVNdWx0aXBsaWVyOyAvLyBmcm9tIHRoZSBmb250LlxuICB9IGVsc2UgaWYgKGRlbGltLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgIC8vIFRoZXNlIFNWR3MgY29tZSBmcm9tIGZvbnRzOiBLYVRlWF9TaXplMSwgX1NpemUyLCBldGMuXG4gICAgdmlld0JveEhlaWdodCA9ICgxMDAwICsgdmJQYWQpICogc2l6ZVRvTWF4SGVpZ2h0W2RlbGltLnNpemVdO1xuICAgIHRleEhlaWdodCA9IHNpemVUb01heEhlaWdodFtkZWxpbS5zaXplXSAvIHNpemVNdWx0aXBsaWVyO1xuICAgIHNwYW5IZWlnaHQgPSAoc2l6ZVRvTWF4SGVpZ2h0W2RlbGltLnNpemVdICsgZW1QYWQpIC8gc2l6ZU11bHRpcGxpZXI7XG4gICAgc3BhbiA9IGRlbGltaXRlcl9zcXJ0U3ZnKFwic3FydFNpemVcIiArIGRlbGltLnNpemUsIHNwYW5IZWlnaHQsIHZpZXdCb3hIZWlnaHQsIG9wdGlvbnMpO1xuICAgIHNwYW4uc3R5bGUubWluV2lkdGggPSBcIjEuMDJlbVwiO1xuICAgIGFkdmFuY2VXaWR0aCA9IDEuMCAvIHNpemVNdWx0aXBsaWVyOyAvLyAxLjAgZnJvbSB0aGUgZm9udC5cbiAgfSBlbHNlIHtcbiAgICAvLyBUYWxsIHNxcnQuIEluIFRlWCwgdGhpcyB3b3VsZCBiZSBzdGFja2VkIHVzaW5nIG11bHRpcGxlIGdseXBocy5cbiAgICAvLyBXZSdsbCB1c2UgYSBzaW5nbGUgU1ZHIHRvIGFjY29tcGxpc2ggdGhlIHNhbWUgdGhpbmcuXG4gICAgc3BhbkhlaWdodCA9IGhlaWdodCArIGVtUGFkO1xuICAgIHRleEhlaWdodCA9IGhlaWdodDtcbiAgICB2aWV3Qm94SGVpZ2h0ID0gTWF0aC5mbG9vcigxMDAwICogaGVpZ2h0KSArIHZiUGFkO1xuICAgIHNwYW4gPSBkZWxpbWl0ZXJfc3FydFN2ZyhcInNxcnRUYWxsXCIsIHNwYW5IZWlnaHQsIHZpZXdCb3hIZWlnaHQsIG9wdGlvbnMpO1xuICAgIHNwYW4uc3R5bGUubWluV2lkdGggPSBcIjAuNzQyZW1cIjtcbiAgICBhZHZhbmNlV2lkdGggPSAxLjA1NjtcbiAgfVxuXG4gIHNwYW4uaGVpZ2h0ID0gdGV4SGVpZ2h0O1xuICBzcGFuLnN0eWxlLmhlaWdodCA9IHNwYW5IZWlnaHQgKyBcImVtXCI7XG4gIHJldHVybiB7XG4gICAgc3Bhbjogc3BhbixcbiAgICBhZHZhbmNlV2lkdGg6IGFkdmFuY2VXaWR0aCxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFjdHVhbCBsaW5lIHdpZHRoLlxuICAgIC8vIFRoaXMgYWN0dWFsbHkgc2hvdWxkIGRlcGVuZCBvbiB0aGUgY2hvc2VuIGZvbnQgLS0gZS5nLiBcXGJvbGRtYXRoXG4gICAgLy8gc2hvdWxkIHVzZSB0aGUgdGhpY2tlciBzdXJkIHN5bWJvbHMgZnJvbSBlLmcuIEthVGVYX01haW4tQm9sZCwgYW5kXG4gICAgLy8gaGF2ZSB0aGlja2VyIHJ1bGVzLlxuICAgIHJ1bGVXaWR0aDogb3B0aW9ucy5mb250TWV0cmljcygpLnNxcnRSdWxlVGhpY2tuZXNzICogc2l6ZU11bHRpcGxpZXJcbiAgfTtcbn07IC8vIFRoZXJlIGFyZSB0aHJlZSBraW5kcyBvZiBkZWxpbWl0ZXJzLCBkZWxpbWl0ZXJzIHRoYXQgc3RhY2sgd2hlbiB0aGV5IGJlY29tZVxuLy8gdG9vIGxhcmdlXG5cblxudmFyIHN0YWNrTGFyZ2VEZWxpbWl0ZXJzID0gW1wiKFwiLCBcIlxcXFxscGFyZW5cIiwgXCIpXCIsIFwiXFxcXHJwYXJlblwiLCBcIltcIiwgXCJcXFxcbGJyYWNrXCIsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIiwgXCJcXFxce1wiLCBcIlxcXFxsYnJhY2VcIiwgXCJcXFxcfVwiLCBcIlxcXFxyYnJhY2VcIiwgXCJcXFxcbGZsb29yXCIsIFwiXFxcXHJmbG9vclwiLCBcIlxcdTIzMEFcIiwgXCJcXHUyMzBCXCIsIFwiXFxcXGxjZWlsXCIsIFwiXFxcXHJjZWlsXCIsIFwiXFx1MjMwOFwiLCBcIlxcdTIzMDlcIiwgXCJcXFxcc3VyZFwiXTsgLy8gZGVsaW1pdGVycyB0aGF0IGFsd2F5cyBzdGFja1xuXG52YXIgc3RhY2tBbHdheXNEZWxpbWl0ZXJzID0gW1wiXFxcXHVwYXJyb3dcIiwgXCJcXFxcZG93bmFycm93XCIsIFwiXFxcXHVwZG93bmFycm93XCIsIFwiXFxcXFVwYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsIFwiXFxcXFVwZG93bmFycm93XCIsIFwifFwiLCBcIlxcXFx8XCIsIFwiXFxcXHZlcnRcIiwgXCJcXFxcVmVydFwiLCBcIlxcXFxsdmVydFwiLCBcIlxcXFxydmVydFwiLCBcIlxcXFxsVmVydFwiLCBcIlxcXFxyVmVydFwiLCBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFx1MjdFRVwiLCBcIlxcdTI3RUZcIiwgXCJcXFxcbG1vdXN0YWNoZVwiLCBcIlxcXFxybW91c3RhY2hlXCIsIFwiXFx1MjNCMFwiLCBcIlxcdTIzQjFcIl07IC8vIGFuZCBkZWxpbWl0ZXJzIHRoYXQgbmV2ZXIgc3RhY2tcblxudmFyIHN0YWNrTmV2ZXJEZWxpbWl0ZXJzID0gW1wiPFwiLCBcIj5cIiwgXCJcXFxcbGFuZ2xlXCIsIFwiXFxcXHJhbmdsZVwiLCBcIi9cIiwgXCJcXFxcYmFja3NsYXNoXCIsIFwiXFxcXGx0XCIsIFwiXFxcXGd0XCJdOyAvLyBNZXRyaWNzIG9mIHRoZSBkaWZmZXJlbnQgc2l6ZXMuIEZvdW5kIGJ5IGxvb2tpbmcgYXQgVGVYJ3Mgb3V0cHV0IG9mXG4vLyAkXFxiaWdsfCAvLyBcXEJpZ2x8IFxcYmlnZ2x8IFxcQmlnZ2x8IFxcc2hvd2xpc3RzJFxuLy8gVXNlZCB0byBjcmVhdGUgc3RhY2tlZCBkZWxpbWl0ZXJzIG9mIGFwcHJvcHJpYXRlIHNpemVzIGluIG1ha2VTaXplZERlbGltLlxuXG52YXIgc2l6ZVRvTWF4SGVpZ2h0ID0gWzAsIDEuMiwgMS44LCAyLjQsIDMuMF07XG4vKipcbiAqIFVzZWQgdG8gY3JlYXRlIGEgZGVsaW1pdGVyIG9mIGEgc3BlY2lmaWMgc2l6ZSwgd2hlcmUgYHNpemVgIGlzIDEsIDIsIDMsIG9yIDQuXG4gKi9cblxudmFyIGRlbGltaXRlcl9tYWtlU2l6ZWREZWxpbSA9IGZ1bmN0aW9uIG1ha2VTaXplZERlbGltKGRlbGltLCBzaXplLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gIC8vIDwgYW5kID4gdHVybiBpbnRvIFxcbGFuZ2xlIGFuZCBcXHJhbmdsZSBpbiBkZWxpbWl0ZXJzXG4gIGlmIChkZWxpbSA9PT0gXCI8XCIgfHwgZGVsaW0gPT09IFwiXFxcXGx0XCIgfHwgZGVsaW0gPT09IFwiXFx1MjdFOFwiKSB7XG4gICAgZGVsaW0gPSBcIlxcXFxsYW5nbGVcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCI+XCIgfHwgZGVsaW0gPT09IFwiXFxcXGd0XCIgfHwgZGVsaW0gPT09IFwiXFx1MjdFOVwiKSB7XG4gICAgZGVsaW0gPSBcIlxcXFxyYW5nbGVcIjtcbiAgfSAvLyBTaXplZCBkZWxpbWl0ZXJzIGFyZSBuZXZlciBjZW50ZXJlZC5cblxuXG4gIGlmICh1dGlscy5jb250YWlucyhzdGFja0xhcmdlRGVsaW1pdGVycywgZGVsaW0pIHx8IHV0aWxzLmNvbnRhaW5zKHN0YWNrTmV2ZXJEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICByZXR1cm4gZGVsaW1pdGVyX21ha2VMYXJnZURlbGltKGRlbGltLCBzaXplLCBmYWxzZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuY29udGFpbnMoc3RhY2tBbHdheXNEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICByZXR1cm4gZGVsaW1pdGVyX21ha2VTdGFja2VkRGVsaW0oZGVsaW0sIHNpemVUb01heEhlaWdodFtzaXplXSwgZmFsc2UsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIklsbGVnYWwgZGVsaW1pdGVyOiAnXCIgKyBkZWxpbSArIFwiJ1wiKTtcbiAgfVxufTtcbi8qKlxuICogVGhlcmUgYXJlIHRocmVlIGRpZmZlcmVudCBzZXF1ZW5jZXMgb2YgZGVsaW1pdGVyIHNpemVzIHRoYXQgdGhlIGRlbGltaXRlcnNcbiAqIGZvbGxvdyBkZXBlbmRpbmcgb24gdGhlIGtpbmQgb2YgZGVsaW1pdGVyLiBUaGlzIGlzIHVzZWQgd2hlbiBjcmVhdGluZyBjdXN0b21cbiAqIHNpemVkIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoZXRoZXIgdG8gY3JlYXRlIGEgc21hbGwsIGxhcmdlLCBvciBzdGFja2VkXG4gKiBkZWxpbWl0ZXIuXG4gKlxuICogSW4gcmVhbCBUZVgsIHRoZXNlIHNlcXVlbmNlcyBhcmVuJ3QgZXhwbGljaXRseSBkZWZpbmVkLCBidXQgYXJlIGluc3RlYWRcbiAqIGRlZmluZWQgaW5zaWRlIHRoZSBmb250IG1ldHJpY3MuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlIHNlcXVlbmNlcyB0aGF0XG4gKiBhcmUgcG9zc2libGUgZm9yIHRoZSBkZWxpbWl0ZXJzIHRoYXQgVGVYIGRlZmluZXMsIGl0IGlzIGVhc2llciB0byBqdXN0IGVuY29kZVxuICogdGhlbSBleHBsaWNpdGx5IGhlcmUuXG4gKi9cblxuXG4vLyBEZWxpbWl0ZXJzIHRoYXQgbmV2ZXIgc3RhY2sgdHJ5IHNtYWxsIGRlbGltaXRlcnMgYW5kIGxhcmdlIGRlbGltaXRlcnMgb25seVxudmFyIHN0YWNrTmV2ZXJEZWxpbWl0ZXJTZXF1ZW5jZSA9IFt7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IHNyY19TdHlsZS5TQ1JJUFRTQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogc3JjX1N0eWxlLlNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBzcmNfU3R5bGUuVEVYVFxufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDFcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiAyXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogM1xufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDRcbn1dOyAvLyBEZWxpbWl0ZXJzIHRoYXQgYWx3YXlzIHN0YWNrIHRyeSB0aGUgc21hbGwgZGVsaW1pdGVycyBmaXJzdCwgdGhlbiBzdGFja1xuXG52YXIgc3RhY2tBbHdheXNEZWxpbWl0ZXJTZXF1ZW5jZSA9IFt7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IHNyY19TdHlsZS5TQ1JJUFRTQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogc3JjX1N0eWxlLlNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBzcmNfU3R5bGUuVEVYVFxufSwge1xuICB0eXBlOiBcInN0YWNrXCJcbn1dOyAvLyBEZWxpbWl0ZXJzIHRoYXQgc3RhY2sgd2hlbiBsYXJnZSB0cnkgdGhlIHNtYWxsIGFuZCB0aGVuIGxhcmdlIGRlbGltaXRlcnMsIGFuZFxuLy8gc3RhY2sgYWZ0ZXJ3YXJkc1xuXG52YXIgc3RhY2tMYXJnZURlbGltaXRlclNlcXVlbmNlID0gW3tcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogc3JjX1N0eWxlLlNDUklQVFNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBzcmNfU3R5bGUuU0NSSVBUXG59LCB7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IHNyY19TdHlsZS5URVhUXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogMVxufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDJcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiAzXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogNFxufSwge1xuICB0eXBlOiBcInN0YWNrXCJcbn1dO1xuLyoqXG4gKiBHZXQgdGhlIGZvbnQgdXNlZCBpbiBhIGRlbGltaXRlciBiYXNlZCBvbiB3aGF0IGtpbmQgb2YgZGVsaW1pdGVyIGl0IGlzLlxuICogVE9ETygjOTYzKSBVc2UgbW9yZSBzcGVjaWZpYyBmb250IGZhbWlseSByZXR1cm4gdHlwZSBvbmNlIHRoYXQgaXMgaW50cm9kdWNlZC5cbiAqL1xuXG52YXIgZGVsaW1UeXBlVG9Gb250ID0gZnVuY3Rpb24gZGVsaW1UeXBlVG9Gb250KHR5cGUpIHtcbiAgaWYgKHR5cGUudHlwZSA9PT0gXCJzbWFsbFwiKSB7XG4gICAgcmV0dXJuIFwiTWFpbi1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAodHlwZS50eXBlID09PSBcImxhcmdlXCIpIHtcbiAgICByZXR1cm4gXCJTaXplXCIgKyB0eXBlLnNpemUgKyBcIi1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAodHlwZS50eXBlID09PSBcInN0YWNrXCIpIHtcbiAgICByZXR1cm4gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQWRkIHN1cHBvcnQgZm9yIGRlbGltIHR5cGUgJ1wiICsgdHlwZS50eXBlICsgXCInIGhlcmUuXCIpO1xuICB9XG59O1xuLyoqXG4gKiBUcmF2ZXJzZSBhIHNlcXVlbmNlIG9mIHR5cGVzIG9mIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoYXQga2luZCBvZiBkZWxpbWl0ZXJcbiAqIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIGRlbGltaXRlciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0K2RlcHRoLlxuICovXG5cblxudmFyIHRyYXZlcnNlU2VxdWVuY2UgPSBmdW5jdGlvbiB0cmF2ZXJzZVNlcXVlbmNlKGRlbGltLCBoZWlnaHQsIHNlcXVlbmNlLCBvcHRpb25zKSB7XG4gIC8vIEhlcmUsIHdlIGNob29zZSB0aGUgaW5kZXggd2Ugc2hvdWxkIHN0YXJ0IGF0IGluIHRoZSBzZXF1ZW5jZXMuIEluIHNtYWxsZXJcbiAgLy8gc2l6ZXMgKHdoaWNoIGNvcnJlc3BvbmQgdG8gbGFyZ2VyIG51bWJlcnMgaW4gc3R5bGUuc2l6ZSkgd2Ugc3RhcnQgZWFybGllclxuICAvLyBpbiB0aGUgc2VxdWVuY2UuIFRodXMsIHNjcmlwdHNjcmlwdCBzdGFydHMgYXQgaW5kZXggMy0zPTAsIHNjcmlwdCBzdGFydHNcbiAgLy8gYXQgaW5kZXggMy0yPTEsIHRleHQgc3RhcnRzIGF0IDMtMT0yLCBhbmQgZGlzcGxheSBzdGFydHMgYXQgbWluKDIsMy0wKT0yXG4gIHZhciBzdGFydCA9IE1hdGgubWluKDIsIDMgLSBvcHRpb25zLnN0eWxlLnNpemUpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHNlcXVlbmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNlcXVlbmNlW2ldLnR5cGUgPT09IFwic3RhY2tcIikge1xuICAgICAgLy8gVGhpcyBpcyBhbHdheXMgdGhlIGxhc3QgZGVsaW1pdGVyLCBzbyB3ZSBqdXN0IGJyZWFrIHRoZSBsb29wIG5vdy5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBtZXRyaWNzID0gZGVsaW1pdGVyX2dldE1ldHJpY3MoZGVsaW0sIGRlbGltVHlwZVRvRm9udChzZXF1ZW5jZVtpXSksIFwibWF0aFwiKTtcbiAgICB2YXIgaGVpZ2h0RGVwdGggPSBtZXRyaWNzLmhlaWdodCArIG1ldHJpY3MuZGVwdGg7IC8vIFNtYWxsIGRlbGltaXRlcnMgYXJlIHNjYWxlZCBkb3duIHZlcnNpb25zIG9mIHRoZSBzYW1lIGZvbnQsIHNvIHdlXG4gICAgLy8gYWNjb3VudCBmb3IgdGhlIHN0eWxlIGNoYW5nZSBzaXplLlxuXG4gICAgaWYgKHNlcXVlbmNlW2ldLnR5cGUgPT09IFwic21hbGxcIikge1xuICAgICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShzZXF1ZW5jZVtpXS5zdHlsZSk7XG4gICAgICBoZWlnaHREZXB0aCAqPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgIH0gLy8gQ2hlY2sgaWYgdGhlIGRlbGltaXRlciBhdCB0aGlzIHNpemUgd29ya3MgZm9yIHRoZSBnaXZlbiBoZWlnaHQuXG5cblxuICAgIGlmIChoZWlnaHREZXB0aCA+IGhlaWdodCkge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlW2ldO1xuICAgIH1cbiAgfSAvLyBJZiB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCByZXR1cm4gdGhlIGxhc3Qgc2VxdWVuY2UgZWxlbWVudC5cblxuXG4gIHJldHVybiBzZXF1ZW5jZVtzZXF1ZW5jZS5sZW5ndGggLSAxXTtcbn07XG4vKipcbiAqIE1ha2UgYSBkZWxpbWl0ZXIgb2YgYSBnaXZlbiBoZWlnaHQrZGVwdGgsIHdpdGggb3B0aW9uYWwgY2VudGVyaW5nLiBIZXJlLCB3ZVxuICogdHJhdmVyc2UgdGhlIHNlcXVlbmNlcywgYW5kIGNyZWF0ZSBhIGRlbGltaXRlciB0aGF0IHRoZSBzZXF1ZW5jZSB0ZWxscyB1cyB0by5cbiAqL1xuXG5cbnZhciBkZWxpbWl0ZXJfbWFrZUN1c3RvbVNpemVkRGVsaW0gPSBmdW5jdGlvbiBtYWtlQ3VzdG9tU2l6ZWREZWxpbShkZWxpbSwgaGVpZ2h0LCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHtcbiAgaWYgKGRlbGltID09PSBcIjxcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbHRcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN0U4XCIpIHtcbiAgICBkZWxpbSA9IFwiXFxcXGxhbmdsZVwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIj5cIiB8fCBkZWxpbSA9PT0gXCJcXFxcZ3RcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN0U5XCIpIHtcbiAgICBkZWxpbSA9IFwiXFxcXHJhbmdsZVwiO1xuICB9IC8vIERlY2lkZSB3aGF0IHNlcXVlbmNlIHRvIHVzZVxuXG5cbiAgdmFyIHNlcXVlbmNlO1xuXG4gIGlmICh1dGlscy5jb250YWlucyhzdGFja05ldmVyRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgc2VxdWVuY2UgPSBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2U7XG4gIH0gZWxzZSBpZiAodXRpbHMuY29udGFpbnMoc3RhY2tMYXJnZURlbGltaXRlcnMsIGRlbGltKSkge1xuICAgIHNlcXVlbmNlID0gc3RhY2tMYXJnZURlbGltaXRlclNlcXVlbmNlO1xuICB9IGVsc2Uge1xuICAgIHNlcXVlbmNlID0gc3RhY2tBbHdheXNEZWxpbWl0ZXJTZXF1ZW5jZTtcbiAgfSAvLyBMb29rIHRocm91Z2ggdGhlIHNlcXVlbmNlXG5cblxuICB2YXIgZGVsaW1UeXBlID0gdHJhdmVyc2VTZXF1ZW5jZShkZWxpbSwgaGVpZ2h0LCBzZXF1ZW5jZSwgb3B0aW9ucyk7IC8vIEdldCB0aGUgZGVsaW1pdGVyIGZyb20gZm9udCBnbHlwaHMuXG4gIC8vIERlcGVuZGluZyBvbiB0aGUgc2VxdWVuY2UgZWxlbWVudCB3ZSBkZWNpZGVkIG9uLCBjYWxsIHRoZVxuICAvLyBhcHByb3ByaWF0ZSBmdW5jdGlvbi5cblxuICBpZiAoZGVsaW1UeXBlLnR5cGUgPT09IFwic21hbGxcIikge1xuICAgIHJldHVybiBkZWxpbWl0ZXJfbWFrZVNtYWxsRGVsaW0oZGVsaW0sIGRlbGltVHlwZS5zdHlsZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgfSBlbHNlIGlmIChkZWxpbVR5cGUudHlwZSA9PT0gXCJsYXJnZVwiKSB7XG4gICAgcmV0dXJuIGRlbGltaXRlcl9tYWtlTGFyZ2VEZWxpbShkZWxpbSwgZGVsaW1UeXBlLnNpemUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gIH0gZWxzZVxuICAgIC8qIGlmIChkZWxpbVR5cGUudHlwZSA9PT0gXCJzdGFja1wiKSAqL1xuICAgIHtcbiAgICAgIHJldHVybiBkZWxpbWl0ZXJfbWFrZVN0YWNrZWREZWxpbShkZWxpbSwgaGVpZ2h0LCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpO1xuICAgIH1cbn07XG4vKipcbiAqIE1ha2UgYSBkZWxpbWl0ZXIgZm9yIHVzZSB3aXRoIGBcXGxlZnRgIGFuZCBgXFxyaWdodGAsIGdpdmVuIGEgaGVpZ2h0IGFuZCBkZXB0aFxuICogb2YgYW4gZXhwcmVzc2lvbiB0aGF0IHRoZSBkZWxpbWl0ZXJzIHN1cnJvdW5kLlxuICovXG5cblxudmFyIG1ha2VMZWZ0UmlnaHREZWxpbSA9IGZ1bmN0aW9uIG1ha2VMZWZ0UmlnaHREZWxpbShkZWxpbSwgaGVpZ2h0LCBkZXB0aCwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICAvLyBXZSBhbHdheXMgY2VudGVyIFxcbGVmdC9cXHJpZ2h0IGRlbGltaXRlcnMsIHNvIHRoZSBheGlzIGlzIGFsd2F5cyBzaGlmdGVkXG4gIHZhciBheGlzSGVpZ2h0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQgKiBvcHRpb25zLnNpemVNdWx0aXBsaWVyOyAvLyBUYWtlbiBmcm9tIFRlWCBzb3VyY2UsIHRleC53ZWIsIGZ1bmN0aW9uIG1ha2VfbGVmdF9yaWdodFxuXG4gIHZhciBkZWxpbWl0ZXJGYWN0b3IgPSA5MDE7XG4gIHZhciBkZWxpbWl0ZXJFeHRlbmQgPSA1LjAgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTtcbiAgdmFyIG1heERpc3RGcm9tQXhpcyA9IE1hdGgubWF4KGhlaWdodCAtIGF4aXNIZWlnaHQsIGRlcHRoICsgYXhpc0hlaWdodCk7XG4gIHZhciB0b3RhbEhlaWdodCA9IE1hdGgubWF4KCAvLyBJbiByZWFsIFRlWCwgY2FsY3VsYXRpb25zIGFyZSBkb25lIHVzaW5nIGludGVncmFsIHZhbHVlcyB3aGljaCBhcmVcbiAgLy8gNjU1MzYgcGVyIHB0LCBvciA2NTUzNjAgcGVyIGVtLiBTbywgdGhlIGRpdmlzaW9uIGhlcmUgdHJ1bmNhdGVzIGluXG4gIC8vIFRlWCBidXQgZG9lc24ndCBoZXJlLCBwcm9kdWNpbmcgZGlmZmVyZW50IHJlc3VsdHMuIElmIHdlIHdhbnRlZCB0b1xuICAvLyBleGFjdGx5IG1hdGNoIFRlWCdzIGNhbGN1bGF0aW9uLCB3ZSBjb3VsZCBkb1xuICAvLyAgIE1hdGguZmxvb3IoNjU1MzYwICogbWF4RGlzdEZyb21BeGlzIC8gNTAwKSAqXG4gIC8vICAgIGRlbGltaXRlckZhY3RvciAvIDY1NTM2MFxuICAvLyAoVG8gc2VlIHRoZSBkaWZmZXJlbmNlLCBjb21wYXJlXG4gIC8vICAgIHhee3hee1xcbGVmdChcXHJ1bGV7MC4xZW19ezAuNjhlbX1cXHJpZ2h0KX19XG4gIC8vIGluIFRlWCBhbmQgS2FUZVgpXG4gIG1heERpc3RGcm9tQXhpcyAvIDUwMCAqIGRlbGltaXRlckZhY3RvciwgMiAqIG1heERpc3RGcm9tQXhpcyAtIGRlbGltaXRlckV4dGVuZCk7IC8vIEZpbmFsbHksIHdlIGRlZmVyIHRvIGBtYWtlQ3VzdG9tU2l6ZWREZWxpbWAgd2l0aCBvdXIgY2FsY3VsYXRlZCB0b3RhbFxuICAvLyBoZWlnaHRcblxuICByZXR1cm4gZGVsaW1pdGVyX21ha2VDdXN0b21TaXplZERlbGltKGRlbGltLCB0b3RhbEhlaWdodCwgdHJ1ZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZWxpbWl0ZXIgPSAoe1xuICBzcXJ0SW1hZ2U6IG1ha2VTcXJ0SW1hZ2UsXG4gIHNpemVkRGVsaW06IGRlbGltaXRlcl9tYWtlU2l6ZWREZWxpbSxcbiAgY3VzdG9tU2l6ZWREZWxpbTogZGVsaW1pdGVyX21ha2VDdXN0b21TaXplZERlbGltLFxuICBsZWZ0UmlnaHREZWxpbTogbWFrZUxlZnRSaWdodERlbGltXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9kZWxpbXNpemluZy5qc1xuXG5cblxuXG5cblxuXG5cblxuLy8gRXh0cmEgZGF0YSBuZWVkZWQgZm9yIHRoZSBkZWxpbWl0ZXIgaGFuZGxlciBkb3duIGJlbG93XG52YXIgZGVsaW1pdGVyU2l6ZXMgPSB7XG4gIFwiXFxcXGJpZ2xcIjoge1xuICAgIG1jbGFzczogXCJtb3BlblwiLFxuICAgIHNpemU6IDFcbiAgfSxcbiAgXCJcXFxcQmlnbFwiOiB7XG4gICAgbWNsYXNzOiBcIm1vcGVuXCIsXG4gICAgc2l6ZTogMlxuICB9LFxuICBcIlxcXFxiaWdnbFwiOiB7XG4gICAgbWNsYXNzOiBcIm1vcGVuXCIsXG4gICAgc2l6ZTogM1xuICB9LFxuICBcIlxcXFxCaWdnbFwiOiB7XG4gICAgbWNsYXNzOiBcIm1vcGVuXCIsXG4gICAgc2l6ZTogNFxuICB9LFxuICBcIlxcXFxiaWdyXCI6IHtcbiAgICBtY2xhc3M6IFwibWNsb3NlXCIsXG4gICAgc2l6ZTogMVxuICB9LFxuICBcIlxcXFxCaWdyXCI6IHtcbiAgICBtY2xhc3M6IFwibWNsb3NlXCIsXG4gICAgc2l6ZTogMlxuICB9LFxuICBcIlxcXFxiaWdnclwiOiB7XG4gICAgbWNsYXNzOiBcIm1jbG9zZVwiLFxuICAgIHNpemU6IDNcbiAgfSxcbiAgXCJcXFxcQmlnZ3JcIjoge1xuICAgIG1jbGFzczogXCJtY2xvc2VcIixcbiAgICBzaXplOiA0XG4gIH0sXG4gIFwiXFxcXGJpZ21cIjoge1xuICAgIG1jbGFzczogXCJtcmVsXCIsXG4gICAgc2l6ZTogMVxuICB9LFxuICBcIlxcXFxCaWdtXCI6IHtcbiAgICBtY2xhc3M6IFwibXJlbFwiLFxuICAgIHNpemU6IDJcbiAgfSxcbiAgXCJcXFxcYmlnZ21cIjoge1xuICAgIG1jbGFzczogXCJtcmVsXCIsXG4gICAgc2l6ZTogM1xuICB9LFxuICBcIlxcXFxCaWdnbVwiOiB7XG4gICAgbWNsYXNzOiBcIm1yZWxcIixcbiAgICBzaXplOiA0XG4gIH0sXG4gIFwiXFxcXGJpZ1wiOiB7XG4gICAgbWNsYXNzOiBcIm1vcmRcIixcbiAgICBzaXplOiAxXG4gIH0sXG4gIFwiXFxcXEJpZ1wiOiB7XG4gICAgbWNsYXNzOiBcIm1vcmRcIixcbiAgICBzaXplOiAyXG4gIH0sXG4gIFwiXFxcXGJpZ2dcIjoge1xuICAgIG1jbGFzczogXCJtb3JkXCIsXG4gICAgc2l6ZTogM1xuICB9LFxuICBcIlxcXFxCaWdnXCI6IHtcbiAgICBtY2xhc3M6IFwibW9yZFwiLFxuICAgIHNpemU6IDRcbiAgfVxufTtcbnZhciBkZWxpbWl0ZXJzID0gW1wiKFwiLCBcIlxcXFxscGFyZW5cIiwgXCIpXCIsIFwiXFxcXHJwYXJlblwiLCBcIltcIiwgXCJcXFxcbGJyYWNrXCIsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIiwgXCJcXFxce1wiLCBcIlxcXFxsYnJhY2VcIiwgXCJcXFxcfVwiLCBcIlxcXFxyYnJhY2VcIiwgXCJcXFxcbGZsb29yXCIsIFwiXFxcXHJmbG9vclwiLCBcIlxcdTIzMEFcIiwgXCJcXHUyMzBCXCIsIFwiXFxcXGxjZWlsXCIsIFwiXFxcXHJjZWlsXCIsIFwiXFx1MjMwOFwiLCBcIlxcdTIzMDlcIiwgXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXHUyN0U4XCIsIFwiXFxcXHJhbmdsZVwiLCBcIlxcdTI3RTlcIiwgXCJcXFxcbHRcIiwgXCJcXFxcZ3RcIiwgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIiwgXCJcXFxcbGdyb3VwXCIsIFwiXFxcXHJncm91cFwiLCBcIlxcdTI3RUVcIiwgXCJcXHUyN0VGXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgXCJcXFxccm1vdXN0YWNoZVwiLCBcIlxcdTIzQjBcIiwgXCJcXHUyM0IxXCIsIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIiwgXCJ8XCIsIFwiXFxcXHZlcnRcIiwgXCJcXFxcfFwiLCBcIlxcXFxWZXJ0XCIsIFwiXFxcXHVwYXJyb3dcIiwgXCJcXFxcVXBhcnJvd1wiLCBcIlxcXFxkb3duYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsIFwiXFxcXHVwZG93bmFycm93XCIsIFwiXFxcXFVwZG93bmFycm93XCIsIFwiLlwiXTtcblxuLy8gRGVsaW1pdGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gY2hlY2tEZWxpbWl0ZXIoZGVsaW0sIGNvbnRleHQpIHtcbiAgdmFyIHN5bURlbGltID0gY2hlY2tTeW1ib2xOb2RlVHlwZShkZWxpbSk7XG5cbiAgaWYgKHN5bURlbGltICYmIHV0aWxzLmNvbnRhaW5zKGRlbGltaXRlcnMsIHN5bURlbGltLnRleHQpKSB7XG4gICAgcmV0dXJuIHN5bURlbGltO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgZGVsaW1pdGVyOiAnXCIgKyAoc3ltRGVsaW0gPyBzeW1EZWxpbS50ZXh0IDogSlNPTi5zdHJpbmdpZnkoZGVsaW0pKSArIFwiJyBhZnRlciAnXCIgKyBjb250ZXh0LmZ1bmNOYW1lICsgXCInXCIsIGRlbGltKTtcbiAgfVxufVxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZGVsaW1zaXppbmdcIixcbiAgbmFtZXM6IFtcIlxcXFxiaWdsXCIsIFwiXFxcXEJpZ2xcIiwgXCJcXFxcYmlnZ2xcIiwgXCJcXFxcQmlnZ2xcIiwgXCJcXFxcYmlnclwiLCBcIlxcXFxCaWdyXCIsIFwiXFxcXGJpZ2dyXCIsIFwiXFxcXEJpZ2dyXCIsIFwiXFxcXGJpZ21cIiwgXCJcXFxcQmlnbVwiLCBcIlxcXFxiaWdnbVwiLCBcIlxcXFxCaWdnbVwiLCBcIlxcXFxiaWdcIiwgXCJcXFxcQmlnXCIsIFwiXFxcXGJpZ2dcIiwgXCJcXFxcQmlnZ1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIHZhciBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRlbGltc2l6aW5nXCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgc2l6ZTogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0uc2l6ZSxcbiAgICAgIG1jbGFzczogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0ubWNsYXNzLFxuICAgICAgZGVsaW06IGRlbGltLnRleHRcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoZ3JvdXAuZGVsaW0gPT09IFwiLlwiKSB7XG4gICAgICAvLyBFbXB0eSBkZWxpbWl0ZXJzIHN0aWxsIGNvdW50IGFzIGVsZW1lbnRzLCBldmVuIHRob3VnaCB0aGV5IGRvbid0XG4gICAgICAvLyBzaG93IGFueXRoaW5nLlxuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtncm91cC5tY2xhc3NdKTtcbiAgICB9IC8vIFVzZSBkZWxpbWl0ZXIuc2l6ZWREZWxpbSB0byBnZW5lcmF0ZSB0aGUgZGVsaW1pdGVyLlxuXG5cbiAgICByZXR1cm4gZGVsaW1pdGVyLnNpemVkRGVsaW0oZ3JvdXAuZGVsaW0sIGdyb3VwLnNpemUsIG9wdGlvbnMsIGdyb3VwLm1vZGUsIFtncm91cC5tY2xhc3NdKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCkge1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLmRlbGltICE9PSBcIi5cIikge1xuICAgICAgY2hpbGRyZW4ucHVzaChidWlsZE1hdGhNTF9tYWtlVGV4dChncm91cC5kZWxpbSwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBjaGlsZHJlbik7XG5cbiAgICBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1vcGVuXCIgfHwgZ3JvdXAubWNsYXNzID09PSBcIm1jbG9zZVwiKSB7XG4gICAgICAvLyBPbmx5IHNvbWUgb2YgdGhlIGRlbGltc2l6aW5nIGZ1bmN0aW9ucyBhY3QgYXMgZmVuY2VzLCBhbmQgdGhleVxuICAgICAgLy8gcmV0dXJuIFwibW9wZW5cIiBvciBcIm1jbG9zZVwiIG1jbGFzcy5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFeHBsaWNpdGx5IGRpc2FibGUgZmVuY2luZyBpZiBpdCdzIG5vdCBhIGZlbmNlLCB0byBvdmVycmlkZSB0aGVcbiAgICAgIC8vIGRlZmF1bHRzLlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcImZhbHNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuZnVuY3Rpb24gYXNzZXJ0UGFyc2VkKGdyb3VwKSB7XG4gIGlmICghZ3JvdXAuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZzogVGhlIGxlZnRyaWdodCBQYXJzZU5vZGUgd2Fzbid0IGZ1bGx5IHBhcnNlZC5cIik7XG4gIH1cbn1cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImxlZnRyaWdodC1yaWdodFwiLFxuICBuYW1lczogW1wiXFxcXHJpZ2h0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihjb250ZXh0LCBhcmdzKSB7XG4gICAgLy8gXFxsZWZ0IGNhc2UgYmVsb3cgdHJpZ2dlcnMgcGFyc2luZyBvZiBcXHJpZ2h0IGluXG4gICAgLy8gICBgY29uc3QgcmlnaHQgPSBwYXJzZXIucGFyc2VGdW5jdGlvbigpO2BcbiAgICAvLyB1c2VzIHRoaXMgcmV0dXJuIHZhbHVlLlxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodC1yaWdodFwiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIGRlbGltOiBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KS50ZXh0XG4gICAgfTtcbiAgfVxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gIG5hbWVzOiBbXCJcXFxcbGVmdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIHZhciBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuICAgIHZhciBwYXJzZXIgPSBjb250ZXh0LnBhcnNlcjsgLy8gUGFyc2Ugb3V0IHRoZSBpbXBsaWNpdCBib2R5XG5cbiAgICArK3BhcnNlci5sZWZ0cmlnaHREZXB0aDsgLy8gcGFyc2VFeHByZXNzaW9uIHN0b3BzIGJlZm9yZSAnXFxcXHJpZ2h0J1xuXG4gICAgdmFyIGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICAtLXBhcnNlci5sZWZ0cmlnaHREZXB0aDsgLy8gQ2hlY2sgdGhlIG5leHQgdG9rZW5cblxuICAgIHBhcnNlci5leHBlY3QoXCJcXFxccmlnaHRcIiwgZmFsc2UpO1xuICAgIHZhciByaWdodCA9IGFzc2VydE5vZGVUeXBlKHBhcnNlci5wYXJzZUZ1bmN0aW9uKCksIFwibGVmdHJpZ2h0LXJpZ2h0XCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBib2R5LFxuICAgICAgbGVmdDogZGVsaW0udGV4dCxcbiAgICAgIHJpZ2h0OiByaWdodC5kZWxpbVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGFzc2VydFBhcnNlZChncm91cCk7IC8vIEJ1aWxkIHRoZSBpbm5lciBleHByZXNzaW9uXG5cbiAgICB2YXIgaW5uZXIgPSBidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUsIFtcIm1vcGVuXCIsIFwibWNsb3NlXCJdKTtcbiAgICB2YXIgaW5uZXJIZWlnaHQgPSAwO1xuICAgIHZhciBpbm5lckRlcHRoID0gMDtcbiAgICB2YXIgaGFkTWlkZGxlID0gZmFsc2U7IC8vIENhbGN1bGF0ZSBpdHMgaGVpZ2h0IGFuZCBkZXB0aFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbm5lci5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gUHJvcGVydHkgYGlzTWlkZGxlYCBub3QgZGVmaW5lZCBvbiBgc3BhbmAuIFNlZSBjb21tZW50IGluXG4gICAgICAvLyBcIm1pZGRsZVwiJ3MgaHRtbEJ1aWxkZXIuXG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBpZiAoaW5uZXJbaV0uaXNNaWRkbGUpIHtcbiAgICAgICAgaGFkTWlkZGxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVySGVpZ2h0ID0gTWF0aC5tYXgoaW5uZXJbaV0uaGVpZ2h0LCBpbm5lckhlaWdodCk7XG4gICAgICAgIGlubmVyRGVwdGggPSBNYXRoLm1heChpbm5lcltpXS5kZXB0aCwgaW5uZXJEZXB0aCk7XG4gICAgICB9XG4gICAgfSAvLyBUaGUgc2l6ZSBvZiBkZWxpbWl0ZXJzIGlzIHRoZSBzYW1lLCByZWdhcmRsZXNzIG9mIHdoYXQgc3R5bGUgd2UgYXJlXG4gICAgLy8gaW4uIFRodXMsIHRvIGNvcnJlY3RseSBjYWxjdWxhdGUgdGhlIHNpemUgb2YgZGVsaW1pdGVyIHdlIG5lZWQgYXJvdW5kXG4gICAgLy8gYSBncm91cCwgd2Ugc2NhbGUgZG93biB0aGUgaW5uZXIgc2l6ZSBiYXNlZCBvbiB0aGUgc2l6ZS5cblxuXG4gICAgaW5uZXJIZWlnaHQgKj0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICBpbm5lckRlcHRoICo9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIGxlZnREZWxpbTtcblxuICAgIGlmIChncm91cC5sZWZ0ID09PSBcIi5cIikge1xuICAgICAgLy8gRW1wdHkgZGVsaW1pdGVycyBpbiBcXGxlZnQgYW5kIFxccmlnaHQgbWFrZSBudWxsIGRlbGltaXRlciBzcGFjZXMuXG4gICAgICBsZWZ0RGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbXCJtb3BlblwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgdXNlIGxlZnRSaWdodERlbGltIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IHNpemVkXG4gICAgICAvLyBkZWxpbWl0ZXIuXG4gICAgICBsZWZ0RGVsaW0gPSBkZWxpbWl0ZXIubGVmdFJpZ2h0RGVsaW0oZ3JvdXAubGVmdCwgaW5uZXJIZWlnaHQsIGlubmVyRGVwdGgsIG9wdGlvbnMsIGdyb3VwLm1vZGUsIFtcIm1vcGVuXCJdKTtcbiAgICB9IC8vIEFkZCBpdCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBleHByZXNzaW9uXG5cblxuICAgIGlubmVyLnVuc2hpZnQobGVmdERlbGltKTsgLy8gSGFuZGxlIG1pZGRsZSBkZWxpbWl0ZXJzXG5cbiAgICBpZiAoaGFkTWlkZGxlKSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgaW5uZXIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBtaWRkbGVEZWxpbSA9IGlubmVyW19pXTsgLy8gUHJvcGVydHkgYGlzTWlkZGxlYCBub3QgZGVmaW5lZCBvbiBgc3BhbmAuIFNlZSBjb21tZW50IGluXG4gICAgICAgIC8vIFwibWlkZGxlXCIncyBodG1sQnVpbGRlci5cbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgIHZhciBpc01pZGRsZSA9IG1pZGRsZURlbGltLmlzTWlkZGxlO1xuXG4gICAgICAgIGlmIChpc01pZGRsZSkge1xuICAgICAgICAgIC8vIEFwcGx5IHRoZSBvcHRpb25zIHRoYXQgd2VyZSBhY3RpdmUgd2hlbiBcXG1pZGRsZSB3YXMgY2FsbGVkXG4gICAgICAgICAgaW5uZXJbX2ldID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKGlzTWlkZGxlLmRlbGltLCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCwgaXNNaWRkbGUub3B0aW9ucywgZ3JvdXAubW9kZSwgW10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJpZ2h0RGVsaW07IC8vIFNhbWUgZm9yIHRoZSByaWdodCBkZWxpbWl0ZXJcblxuICAgIGlmIChncm91cC5yaWdodCA9PT0gXCIuXCIpIHtcbiAgICAgIHJpZ2h0RGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbXCJtY2xvc2VcIl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodERlbGltID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKGdyb3VwLnJpZ2h0LCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCwgb3B0aW9ucywgZ3JvdXAubW9kZSwgW1wibWNsb3NlXCJdKTtcbiAgICB9IC8vIEFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uLlxuXG5cbiAgICBpbm5lci5wdXNoKHJpZ2h0RGVsaW0pO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtaW5uZXJcIl0sIGlubmVyLCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGFzc2VydFBhcnNlZChncm91cCk7XG4gICAgdmFyIGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdyb3VwLmxlZnQgIT09IFwiLlwiKSB7XG4gICAgICB2YXIgbGVmdE5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtidWlsZE1hdGhNTF9tYWtlVGV4dChncm91cC5sZWZ0LCBncm91cC5tb2RlKV0pO1xuICAgICAgbGVmdE5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgICAgaW5uZXIudW5zaGlmdChsZWZ0Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnJpZ2h0ICE9PSBcIi5cIikge1xuICAgICAgdmFyIHJpZ2h0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW2J1aWxkTWF0aE1MX21ha2VUZXh0KGdyb3VwLnJpZ2h0LCBncm91cC5tb2RlKV0pO1xuICAgICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICAgIGlubmVyLnB1c2gocmlnaHROb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVpbGRNYXRoTUxfbWFrZVJvdyhpbm5lcik7XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1pZGRsZVwiLFxuICBuYW1lczogW1wiXFxcXG1pZGRsZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIHZhciBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuXG4gICAgaWYgKCFjb250ZXh0LnBhcnNlci5sZWZ0cmlnaHREZXB0aCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXG1pZGRsZSB3aXRob3V0IHByZWNlZGluZyBcXFxcbGVmdFwiLCBkZWxpbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWlkZGxlXCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgZGVsaW06IGRlbGltLnRleHRcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbWlkZGxlRGVsaW07XG5cbiAgICBpZiAoZ3JvdXAuZGVsaW0gPT09IFwiLlwiKSB7XG4gICAgICBtaWRkbGVEZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWlkZGxlRGVsaW0gPSBkZWxpbWl0ZXIuc2l6ZWREZWxpbShncm91cC5kZWxpbSwgMSwgb3B0aW9ucywgZ3JvdXAubW9kZSwgW10pO1xuICAgICAgdmFyIGlzTWlkZGxlID0ge1xuICAgICAgICBkZWxpbTogZ3JvdXAuZGVsaW0sXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgIH07IC8vIFByb3BlcnR5IGBpc01pZGRsZWAgbm90IGRlZmluZWQgb24gYHNwYW5gLiBJdCBpcyBvbmx5IHVzZWQgaW5cbiAgICAgIC8vIHRoaXMgZmlsZSBhYm92ZS5cbiAgICAgIC8vIFRPRE86IEZpeCB0aGlzIHZpb2xhdGlvbiBvZiB0aGUgYHNwYW5gIHR5cGUgYW5kIHBvc3NpYmx5IHJlbmFtZVxuICAgICAgLy8gdGhpbmdzIHNpbmNlIGBpc01pZGRsZWAgc291bmRzIGxpa2UgYSBib29sZWFuLCBidXQgaXMgYSBzdHJ1Y3QuXG4gICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgIG1pZGRsZURlbGltLmlzTWlkZGxlID0gaXNNaWRkbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pZGRsZURlbGltO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gQSBGaXJlZm94IFxcbWlkZGxlIHdpbGwgc3RyZWNoIGEgY2hhcmFjdGVyIHZlcnRpY2FsbHkgb25seSBpZiBpdFxuICAgIC8vIGlzIGluIHRoZSBmZW5jZSBwYXJ0IG9mIHRoZSBvcGVyYXRvciBkaWN0aW9uYXJ5IGF0OlxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9NYXRoTUwzL2FwcGVuZGl4Yy5odG1sLlxuICAgIC8vIFNvIHdlIG5lZWQgdG8gYXZvaWQgVSsyMjIzIGFuZCB1c2UgcGxhaW4gXCJ8XCIgaW5zdGVhZC5cbiAgICB2YXIgdGV4dE5vZGUgPSBncm91cC5kZWxpbSA9PT0gXCJcXFxcdmVydFwiIHx8IGdyb3VwLmRlbGltID09PSBcInxcIiA/IGJ1aWxkTWF0aE1MX21ha2VUZXh0KFwifFwiLCBcInRleHRcIikgOiBidWlsZE1hdGhNTF9tYWtlVGV4dChncm91cC5kZWxpbSwgZ3JvdXAubW9kZSk7XG4gICAgdmFyIG1pZGRsZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFt0ZXh0Tm9kZV0pO1xuICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpOyAvLyBNYXRoTUwgZ2l2ZXMgNS8xOGVtIHNwYWNpbmcgdG8gZWFjaCA8bW8+IGVsZW1lbnQuXG4gICAgLy8gXFxtaWRkbGUgc2hvdWxkIGdldCBkZWxpbWl0ZXIgc3BhY2luZyBpbnN0ZWFkLlxuXG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwLjA1ZW1cIik7XG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgXCIwLjA1ZW1cIik7XG4gICAgcmV0dXJuIG1pZGRsZU5vZGU7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2VuY2xvc2UuanNcblxuXG5cblxuXG5cblxuXG5cbnZhciBlbmNsb3NlX2h0bWxCdWlsZGVyID0gZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgLy8gXFxjYW5jZWwsIFxcYmNhbmNlbCwgXFx4Y2FuY2VsLCBcXHNvdXQsIFxcZmJveCwgXFxjb2xvcmJveCwgXFxmY29sb3Jib3hcbiAgLy8gU29tZSBncm91cHMgY2FuIHJldHVybiBkb2N1bWVudCBmcmFnbWVudHMuICBIYW5kbGUgdGhvc2UgYnkgd3JhcHBpbmdcbiAgLy8gdGhlbSBpbiBhIHNwYW4uXG4gIHZhciBpbm5lciA9IGJ1aWxkQ29tbW9uLndyYXBGcmFnbWVudChidWlsZEhUTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gIHZhciBsYWJlbCA9IGdyb3VwLmxhYmVsLnN1YnN0cigxKTtcbiAgdmFyIHNjYWxlID0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgdmFyIGltZztcbiAgdmFyIGltZ1NoaWZ0ID0gMDsgLy8gSW4gdGhlIExhVGVYIGNhbmNlbCBwYWNrYWdlLCBsaW5lIGdlb21ldHJ5IGlzIHNsaWdodGx5IGRpZmZlcmVudFxuICAvLyBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgc3ViamVjdCBpcyB3aWRlciB0aGFuIGl0IGlzIHRhbGwsIG9yIHZpY2UgdmVyc2EuXG4gIC8vIFdlIGRvbid0IGtub3cgdGhlIHdpZHRoIG9mIGEgZ3JvdXAsIHNvIGFzIGEgcHJveHksIHdlIHRlc3QgaWZcbiAgLy8gdGhlIHN1YmplY3QgaXMgYSBzaW5nbGUgY2hhcmFjdGVyLiBUaGlzIGNhcHR1cmVzIG1vc3Qgb2YgdGhlXG4gIC8vIHN1YmplY3RzIHRoYXQgc2hvdWxkIGdldCB0aGUgXCJ0YWxsXCIgdHJlYXRtZW50LlxuXG4gIHZhciBpc1NpbmdsZUNoYXIgPSB1dGlscy5pc0NoYXJhY3RlckJveChncm91cC5ib2R5KTtcblxuICBpZiAobGFiZWwgPT09IFwic291dFwiKSB7XG4gICAgaW1nID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wic3RyZXRjaHlcIiwgXCJzb3V0XCJdKTtcbiAgICBpbWcuaGVpZ2h0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzIC8gc2NhbGU7XG4gICAgaW1nU2hpZnQgPSAtMC41ICogb3B0aW9ucy5mb250TWV0cmljcygpLnhIZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkIGhvcml6b250YWwgcGFkZGluZ1xuICAgIGlmICgvY2FuY2VsLy50ZXN0KGxhYmVsKSkge1xuICAgICAgaWYgKCFpc1NpbmdsZUNoYXIpIHtcbiAgICAgICAgaW5uZXIuY2xhc3Nlcy5wdXNoKFwiY2FuY2VsLXBhZFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5uZXIuY2xhc3Nlcy5wdXNoKFwiYm94cGFkXCIpO1xuICAgIH0gLy8gQWRkIHZlcnRpY2FsIHBhZGRpbmdcblxuXG4gICAgdmFyIHZlcnRQYWQgPSAwOyAvLyByZWY6IExhVGVYIHNvdXJjZTJlOiBcXGZib3hzZXAgPSAzcHQ7ICBcXGZib3hydWxlID0gLjRwdFxuICAgIC8vIHJlZjogY2FuY2VsIHBhY2thZ2U6IFxcYWR2YW5jZVxcdG90YWxoZWlnaHQyXFxwQCAlIFwiKzJcIlxuXG4gICAgaWYgKC9ib3gvLnRlc3QobGFiZWwpKSB7XG4gICAgICB2ZXJ0UGFkID0gbGFiZWwgPT09IFwiY29sb3Jib3hcIiA/IDAuMyA6IDAuMzQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnRQYWQgPSBpc1NpbmdsZUNoYXIgPyAwLjIgOiAwO1xuICAgIH1cblxuICAgIGltZyA9IHN0cmV0Y2h5LmVuY2xvc2VTcGFuKGlubmVyLCBsYWJlbCwgdmVydFBhZCwgb3B0aW9ucyk7XG4gICAgaW1nU2hpZnQgPSBpbm5lci5kZXB0aCArIHZlcnRQYWQ7XG5cbiAgICBpZiAoZ3JvdXAuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBpbWcuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZ3JvdXAuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICBpZiAoZ3JvdXAuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgaW1nLnN0eWxlLmJvcmRlckNvbG9yID0gZ3JvdXAuYm9yZGVyQ29sb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHZsaXN0O1xuXG4gIGlmIChncm91cC5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogWy8vIFB1dCB0aGUgY29sb3IgYmFja2dyb3VuZCBiZWhpbmQgaW5uZXI7XG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbWcsXG4gICAgICAgIHNoaWZ0OiBpbWdTaGlmdFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW5uZXIsXG4gICAgICAgIHNoaWZ0OiAwXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgIGNoaWxkcmVuOiBbLy8gV3JpdGUgdGhlIFxcY2FuY2VsIHN0cm9rZSBvbiB0b3Agb2YgaW5uZXIuXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lcixcbiAgICAgICAgc2hpZnQ6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGltZyxcbiAgICAgICAgc2hpZnQ6IGltZ1NoaWZ0LFxuICAgICAgICB3cmFwcGVyQ2xhc3NlczogL2NhbmNlbC8udGVzdChsYWJlbCkgPyBbXCJzdmctYWxpZ25cIl0gOiBbXVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICgvY2FuY2VsLy50ZXN0KGxhYmVsKSkge1xuICAgIC8vIFRoZSBjYW5jZWwgcGFja2FnZSBkb2N1bWVudGF0aW9uIHNheXMgdGhhdCBjYW5jZWwgbGluZXMgYWRkIHRoZWlyIGhlaWdodFxuICAgIC8vIHRvIHRoZSBleHByZXNzaW9uLCBidXQgdGVzdHMgc2hvdyB0aGF0IGlzbid0IGhvdyBpdCBhY3R1YWxseSB3b3Jrcy5cbiAgICB2bGlzdC5oZWlnaHQgPSBpbm5lci5oZWlnaHQ7XG4gICAgdmxpc3QuZGVwdGggPSBpbm5lci5kZXB0aDtcbiAgfVxuXG4gIGlmICgvY2FuY2VsLy50ZXN0KGxhYmVsKSAmJiAhaXNTaW5nbGVDaGFyKSB7XG4gICAgLy8gY2FuY2VsIGRvZXMgbm90IGNyZWF0ZSBob3JpeiBzcGFjZSBmb3IgaXRzIGxpbmUgZXh0ZW5zaW9uLlxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwiY2FuY2VsLWxhcFwiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgZW5jbG9zZV9tYXRobWxCdWlsZGVyID0gZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKGdyb3VwLmxhYmVsLmluZGV4T2YoXCJjb2xvcmJveFwiKSA+IC0xID8gXCJtcGFkZGVkXCIgOiBcIm1lbmNsb3NlXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG5cbiAgc3dpdGNoIChncm91cC5sYWJlbCkge1xuICAgIGNhc2UgXCJcXFxcY2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwidXBkaWFnb25hbHN0cmlrZVwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFxiY2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiZG93bmRpYWdvbmFsc3RyaWtlXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiXFxcXHNvdXRcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJob3Jpem9udGFsc3RyaWtlXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiXFxcXGZib3hcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJib3hcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJcXFxcZmNvbG9yYm94XCI6XG4gICAgY2FzZSBcIlxcXFxjb2xvcmJveFwiOlxuICAgICAgLy8gPG1lbmNsb3NlPiBkb2Vzbid0IGhhdmUgYSBnb29kIG5vdGF0aW9uIG9wdGlvbi4gU28gdXNlIDxtcGFkZGVkPlxuICAgICAgLy8gaW5zdGVhZC4gU2V0IHNvbWUgYXR0cmlidXRlcyB0aGF0IGNvbWUgaW5jbHVkZWQgd2l0aCA8bWVuY2xvc2U+LlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIis2cHRcIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIis2cHRcIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjNwdFwiKTsgLy8gTGFUZVggc291cmNlMmU6IFxcZmJveHNlcCA9IDNwdFxuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgXCIzcHRcIik7XG5cbiAgICAgIGlmIChncm91cC5sYWJlbCA9PT0gXCJcXFxcZmNvbG9yYm94XCIpIHtcbiAgICAgICAgdmFyIHRoayA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWZhdWx0UnVsZVRoaWNrbmVzcztcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImJvcmRlcjogXCIgKyB0aGsgKyBcImVtIHNvbGlkIFwiICsgU3RyaW5nKGdyb3VwLmJvcmRlckNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFx4Y2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwidXBkaWFnb25hbHN0cmlrZSBkb3duZGlhZ29uYWxzdHJpa2VcIik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGlmIChncm91cC5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhiYWNrZ3JvdW5kXCIsIGdyb3VwLmJhY2tncm91bmRDb2xvcik7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcY29sb3Jib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGdyZWVkaW5lc3M6IDMsXG4gICAgYXJnVHlwZXM6IFtcImNvbG9yXCIsIFwidGV4dFwiXVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZi5mdW5jTmFtZTtcbiAgICB2YXIgY29sb3IgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcImNvbG9yLXRva2VuXCIpLmNvbG9yO1xuICAgIHZhciBib2R5ID0gYXJnc1sxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgICBib2R5OiBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGVuY2xvc2VfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGVuY2xvc2VfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGZjb2xvcmJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAzLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgZ3JlZWRpbmVzczogMyxcbiAgICBhcmdUeXBlczogW1wiY29sb3JcIiwgXCJjb2xvclwiLCBcInRleHRcIl1cbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmMiwgYXJncywgb3B0QXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmMi5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZjIuZnVuY05hbWU7XG4gICAgdmFyIGJvcmRlckNvbG9yID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJjb2xvci10b2tlblwiKS5jb2xvcjtcbiAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJjb2xvci10b2tlblwiKS5jb2xvcjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMl07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlckNvbG9yOiBib3JkZXJDb2xvcixcbiAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZW5jbG9zZV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogZW5jbG9zZV9tYXRobWxCdWlsZGVyXG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcZmJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ0ZXh0XCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmMywgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmMy5wYXJzZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogXCJcXFxcZmJveFwiLFxuICAgICAgYm9keTogYXJnc1swXVxuICAgIH07XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVuY2xvc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxjYW5jZWxcIiwgXCJcXFxcYmNhbmNlbFwiLCBcIlxcXFx4Y2FuY2VsXCIsIFwiXFxcXHNvdXRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWY0LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWY0LnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmNC5mdW5jTmFtZTtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBib2R5OiBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGVuY2xvc2VfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGVuY2xvc2VfbWF0aG1sQnVpbGRlclxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kZWZpbmVFbnZpcm9ubWVudC5qc1xuXG5cbi8qKlxuICogQWxsIHJlZ2lzdGVyZWQgZW52aXJvbm1lbnRzLlxuICogYGVudmlyb25tZW50cy5qc2AgZXhwb3J0cyB0aGlzIHNhbWUgZGljdGlvbmFyeSBhZ2FpbiBhbmQgbWFrZXMgaXQgcHVibGljLlxuICogYFBhcnNlci5qc2AgcmVxdWlyZXMgdGhpcyBkaWN0aW9uYXJ5IHZpYSBgZW52aXJvbm1lbnRzLmpzYC5cbiAqL1xudmFyIF9lbnZpcm9ubWVudHMgPSB7fTtcbmZ1bmN0aW9uIGRlZmluZUVudmlyb25tZW50KF9yZWYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICBuYW1lcyA9IF9yZWYubmFtZXMsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICBoYW5kbGVyID0gX3JlZi5oYW5kbGVyLFxuICAgICAgaHRtbEJ1aWxkZXIgPSBfcmVmLmh0bWxCdWlsZGVyLFxuICAgICAgbWF0aG1sQnVpbGRlciA9IF9yZWYubWF0aG1sQnVpbGRlcjtcbiAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIG9mIGVudmlyb25tZW50cy5cbiAgdmFyIGRhdGEgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBudW1BcmdzOiBwcm9wcy5udW1BcmdzIHx8IDAsXG4gICAgZ3JlZWRpbmVzczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDAsXG4gICAgaGFuZGxlcjogaGFuZGxlclxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBUT0RPOiBUaGUgdmFsdWUgdHlwZSBvZiBfZW52aXJvbm1lbnRzIHNob3VsZCBiZSBhIHR5cGUgdW5pb24gb2YgYWxsXG4gICAgLy8gcG9zc2libGUgYEVudlNwZWM8PmAgcG9zc2liaWxpdGllcyBpbnN0ZWFkIG9mIGBFbnZTcGVjPCo+YCwgd2hpY2ggaXNcbiAgICAvLyBhbiBleGlzdGVudGlhbCB0eXBlLlxuICAgIC8vICRGbG93Rml4TWVcbiAgICBfZW52aXJvbm1lbnRzW25hbWVzW2ldXSA9IGRhdGE7XG4gIH1cblxuICBpZiAoaHRtbEJ1aWxkZXIpIHtcbiAgICBfaHRtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBodG1sQnVpbGRlcjtcbiAgfVxuXG4gIGlmIChtYXRobWxCdWlsZGVyKSB7XG4gICAgX21hdGhtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBtYXRobWxCdWlsZGVyO1xuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9lbnZpcm9ubWVudHMvYXJyYXkuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldEhMaW5lcyhwYXJzZXIpIHtcbiAgLy8gUmV0dXJuIGFuIGFycmF5LiBUaGUgYXJyYXkgbGVuZ3RoID0gbnVtYmVyIG9mIGhsaW5lcy5cbiAgLy8gRWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSB0ZWxscyBpZiB0aGUgbGluZSBpcyBkYXNoZWQuXG4gIHZhciBobGluZUluZm8gPSBbXTtcbiAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgdmFyIG54dCA9IHBhcnNlci5uZXh0VG9rZW4udGV4dDtcblxuICB3aGlsZSAobnh0ID09PSBcIlxcXFxobGluZVwiIHx8IG54dCA9PT0gXCJcXFxcaGRhc2hsaW5lXCIpIHtcbiAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgIGhsaW5lSW5mby5wdXNoKG54dCA9PT0gXCJcXFxcaGRhc2hsaW5lXCIpO1xuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgbnh0ID0gcGFyc2VyLm5leHRUb2tlbi50ZXh0O1xuICB9XG5cbiAgcmV0dXJuIGhsaW5lSW5mbztcbn1cbi8qKlxuICogUGFyc2UgdGhlIGJvZHkgb2YgdGhlIGVudmlyb25tZW50LCB3aXRoIHJvd3MgZGVsaW1pdGVkIGJ5IFxcXFwgYW5kXG4gKiBjb2x1bW5zIGRlbGltaXRlZCBieSAmLCBhbmQgY3JlYXRlIGEgbmVzdGVkIGxpc3QgaW4gcm93LW1ham9yIG9yZGVyXG4gKiB3aXRoIG9uZSBncm91cCBwZXIgY2VsbC4gIElmIGdpdmVuIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHN0eWxlXG4gKiAoXCJ0ZXh0XCIsIFwiZGlzcGxheVwiLCBldGMuKSwgdGhlbiBlYWNoIGNlbGwgaXMgY2FzdCBpbnRvIHRoYXQgc3R5bGUuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUFycmF5KHBhcnNlciwgX3JlZiwgc3R5bGUpIHtcbiAgdmFyIGhza2lwQmVmb3JlQW5kQWZ0ZXIgPSBfcmVmLmhza2lwQmVmb3JlQW5kQWZ0ZXIsXG4gICAgICBhZGRKb3QgPSBfcmVmLmFkZEpvdCxcbiAgICAgIGNvbHMgPSBfcmVmLmNvbHMsXG4gICAgICBhcnJheXN0cmV0Y2ggPSBfcmVmLmFycmF5c3RyZXRjaCxcbiAgICAgIGNvbFNlcGFyYXRpb25UeXBlID0gX3JlZi5jb2xTZXBhcmF0aW9uVHlwZTtcbiAgLy8gUGFyc2UgYm9keSBvZiBhcnJheSB3aXRoIFxcXFwgdGVtcG9yYXJpbHkgbWFwcGVkIHRvIFxcY3JcbiAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG4gIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxcXFxcXCIsIFwiXFxcXGNyXCIpOyAvLyBHZXQgY3VycmVudCBhcnJheXN0cmV0Y2ggaWYgaXQncyBub3Qgc2V0IGJ5IHRoZSBlbnZpcm9ubWVudFxuXG4gIGlmICghYXJyYXlzdHJldGNoKSB7XG4gICAgdmFyIHN0cmV0Y2ggPSBwYXJzZXIuZ3VsbGV0LmV4cGFuZE1hY3JvQXNUZXh0KFwiXFxcXGFycmF5c3RyZXRjaFwiKTtcblxuICAgIGlmIChzdHJldGNoID09IG51bGwpIHtcbiAgICAgIC8vIERlZmF1bHQgXFxhcnJheXN0cmV0Y2ggZnJvbSBsdHRhYi5kdHhcbiAgICAgIGFycmF5c3RyZXRjaCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5c3RyZXRjaCA9IHBhcnNlRmxvYXQoc3RyZXRjaCk7XG5cbiAgICAgIGlmICghYXJyYXlzdHJldGNoIHx8IGFycmF5c3RyZXRjaCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBcXFxcYXJyYXlzdHJldGNoOiBcIiArIHN0cmV0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciByb3cgPSBbXTtcbiAgdmFyIGJvZHkgPSBbcm93XTtcbiAgdmFyIHJvd0dhcHMgPSBbXTtcbiAgdmFyIGhMaW5lc0JlZm9yZVJvdyA9IFtdOyAvLyBUZXN0IGZvciBcXGhsaW5lIGF0IHRoZSB0b3Agb2YgdGhlIGFycmF5LlxuXG4gIGhMaW5lc0JlZm9yZVJvdy5wdXNoKGdldEhMaW5lcyhwYXJzZXIpKTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgdmFyIGNlbGwgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBcIlxcXFxjclwiKTtcbiAgICBjZWxsID0ge1xuICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBjZWxsXG4gICAgfTtcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgY2VsbCA9IHtcbiAgICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIGJvZHk6IFtjZWxsXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByb3cucHVzaChjZWxsKTtcbiAgICB2YXIgbmV4dCA9IHBhcnNlci5uZXh0VG9rZW4udGV4dDtcblxuICAgIGlmIChuZXh0ID09PSBcIiZcIikge1xuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXGVuZFwiKSB7XG4gICAgICAvLyBBcnJheXMgdGVybWluYXRlIG5ld2xpbmVzIHdpdGggYFxcY3JjcmAgd2hpY2ggY29uc3VtZXMgYSBgXFxjcmAgaWZcbiAgICAgIC8vIHRoZSBsYXN0IGxpbmUgaXMgZW1wdHkuXG4gICAgICAvLyBOT1RFOiBDdXJyZW50bHksIGBjZWxsYCBpcyB0aGUgbGFzdCBpdGVtIGFkZGVkIGludG8gYHJvd2AuXG4gICAgICBpZiAocm93Lmxlbmd0aCA9PT0gMSAmJiBjZWxsLnR5cGUgPT09IFwic3R5bGluZ1wiICYmIGNlbGwuYm9keVswXS5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBib2R5LnBvcCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaExpbmVzQmVmb3JlUm93Lmxlbmd0aCA8IGJvZHkubGVuZ3RoICsgMSkge1xuICAgICAgICBoTGluZXNCZWZvcmVSb3cucHVzaChbXSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gXCJcXFxcY3JcIikge1xuICAgICAgdmFyIGNyID0gYXNzZXJ0Tm9kZVR5cGUocGFyc2VyLnBhcnNlRnVuY3Rpb24oKSwgXCJjclwiKTtcbiAgICAgIHJvd0dhcHMucHVzaChjci5zaXplKTsgLy8gY2hlY2sgZm9yIFxcaGxpbmUocykgZm9sbG93aW5nIHRoZSByb3cgc2VwYXJhdG9yXG5cbiAgICAgIGhMaW5lc0JlZm9yZVJvdy5wdXNoKGdldEhMaW5lcyhwYXJzZXIpKTtcbiAgICAgIHJvdyA9IFtdO1xuICAgICAgYm9keS5wdXNoKHJvdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkV4cGVjdGVkICYgb3IgXFxcXFxcXFwgb3IgXFxcXGNyIG9yIFxcXFxlbmRcIiwgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICBhZGRKb3Q6IGFkZEpvdCxcbiAgICBhcnJheXN0cmV0Y2g6IGFycmF5c3RyZXRjaCxcbiAgICBib2R5OiBib2R5LFxuICAgIGNvbHM6IGNvbHMsXG4gICAgcm93R2Fwczogcm93R2FwcyxcbiAgICBoc2tpcEJlZm9yZUFuZEFmdGVyOiBoc2tpcEJlZm9yZUFuZEFmdGVyLFxuICAgIGhMaW5lc0JlZm9yZVJvdzogaExpbmVzQmVmb3JlUm93LFxuICAgIGNvbFNlcGFyYXRpb25UeXBlOiBjb2xTZXBhcmF0aW9uVHlwZVxuICB9O1xufSAvLyBEZWNpZGVzIG9uIGEgc3R5bGUgZm9yIGNlbGxzIGluIGFuIGFycmF5IGFjY29yZGluZyB0byB3aGV0aGVyIHRoZSBnaXZlblxuLy8gZW52aXJvbm1lbnQgbmFtZSBzdGFydHMgd2l0aCB0aGUgbGV0dGVyICdkJy5cblxuXG5mdW5jdGlvbiBkQ2VsbFN0eWxlKGVudk5hbWUpIHtcbiAgaWYgKGVudk5hbWUuc3Vic3RyKDAsIDEpID09PSBcImRcIikge1xuICAgIHJldHVybiBcImRpc3BsYXlcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJ0ZXh0XCI7XG4gIH1cbn1cblxudmFyIGFycmF5X2h0bWxCdWlsZGVyID0gZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgdmFyIHI7XG4gIHZhciBjO1xuICB2YXIgbnIgPSBncm91cC5ib2R5Lmxlbmd0aDtcbiAgdmFyIGhMaW5lc0JlZm9yZVJvdyA9IGdyb3VwLmhMaW5lc0JlZm9yZVJvdztcbiAgdmFyIG5jID0gMDtcbiAgdmFyIGJvZHkgPSBuZXcgQXJyYXkobnIpO1xuICB2YXIgaGxpbmVzID0gW107IC8vIEhvcml6b250YWwgc3BhY2luZ1xuXG4gIHZhciBwdCA9IDEgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTtcbiAgdmFyIGFycmF5Y29sc2VwID0gNSAqIHB0OyAvLyBcXGFycmF5Y29sc2VwIGluIGFydGljbGUuY2xzXG4gIC8vIFZlcnRpY2FsIHNwYWNpbmdcblxuICB2YXIgYmFzZWxpbmVza2lwID0gMTIgKiBwdDsgLy8gc2VlIHNpemUxMC5jbG9cbiAgLy8gRGVmYXVsdCBcXGpvdCBmcm9tIGx0bWF0aC5kdHhcbiAgLy8gVE9ETyhlZGVtYWluZSk6IGFsbG93IG92ZXJyaWRpbmcgXFxqb3QgdmlhIFxcc2V0bGVuZ3RoICgjNjg3KVxuXG4gIHZhciBqb3QgPSAzICogcHQ7XG4gIHZhciBhcnJheXNraXAgPSBncm91cC5hcnJheXN0cmV0Y2ggKiBiYXNlbGluZXNraXA7XG4gIHZhciBhcnN0cnV0SGVpZ2h0ID0gMC43ICogYXJyYXlza2lwOyAvLyBcXHN0cnV0Ym94IGluIGx0ZnNzdHJjLmR0eCBhbmRcblxuICB2YXIgYXJzdHJ1dERlcHRoID0gMC4zICogYXJyYXlza2lwOyAvLyBcXEBhcnN0cnV0Ym94IGluIGx0dGFiLmR0eFxuXG4gIHZhciB0b3RhbEhlaWdodCA9IDA7IC8vIFNldCBhIHBvc2l0aW9uIGZvciBcXGhsaW5lKHMpIGF0IHRoZSB0b3Agb2YgdGhlIGFycmF5LCBpZiBhbnkuXG5cbiAgZnVuY3Rpb24gc2V0SExpbmVQb3MoaGxpbmVzSW5HYXApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhsaW5lc0luR2FwLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgdG90YWxIZWlnaHQgKz0gMC4yNTtcbiAgICAgIH1cblxuICAgICAgaGxpbmVzLnB1c2goe1xuICAgICAgICBwb3M6IHRvdGFsSGVpZ2h0LFxuICAgICAgICBpc0Rhc2hlZDogaGxpbmVzSW5HYXBbaV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNldEhMaW5lUG9zKGhMaW5lc0JlZm9yZVJvd1swXSk7XG5cbiAgZm9yIChyID0gMDsgciA8IGdyb3VwLmJvZHkubGVuZ3RoOyArK3IpIHtcbiAgICB2YXIgaW5yb3cgPSBncm91cC5ib2R5W3JdO1xuICAgIHZhciBoZWlnaHQgPSBhcnN0cnV0SGVpZ2h0OyAvLyBcXEBhcnJheSBhZGRzIGFuIFxcQGFyc3RydXRcblxuICAgIHZhciBkZXB0aCA9IGFyc3RydXREZXB0aDsgLy8gdG8gZWFjaCB0b3cgKHZpYSB0aGUgdGVtcGxhdGUpXG5cbiAgICBpZiAobmMgPCBpbnJvdy5sZW5ndGgpIHtcbiAgICAgIG5jID0gaW5yb3cubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBvdXRyb3cgPSBuZXcgQXJyYXkoaW5yb3cubGVuZ3RoKTtcblxuICAgIGZvciAoYyA9IDA7IGMgPCBpbnJvdy5sZW5ndGg7ICsrYykge1xuICAgICAgdmFyIGVsdCA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKGlucm93W2NdLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGRlcHRoIDwgZWx0LmRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gZWx0LmRlcHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGVpZ2h0IDwgZWx0LmhlaWdodCkge1xuICAgICAgICBoZWlnaHQgPSBlbHQuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBvdXRyb3dbY10gPSBlbHQ7XG4gICAgfVxuXG4gICAgdmFyIHJvd0dhcCA9IGdyb3VwLnJvd0dhcHNbcl07XG4gICAgdmFyIGdhcCA9IDA7XG5cbiAgICBpZiAocm93R2FwKSB7XG4gICAgICBnYXAgPSB1bml0c19jYWxjdWxhdGVTaXplKHJvd0dhcCwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChnYXAgPiAwKSB7XG4gICAgICAgIC8vIFxcQGFyZ2FycmF5Y3JcbiAgICAgICAgZ2FwICs9IGFyc3RydXREZXB0aDtcblxuICAgICAgICBpZiAoZGVwdGggPCBnYXApIHtcbiAgICAgICAgICBkZXB0aCA9IGdhcDsgLy8gXFxAeGFyZ2FycmF5Y3JcbiAgICAgICAgfVxuXG4gICAgICAgIGdhcCA9IDA7XG4gICAgICB9XG4gICAgfSAvLyBJbiBBTVMgbXVsdGlsaW5lIGVudmlyb25tZW50cyBzdWNoIGFzIGFsaWduZWQgYW5kIGdhdGhlcmVkLCByb3dzXG4gICAgLy8gY29ycmVzcG9uZCB0byBsaW5lcyB0aGF0IGhhdmUgYWRkaXRpb25hbCBcXGpvdCBhZGRlZCB0byB0aGVcbiAgICAvLyBcXGJhc2VsaW5lc2tpcCB2aWEgXFxvcGVudXAuXG5cblxuICAgIGlmIChncm91cC5hZGRKb3QpIHtcbiAgICAgIGRlcHRoICs9IGpvdDtcbiAgICB9XG5cbiAgICBvdXRyb3cuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIG91dHJvdy5kZXB0aCA9IGRlcHRoO1xuICAgIHRvdGFsSGVpZ2h0ICs9IGhlaWdodDtcbiAgICBvdXRyb3cucG9zID0gdG90YWxIZWlnaHQ7XG4gICAgdG90YWxIZWlnaHQgKz0gZGVwdGggKyBnYXA7IC8vIFxcQHlhcmdhcnJheWNyXG5cbiAgICBib2R5W3JdID0gb3V0cm93OyAvLyBTZXQgYSBwb3NpdGlvbiBmb3IgXFxobGluZShzKSwgaWYgYW55LlxuXG4gICAgc2V0SExpbmVQb3MoaExpbmVzQmVmb3JlUm93W3IgKyAxXSk7XG4gIH1cblxuICB2YXIgb2Zmc2V0ID0gdG90YWxIZWlnaHQgLyAyICsgb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQ7XG4gIHZhciBjb2xEZXNjcmlwdGlvbnMgPSBncm91cC5jb2xzIHx8IFtdO1xuICB2YXIgY29scyA9IFtdO1xuICB2YXIgY29sU2VwO1xuICB2YXIgY29sRGVzY3JOdW07XG5cbiAgZm9yIChjID0gMCwgY29sRGVzY3JOdW0gPSAwOyAvLyBDb250aW51ZSB3aGlsZSBlaXRoZXIgdGhlcmUgYXJlIG1vcmUgY29sdW1ucyBvciBtb3JlIGNvbHVtblxuICAvLyBkZXNjcmlwdGlvbnMsIHNvIHRyYWlsaW5nIHNlcGFyYXRvcnMgZG9uJ3QgZ2V0IGxvc3QuXG4gIGMgPCBuYyB8fCBjb2xEZXNjck51bSA8IGNvbERlc2NyaXB0aW9ucy5sZW5ndGg7ICsrYywgKytjb2xEZXNjck51bSkge1xuICAgIHZhciBjb2xEZXNjciA9IGNvbERlc2NyaXB0aW9uc1tjb2xEZXNjck51bV0gfHwge307XG4gICAgdmFyIGZpcnN0U2VwYXJhdG9yID0gdHJ1ZTtcblxuICAgIHdoaWxlIChjb2xEZXNjci50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHNlcGFyYXRvciBpbiBhIHJvdywgYWRkIGEgc3BhY2VcbiAgICAgIC8vIGJldHdlZW4gdGhlbS5cbiAgICAgIGlmICghZmlyc3RTZXBhcmF0b3IpIHtcbiAgICAgICAgY29sU2VwID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiYXJyYXljb2xzZXBcIl0sIFtdKTtcbiAgICAgICAgY29sU2VwLnN0eWxlLndpZHRoID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRvdWJsZVJ1bGVTZXAgKyBcImVtXCI7XG4gICAgICAgIGNvbHMucHVzaChjb2xTZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sRGVzY3Iuc2VwYXJhdG9yID09PSBcInxcIikge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1widmVydGljYWwtc2VwYXJhdG9yXCJdLCBbXSwgb3B0aW9ucyk7XG4gICAgICAgIHNlcGFyYXRvci5zdHlsZS5oZWlnaHQgPSB0b3RhbEhlaWdodCArIFwiZW1cIjtcbiAgICAgICAgc2VwYXJhdG9yLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAtKHRvdGFsSGVpZ2h0IC0gb2Zmc2V0KSArIFwiZW1cIjtcbiAgICAgICAgY29scy5wdXNoKHNlcGFyYXRvcik7XG4gICAgICB9IGVsc2UgaWYgKGNvbERlc2NyLnNlcGFyYXRvciA9PT0gXCI6XCIpIHtcbiAgICAgICAgdmFyIF9zZXBhcmF0b3IgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJ2ZXJ0aWNhbC1zZXBhcmF0b3JcIiwgXCJ2cy1kYXNoZWRcIl0sIFtdLCBvcHRpb25zKTtcblxuICAgICAgICBfc2VwYXJhdG9yLnN0eWxlLmhlaWdodCA9IHRvdGFsSGVpZ2h0ICsgXCJlbVwiO1xuICAgICAgICBfc2VwYXJhdG9yLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAtKHRvdGFsSGVpZ2h0IC0gb2Zmc2V0KSArIFwiZW1cIjtcbiAgICAgICAgY29scy5wdXNoKF9zZXBhcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBzZXBhcmF0b3IgdHlwZTogXCIgKyBjb2xEZXNjci5zZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBjb2xEZXNjck51bSsrO1xuICAgICAgY29sRGVzY3IgPSBjb2xEZXNjcmlwdGlvbnNbY29sRGVzY3JOdW1dIHx8IHt9O1xuICAgICAgZmlyc3RTZXBhcmF0b3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYyA+PSBuYykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHNlcHdpZHRoID0gdm9pZCAwO1xuXG4gICAgaWYgKGMgPiAwIHx8IGdyb3VwLmhza2lwQmVmb3JlQW5kQWZ0ZXIpIHtcbiAgICAgIHNlcHdpZHRoID0gdXRpbHMuZGVmbHQoY29sRGVzY3IucHJlZ2FwLCBhcnJheWNvbHNlcCk7XG5cbiAgICAgIGlmIChzZXB3aWR0aCAhPT0gMCkge1xuICAgICAgICBjb2xTZXAgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJhcnJheWNvbHNlcFwiXSwgW10pO1xuICAgICAgICBjb2xTZXAuc3R5bGUud2lkdGggPSBzZXB3aWR0aCArIFwiZW1cIjtcbiAgICAgICAgY29scy5wdXNoKGNvbFNlcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbCA9IFtdO1xuXG4gICAgZm9yIChyID0gMDsgciA8IG5yOyArK3IpIHtcbiAgICAgIHZhciByb3cgPSBib2R5W3JdO1xuICAgICAgdmFyIGVsZW0gPSByb3dbY107XG5cbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNoaWZ0ID0gcm93LnBvcyAtIG9mZnNldDtcbiAgICAgIGVsZW0uZGVwdGggPSByb3cuZGVwdGg7XG4gICAgICBlbGVtLmhlaWdodCA9IHJvdy5oZWlnaHQ7XG4gICAgICBjb2wucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICBzaGlmdDogc2hpZnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogY29sXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgY29sID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiY29sLWFsaWduLVwiICsgKGNvbERlc2NyLmFsaWduIHx8IFwiY1wiKV0sIFtjb2xdKTtcbiAgICBjb2xzLnB1c2goY29sKTtcblxuICAgIGlmIChjIDwgbmMgLSAxIHx8IGdyb3VwLmhza2lwQmVmb3JlQW5kQWZ0ZXIpIHtcbiAgICAgIHNlcHdpZHRoID0gdXRpbHMuZGVmbHQoY29sRGVzY3IucG9zdGdhcCwgYXJyYXljb2xzZXApO1xuXG4gICAgICBpZiAoc2Vwd2lkdGggIT09IDApIHtcbiAgICAgICAgY29sU2VwID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiYXJyYXljb2xzZXBcIl0sIFtdKTtcbiAgICAgICAgY29sU2VwLnN0eWxlLndpZHRoID0gc2Vwd2lkdGggKyBcImVtXCI7XG4gICAgICAgIGNvbHMucHVzaChjb2xTZXApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJvZHkgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtdGFibGVcIl0sIGNvbHMpOyAvLyBBZGQgXFxobGluZShzKSwgaWYgYW55LlxuXG4gIGlmIChobGluZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBsaW5lID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwiaGxpbmVcIiwgb3B0aW9ucywgMC4wNSk7XG4gICAgdmFyIGRhc2hlcyA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbihcImhkYXNobGluZVwiLCBvcHRpb25zLCAwLjA1KTtcbiAgICB2YXIgdkxpc3RFbGVtcyA9IFt7XG4gICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgIGVsZW06IGJvZHksXG4gICAgICBzaGlmdDogMFxuICAgIH1dO1xuXG4gICAgd2hpbGUgKGhsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaGxpbmUgPSBobGluZXMucG9wKCk7XG4gICAgICB2YXIgbGluZVNoaWZ0ID0gaGxpbmUucG9zIC0gb2Zmc2V0O1xuXG4gICAgICBpZiAoaGxpbmUuaXNEYXNoZWQpIHtcbiAgICAgICAgdkxpc3RFbGVtcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBkYXNoZXMsXG4gICAgICAgICAgc2hpZnQ6IGxpbmVTaGlmdFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZMaXN0RWxlbXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogbGluZSxcbiAgICAgICAgICBzaGlmdDogbGluZVNoaWZ0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IHZMaXN0RWxlbXNcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLCBbYm9keV0sIG9wdGlvbnMpO1xufTtcblxudmFyIGFsaWduTWFwID0ge1xuICBjOiBcImNlbnRlciBcIixcbiAgbDogXCJsZWZ0IFwiLFxuICByOiBcInJpZ2h0IFwiXG59O1xuXG52YXIgYXJyYXlfbWF0aG1sQnVpbGRlciA9IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgdmFyIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgZ3JvdXAuYm9keS5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCByb3cubWFwKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2J1aWxkTWF0aE1MX2J1aWxkR3JvdXAoY2VsbCwgb3B0aW9ucyldKTtcbiAgICB9KSk7XG4gIH0pKTsgLy8gU2V0IGNvbHVtbiBhbGlnbm1lbnQsIHJvdyBzcGFjaW5nLCBjb2x1bW4gc3BhY2luZywgYW5kXG4gIC8vIGFycmF5IGxpbmVzIGJ5IHNldHRpbmcgYXR0cmlidXRlcyBvbiB0aGUgdGFibGUgZWxlbWVudC5cbiAgLy8gU2V0IHRoZSByb3cgc3BhY2luZy4gSW4gTWF0aE1MLCB3ZSBzcGVjaWZ5IGEgZ2FwIGRpc3RhbmNlLlxuICAvLyBXZSBkbyBub3QgdXNlIHJvd0dhcFtdIGJlY2F1c2UgTWF0aE1MIGF1dG9tYXRpY2FsbHkgaW5jcmVhc2VzXG4gIC8vIGNlbGwgaGVpZ2h0IHdpdGggdGhlIGhlaWdodC9kZXB0aCBvZiB0aGUgZWxlbWVudCBjb250ZW50LlxuICAvLyBMYVRlWCBcXGFycmF5c3RyZXRjaCBtdWx0aXBsaWVzIHRoZSByb3cgYmFzZWxpbmUtdG8tYmFzZWxpbmUgZGlzdGFuY2UuXG4gIC8vIFdlIHNpbXVsYXRlIHRoaXMgYnkgYWRkaW5nIChhcnJheXN0cmV0Y2ggLSAxKWVtIHRvIHRoZSBnYXAuIFRoaXNcbiAgLy8gZG9lcyBhIHJlYXNvbmFibGUgam9iIG9mIGFkanVzdGluZyBhcnJheXMgY29udGFpbmluZyAxIGVtIHRhbGwgY29udGVudC5cbiAgLy8gVGhlIDAuMTYgYW5kIDAuMDkgdmFsdWVzIGFyZSBmb3VuZCBlbXByaWNhbGx5LiBUaGV5IHByb2R1Y2UgYW4gYXJyYXlcbiAgLy8gc2ltaWxhciB0byBMYVRlWCBhbmQgaW4gd2hpY2ggY29udGVudCBkb2VzIG5vdCBpbnRlcmZlcmUgd2l0aCBcXGhpbmVzLlxuXG4gIHZhciBnYXAgPSAwLjE2ICsgZ3JvdXAuYXJyYXlzdHJldGNoIC0gMSArIChncm91cC5hZGRKb3QgPyAwLjA5IDogMCk7XG4gIHRhYmxlLnNldEF0dHJpYnV0ZShcInJvd3NwYWNpbmdcIiwgZ2FwICsgXCJlbVwiKTsgLy8gTWF0aE1MIHRhYmxlIGxpbmVzIGdvIG9ubHkgYmV0d2VlbiBjZWxscy5cbiAgLy8gVG8gcGxhY2UgYSBsaW5lIG9uIGFuIGVkZ2Ugd2UnbGwgdXNlIDxtZW5jbG9zZT4sIGlmIG5lY2Vzc2FyeS5cblxuICB2YXIgbWVuY2xvc2UgPSBcIlwiO1xuICB2YXIgYWxpZ24gPSBcIlwiO1xuXG4gIGlmIChncm91cC5jb2xzKSB7XG4gICAgLy8gRmluZCBjb2x1bW4gYWxpZ25tZW50LCBjb2x1bW4gc3BhY2luZywgYW5kICB2ZXJ0aWNhbCBsaW5lcy5cbiAgICB2YXIgY29scyA9IGdyb3VwLmNvbHM7XG4gICAgdmFyIGNvbHVtbkxpbmVzID0gXCJcIjtcbiAgICB2YXIgcHJldlR5cGVXYXNBbGlnbiA9IGZhbHNlO1xuICAgIHZhciBpU3RhcnQgPSAwO1xuICAgIHZhciBpRW5kID0gY29scy5sZW5ndGg7XG5cbiAgICBpZiAoY29sc1swXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBtZW5jbG9zZSArPSBcInRvcCBcIjtcbiAgICAgIGlTdGFydCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGNvbHNbY29scy5sZW5ndGggLSAxXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBtZW5jbG9zZSArPSBcImJvdHRvbSBcIjtcbiAgICAgIGlFbmQgLT0gMTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gaVN0YXJ0OyBpIDwgaUVuZDsgaSsrKSB7XG4gICAgICBpZiAoY29sc1tpXS50eXBlID09PSBcImFsaWduXCIpIHtcbiAgICAgICAgYWxpZ24gKz0gYWxpZ25NYXBbY29sc1tpXS5hbGlnbl07XG5cbiAgICAgICAgaWYgKHByZXZUeXBlV2FzQWxpZ24pIHtcbiAgICAgICAgICBjb2x1bW5MaW5lcyArPSBcIm5vbmUgXCI7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2VHlwZVdhc0FsaWduID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY29sc1tpXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAgIC8vIE1hdGhNTCBhY2NlcHRzIG9ubHkgc2luZ2xlIGxpbmVzIGJldHdlZW4gY2VsbHMuXG4gICAgICAgIC8vIFNvIHdlIHJlYWQgb25seSB0aGUgZmlyc3Qgb2YgY29uc2VjdXRpdmUgc2VwYXJhdG9ycy5cbiAgICAgICAgaWYgKHByZXZUeXBlV2FzQWxpZ24pIHtcbiAgICAgICAgICBjb2x1bW5MaW5lcyArPSBjb2xzW2ldLnNlcGFyYXRvciA9PT0gXCJ8XCIgPyBcInNvbGlkIFwiIDogXCJkYXNoZWQgXCI7XG4gICAgICAgICAgcHJldlR5cGVXYXNBbGlnbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwiY29sdW1uYWxpZ25cIiwgYWxpZ24udHJpbSgpKTtcblxuICAgIGlmICgvW3NkXS8udGVzdChjb2x1bW5MaW5lcykpIHtcbiAgICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbmxpbmVzXCIsIGNvbHVtbkxpbmVzLnRyaW0oKSk7XG4gICAgfVxuICB9IC8vIFNldCBjb2x1bW4gc3BhY2luZy5cblxuXG4gIGlmIChncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJhbGlnblwiKSB7XG4gICAgdmFyIF9jb2xzID0gZ3JvdXAuY29scyB8fCBbXTtcblxuICAgIHZhciBzcGFjaW5nID0gXCJcIjtcblxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBfY29scy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHNwYWNpbmcgKz0gX2kgJSAyID8gXCIwZW0gXCIgOiBcIjFlbSBcIjtcbiAgICB9XG5cbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5zcGFjaW5nXCIsIHNwYWNpbmcudHJpbSgpKTtcbiAgfSBlbHNlIGlmIChncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJhbGlnbmF0XCIpIHtcbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5zcGFjaW5nXCIsIFwiMGVtXCIpO1xuICB9IGVsc2Uge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgXCIxZW1cIik7XG4gIH0gLy8gQWRkcmVzcyBcXGhsaW5lIGFuZCBcXGhkYXNobGluZVxuXG5cbiAgdmFyIHJvd0xpbmVzID0gXCJcIjtcbiAgdmFyIGhsaW5lcyA9IGdyb3VwLmhMaW5lc0JlZm9yZVJvdztcbiAgbWVuY2xvc2UgKz0gaGxpbmVzWzBdLmxlbmd0aCA+IDAgPyBcImxlZnQgXCIgOiBcIlwiO1xuICBtZW5jbG9zZSArPSBobGluZXNbaGxpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCA+IDAgPyBcInJpZ2h0IFwiIDogXCJcIjtcblxuICBmb3IgKHZhciBfaTIgPSAxOyBfaTIgPCBobGluZXMubGVuZ3RoIC0gMTsgX2kyKyspIHtcbiAgICByb3dMaW5lcyArPSBobGluZXNbX2kyXS5sZW5ndGggPT09IDAgPyBcIm5vbmUgXCIgLy8gTWF0aE1MIGFjY2VwdHMgb25seSBhIHNpbmdsZSBsaW5lIGJldHdlZW4gcm93cy4gUmVhZCBvbmUgZWxlbWVudC5cbiAgICA6IGhsaW5lc1tfaTJdWzBdID8gXCJkYXNoZWQgXCIgOiBcInNvbGlkIFwiO1xuICB9XG5cbiAgaWYgKC9bc2RdLy50ZXN0KHJvd0xpbmVzKSkge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcInJvd2xpbmVzXCIsIHJvd0xpbmVzLnRyaW0oKSk7XG4gIH1cblxuICBpZiAobWVuY2xvc2UgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdGFibGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdyYXBwZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1lbmNsb3NlXCIsIFt0YWJsZV0pO1xuICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgbWVuY2xvc2UudHJpbSgpKTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfVxufTsgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFsaWduZWQgYW5kIGFsaWduZWRhdCBlbnZpcm9ubWVudHMuXG5cblxudmFyIGFycmF5X2FsaWduZWRIYW5kbGVyID0gZnVuY3Rpb24gYWxpZ25lZEhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICB2YXIgY29scyA9IFtdO1xuICB2YXIgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwge1xuICAgIGNvbHM6IGNvbHMsXG4gICAgYWRkSm90OiB0cnVlXG4gIH0sIFwiZGlzcGxheVwiKTsgLy8gRGV0ZXJtaW5pbmcgbnVtYmVyIG9mIGNvbHVtbnMuXG4gIC8vIDEuIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBnaXZlbiwgd2UgdXNlIGl0IGFzIGEgbnVtYmVyIG9mIGNvbHVtbnMsXG4gIC8vICAgIGFuZCBtYWtlcyBzdXJlIHRoYXQgZWFjaCByb3cgZG9lc24ndCBleGNlZWQgdGhhdCBudW1iZXIuXG4gIC8vIDIuIE90aGVyd2lzZSwganVzdCBjb3VudCBudW1iZXIgb2YgY29sdW1ucyA9IG1heGltdW0gbnVtYmVyXG4gIC8vICAgIG9mIGNlbGxzIGluIGVhY2ggcm93IChcImFsaWduZWRcIiBtb2RlIC0tIGlzQWxpZ25lZCB3aWxsIGJlIHRydWUpLlxuICAvL1xuICAvLyBBdCB0aGUgc2FtZSB0aW1lLCBwcmVwZW5kIGVtcHR5IGdyb3VwIHt9IGF0IGJlZ2lubmluZyBvZiBldmVyeSBzZWNvbmRcbiAgLy8gY2VsbCBpbiBlYWNoIHJvdyAoc3RhcnRpbmcgd2l0aCBzZWNvbmQgY2VsbCkgc28gdGhhdCBvcGVyYXRvcnMgYmVjb21lXG4gIC8vIGJpbmFyeS4gIFRoaXMgYmVoYXZpb3IgaXMgaW1wbGVtZW50ZWQgaW4gYW1zbWF0aCdzIFxcc3RhcnRAYWxpZ25lZC5cblxuICB2YXIgbnVtTWF0aHM7XG4gIHZhciBudW1Db2xzID0gMDtcbiAgdmFyIGVtcHR5R3JvdXAgPSB7XG4gICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgIG1vZGU6IGNvbnRleHQubW9kZSxcbiAgICBib2R5OiBbXVxuICB9O1xuICB2YXIgb3JkZ3JvdXAgPSBjaGVja05vZGVUeXBlKGFyZ3NbMF0sIFwib3JkZ3JvdXBcIik7XG5cbiAgaWYgKG9yZGdyb3VwKSB7XG4gICAgdmFyIGFyZzAgPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRncm91cC5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGV4dG9yZCA9IGFzc2VydE5vZGVUeXBlKG9yZGdyb3VwLmJvZHlbaV0sIFwidGV4dG9yZFwiKTtcbiAgICAgIGFyZzAgKz0gdGV4dG9yZC50ZXh0O1xuICAgIH1cblxuICAgIG51bU1hdGhzID0gTnVtYmVyKGFyZzApO1xuICAgIG51bUNvbHMgPSBudW1NYXRocyAqIDI7XG4gIH1cblxuICB2YXIgaXNBbGlnbmVkID0gIW51bUNvbHM7XG4gIHJlcy5ib2R5LmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgIGZvciAodmFyIF9pMyA9IDE7IF9pMyA8IHJvdy5sZW5ndGg7IF9pMyArPSAyKSB7XG4gICAgICAvLyBNb2RpZnkgb3JkZ3JvdXAgbm9kZSB3aXRoaW4gc3R5bGluZyBub2RlXG4gICAgICB2YXIgc3R5bGluZyA9IGFzc2VydE5vZGVUeXBlKHJvd1tfaTNdLCBcInN0eWxpbmdcIik7XG5cbiAgICAgIHZhciBfb3JkZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShzdHlsaW5nLmJvZHlbMF0sIFwib3JkZ3JvdXBcIik7XG5cbiAgICAgIF9vcmRncm91cC5ib2R5LnVuc2hpZnQoZW1wdHlHcm91cCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0FsaWduZWQpIHtcbiAgICAgIC8vIENhc2UgMVxuICAgICAgdmFyIGN1ck1hdGhzID0gcm93Lmxlbmd0aCAvIDI7XG5cbiAgICAgIGlmIChudW1NYXRocyA8IGN1ck1hdGhzKSB7XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlRvbyBtYW55IG1hdGggaW4gYSByb3c6IFwiICsgKFwiZXhwZWN0ZWQgXCIgKyBudW1NYXRocyArIFwiLCBidXQgZ290IFwiICsgY3VyTWF0aHMpLCByb3dbMF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnVtQ29scyA8IHJvdy5sZW5ndGgpIHtcbiAgICAgIC8vIENhc2UgMlxuICAgICAgbnVtQ29scyA9IHJvdy5sZW5ndGg7XG4gICAgfVxuICB9KTsgLy8gQWRqdXN0aW5nIGFsaWdubWVudC5cbiAgLy8gSW4gYWxpZ25lZCBtb2RlLCB3ZSBhZGQgb25lIFxccXF1YWQgYmV0d2VlbiBjb2x1bW5zO1xuICAvLyBvdGhlcndpc2Ugd2UgYWRkIG5vdGhpbmcuXG5cbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbnVtQ29sczsgKytfaTQpIHtcbiAgICB2YXIgYWxpZ24gPSBcInJcIjtcbiAgICB2YXIgcHJlZ2FwID0gMDtcblxuICAgIGlmIChfaTQgJSAyID09PSAxKSB7XG4gICAgICBhbGlnbiA9IFwibFwiO1xuICAgIH0gZWxzZSBpZiAoX2k0ID4gMCAmJiBpc0FsaWduZWQpIHtcbiAgICAgIC8vIFwiYWxpZ25lZFwiIG1vZGUuXG4gICAgICBwcmVnYXAgPSAxOyAvLyBhZGQgb25lIFxccXVhZFxuICAgIH1cblxuICAgIGNvbHNbX2k0XSA9IHtcbiAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgIHByZWdhcDogcHJlZ2FwLFxuICAgICAgcG9zdGdhcDogMFxuICAgIH07XG4gIH1cblxuICByZXMuY29sU2VwYXJhdGlvblR5cGUgPSBpc0FsaWduZWQgPyBcImFsaWduXCIgOiBcImFsaWduYXRcIjtcbiAgcmV0dXJuIHJlcztcbn07IC8vIEFycmF5cyBhcmUgcGFydCBvZiBMYVRlWCwgZGVmaW5lZCBpbiBsdHRhYi5kdHggc28gaXRzIGRvY3VtZW50YXRpb25cbi8vIGlzIHBhcnQgb2YgdGhlIHNvdXJjZTJlLnBkZiBmaWxlIG9mIExhVGVYMmUgc291cmNlIGRvY3VtZW50YXRpb24uXG4vLyB7ZGFycmF5fSBpcyBhbiB7YXJyYXl9IGVudmlyb25tZW50IHdoZXJlIGNlbGxzIGFyZSBzZXQgaW4gXFxkaXNwbGF5c3R5bGUsXG4vLyBhcyBkZWZpbmVkIGluIG5jY21hdGguc3R5LlxuXG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYXJyYXlcIiwgXCJkYXJyYXlcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAvLyBTaW5jZSBubyB0eXBlcyBhcmUgc3BlY2lmaWVkIGFib3ZlLCB0aGUgdHdvIHBvc3NpYmlsaXRpZXMgYXJlXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgd3JhcHBlZCBpbiB7fSBvciBbXSwgaW4gd2hpY2ggY2FzZSBQYXJzZXInc1xuICAgIC8vICAgcGFyc2VHcm91cCgpIHJldHVybnMgYW4gXCJvcmRncm91cFwiIHdyYXBwaW5nIHNvbWUgc3ltYm9sIG5vZGUuXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgYSBiYXJlIHN5bWJvbCBub2RlLlxuICAgIHZhciBzeW1Ob2RlID0gY2hlY2tTeW1ib2xOb2RlVHlwZShhcmdzWzBdKTtcbiAgICB2YXIgY29sYWxpZ24gPSBzeW1Ob2RlID8gW2FyZ3NbMF1dIDogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKS5ib2R5O1xuICAgIHZhciBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uIChuZGUpIHtcbiAgICAgIHZhciBub2RlID0gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobmRlKTtcbiAgICAgIHZhciBjYSA9IG5vZGUudGV4dDtcblxuICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjYSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICAgIGFsaWduOiBjYVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjYSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInNlcGFyYXRvclwiLFxuICAgICAgICAgIHNlcGFyYXRvcjogXCJ8XCJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwiOlwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzZXBhcmF0b3JcIixcbiAgICAgICAgICBzZXBhcmF0b3I6IFwiOlwiXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVua25vd24gY29sdW1uIGFsaWdubWVudDogXCIgKyBjYSwgbmRlKTtcbiAgICB9KTtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgY29sczogY29scyxcbiAgICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXI6IHRydWUgLy8gXFxAcHJlYW1ibGUgaW4gbHR0YWIuZHR4XG5cbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7IC8vIFRoZSBtYXRyaXggZW52aXJvbm1lbnRzIG9mIGFtc21hdGggYnVpbGRzIG9uIHRoZSBhcnJheSBlbnZpcm9ubWVudFxuLy8gb2YgTGFUZVgsIHdoaWNoIGlzIGRpc2N1c3NlZCBhYm92ZS5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJtYXRyaXhcIiwgXCJwbWF0cml4XCIsIFwiYm1hdHJpeFwiLCBcIkJtYXRyaXhcIiwgXCJ2bWF0cml4XCIsIFwiVm1hdHJpeFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoY29udGV4dCkge1xuICAgIHZhciBkZWxpbWl0ZXJzID0ge1xuICAgICAgXCJtYXRyaXhcIjogbnVsbCxcbiAgICAgIFwicG1hdHJpeFwiOiBbXCIoXCIsIFwiKVwiXSxcbiAgICAgIFwiYm1hdHJpeFwiOiBbXCJbXCIsIFwiXVwiXSxcbiAgICAgIFwiQm1hdHJpeFwiOiBbXCJcXFxce1wiLCBcIlxcXFx9XCJdLFxuICAgICAgXCJ2bWF0cml4XCI6IFtcInxcIiwgXCJ8XCJdLFxuICAgICAgXCJWbWF0cml4XCI6IFtcIlxcXFxWZXJ0XCIsIFwiXFxcXFZlcnRcIl1cbiAgICB9W2NvbnRleHQuZW52TmFtZV07IC8vIFxcaHNraXAgLVxcYXJyYXljb2xzZXAgaW4gYW1zbWF0aFxuXG4gICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICBoc2tpcEJlZm9yZUFuZEFmdGVyOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHBheWxvYWQsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7XG4gICAgcmV0dXJuIGRlbGltaXRlcnMgPyB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgbW9kZTogY29udGV4dC5tb2RlLFxuICAgICAgYm9keTogW3Jlc10sXG4gICAgICBsZWZ0OiBkZWxpbWl0ZXJzWzBdLFxuICAgICAgcmlnaHQ6IGRlbGltaXRlcnNbMV1cbiAgICB9IDogcmVzO1xuICB9LFxuICBodG1sQnVpbGRlcjogYXJyYXlfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGFycmF5X21hdGhtbEJ1aWxkZXJcbn0pOyAvLyBBIGNhc2VzIGVudmlyb25tZW50IChpbiBhbXNtYXRoLnN0eSkgaXMgYWxtb3N0IGVxdWl2YWxlbnQgdG9cbi8vIFxcZGVmXFxhcnJheXN0cmV0Y2h7MS4yfSVcbi8vIFxcbGVmdFxce1xcYmVnaW57YXJyYXl9e0B7fWxAe1xccXVhZH1sQHt9fSDigKYgXFxlbmR7YXJyYXl9XFxyaWdodC5cbi8vIHtkY2FzZXN9IGlzIGEge2Nhc2VzfSBlbnZpcm9ubWVudCB3aGVyZSBjZWxscyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLFxuLy8gYXMgZGVmaW5lZCBpbiBtYXRodG9vbHMuc3R5LlxuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImNhc2VzXCIsIFwiZGNhc2VzXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihjb250ZXh0KSB7XG4gICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICBhcnJheXN0cmV0Y2g6IDEuMixcbiAgICAgIGNvbHM6IFt7XG4gICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgYWxpZ246IFwibFwiLFxuICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgIC8vIFRPRE8oa2V2aW5iKSBnZXQgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAgICAgIC8vIEZvciBub3cgd2UgdXNlIHRoZSBtZXRyaWNzIGZvciBURVhUIHN0eWxlIHdoaWNoIGlzIHdoYXQgd2Ugd2VyZVxuICAgICAgICAvLyBkb2luZyBiZWZvcmUuICBCZWZvcmUgYXR0ZW1wdGluZyB0byBnZXQgdGhlIGN1cnJlbnQgc3R5bGUgd2VcbiAgICAgICAgLy8gc2hvdWxkIGxvb2sgYXQgVGVYJ3MgYmVoYXZpb3IgZXNwZWNpYWxseSBmb3IgXFxvdmVyIGFuZCBtYXRyaWNlcy5cbiAgICAgICAgcG9zdGdhcDogMS4wXG4gICAgICAgIC8qIDFlbSBxdWFkICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICBhbGlnbjogXCJsXCIsXG4gICAgICAgIHByZWdhcDogMCxcbiAgICAgICAgcG9zdGdhcDogMFxuICAgICAgfV1cbiAgICB9O1xuICAgIHZhciByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBkQ2VsbFN0eWxlKGNvbnRleHQuZW52TmFtZSkpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgbW9kZTogY29udGV4dC5tb2RlLFxuICAgICAgYm9keTogW3Jlc10sXG4gICAgICBsZWZ0OiBcIlxcXFx7XCIsXG4gICAgICByaWdodDogXCIuXCJcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogYXJyYXlfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGFycmF5X21hdGhtbEJ1aWxkZXJcbn0pOyAvLyBBbiBhbGlnbmVkIGVudmlyb25tZW50IGlzIGxpa2UgdGhlIGFsaWduKiBlbnZpcm9ubWVudFxuLy8gZXhjZXB0IGl0IG9wZXJhdGVzIHdpdGhpbiBtYXRoIG1vZGUuXG4vLyBOb3RlIHRoYXQgd2UgYXNzdW1lIFxcbm9tYWxsaW5lc2tpcGxpbWl0IHRvIGJlIHplcm8sXG4vLyBzbyB0aGF0IFxcc3RydXRAIGlzIHRoZSBzYW1lIGFzIFxcc3RydXQuXG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYWxpZ25lZFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6IGFycmF5X2FsaWduZWRIYW5kbGVyLFxuICBodG1sQnVpbGRlcjogYXJyYXlfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGFycmF5X21hdGhtbEJ1aWxkZXJcbn0pOyAvLyBBIGdhdGhlcmVkIGVudmlyb25tZW50IGlzIGxpa2UgYW4gYXJyYXkgZW52aXJvbm1lbnQgd2l0aCBvbmUgY2VudGVyZWRcbi8vIGNvbHVtbiwgYnV0IHdoZXJlIHJvd3MgYXJlIGNvbnNpZGVyZWQgbGluZXMgc28gZ2V0IFxcam90IGxpbmUgc3BhY2luZ1xuLy8gYW5kIGNvbnRlbnRzIGFyZSBzZXQgaW4gXFxkaXNwbGF5c3R5bGUuXG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiZ2F0aGVyZWRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgY29sczogW3tcbiAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICBhbGlnbjogXCJjXCJcbiAgICAgIH1dLFxuICAgICAgYWRkSm90OiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCBcImRpc3BsYXlcIik7XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBhcnJheV9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogYXJyYXlfbWF0aG1sQnVpbGRlclxufSk7IC8vIGFsaWduYXQgZW52aXJvbm1lbnQgaXMgbGlrZSBhbiBhbGlnbiBlbnZpcm9ubWVudCwgYnV0IG9uZSBtdXN0IGV4cGxpY2l0bHlcbi8vIHNwZWNpZnkgbWF4aW11bSBudW1iZXIgb2YgY29sdW1ucyBpbiBlYWNoIHJvdywgYW5kIGNhbiBhZGp1c3Qgc3BhY2luZyBiZXR3ZWVuXG4vLyBlYWNoIGNvbHVtbnMuXG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYWxpZ25lZGF0XCJdLFxuICAvLyBPbmUgZm9yIG51bWJlcmVkIGFuZCBmb3IgdW5udW1iZXJlZDtcbiAgLy8gYnV0LCBLYVRlWCBkb2Vzbid0IHN1cHBvcnRzIG1hdGggbnVtYmVyaW5nIHlldCxcbiAgLy8gdGhleSBtYWtlIG5vIGRpZmZlcmVuY2UgZm9yIG5vdy5cbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGFycmF5X2FsaWduZWRIYW5kbGVyLFxuICBodG1sQnVpbGRlcjogYXJyYXlfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGFycmF5X21hdGhtbEJ1aWxkZXJcbn0pOyAvLyBDYXRjaCBcXGhsaW5lIG91dHNpZGUgYXJyYXkgZW52aXJvbm1lbnRcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIixcbiAgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGlzIGlzLlxuICBuYW1lczogW1wiXFxcXGhsaW5lXCIsIFwiXFxcXGhkYXNobGluZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoY29udGV4dC5mdW5jTmFtZSArIFwiIHZhbGlkIG9ubHkgd2l0aGluIGFycmF5IGVudmlyb25tZW50XCIpO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Vudmlyb25tZW50cy5qc1xuXG52YXIgZW52aXJvbm1lbnRzID0gX2Vudmlyb25tZW50cztcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19lbnZpcm9ubWVudHMgPSAoZW52aXJvbm1lbnRzKTsgLy8gQWxsIGVudmlyb25tZW50IGRlZmluaXRpb25zIHNob3VsZCBiZSBpbXBvcnRlZCBiZWxvd1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9lbnZpcm9ubWVudC5qc1xuXG5cblxuIC8vIEVudmlyb25tZW50IGRlbGltaXRlcnMuIEhUTUwvTWF0aE1MIHJlbmRlcmluZyBpcyBkZWZpbmVkIGluIHRoZSBjb3JyZXNwb25kaW5nXG4vLyBkZWZpbmVFbnZpcm9ubWVudCBkZWZpbml0aW9ucy5cbi8vICRGbG93Rml4TWUsIFwiZW52aXJvbm1lbnRcIiBoYW5kbGVyIHJldHVybnMgYW4gZW52aXJvbm1lbnQgUGFyc2VOb2RlXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbnZpcm9ubWVudFwiLFxuICBuYW1lczogW1wiXFxcXGJlZ2luXCIsIFwiXFxcXGVuZFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ0ZXh0XCJdXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lO1xuICAgIHZhciBuYW1lR3JvdXAgPSBhcmdzWzBdO1xuXG4gICAgaWYgKG5hbWVHcm91cC50eXBlICE9PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgZW52aXJvbm1lbnQgbmFtZVwiLCBuYW1lR3JvdXApO1xuICAgIH1cblxuICAgIHZhciBlbnZOYW1lID0gXCJcIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZUdyb3VwLmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgIGVudk5hbWUgKz0gYXNzZXJ0Tm9kZVR5cGUobmFtZUdyb3VwLmJvZHlbaV0sIFwidGV4dG9yZFwiKS50ZXh0O1xuICAgIH1cblxuICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcYmVnaW5cIikge1xuICAgICAgLy8gYmVnaW4uLi5lbmQgaXMgc2ltaWxhciB0byBsZWZ0Li4ucmlnaHRcbiAgICAgIGlmICghc3JjX2Vudmlyb25tZW50cy5oYXNPd25Qcm9wZXJ0eShlbnZOYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJObyBzdWNoIGVudmlyb25tZW50OiBcIiArIGVudk5hbWUsIG5hbWVHcm91cCk7XG4gICAgICB9IC8vIEJ1aWxkIHRoZSBlbnZpcm9ubWVudCBvYmplY3QuIEFyZ3VtZW50cyBhbmQgb3RoZXIgaW5mb3JtYXRpb24gd2lsbFxuICAgICAgLy8gYmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGJlZ2luIGFuZCBlbmQgbWV0aG9kcyB1c2luZyBwcm9wZXJ0aWVzLlxuXG5cbiAgICAgIHZhciBlbnYgPSBzcmNfZW52aXJvbm1lbnRzW2Vudk5hbWVdO1xuXG4gICAgICB2YXIgX3BhcnNlciRwYXJzZUFyZ3VtZW50ID0gcGFyc2VyLnBhcnNlQXJndW1lbnRzKFwiXFxcXGJlZ2lue1wiICsgZW52TmFtZSArIFwifVwiLCBlbnYpLFxuICAgICAgICAgIF9hcmdzID0gX3BhcnNlciRwYXJzZUFyZ3VtZW50LmFyZ3MsXG4gICAgICAgICAgb3B0QXJncyA9IF9wYXJzZXIkcGFyc2VBcmd1bWVudC5vcHRBcmdzO1xuXG4gICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGVudk5hbWU6IGVudk5hbWUsXG4gICAgICAgIHBhcnNlcjogcGFyc2VyXG4gICAgICB9O1xuICAgICAgdmFyIHJlc3VsdCA9IGVudi5oYW5kbGVyKGNvbnRleHQsIF9hcmdzLCBvcHRBcmdzKTtcbiAgICAgIHBhcnNlci5leHBlY3QoXCJcXFxcZW5kXCIsIGZhbHNlKTtcbiAgICAgIHZhciBlbmROYW1lVG9rZW4gPSBwYXJzZXIubmV4dFRva2VuO1xuICAgICAgdmFyIGVuZCA9IGFzc2VydE5vZGVUeXBlKHBhcnNlci5wYXJzZUZ1bmN0aW9uKCksIFwiZW52aXJvbm1lbnRcIik7XG5cbiAgICAgIGlmIChlbmQubmFtZSAhPT0gZW52TmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJNaXNtYXRjaDogXFxcXGJlZ2lue1wiICsgZW52TmFtZSArIFwifSBtYXRjaGVkIGJ5IFxcXFxlbmR7XCIgKyBlbmQubmFtZSArIFwifVwiLCBlbmROYW1lVG9rZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG5hbWU6IGVudk5hbWUsXG4gICAgICBuYW1lR3JvdXA6IG5hbWVHcm91cFxuICAgIH07XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL21jbGFzcy5qc1xuXG5cblxuXG5cbnZhciBtY2xhc3NfbWFrZVNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbjtcblxuZnVuY3Rpb24gbWNsYXNzX2h0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50cyA9IGJ1aWxkSFRNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSk7XG4gIHJldHVybiBtY2xhc3NfbWFrZVNwYW4oW2dyb3VwLm1jbGFzc10sIGVsZW1lbnRzLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbWNsYXNzX21hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgdmFyIGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuICByZXR1cm4gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KGlubmVyKTtcbn0gLy8gTWF0aCBjbGFzcyBjb21tYW5kcyBleGNlcHQgXFxtYXRob3BcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aG9yZFwiLCBcIlxcXFxtYXRoYmluXCIsIFwiXFxcXG1hdGhyZWxcIiwgXCJcXFxcbWF0aG9wZW5cIiwgXCJcXFxcbWF0aGNsb3NlXCIsIFwiXFxcXG1hdGhwdW5jdFwiLCBcIlxcXFxtYXRoaW5uZXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZi5mdW5jTmFtZTtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG1jbGFzczogXCJtXCIgKyBmdW5jTmFtZS5zdWJzdHIoNSksXG4gICAgICBib2R5OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBtY2xhc3NfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IG1jbGFzc19tYXRobWxCdWlsZGVyXG59KTtcbnZhciBiaW5yZWxDbGFzcyA9IGZ1bmN0aW9uIGJpbnJlbENsYXNzKGFyZykge1xuICAvLyBcXGJpbnJlbEAgc3BhY2luZyB2YXJpZXMgd2l0aCAoYmlufHJlbHxvcmQpIG9mIHRoZSBhdG9tIGluIHRoZSBhcmd1bWVudC5cbiAgLy8gKGJ5IHJlbmRlcmluZyBzZXBhcmF0ZWx5IGFuZCB3aXRoIHt9cyBiZWZvcmUgYW5kIGFmdGVyLCBhbmQgbWVhc3VyaW5nXG4gIC8vIHRoZSBjaGFuZ2UgaW4gc3BhY2luZykuICBXZSdsbCBkbyByb3VnaGx5IHRoZSBzYW1lIGJ5IGRldGVjdGluZyB0aGVcbiAgLy8gYXRvbSB0eXBlIGRpcmVjdGx5LlxuICB2YXIgYXRvbSA9IGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIgJiYgYXJnLmJvZHkubGVuZ3RoID8gYXJnLmJvZHlbMF0gOiBhcmc7XG5cbiAgaWYgKGF0b20udHlwZSA9PT0gXCJhdG9tXCIgJiYgKGF0b20uZmFtaWx5ID09PSBcImJpblwiIHx8IGF0b20uZmFtaWx5ID09PSBcInJlbFwiKSkge1xuICAgIHJldHVybiBcIm1cIiArIGF0b20uZmFtaWx5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm1vcmRcIjtcbiAgfVxufTsgLy8gXFxAYmlucmVse3h9e3l9IHJlbmRlcnMgbGlrZSB5IGJ1dCBhcyBtYmluL21yZWwvbW9yZCBpZiB4IGlzIG1iaW4vbXJlbC9tb3JkLlxuLy8gVGhpcyBpcyBlcXVpdmFsZW50IHRvIFxcYmlucmVsQHt4fVxcYmlucmVsQEB7eX0gaW4gQU1TVGVYLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcQGJpbnJlbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZjIsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZjIucGFyc2VyO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1jbGFzc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBtY2xhc3M6IGJpbnJlbENsYXNzKGFyZ3NbMF0pLFxuICAgICAgYm9keTogW2FyZ3NbMV1dXG4gICAgfTtcbiAgfVxufSk7IC8vIEJ1aWxkIGEgcmVsYXRpb24gb3Igc3RhY2tlZCBvcCBieSBwbGFjaW5nIG9uZSBzeW1ib2wgb24gdG9wIG9mIGFub3RoZXJcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1jbGFzc1wiLFxuICBuYW1lczogW1wiXFxcXHN0YWNrcmVsXCIsIFwiXFxcXG92ZXJzZXRcIiwgXCJcXFxcdW5kZXJzZXRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMlxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYzLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYzLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmMy5mdW5jTmFtZTtcbiAgICB2YXIgYmFzZUFyZyA9IGFyZ3NbMV07XG4gICAgdmFyIHNoaWZ0ZWRBcmcgPSBhcmdzWzBdO1xuICAgIHZhciBtY2xhc3M7XG5cbiAgICBpZiAoZnVuY05hbWUgIT09IFwiXFxcXHN0YWNrcmVsXCIpIHtcbiAgICAgIC8vIExhVGVYIGFwcGxpZXMgXFxiaW5yZWwgc3BhY2luZyB0byBcXG92ZXJzZXQgYW5kIFxcdW5kZXJzZXQuXG4gICAgICBtY2xhc3MgPSBiaW5yZWxDbGFzcyhiYXNlQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWNsYXNzID0gXCJtcmVsXCI7IC8vIGZvciBcXHN0YWNrcmVsXG4gICAgfVxuXG4gICAgdmFyIGJhc2VPcCA9IHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IGJhc2VBcmcubW9kZSxcbiAgICAgIGxpbWl0czogdHJ1ZSxcbiAgICAgIGFsd2F5c0hhbmRsZVN1cFN1YjogdHJ1ZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBzdXBwcmVzc0Jhc2VTaGlmdDogZnVuY05hbWUgIT09IFwiXFxcXHN0YWNrcmVsXCIsXG4gICAgICBib2R5OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChiYXNlQXJnKVxuICAgIH07XG4gICAgdmFyIHN1cHN1YiA9IHtcbiAgICAgIHR5cGU6IFwic3Vwc3ViXCIsXG4gICAgICBtb2RlOiBzaGlmdGVkQXJnLm1vZGUsXG4gICAgICBiYXNlOiBiYXNlT3AsXG4gICAgICBzdXA6IGZ1bmNOYW1lID09PSBcIlxcXFx1bmRlcnNldFwiID8gbnVsbCA6IHNoaWZ0ZWRBcmcsXG4gICAgICBzdWI6IGZ1bmNOYW1lID09PSBcIlxcXFx1bmRlcnNldFwiID8gc2hpZnRlZEFyZyA6IG51bGxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1jbGFzc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBtY2xhc3M6IG1jbGFzcyxcbiAgICAgIGJvZHk6IFtzdXBzdWJdXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IG1jbGFzc19odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogbWNsYXNzX21hdGhtbEJ1aWxkZXJcbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2ZvbnQuanNcbi8vIFRPRE8oa2V2aW5iKTogaW1wbGVtZW50IFxcXFxzbCBhbmQgXFxcXHNjXG5cblxuXG5cblxudmFyIGZvbnRfaHRtbEJ1aWxkZXIgPSBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICB2YXIgZm9udCA9IGdyb3VwLmZvbnQ7XG4gIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoRm9udChmb250KTtcbiAgcmV0dXJuIGJ1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG5ld09wdGlvbnMpO1xufTtcblxudmFyIGZvbnRfbWF0aG1sQnVpbGRlciA9IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgdmFyIGZvbnQgPSBncm91cC5mb250O1xuICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aEZvbnQoZm9udCk7XG4gIHJldHVybiBidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG5ld09wdGlvbnMpO1xufTtcblxudmFyIGZvbnRBbGlhc2VzID0ge1xuICBcIlxcXFxCYmJcIjogXCJcXFxcbWF0aGJiXCIsXG4gIFwiXFxcXGJvbGRcIjogXCJcXFxcbWF0aGJmXCIsXG4gIFwiXFxcXGZyYWtcIjogXCJcXFxcbWF0aGZyYWtcIixcbiAgXCJcXFxcYm1cIjogXCJcXFxcYm9sZHN5bWJvbFwiXG59O1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImZvbnRcIixcbiAgbmFtZXM6IFsvLyBzdHlsZXMsIGV4Y2VwdCBcXGJvbGRzeW1ib2wgZGVmaW5lZCBiZWxvd1xuICBcIlxcXFxtYXRocm1cIiwgXCJcXFxcbWF0aGl0XCIsIFwiXFxcXG1hdGhiZlwiLCBcIlxcXFxtYXRobm9ybWFsXCIsIC8vIGZhbWlsaWVzXG4gIFwiXFxcXG1hdGhiYlwiLCBcIlxcXFxtYXRoY2FsXCIsIFwiXFxcXG1hdGhmcmFrXCIsIFwiXFxcXG1hdGhzY3JcIiwgXCJcXFxcbWF0aHNmXCIsIFwiXFxcXG1hdGh0dFwiLCAvLyBhbGlhc2VzLCBleGNlcHQgXFxibSBkZWZpbmVkIGJlbG93XG4gIFwiXFxcXEJiYlwiLCBcIlxcXFxib2xkXCIsIFwiXFxcXGZyYWtcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBncmVlZGluZXNzOiAyXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICB2YXIgZnVuYyA9IGZ1bmNOYW1lO1xuXG4gICAgaWYgKGZ1bmMgaW4gZm9udEFsaWFzZXMpIHtcbiAgICAgIGZ1bmMgPSBmb250QWxpYXNlc1tmdW5jXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmb250XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGZvbnQ6IGZ1bmMuc2xpY2UoMSksXG4gICAgICBib2R5OiBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZvbnRfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGZvbnRfbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcYm9sZHN5bWJvbFwiLCBcIlxcXFxibVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGdyZWVkaW5lc3M6IDJcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmMiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmMi5wYXJzZXI7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdOyAvLyBhbXNic3kuc3R5J3MgXFxib2xkc3ltYm9sIHVzZXMgXFxiaW5yZWwgc3BhY2luZyB0byBpbmhlcml0IHRoZVxuICAgIC8vIGFyZ3VtZW50J3MgYmlufHJlbHxvcmQgc3RhdHVzXG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtY2xhc3NcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbWNsYXNzOiBiaW5yZWxDbGFzcyhib2R5KSxcbiAgICAgIGJvZHk6IFt7XG4gICAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgZm9udDogXCJib2xkc3ltYm9sXCIsXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICAgIH1dXG4gICAgfTtcbiAgfVxufSk7IC8vIE9sZCBmb250IGNoYW5naW5nIGZ1bmN0aW9uc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZm9udFwiLFxuICBuYW1lczogW1wiXFxcXHJtXCIsIFwiXFxcXHNmXCIsIFwiXFxcXHR0XCIsIFwiXFxcXGJmXCIsIFwiXFxcXGl0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYzLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYzLnBhcnNlcixcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmMy5mdW5jTmFtZSxcbiAgICAgICAgYnJlYWtPblRva2VuVGV4dCA9IF9yZWYzLmJyZWFrT25Ub2tlblRleHQ7XG4gICAgdmFyIG1vZGUgPSBwYXJzZXIubW9kZTtcbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCk7XG4gICAgdmFyIHN0eWxlID0gXCJtYXRoXCIgKyBmdW5jTmFtZS5zbGljZSgxKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmb250XCIsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgZm9udDogc3R5bGUsXG4gICAgICBib2R5OiB7XG4gICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZm9udF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogZm9udF9tYXRobWxCdWlsZGVyXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9nZW5mcmFjLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGdlbmZyYWNfYWRqdXN0U3R5bGUgPSBmdW5jdGlvbiBhZGp1c3RTdHlsZShzaXplLCBvcmlnaW5hbFN0eWxlKSB7XG4gIC8vIEZpZ3VyZSBvdXQgd2hhdCBzdHlsZSB0aGlzIGZyYWN0aW9uIHNob3VsZCBiZSBpbiBiYXNlZCBvbiB0aGVcbiAgLy8gZnVuY3Rpb24gdXNlZFxuICB2YXIgc3R5bGUgPSBvcmlnaW5hbFN0eWxlO1xuXG4gIGlmIChzaXplID09PSBcImRpc3BsYXlcIikge1xuICAgIC8vIEdldCBkaXNwbGF5IHN0eWxlIGFzIGEgZGVmYXVsdC5cbiAgICAvLyBJZiBpbmNvbWluZyBzdHlsZSBpcyBzdWIvc3VwLCB1c2Ugc3R5bGUudGV4dCgpIHRvIGdldCBjb3JyZWN0IHNpemUuXG4gICAgc3R5bGUgPSBzdHlsZS5pZCA+PSBzcmNfU3R5bGUuU0NSSVBULmlkID8gc3R5bGUudGV4dCgpIDogc3JjX1N0eWxlLkRJU1BMQVk7XG4gIH0gZWxzZSBpZiAoc2l6ZSA9PT0gXCJ0ZXh0XCIgJiYgc3R5bGUuc2l6ZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkuc2l6ZSkge1xuICAgIC8vIFdlJ3JlIGluIGEgXFx0ZnJhYyBidXQgaW5jb21pbmcgc3R5bGUgaXMgZGlzcGxheXN0eWxlLCBzbzpcbiAgICBzdHlsZSA9IHNyY19TdHlsZS5URVhUO1xuICB9IGVsc2UgaWYgKHNpemUgPT09IFwic2NyaXB0XCIpIHtcbiAgICBzdHlsZSA9IHNyY19TdHlsZS5TQ1JJUFQ7XG4gIH0gZWxzZSBpZiAoc2l6ZSA9PT0gXCJzY3JpcHRzY3JpcHRcIikge1xuICAgIHN0eWxlID0gc3JjX1N0eWxlLlNDUklQVFNDUklQVDtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnZhciBnZW5mcmFjX2h0bWxCdWlsZGVyID0gZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgLy8gRnJhY3Rpb25zIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIG9uIHBhZ2VzIDQ0NC00NDUsIHJ1bGVzIDE1KGEtZSkuXG4gIHZhciBzdHlsZSA9IGdlbmZyYWNfYWRqdXN0U3R5bGUoZ3JvdXAuc2l6ZSwgb3B0aW9ucy5zdHlsZSk7XG4gIHZhciBuc3R5bGUgPSBzdHlsZS5mcmFjTnVtKCk7XG4gIHZhciBkc3R5bGUgPSBzdHlsZS5mcmFjRGVuKCk7XG4gIHZhciBuZXdPcHRpb25zO1xuICBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShuc3R5bGUpO1xuICB2YXIgbnVtZXJtID0gYnVpbGRIVE1MX2J1aWxkR3JvdXAoZ3JvdXAubnVtZXIsIG5ld09wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIGlmIChncm91cC5jb250aW51ZWQpIHtcbiAgICAvLyBcXGNmcmFjIGluc2VydHMgYSBcXHN0cnV0IGludG8gdGhlIG51bWVyYXRvci5cbiAgICAvLyBHZXQgXFxzdHJ1dCBkaW1lbnNpb25zIGZyb20gVGVYYm9vayBwYWdlIDM1My5cbiAgICB2YXIgaFN0cnV0ID0gOC41IC8gb3B0aW9ucy5mb250TWV0cmljcygpLnB0UGVyRW07XG4gICAgdmFyIGRTdHJ1dCA9IDMuNSAvIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtO1xuICAgIG51bWVybS5oZWlnaHQgPSBudW1lcm0uaGVpZ2h0IDwgaFN0cnV0ID8gaFN0cnV0IDogbnVtZXJtLmhlaWdodDtcbiAgICBudW1lcm0uZGVwdGggPSBudW1lcm0uZGVwdGggPCBkU3RydXQgPyBkU3RydXQgOiBudW1lcm0uZGVwdGg7XG4gIH1cblxuICBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShkc3R5bGUpO1xuICB2YXIgZGVub21tID0gYnVpbGRIVE1MX2J1aWxkR3JvdXAoZ3JvdXAuZGVub20sIG5ld09wdGlvbnMsIG9wdGlvbnMpO1xuICB2YXIgcnVsZTtcbiAgdmFyIHJ1bGVXaWR0aDtcbiAgdmFyIHJ1bGVTcGFjaW5nO1xuXG4gIGlmIChncm91cC5oYXNCYXJMaW5lKSB7XG4gICAgaWYgKGdyb3VwLmJhclNpemUpIHtcbiAgICAgIHJ1bGVXaWR0aCA9IHVuaXRzX2NhbGN1bGF0ZVNpemUoZ3JvdXAuYmFyU2l6ZSwgb3B0aW9ucyk7XG4gICAgICBydWxlID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwiZnJhYy1saW5lXCIsIG9wdGlvbnMsIHJ1bGVXaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1bGUgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oXCJmcmFjLWxpbmVcIiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcnVsZVdpZHRoID0gcnVsZS5oZWlnaHQ7XG4gICAgcnVsZVNwYWNpbmcgPSBydWxlLmhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICBydWxlID0gbnVsbDtcbiAgICBydWxlV2lkdGggPSAwO1xuICAgIHJ1bGVTcGFjaW5nID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICB9IC8vIFJ1bGUgMTViXG5cblxuICB2YXIgbnVtU2hpZnQ7XG4gIHZhciBjbGVhcmFuY2U7XG4gIHZhciBkZW5vbVNoaWZ0O1xuXG4gIGlmIChzdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplIHx8IGdyb3VwLnNpemUgPT09IFwiZGlzcGxheVwiKSB7XG4gICAgbnVtU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkubnVtMTtcblxuICAgIGlmIChydWxlV2lkdGggPiAwKSB7XG4gICAgICBjbGVhcmFuY2UgPSAzICogcnVsZVNwYWNpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyYW5jZSA9IDcgKiBydWxlU3BhY2luZztcbiAgICB9XG5cbiAgICBkZW5vbVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlbm9tMTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgbnVtU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkubnVtMjtcbiAgICAgIGNsZWFyYW5jZSA9IHJ1bGVTcGFjaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1TaGlmdCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5udW0zO1xuICAgICAgY2xlYXJhbmNlID0gMyAqIHJ1bGVTcGFjaW5nO1xuICAgIH1cblxuICAgIGRlbm9tU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVub20yO1xuICB9XG5cbiAgdmFyIGZyYWM7XG5cbiAgaWYgKCFydWxlKSB7XG4gICAgLy8gUnVsZSAxNWNcbiAgICB2YXIgY2FuZGlkYXRlQ2xlYXJhbmNlID0gbnVtU2hpZnQgLSBudW1lcm0uZGVwdGggLSAoZGVub21tLmhlaWdodCAtIGRlbm9tU2hpZnQpO1xuXG4gICAgaWYgKGNhbmRpZGF0ZUNsZWFyYW5jZSA8IGNsZWFyYW5jZSkge1xuICAgICAgbnVtU2hpZnQgKz0gMC41ICogKGNsZWFyYW5jZSAtIGNhbmRpZGF0ZUNsZWFyYW5jZSk7XG4gICAgICBkZW5vbVNoaWZ0ICs9IDAuNSAqIChjbGVhcmFuY2UgLSBjYW5kaWRhdGVDbGVhcmFuY2UpO1xuICAgIH1cblxuICAgIGZyYWMgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBkZW5vbW0sXG4gICAgICAgIHNoaWZ0OiBkZW5vbVNoaWZ0XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBudW1lcm0sXG4gICAgICAgIHNoaWZ0OiAtbnVtU2hpZnRcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUnVsZSAxNWRcbiAgICB2YXIgYXhpc0hlaWdodCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0O1xuXG4gICAgaWYgKG51bVNoaWZ0IC0gbnVtZXJtLmRlcHRoIC0gKGF4aXNIZWlnaHQgKyAwLjUgKiBydWxlV2lkdGgpIDwgY2xlYXJhbmNlKSB7XG4gICAgICBudW1TaGlmdCArPSBjbGVhcmFuY2UgLSAobnVtU2hpZnQgLSBudW1lcm0uZGVwdGggLSAoYXhpc0hlaWdodCArIDAuNSAqIHJ1bGVXaWR0aCkpO1xuICAgIH1cblxuICAgIGlmIChheGlzSGVpZ2h0IC0gMC41ICogcnVsZVdpZHRoIC0gKGRlbm9tbS5oZWlnaHQgLSBkZW5vbVNoaWZ0KSA8IGNsZWFyYW5jZSkge1xuICAgICAgZGVub21TaGlmdCArPSBjbGVhcmFuY2UgLSAoYXhpc0hlaWdodCAtIDAuNSAqIHJ1bGVXaWR0aCAtIChkZW5vbW0uaGVpZ2h0IC0gZGVub21TaGlmdCkpO1xuICAgIH1cblxuICAgIHZhciBtaWRTaGlmdCA9IC0oYXhpc0hlaWdodCAtIDAuNSAqIHJ1bGVXaWR0aCk7XG4gICAgZnJhYyA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGRlbm9tbSxcbiAgICAgICAgc2hpZnQ6IGRlbm9tU2hpZnRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHJ1bGUsXG4gICAgICAgIHNoaWZ0OiBtaWRTaGlmdFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbnVtZXJtLFxuICAgICAgICBzaGlmdDogLW51bVNoaWZ0XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IC8vIFNpbmNlIHdlIG1hbnVhbGx5IGNoYW5nZSB0aGUgc3R5bGUgc29tZXRpbWVzICh3aXRoIFxcZGZyYWMgb3IgXFx0ZnJhYyksXG4gIC8vIGFjY291bnQgZm9yIHRoZSBwb3NzaWJsZSBzaXplIGNoYW5nZSBoZXJlLlxuXG5cbiAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUpO1xuICBmcmFjLmhlaWdodCAqPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgZnJhYy5kZXB0aCAqPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjsgLy8gUnVsZSAxNWVcblxuICB2YXIgZGVsaW1TaXplO1xuXG4gIGlmIChzdHlsZS5zaXplID09PSBzcmNfU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgZGVsaW1TaXplID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlbGltMTtcbiAgfSBlbHNlIHtcbiAgICBkZWxpbVNpemUgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVsaW0yO1xuICB9XG5cbiAgdmFyIGxlZnREZWxpbTtcbiAgdmFyIHJpZ2h0RGVsaW07XG5cbiAgaWYgKGdyb3VwLmxlZnREZWxpbSA9PSBudWxsKSB7XG4gICAgbGVmdERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibW9wZW5cIl0pO1xuICB9IGVsc2Uge1xuICAgIGxlZnREZWxpbSA9IGRlbGltaXRlci5jdXN0b21TaXplZERlbGltKGdyb3VwLmxlZnREZWxpbSwgZGVsaW1TaXplLCB0cnVlLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlKSwgZ3JvdXAubW9kZSwgW1wibW9wZW5cIl0pO1xuICB9XG5cbiAgaWYgKGdyb3VwLmNvbnRpbnVlZCkge1xuICAgIHJpZ2h0RGVsaW0gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSk7IC8vIHplcm8gd2lkdGggZm9yIFxcY2ZyYWNcbiAgfSBlbHNlIGlmIChncm91cC5yaWdodERlbGltID09IG51bGwpIHtcbiAgICByaWdodERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibWNsb3NlXCJdKTtcbiAgfSBlbHNlIHtcbiAgICByaWdodERlbGltID0gZGVsaW1pdGVyLmN1c3RvbVNpemVkRGVsaW0oZ3JvdXAucmlnaHREZWxpbSwgZGVsaW1TaXplLCB0cnVlLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlKSwgZ3JvdXAubW9kZSwgW1wibWNsb3NlXCJdKTtcbiAgfVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLmNvbmNhdChuZXdPcHRpb25zLnNpemluZ0NsYXNzZXMob3B0aW9ucykpLCBbbGVmdERlbGltLCBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtZnJhY1wiXSwgW2ZyYWNdKSwgcmlnaHREZWxpbV0sIG9wdGlvbnMpO1xufTtcblxudmFyIGdlbmZyYWNfbWF0aG1sQnVpbGRlciA9IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1mcmFjXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLm51bWVyLCBvcHRpb25zKSwgYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5kZW5vbSwgb3B0aW9ucyldKTtcblxuICBpZiAoIWdyb3VwLmhhc0JhckxpbmUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImxpbmV0aGlja25lc3NcIiwgXCIwcHhcIik7XG4gIH0gZWxzZSBpZiAoZ3JvdXAuYmFyU2l6ZSkge1xuICAgIHZhciBydWxlV2lkdGggPSB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLmJhclNpemUsIG9wdGlvbnMpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibGluZXRoaWNrbmVzc1wiLCBydWxlV2lkdGggKyBcImVtXCIpO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZ2VuZnJhY19hZGp1c3RTdHlsZShncm91cC5zaXplLCBvcHRpb25zLnN0eWxlKTtcblxuICBpZiAoc3R5bGUuc2l6ZSAhPT0gb3B0aW9ucy5zdHlsZS5zaXplKSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXN0eWxlXCIsIFtub2RlXSk7XG4gICAgdmFyIGlzRGlzcGxheSA9IHN0eWxlLnNpemUgPT09IHNyY19TdHlsZS5ESVNQTEFZLnNpemUgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBpc0Rpc3BsYXkpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIwXCIpO1xuICB9XG5cbiAgaWYgKGdyb3VwLmxlZnREZWxpbSAhPSBudWxsIHx8IGdyb3VwLnJpZ2h0RGVsaW0gIT0gbnVsbCkge1xuICAgIHZhciB3aXRoRGVsaW1zID0gW107XG5cbiAgICBpZiAoZ3JvdXAubGVmdERlbGltICE9IG51bGwpIHtcbiAgICAgIHZhciBsZWZ0T3AgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC5sZWZ0RGVsaW0ucmVwbGFjZShcIlxcXFxcIiwgXCJcIikpXSk7XG4gICAgICBsZWZ0T3Auc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgICAgd2l0aERlbGltcy5wdXNoKGxlZnRPcCk7XG4gICAgfVxuXG4gICAgd2l0aERlbGltcy5wdXNoKG5vZGUpO1xuXG4gICAgaWYgKGdyb3VwLnJpZ2h0RGVsaW0gIT0gbnVsbCkge1xuICAgICAgdmFyIHJpZ2h0T3AgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC5yaWdodERlbGltLnJlcGxhY2UoXCJcXFxcXCIsIFwiXCIpKV0pO1xuICAgICAgcmlnaHRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgICB3aXRoRGVsaW1zLnB1c2gocmlnaHRPcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWxkTWF0aE1MX21ha2VSb3cod2l0aERlbGltcyk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXCJcXFxcY2ZyYWNcIiwgXCJcXFxcZGZyYWNcIiwgXCJcXFxcZnJhY1wiLCBcIlxcXFx0ZnJhY1wiLCBcIlxcXFxkYmlub21cIiwgXCJcXFxcYmlub21cIiwgXCJcXFxcdGJpbm9tXCIsIFwiXFxcXFxcXFxhdG9wZnJhY1wiLCAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbiAgXCJcXFxcXFxcXGJyYWNlZnJhY1wiLCBcIlxcXFxcXFxcYnJhY2tmcmFjXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgZ3JlZWRpbmVzczogMlxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZi5mdW5jTmFtZTtcbiAgICB2YXIgbnVtZXIgPSBhcmdzWzBdO1xuICAgIHZhciBkZW5vbSA9IGFyZ3NbMV07XG4gICAgdmFyIGhhc0JhckxpbmU7XG4gICAgdmFyIGxlZnREZWxpbSA9IG51bGw7XG4gICAgdmFyIHJpZ2h0RGVsaW0gPSBudWxsO1xuICAgIHZhciBzaXplID0gXCJhdXRvXCI7XG5cbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXGNmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXGRmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXGZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcdGZyYWNcIjpcbiAgICAgICAgaGFzQmFyTGluZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXFxcXFxhdG9wZnJhY1wiOlxuICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgY2FzZSBcIlxcXFxiaW5vbVwiOlxuICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgaGFzQmFyTGluZSA9IGZhbHNlO1xuICAgICAgICBsZWZ0RGVsaW0gPSBcIihcIjtcbiAgICAgICAgcmlnaHREZWxpbSA9IFwiKVwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxcXFxcYnJhY2VmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgbGVmdERlbGltID0gXCJcXFxce1wiO1xuICAgICAgICByaWdodERlbGltID0gXCJcXFxcfVwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxcXFxcYnJhY2tmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgbGVmdERlbGltID0gXCJbXCI7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSBcIl1cIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBnZW5mcmFjIGNvbW1hbmRcIik7XG4gICAgfVxuXG4gICAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgICAgY2FzZSBcIlxcXFxjZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFxkYmlub21cIjpcbiAgICAgICAgc2l6ZSA9IFwiZGlzcGxheVwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFx0ZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgc2l6ZSA9IFwidGV4dFwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGNvbnRpbnVlZDogZnVuY05hbWUgPT09IFwiXFxcXGNmcmFjXCIsXG4gICAgICBudW1lcjogbnVtZXIsXG4gICAgICBkZW5vbTogZGVub20sXG4gICAgICBoYXNCYXJMaW5lOiBoYXNCYXJMaW5lLFxuICAgICAgbGVmdERlbGltOiBsZWZ0RGVsaW0sXG4gICAgICByaWdodERlbGltOiByaWdodERlbGltLFxuICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgIGJhclNpemU6IG51bGxcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZ2VuZnJhY19odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogZ2VuZnJhY19tYXRobWxCdWlsZGVyXG59KTsgLy8gSW5maXggZ2VuZXJhbGl6ZWQgZnJhY3Rpb25zIC0tIHRoZXNlIGFyZSBub3QgcmVuZGVyZWQgZGlyZWN0bHksIGJ1dCByZXBsYWNlZFxuLy8gaW1tZWRpYXRlbHkgYnkgb25lIG9mIHRoZSB2YXJpYW50cyBhYm92ZS5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluZml4XCIsXG4gIG5hbWVzOiBbXCJcXFxcb3ZlclwiLCBcIlxcXFxjaG9vc2VcIiwgXCJcXFxcYXRvcFwiLCBcIlxcXFxicmFjZVwiLCBcIlxcXFxicmFja1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGluZml4OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZjIpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZjIucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWYyLmZ1bmNOYW1lLFxuICAgICAgICB0b2tlbiA9IF9yZWYyLnRva2VuO1xuICAgIHZhciByZXBsYWNlV2l0aDtcblxuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcb3ZlclwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcY2hvb3NlXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcYmlub21cIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcYXRvcFwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxhdG9wZnJhY1wiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxicmFjZVwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxicmFjZWZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcYnJhY2tcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxcXFxcYnJhY2tmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgaW5maXggZ2VuZnJhYyBjb21tYW5kXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHJlcGxhY2VXaXRoOiByZXBsYWNlV2l0aCxcbiAgICAgIHRva2VuOiB0b2tlblxuICAgIH07XG4gIH1cbn0pO1xudmFyIHN0eWxBcnJheSA9IFtcImRpc3BsYXlcIiwgXCJ0ZXh0XCIsIFwic2NyaXB0XCIsIFwic2NyaXB0c2NyaXB0XCJdO1xuXG52YXIgZGVsaW1Gcm9tVmFsdWUgPSBmdW5jdGlvbiBkZWxpbUZyb21WYWx1ZShkZWxpbVN0cmluZykge1xuICB2YXIgZGVsaW0gPSBudWxsO1xuXG4gIGlmIChkZWxpbVN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgZGVsaW0gPSBkZWxpbVN0cmluZztcbiAgICBkZWxpbSA9IGRlbGltID09PSBcIi5cIiA/IG51bGwgOiBkZWxpbTtcbiAgfVxuXG4gIHJldHVybiBkZWxpbTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXCJcXFxcZ2VuZnJhY1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiA2LFxuICAgIGdyZWVkaW5lc3M6IDYsXG4gICAgYXJnVHlwZXM6IFtcIm1hdGhcIiwgXCJtYXRoXCIsIFwic2l6ZVwiLCBcInRleHRcIiwgXCJtYXRoXCIsIFwibWF0aFwiXVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYzLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYzLnBhcnNlcjtcbiAgICB2YXIgbnVtZXIgPSBhcmdzWzRdO1xuICAgIHZhciBkZW5vbSA9IGFyZ3NbNV07IC8vIExvb2sgaW50byB0aGUgcGFyc2Ugbm9kZXMgdG8gZ2V0IHRoZSBkZXNpcmVkIGRlbGltaXRlcnMuXG5cbiAgICB2YXIgbGVmdE5vZGUgPSBjaGVja05vZGVUeXBlKGFyZ3NbMF0sIFwiYXRvbVwiKTtcblxuICAgIGlmIChsZWZ0Tm9kZSkge1xuICAgICAgbGVmdE5vZGUgPSBhc3NlcnRBdG9tRmFtaWx5KGFyZ3NbMF0sIFwib3BlblwiKTtcbiAgICB9XG5cbiAgICB2YXIgbGVmdERlbGltID0gbGVmdE5vZGUgPyBkZWxpbUZyb21WYWx1ZShsZWZ0Tm9kZS50ZXh0KSA6IG51bGw7XG4gICAgdmFyIHJpZ2h0Tm9kZSA9IGNoZWNrTm9kZVR5cGUoYXJnc1sxXSwgXCJhdG9tXCIpO1xuXG4gICAgaWYgKHJpZ2h0Tm9kZSkge1xuICAgICAgcmlnaHROb2RlID0gYXNzZXJ0QXRvbUZhbWlseShhcmdzWzFdLCBcImNsb3NlXCIpO1xuICAgIH1cblxuICAgIHZhciByaWdodERlbGltID0gcmlnaHROb2RlID8gZGVsaW1Gcm9tVmFsdWUocmlnaHROb2RlLnRleHQpIDogbnVsbDtcbiAgICB2YXIgYmFyTm9kZSA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMl0sIFwic2l6ZVwiKTtcbiAgICB2YXIgaGFzQmFyTGluZTtcbiAgICB2YXIgYmFyU2l6ZSA9IG51bGw7XG5cbiAgICBpZiAoYmFyTm9kZS5pc0JsYW5rKSB7XG4gICAgICAvLyBcXGdlbmZyYWMgYWN0cyBkaWZmZXJlbnRseSB0aGFuIFxcYWJvdmUuXG4gICAgICAvLyBcXGdlbmZyYWMgdHJlYXRzIGFuIGVtcHR5IHNpemUgZ3JvdXAgYXMgYSBzaWduYWwgdG8gdXNlIGFcbiAgICAgIC8vIHN0YW5kYXJkIGJhciBzaXplLiBcXGFib3ZlIHdvdWxkIHNlZSBzaXplID0gMCBhbmQgb21pdCB0aGUgYmFyLlxuICAgICAgaGFzQmFyTGluZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhclNpemUgPSBiYXJOb2RlLnZhbHVlO1xuICAgICAgaGFzQmFyTGluZSA9IGJhclNpemUubnVtYmVyID4gMDtcbiAgICB9IC8vIEZpbmQgb3V0IGlmIHdlIHdhbnQgZGlzcGxheXN0eWxlLCB0ZXh0c3R5bGUsIGV0Yy5cblxuXG4gICAgdmFyIHNpemUgPSBcImF1dG9cIjtcbiAgICB2YXIgc3R5bCA9IGNoZWNrTm9kZVR5cGUoYXJnc1szXSwgXCJvcmRncm91cFwiKTtcblxuICAgIGlmIChzdHlsKSB7XG4gICAgICBpZiAoc3R5bC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHRleHRPcmQgPSBhc3NlcnROb2RlVHlwZShzdHlsLmJvZHlbMF0sIFwidGV4dG9yZFwiKTtcbiAgICAgICAgc2l6ZSA9IHN0eWxBcnJheVtOdW1iZXIodGV4dE9yZC50ZXh0KV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWwgPSBhc3NlcnROb2RlVHlwZShhcmdzWzNdLCBcInRleHRvcmRcIik7XG4gICAgICBzaXplID0gc3R5bEFycmF5W051bWJlcihzdHlsLnRleHQpXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG51bWVyOiBudW1lcixcbiAgICAgIGRlbm9tOiBkZW5vbSxcbiAgICAgIGNvbnRpbnVlZDogZmFsc2UsXG4gICAgICBoYXNCYXJMaW5lOiBoYXNCYXJMaW5lLFxuICAgICAgYmFyU2l6ZTogYmFyU2l6ZSxcbiAgICAgIGxlZnREZWxpbTogbGVmdERlbGltLFxuICAgICAgcmlnaHREZWxpbTogcmlnaHREZWxpbSxcbiAgICAgIHNpemU6IHNpemVcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZ2VuZnJhY19odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogZ2VuZnJhY19tYXRobWxCdWlsZGVyXG59KTsgLy8gXFxhYm92ZSBpcyBhbiBpbmZpeCBmcmFjdGlvbiB0aGF0IGFsc28gZGVmaW5lcyBhIGZyYWN0aW9uIGJhciBzaXplLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW5maXhcIixcbiAgbmFtZXM6IFtcIlxcXFxhYm92ZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCJdLFxuICAgIGluZml4OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZjQsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZjQucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWY0LmZ1bmNOYW1lLFxuICAgICAgICB0b2tlbiA9IF9yZWY0LnRva2VuO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHJlcGxhY2VXaXRoOiBcIlxcXFxcXFxcYWJvdmVmcmFjXCIsXG4gICAgICBzaXplOiBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIikudmFsdWUsXG4gICAgICB0b2tlbjogdG9rZW5cbiAgICB9O1xuICB9XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXCJcXFxcXFxcXGFib3ZlZnJhY1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAzLFxuICAgIGFyZ1R5cGVzOiBbXCJtYXRoXCIsIFwic2l6ZVwiLCBcIm1hdGhcIl1cbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmNSwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmNS5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZjUuZnVuY05hbWU7XG4gICAgdmFyIG51bWVyID0gYXJnc1swXTtcbiAgICB2YXIgYmFyU2l6ZSA9IGFzc2VydChhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcImluZml4XCIpLnNpemUpO1xuICAgIHZhciBkZW5vbSA9IGFyZ3NbMl07XG4gICAgdmFyIGhhc0JhckxpbmUgPSBiYXJTaXplLm51bWJlciA+IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBudW1lcjogbnVtZXIsXG4gICAgICBkZW5vbTogZGVub20sXG4gICAgICBjb250aW51ZWQ6IGZhbHNlLFxuICAgICAgaGFzQmFyTGluZTogaGFzQmFyTGluZSxcbiAgICAgIGJhclNpemU6IGJhclNpemUsXG4gICAgICBsZWZ0RGVsaW06IG51bGwsXG4gICAgICByaWdodERlbGltOiBudWxsLFxuICAgICAgc2l6ZTogXCJhdXRvXCJcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZ2VuZnJhY19odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogZ2VuZnJhY19tYXRobWxCdWlsZGVyXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9ob3JpekJyYWNlLmpzXG5cblxuXG5cblxuXG5cblxuLy8gTk9URTogVW5saWtlIG1vc3QgYGh0bWxCdWlsZGVyYHMsIHRoaXMgb25lIGhhbmRsZXMgbm90IG9ubHkgXCJob3JpekJyYWNlXCIsIGJ1dFxudmFyIGhvcml6QnJhY2VfaHRtbEJ1aWxkZXIgPSBmdW5jdGlvbiBodG1sQnVpbGRlcihncnAsIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTsgLy8gUHVsbCBvdXQgdGhlIGBQYXJzZU5vZGU8XCJob3JpekJyYWNlXCI+YCBpZiBgZ3JwYCBpcyBhIFwic3Vwc3ViXCIgbm9kZS5cblxuICB2YXIgc3VwU3ViR3JvdXA7XG4gIHZhciBncm91cDtcbiAgdmFyIHN1cFN1YiA9IGNoZWNrTm9kZVR5cGUoZ3JwLCBcInN1cHN1YlwiKTtcblxuICBpZiAoc3VwU3ViKSB7XG4gICAgLy8gUmVmOiBMYVRlWCBzb3VyY2UyZTogfX19fVxcbGltaXRzfVxuICAgIC8vIGkuZS4gTGFUZVggdHJlYXRzIHRoZSBicmFjZSBzaW1pbGFyIHRvIGFuIG9wIGFuZCBwYXNzZXMgaXRcbiAgICAvLyB3aXRoIFxcbGltaXRzLCBzbyB3ZSBuZWVkIHRvIGFzc2lnbiBzdXBzdWIgc3R5bGUuXG4gICAgc3VwU3ViR3JvdXAgPSBzdXBTdWIuc3VwID8gYnVpbGRIVE1MX2J1aWxkR3JvdXAoc3VwU3ViLnN1cCwgb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdXAoKSksIG9wdGlvbnMpIDogYnVpbGRIVE1MX2J1aWxkR3JvdXAoc3VwU3ViLnN1Yiwgb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdWIoKSksIG9wdGlvbnMpO1xuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoc3VwU3ViLmJhc2UsIFwiaG9yaXpCcmFjZVwiKTtcbiAgfSBlbHNlIHtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycCwgXCJob3JpekJyYWNlXCIpO1xuICB9IC8vIEJ1aWxkIHRoZSBiYXNlIGdyb3VwXG5cblxuICB2YXIgYm9keSA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmJhc2UsIG9wdGlvbnMuaGF2aW5nQmFzZVN0eWxlKHNyY19TdHlsZS5ESVNQTEFZKSk7IC8vIENyZWF0ZSB0aGUgc3RyZXRjaHkgZWxlbWVudFxuXG4gIHZhciBicmFjZUJvZHkgPSBzdHJldGNoeS5zdmdTcGFuKGdyb3VwLCBvcHRpb25zKTsgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJucyAgICAgICAg4pSP4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSTXG4gIC8vIFRoaXMgZmlyc3Qgdmxpc3QgY29udGFpbnMgdGhlIGNvbnRlbnQgYW5kIHRoZSBicmFjZTogICBlcXVhdGlvblxuXG4gIHZhciB2bGlzdDtcblxuICBpZiAoZ3JvdXAuaXNPdmVyKSB7XG4gICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogMC4xXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBicmFjZUJvZHlcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7IC8vICRGbG93Rml4TWU6IFJlcGxhY2UgdGhpcyB3aXRoIHBhc3NpbmcgXCJzdmctYWxpZ25cIiBpbnRvIG1ha2VWTGlzdC5cblxuICAgIHZsaXN0LmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzFdLmNsYXNzZXMucHVzaChcInN2Zy1hbGlnblwiKTtcbiAgfSBlbHNlIHtcbiAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IGJvZHkuZGVwdGggKyAwLjEgKyBicmFjZUJvZHkuaGVpZ2h0LFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBicmFjZUJvZHlcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IDAuMVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTsgLy8gJEZsb3dGaXhNZTogUmVwbGFjZSB0aGlzIHdpdGggcGFzc2luZyBcInN2Zy1hbGlnblwiIGludG8gbWFrZVZMaXN0LlxuXG4gICAgdmxpc3QuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2xhc3Nlcy5wdXNoKFwic3ZnLWFsaWduXCIpO1xuICB9XG5cbiAgaWYgKHN1cFN1Ykdyb3VwKSB7XG4gICAgLy8gVG8gd3JpdGUgdGhlIHN1cHN1Yiwgd3JhcCB0aGUgZmlyc3Qgdmxpc3QgaW4gYW5vdGhlciB2bGlzdDpcbiAgICAvLyBUaGV5IGNhbid0IGFsbCBnbyBpbiB0aGUgc2FtZSB2bGlzdCwgYmVjYXVzZSB0aGUgbm90ZSBtaWdodCBiZVxuICAgIC8vIHdpZGVyIHRoYW4gdGhlIGVxdWF0aW9uLiBXZSB3YW50IHRoZSBlcXVhdGlvbiB0byBjb250cm9sIHRoZVxuICAgIC8vIGJyYWNlIHdpZHRoLlxuICAgIC8vICAgICAgbm90ZSAgICAgICAgICBsb25nIG5vdGUgICAgICAgICAgIGxvbmcgbm90ZVxuICAgIC8vICAg4pSP4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSTICAgb3IgICAg4pSP4pSB4pSB4pSB4pSTICAgICBub3QgICAg4pSP4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSTXG4gICAgLy8gICAgZXF1YXRpb24gICAgICAgICAgIGVxbiAgICAgICAgICAgICAgICAgZXFuXG4gICAgdmFyIHZTcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBncm91cC5pc092ZXIgPyBcIm1vdmVyXCIgOiBcIm11bmRlclwiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoZ3JvdXAuaXNPdmVyKSB7XG4gICAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHZTcGFuXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgICBzaXplOiAwLjJcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHN1cFN1Ykdyb3VwXG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgICAgIHBvc2l0aW9uRGF0YTogdlNwYW4uZGVwdGggKyAwLjIgKyBzdXBTdWJHcm91cC5oZWlnaHQgKyBzdXBTdWJHcm91cC5kZXB0aCxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogc3VwU3ViR3JvdXBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICAgIHNpemU6IDAuMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogdlNwYW5cbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIGdyb3VwLmlzT3ZlciA/IFwibW92ZXJcIiA6IFwibXVuZGVyXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbn07XG5cbnZhciBob3JpekJyYWNlX21hdGhtbEJ1aWxkZXIgPSBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBhY2NlbnROb2RlID0gc3RyZXRjaHkubWF0aE1Mbm9kZShncm91cC5sYWJlbCk7XG4gIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShncm91cC5pc092ZXIgPyBcIm1vdmVyXCIgOiBcIm11bmRlclwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5iYXNlLCBvcHRpb25zKSwgYWNjZW50Tm9kZV0pO1xufTsgLy8gSG9yaXpvbnRhbCBzdHJldGNoeSBicmFjZXNcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaG9yaXpCcmFjZVwiLFxuICBuYW1lczogW1wiXFxcXG92ZXJicmFjZVwiLCBcIlxcXFx1bmRlcmJyYWNlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWYuZnVuY05hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaG9yaXpCcmFjZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBpc092ZXI6IC9eXFxcXG92ZXIvLnRlc3QoZnVuY05hbWUpLFxuICAgICAgYmFzZTogYXJnc1swXVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBob3JpekJyYWNlX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBob3JpekJyYWNlX21hdGhtbEJ1aWxkZXJcbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2hyZWYuanNcblxuXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJocmVmXCIsXG4gIG5hbWVzOiBbXCJcXFxcaHJlZlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFyZ1R5cGVzOiBbXCJ1cmxcIiwgXCJvcmlnaW5hbFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMV07XG4gICAgdmFyIGhyZWYgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInVybFwiKS51cmw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHJlZlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBocmVmOiBocmVmLFxuICAgICAgYm9keTogZGVmaW5lRnVuY3Rpb25fb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIGZhbHNlKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUFuY2hvcihncm91cC5ocmVmLCBbXSwgZWxlbWVudHMsIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG1hdGggPSBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIShtYXRoIGluc3RhbmNlb2YgbWF0aE1MVHJlZV9NYXRoTm9kZSkpIHtcbiAgICAgIG1hdGggPSBuZXcgbWF0aE1MVHJlZV9NYXRoTm9kZShcIm1yb3dcIiwgW21hdGhdKTtcbiAgICB9XG5cbiAgICBtYXRoLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgZ3JvdXAuaHJlZik7XG4gICAgcmV0dXJuIG1hdGg7XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhyZWZcIixcbiAgbmFtZXM6IFtcIlxcXFx1cmxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widXJsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmMiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmMi5wYXJzZXI7XG4gICAgdmFyIGhyZWYgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInVybFwiKS51cmw7XG4gICAgdmFyIGNoYXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhyZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gaHJlZltpXTtcblxuICAgICAgaWYgKGMgPT09IFwiflwiKSB7XG4gICAgICAgIGMgPSBcIlxcXFx0ZXh0YXNjaWl0aWxkZVwiO1xuICAgICAgfVxuXG4gICAgICBjaGFycy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICB0ZXh0OiBjXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYm9keSA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmb250OiBcIlxcXFx0ZXh0dHRcIixcbiAgICAgIGJvZHk6IGNoYXJzXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJocmVmXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGhyZWY6IGhyZWYsXG4gICAgICBib2R5OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2h0bWxtYXRobWwuanNcblxuXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImh0bWxtYXRobWxcIixcbiAgbmFtZXM6IFtcIlxcXFxodG1sQG1hdGhtbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImh0bWxtYXRobWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgaHRtbDogZGVmaW5lRnVuY3Rpb25fb3JkYXJndW1lbnQoYXJnc1swXSksXG4gICAgICBtYXRobWw6IGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50KGFyZ3NbMV0pXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRIVE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5odG1sLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLm1hdGhtbCwgb3B0aW9ucyk7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2tlcm4uanNcbi8vIEhvcml6b250YWwgc3BhY2luZyBjb21tYW5kc1xuXG5cblxuXG4gLy8gVE9ETzogXFxoc2tpcCBhbmQgXFxtc2tpcCBzaG91bGQgc3VwcG9ydCBwbHVzIGFuZCBtaW51cyBpbiBsZW5ndGhzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJrZXJuXCIsXG4gIG5hbWVzOiBbXCJcXFxca2VyblwiLCBcIlxcXFxta2VyblwiLCBcIlxcXFxoc2tpcFwiLCBcIlxcXFxtc2tpcFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWYuZnVuY05hbWU7XG4gICAgdmFyIHNpemUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIik7XG5cbiAgICBpZiAocGFyc2VyLnNldHRpbmdzLnN0cmljdCkge1xuICAgICAgdmFyIG1hdGhGdW5jdGlvbiA9IGZ1bmNOYW1lWzFdID09PSAnbSc7IC8vIFxcbWtlcm4sIFxcbXNraXBcblxuICAgICAgdmFyIG11VW5pdCA9IHNpemUudmFsdWUudW5pdCA9PT0gJ211JztcblxuICAgICAgaWYgKG1hdGhGdW5jdGlvbikge1xuICAgICAgICBpZiAoIW11VW5pdCkge1xuICAgICAgICAgIHBhcnNlci5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJtYXRoVnNUZXh0VW5pdHNcIiwgXCJMYVRlWCdzIFwiICsgZnVuY05hbWUgKyBcIiBzdXBwb3J0cyBvbmx5IG11IHVuaXRzLCBcIiArIChcIm5vdCBcIiArIHNpemUudmFsdWUudW5pdCArIFwiIHVuaXRzXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZXIubW9kZSAhPT0gXCJtYXRoXCIpIHtcbiAgICAgICAgICBwYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwibWF0aFZzVGV4dFVuaXRzXCIsIFwiTGFUZVgncyBcIiArIGZ1bmNOYW1lICsgXCIgd29ya3Mgb25seSBpbiBtYXRoIG1vZGVcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICFtYXRoRnVuY3Rpb25cbiAgICAgICAgaWYgKG11VW5pdCkge1xuICAgICAgICAgIHBhcnNlci5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJtYXRoVnNUZXh0VW5pdHNcIiwgXCJMYVRlWCdzIFwiICsgZnVuY05hbWUgKyBcIiBkb2Vzbid0IHN1cHBvcnQgbXUgdW5pdHNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGRpbWVuc2lvbjogc2l6ZS52YWx1ZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlR2x1ZShncm91cC5kaW1lbnNpb24sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGRpbWVuc2lvbiA9IHVuaXRzX2NhbGN1bGF0ZVNpemUoZ3JvdXAuZGltZW5zaW9uLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuU3BhY2VOb2RlKGRpbWVuc2lvbik7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL2xhcC5qc1xuLy8gSG9yaXpvbnRhbCBvdmVybGFwIGZ1bmN0aW9uc1xuXG5cblxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJsYXBcIixcbiAgbmFtZXM6IFtcIlxcXFxtYXRobGxhcFwiLCBcIlxcXFxtYXRocmxhcFwiLCBcIlxcXFxtYXRoY2xhcFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyLFxuICAgICAgICBmdW5jTmFtZSA9IF9yZWYuZnVuY05hbWU7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxhcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBhbGlnbm1lbnQ6IGZ1bmNOYW1lLnNsaWNlKDUpLFxuICAgICAgYm9keTogYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIG1hdGhsbGFwLCBtYXRocmxhcCwgbWF0aGNsYXBcbiAgICB2YXIgaW5uZXI7XG5cbiAgICBpZiAoZ3JvdXAuYWxpZ25tZW50ID09PSBcImNsYXBcIikge1xuICAgICAgLy8gcmVmOiBodHRwczovL3d3dy5tYXRoLmxzdS5lZHUvfmFwZXJsaXMvcHVibGljYXRpb25zL21hdGhjbGFwL1xuICAgICAgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW2J1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7IC8vIHdyYXAsIHNpbmNlIENTUyB3aWxsIGNlbnRlciBhIC5jbGFwID4gLmlubmVyID4gc3BhblxuXG4gICAgICBpbm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImlubmVyXCJdLCBbaW5uZXJdLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJpbm5lclwiXSwgW2J1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG4gICAgfVxuXG4gICAgdmFyIGZpeCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImZpeFwiXSwgW10pO1xuICAgIHZhciBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW2dyb3VwLmFsaWdubWVudF0sIFtpbm5lciwgZml4XSwgb3B0aW9ucyk7IC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgY29ycmVjdGx5IHNldCBob3Jpem9udGFsIGFsaWdubWVudCBvZiB0aGVcbiAgICAvLyB0d28gaXRlbXMgaW52b2x2ZWQgaW4gdGhlIGxhcC5cbiAgICAvLyBOZXh0LCB1c2UgYSBzdHJ1dCB0byBzZXQgdGhlIGhlaWdodCBvZiB0aGUgSFRNTCBib3VuZGluZyBib3guXG4gICAgLy8gT3RoZXJ3aXNlLCBhIHRhbGwgYXJndW1lbnQgbWF5IGJlIG1pc3BsYWNlZC5cblxuICAgIHZhciBzdHJ1dCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInN0cnV0XCJdKTtcbiAgICBzdHJ1dC5zdHlsZS5oZWlnaHQgPSBub2RlLmhlaWdodCArIG5vZGUuZGVwdGggKyBcImVtXCI7XG4gICAgc3RydXQuc3R5bGUudmVydGljYWxBbGlnbiA9IC1ub2RlLmRlcHRoICsgXCJlbVwiO1xuICAgIG5vZGUuY2hpbGRyZW4udW5zaGlmdChzdHJ1dCk7IC8vIE5leHQsIHByZXZlbnQgdmVydGljYWwgbWlzcGxhY2VtZW50IHdoZW4gbmV4dCB0byBzb21ldGhpbmcgdGFsbC5cblxuICAgIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbm9kZVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTsgLy8gR2V0IHRoZSBob3Jpem9udGFsIHNwYWNpbmcgY29ycmVjdCByZWxhdGl2ZSB0byBhZGphY2VudCBpdGVtcy5cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLCBbbm9kZV0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gbWF0aGxsYXAsIG1hdGhybGFwLCBtYXRoY2xhcFxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG5cbiAgICBpZiAoZ3JvdXAuYWxpZ25tZW50ICE9PSBcInJsYXBcIikge1xuICAgICAgdmFyIG9mZnNldCA9IGdyb3VwLmFsaWdubWVudCA9PT0gXCJsbGFwXCIgPyBcIi0xXCIgOiBcIi0wLjVcIjtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIG9mZnNldCArIFwid2lkdGhcIik7XG4gICAgfVxuXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBweFwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvbWF0aC5qc1xuXG4gLy8gU3dpdGNoaW5nIGZyb20gdGV4dCBtb2RlIGJhY2sgdG8gbWF0aCBtb2RlXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzdHlsaW5nXCIsXG4gIG5hbWVzOiBbXCJcXFxcKFwiLCBcIiRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IGZhbHNlLFxuICAgIGNvbnN1bWVNb2RlOiBcIm1hdGhcIlxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lLFxuICAgICAgICBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgb3V0ZXJNb2RlID0gcGFyc2VyLm1vZGU7XG4gICAgcGFyc2VyLnN3aXRjaE1vZGUoXCJtYXRoXCIpO1xuICAgIHZhciBjbG9zZSA9IGZ1bmNOYW1lID09PSBcIlxcXFwoXCIgPyBcIlxcXFwpXCIgOiBcIiRcIjtcbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGNsb3NlKTsgLy8gV2UgY2FuJ3QgZXhwYW5kIHRoZSBuZXh0IHN5bWJvbCBhZnRlciB0aGUgY2xvc2luZyAkIHVudGlsIGFmdGVyXG4gICAgLy8gc3dpdGNoaW5nIG1vZGVzIGJhY2suICBTbyBkb24ndCBjb25zdW1lIHdpdGhpbiBleHBlY3QuXG5cbiAgICBwYXJzZXIuZXhwZWN0KGNsb3NlLCBmYWxzZSk7XG4gICAgcGFyc2VyLnN3aXRjaE1vZGUob3V0ZXJNb2RlKTtcbiAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgc3R5bGU6IFwidGV4dFwiLFxuICAgICAgYm9keTogYm9keVxuICAgIH07XG4gIH1cbn0pOyAvLyBDaGVjayBmb3IgZXh0cmEgY2xvc2luZyBtYXRoIGRlbGltaXRlcnNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIixcbiAgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGlzIGlzLlxuICBuYW1lczogW1wiXFxcXClcIiwgXCJcXFxcXVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogZmFsc2VcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihjb250ZXh0LCBhcmdzKSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiTWlzbWF0Y2hlZCBcIiArIGNvbnRleHQuZnVuY05hbWUpO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9tYXRoY2hvaWNlLmpzXG5cblxuXG5cblxuXG52YXIgbWF0aGNob2ljZV9jaG9vc2VNYXRoU3R5bGUgPSBmdW5jdGlvbiBjaG9vc2VNYXRoU3R5bGUoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgc3dpdGNoIChvcHRpb25zLnN0eWxlLnNpemUpIHtcbiAgICBjYXNlIHNyY19TdHlsZS5ESVNQTEFZLnNpemU6XG4gICAgICByZXR1cm4gZ3JvdXAuZGlzcGxheTtcblxuICAgIGNhc2Ugc3JjX1N0eWxlLlRFWFQuc2l6ZTpcbiAgICAgIHJldHVybiBncm91cC50ZXh0O1xuXG4gICAgY2FzZSBzcmNfU3R5bGUuU0NSSVBULnNpemU6XG4gICAgICByZXR1cm4gZ3JvdXAuc2NyaXB0O1xuXG4gICAgY2FzZSBzcmNfU3R5bGUuU0NSSVBUU0NSSVBULnNpemU6XG4gICAgICByZXR1cm4gZ3JvdXAuc2NyaXB0c2NyaXB0O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBncm91cC50ZXh0O1xuICB9XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWF0aGNob2ljZVwiLFxuICBuYW1lczogW1wiXFxcXG1hdGhjaG9pY2VcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogNFxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWF0aGNob2ljZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBkaXNwbGF5OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChhcmdzWzBdKSxcbiAgICAgIHRleHQ6IGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50KGFyZ3NbMV0pLFxuICAgICAgc2NyaXB0OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChhcmdzWzJdKSxcbiAgICAgIHNjcmlwdHNjcmlwdDogZGVmaW5lRnVuY3Rpb25fb3JkYXJndW1lbnQoYXJnc1szXSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgYm9keSA9IG1hdGhjaG9pY2VfY2hvb3NlTWF0aFN0eWxlKGdyb3VwLCBvcHRpb25zKTtcbiAgICB2YXIgZWxlbWVudHMgPSBidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKGJvZHksIG9wdGlvbnMsIGZhbHNlKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGVsZW1lbnRzKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBib2R5ID0gbWF0aGNob2ljZV9jaG9vc2VNYXRoU3R5bGUoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coYm9keSwgb3B0aW9ucyk7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL29wLmpzXG4vLyBMaW1pdHMsIHN5bWJvbHNcblxuXG5cblxuXG5cblxuXG5cbi8vIE1vc3Qgb3BlcmF0b3JzIGhhdmUgYSBsYXJnZSBzdWNjZXNzb3Igc3ltYm9sLCBidXQgdGhlc2UgZG9uJ3QuXG52YXIgbm9TdWNjZXNzb3IgPSBbXCJcXFxcc21hbGxpbnRcIl07IC8vIE5PVEU6IFVubGlrZSBtb3N0IGBodG1sQnVpbGRlcmBzLCB0aGlzIG9uZSBoYW5kbGVzIG5vdCBvbmx5IFwib3BcIiwgYnV0IGFsc29cbi8vIFwic3Vwc3ViXCIgc2luY2Ugc29tZSBvZiB0aGVtIChsaWtlIFxcaW50KSBjYW4gYWZmZWN0IHN1cGVyL3N1YnNjcmlwdGluZy5cblxudmFyIG9wX2h0bWxCdWlsZGVyID0gZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JwLCBvcHRpb25zKSB7XG4gIC8vIE9wZXJhdG9ycyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBwZy4gNDQzLTQ0NCwgcnVsZSAxMyhhKS5cbiAgdmFyIHN1cEdyb3VwO1xuICB2YXIgc3ViR3JvdXA7XG4gIHZhciBoYXNMaW1pdHMgPSBmYWxzZTtcbiAgdmFyIGdyb3VwO1xuICB2YXIgc3VwU3ViID0gY2hlY2tOb2RlVHlwZShncnAsIFwic3Vwc3ViXCIpO1xuXG4gIGlmIChzdXBTdWIpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGxpbWl0cywgc3Vwc3ViIHdpbGwgcGFzcyB1cyBpdHMgZ3JvdXAgdG8gaGFuZGxlLiBQdWxsXG4gICAgLy8gb3V0IHRoZSBzdXBlcnNjcmlwdCBhbmQgc3Vic2NyaXB0IGFuZCBzZXQgdGhlIGdyb3VwIHRvIHRoZSBvcCBpblxuICAgIC8vIGl0cyBiYXNlLlxuICAgIHN1cEdyb3VwID0gc3VwU3ViLnN1cDtcbiAgICBzdWJHcm91cCA9IHN1cFN1Yi5zdWI7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShzdXBTdWIuYmFzZSwgXCJvcFwiKTtcbiAgICBoYXNMaW1pdHMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLCBcIm9wXCIpO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgdmFyIGxhcmdlID0gZmFsc2U7XG5cbiAgaWYgKHN0eWxlLnNpemUgPT09IHNyY19TdHlsZS5ESVNQTEFZLnNpemUgJiYgZ3JvdXAuc3ltYm9sICYmICF1dGlscy5jb250YWlucyhub1N1Y2Nlc3NvciwgZ3JvdXAubmFtZSkpIHtcbiAgICAvLyBNb3N0IHN5bWJvbCBvcGVyYXRvcnMgZ2V0IGxhcmdlciBpbiBkaXNwbGF5c3R5bGUgKHJ1bGUgMTMpXG4gICAgbGFyZ2UgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGJhc2U7XG5cbiAgaWYgKGdyb3VwLnN5bWJvbCkge1xuICAgIC8vIElmIHRoaXMgaXMgYSBzeW1ib2wsIGNyZWF0ZSB0aGUgc3ltYm9sLlxuICAgIHZhciBmb250TmFtZSA9IGxhcmdlID8gXCJTaXplMi1SZWd1bGFyXCIgOiBcIlNpemUxLVJlZ3VsYXJcIjtcbiAgICB2YXIgc3Rhc2ggPSBcIlwiO1xuXG4gICAgaWYgKGdyb3VwLm5hbWUgPT09IFwiXFxcXG9paW50XCIgfHwgZ3JvdXAubmFtZSA9PT0gXCJcXFxcb2lpaW50XCIpIHtcbiAgICAgIC8vIE5vIGZvbnQgZ2x5cGhzIHlldCwgc28gdXNlIGEgZ2x5cGggdy9vIHRoZSBvdmFsLlxuICAgICAgLy8gVE9ETzogV2hlbiBmb250IGdseXBocyBhcmUgYXZhaWxhYmxlLCBkZWxldGUgdGhpcyBjb2RlLlxuICAgICAgc3Rhc2ggPSBncm91cC5uYW1lLnN1YnN0cigxKTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICBncm91cC5uYW1lID0gc3Rhc2ggPT09IFwib2lpbnRcIiA/IFwiXFxcXGlpbnRcIiA6IFwiXFxcXGlpaW50XCI7XG4gICAgfVxuXG4gICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woZ3JvdXAubmFtZSwgZm9udE5hbWUsIFwibWF0aFwiLCBvcHRpb25zLCBbXCJtb3BcIiwgXCJvcC1zeW1ib2xcIiwgbGFyZ2UgPyBcImxhcmdlLW9wXCIgOiBcInNtYWxsLW9wXCJdKTtcblxuICAgIGlmIChzdGFzaC5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBXZSdyZSBpbiBcXG9paW50IG9yIFxcb2lpaW50LiBPdmVybGF5IHRoZSBvdmFsLlxuICAgICAgLy8gVE9ETzogV2hlbiBmb250IGdseXBocyBhcmUgYXZhaWxhYmxlLCBkZWxldGUgdGhpcyBjb2RlLlxuICAgICAgdmFyIGl0YWxpYyA9IGJhc2UuaXRhbGljO1xuICAgICAgdmFyIG92YWwgPSBidWlsZENvbW1vbi5zdGF0aWNTdmcoc3Rhc2ggKyBcIlNpemVcIiArIChsYXJnZSA/IFwiMlwiIDogXCIxXCIpLCBvcHRpb25zKTtcbiAgICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IGJhc2UsXG4gICAgICAgICAgc2hpZnQ6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IG92YWwsXG4gICAgICAgICAgc2hpZnQ6IGxhcmdlID8gMC4wOCA6IDBcbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgIGdyb3VwLm5hbWUgPSBcIlxcXFxcIiArIHN0YXNoO1xuICAgICAgYmFzZS5jbGFzc2VzLnVuc2hpZnQoXCJtb3BcIik7IC8vICRGbG93Rml4TWVcblxuICAgICAgYmFzZS5pdGFsaWMgPSBpdGFsaWM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdyb3VwLmJvZHkpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgbGlzdCwgY29tcG9zZSB0aGF0IGxpc3QuXG4gICAgdmFyIGlubmVyID0gYnVpbGRIVE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zLCB0cnVlKTtcblxuICAgIGlmIChpbm5lci5sZW5ndGggPT09IDEgJiYgaW5uZXJbMF0gaW5zdGFuY2VvZiBkb21UcmVlX1N5bWJvbE5vZGUpIHtcbiAgICAgIGJhc2UgPSBpbm5lclswXTtcbiAgICAgIGJhc2UuY2xhc3Nlc1swXSA9IFwibW9wXCI7IC8vIHJlcGxhY2Ugb2xkIG1jbGFzc1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9wXCJdLCBidWlsZENvbW1vbi50cnlDb21iaW5lQ2hhcnMoaW5uZXIpLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGlzIGEgdGV4dCBvcGVyYXRvci4gQnVpbGQgdGhlIHRleHQgZnJvbSB0aGVcbiAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgLy8gVE9ETyhlbWlseSk6IEFkZCBhIHNwYWNlIGluIHRoZSBtaWRkbGUgb2Ygc29tZSBvZiB0aGVzZVxuICAgIC8vIG9wZXJhdG9ycywgbGlrZSBcXGxpbXN1cFxuICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZ3JvdXAubmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0LnB1c2goYnVpbGRDb21tb24ubWF0aHN5bShncm91cC5uYW1lW2ldLCBncm91cC5tb2RlKSk7XG4gICAgfVxuXG4gICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcFwiXSwgb3V0cHV0LCBvcHRpb25zKTtcbiAgfSAvLyBJZiBjb250ZW50IG9mIG9wIGlzIGEgc2luZ2xlIHN5bWJvbCwgc2hpZnQgaXQgdmVydGljYWxseS5cblxuXG4gIHZhciBiYXNlU2hpZnQgPSAwO1xuICB2YXIgc2xhbnQgPSAwO1xuXG4gIGlmICgoYmFzZSBpbnN0YW5jZW9mIGRvbVRyZWVfU3ltYm9sTm9kZSB8fCBncm91cC5uYW1lID09PSBcIlxcXFxvaWludFwiIHx8IGdyb3VwLm5hbWUgPT09IFwiXFxcXG9paWludFwiKSAmJiAhZ3JvdXAuc3VwcHJlc3NCYXNlU2hpZnQpIHtcbiAgICAvLyBXZSBzdXBwcmVzcyB0aGUgc2hpZnQgb2YgdGhlIGJhc2Ugb2YgXFxvdmVyc2V0IGFuZCBcXHVuZGVyc2V0LiBPdGhlcndpc2UsXG4gICAgLy8gc2hpZnQgdGhlIHN5bWJvbCBzbyBpdHMgY2VudGVyIGxpZXMgb24gdGhlIGF4aXMgKHJ1bGUgMTMpLiBJdFxuICAgIC8vIGFwcGVhcnMgdGhhdCBvdXIgZm9udHMgaGF2ZSB0aGUgY2VudGVycyBvZiB0aGUgc3ltYm9scyBhbHJlYWR5XG4gICAgLy8gYWxtb3N0IG9uIHRoZSBheGlzLCBzbyB0aGVzZSBudW1iZXJzIGFyZSB2ZXJ5IHNtYWxsLiBOb3RlIHdlXG4gICAgLy8gZG9uJ3QgYWN0dWFsbHkgYXBwbHkgdGhpcyBoZXJlLCBidXQgaW5zdGVhZCBpdCBpcyB1c2VkIGVpdGhlciBpblxuICAgIC8vIHRoZSB2bGlzdCBjcmVhdGlvbiBvciBzZXBhcmF0ZWx5IHdoZW4gdGhlcmUgYXJlIG5vIGxpbWl0cy5cbiAgICBiYXNlU2hpZnQgPSAoYmFzZS5oZWlnaHQgLSBiYXNlLmRlcHRoKSAvIDIgLSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDsgLy8gVGhlIHNsYW50IG9mIHRoZSBzeW1ib2wgaXMganVzdCBpdHMgaXRhbGljIGNvcnJlY3Rpb24uXG4gICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgc2xhbnQgPSBiYXNlLml0YWxpYztcbiAgfVxuXG4gIGlmIChoYXNMaW1pdHMpIHtcbiAgICAvLyBJRSA4IGNsaXBzIFxcaW50IGlmIGl0IGlzIGluIGEgZGlzcGxheTogaW5saW5lLWJsb2NrLiBXZSB3cmFwIGl0XG4gICAgLy8gaW4gYSBuZXcgc3BhbiBzbyBpdCBpcyBhbiBpbmxpbmUsIGFuZCB3b3Jrcy5cbiAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtiYXNlXSk7XG4gICAgdmFyIHN1YjtcbiAgICB2YXIgc3VwOyAvLyBXZSBtYW51YWxseSBoYXZlIHRvIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzLiBUaGlzLFxuICAgIC8vIGFzaWRlIGZyb20gdGhlIGtlcm4gY2FsY3VsYXRpb25zLCBpcyBjb3BpZWQgZnJvbSBzdXBzdWIuXG5cbiAgICBpZiAoc3VwR3JvdXApIHtcbiAgICAgIHZhciBlbGVtID0gYnVpbGRIVE1MX2J1aWxkR3JvdXAoc3VwR3JvdXAsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3VwKCkpLCBvcHRpb25zKTtcbiAgICAgIHN1cCA9IHtcbiAgICAgICAgZWxlbTogZWxlbSxcbiAgICAgICAga2VybjogTWF0aC5tYXgob3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzEsIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmczIC0gZWxlbS5kZXB0aClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHN1Ykdyb3VwKSB7XG4gICAgICB2YXIgX2VsZW0gPSBidWlsZEhUTUxfYnVpbGRHcm91cChzdWJHcm91cCwgb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdWIoKSksIG9wdGlvbnMpO1xuXG4gICAgICBzdWIgPSB7XG4gICAgICAgIGVsZW06IF9lbGVtLFxuICAgICAgICBrZXJuOiBNYXRoLm1heChvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nMiwgb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzQgLSBfZWxlbS5oZWlnaHQpXG4gICAgICB9O1xuICAgIH0gLy8gQnVpbGQgdGhlIGZpbmFsIGdyb3VwIGFzIGEgdmxpc3Qgb2YgdGhlIHBvc3NpYmxlIHN1YnNjcmlwdCwgYmFzZSxcbiAgICAvLyBhbmQgcG9zc2libGUgc3VwZXJzY3JpcHQuXG5cblxuICAgIHZhciBmaW5hbEdyb3VwO1xuXG4gICAgaWYgKHN1cCAmJiBzdWIpIHtcbiAgICAgIHZhciBib3R0b20gPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNSArIHN1Yi5lbGVtLmhlaWdodCArIHN1Yi5lbGVtLmRlcHRoICsgc3ViLmtlcm4gKyBiYXNlLmRlcHRoICsgYmFzZVNoaWZ0O1xuICAgICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJib3R0b21cIixcbiAgICAgICAgcG9zaXRpb25EYXRhOiBib3R0b20sXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICAgIHNpemU6IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBzdWIuZWxlbSxcbiAgICAgICAgICBtYXJnaW5MZWZ0OiAtc2xhbnQgKyBcImVtXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICAgIHNpemU6IHN1Yi5rZXJuXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBiYXNlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgICBzaXplOiBzdXAua2VyblxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogc3VwLmVsZW0sXG4gICAgICAgICAgbWFyZ2luTGVmdDogc2xhbnQgKyBcImVtXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICAgIHNpemU6IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1XG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHN1Yikge1xuICAgICAgdmFyIHRvcCA9IGJhc2UuaGVpZ2h0IC0gYmFzZVNoaWZ0OyAvLyBTaGlmdCB0aGUgbGltaXRzIGJ5IHRoZSBzbGFudCBvZiB0aGUgc3ltYm9sLiBOb3RlXG4gICAgICAvLyB0aGF0IHdlIGFyZSBzdXBwb3NlZCB0byBzaGlmdCB0aGUgbGltaXRzIGJ5IDEvMiBvZiB0aGUgc2xhbnQsXG4gICAgICAvLyBidXQgc2luY2Ugd2UgYXJlIGNlbnRlcmluZyB0aGUgbGltaXRzIGFkZGluZyBhIGZ1bGwgc2xhbnQgb2ZcbiAgICAgIC8vIG1hcmdpbiB3aWxsIHNoaWZ0IGJ5IDEvMiB0aGF0LlxuXG4gICAgICBmaW5hbEdyb3VwID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcInRvcFwiLFxuICAgICAgICBwb3NpdGlvbkRhdGE6IHRvcCxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgICAgc2l6ZTogb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHN1Yi5lbGVtLFxuICAgICAgICAgIG1hcmdpbkxlZnQ6IC1zbGFudCArIFwiZW1cIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgICAgc2l6ZTogc3ViLmtlcm5cbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IGJhc2VcbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoc3VwKSB7XG4gICAgICB2YXIgX2JvdHRvbSA9IGJhc2UuZGVwdGggKyBiYXNlU2hpZnQ7XG5cbiAgICAgIGZpbmFsR3JvdXAgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgICAgIHBvc2l0aW9uRGF0YTogX2JvdHRvbSxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogYmFzZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgICAgc2l6ZTogc3VwLmtlcm5cbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHN1cC5lbGVtLFxuICAgICAgICAgIG1hcmdpbkxlZnQ6IHNsYW50ICsgXCJlbVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgICBzaXplOiBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNVxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgY2FzZSBwcm9iYWJseSBzaG91bGRuJ3Qgb2NjdXIgKHRoaXMgd291bGQgbWVhbiB0aGVcbiAgICAgIC8vIHN1cHN1YiB3YXMgc2VuZGluZyB1cyBhIGdyb3VwIHdpdGggbm8gc3VwZXJzY3JpcHQgb3JcbiAgICAgIC8vIHN1YnNjcmlwdCkgYnV0IGJlIHNhZmUuXG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9wXCIsIFwib3AtbGltaXRzXCJdLCBbZmluYWxHcm91cF0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChiYXNlU2hpZnQpIHtcbiAgICAgIGJhc2Uuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICBiYXNlLnN0eWxlLnRvcCA9IGJhc2VTaGlmdCArIFwiZW1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxufTtcblxudmFyIG9wX21hdGhtbEJ1aWxkZXIgPSBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBub2RlO1xuXG4gIGlmIChncm91cC5zeW1ib2wpIHtcbiAgICAvLyBUaGlzIGlzIGEgc3ltYm9sLiBKdXN0IGFkZCB0aGUgc3ltYm9sLlxuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZV9NYXRoTm9kZShcIm1vXCIsIFtidWlsZE1hdGhNTF9tYWtlVGV4dChncm91cC5uYW1lLCBncm91cC5tb2RlKV0pO1xuXG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKG5vU3VjY2Vzc29yLCBncm91cC5uYW1lKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsYXJnZW9wXCIsIFwiZmFsc2VcIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdyb3VwLmJvZHkpIHtcbiAgICAvLyBUaGlzIGlzIGFuIG9wZXJhdG9yIHdpdGggY2hpbGRyZW4uIEFkZCB0aGVtLlxuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZV9NYXRoTm9kZShcIm1vXCIsIGJ1aWxkTWF0aE1MX2J1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIHRleHQgb3BlcmF0b3IuIEFkZCBhbGwgb2YgdGhlIGNoYXJhY3RlcnMgZnJvbSB0aGVcbiAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgLy8gVE9ETyhlbWlseSk6IEFkZCBhIHNwYWNlIGluIHRoZSBtaWRkbGUgb2Ygc29tZSBvZiB0aGVzZVxuICAgIC8vIG9wZXJhdG9ycywgbGlrZSBcXGxpbXN1cC5cbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWVfTWF0aE5vZGUoXCJtaVwiLCBbbmV3IG1hdGhNTFRyZWVfVGV4dE5vZGUoZ3JvdXAubmFtZS5zbGljZSgxKSldKTsgLy8gQXBwZW5kIGFuIDxtbz4mQXBwbHlGdW5jdGlvbjs8L21vPi5cbiAgICAvLyByZWY6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9SRUMtTWF0aE1ML2NoYXAzXzIuaHRtbCNzZWMzLjIuNFxuXG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWVfTWF0aE5vZGUoXCJtb1wiLCBbYnVpbGRNYXRoTUxfbWFrZVRleHQoXCJcXHUyMDYxXCIsIFwidGV4dFwiKV0pO1xuXG4gICAgaWYgKGdyb3VwLnBhcmVudElzU3VwU3ViKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWVfTWF0aE5vZGUoXCJtb1wiLCBbbm9kZSwgb3BlcmF0b3JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ld0RvY3VtZW50RnJhZ21lbnQoW25vZGUsIG9wZXJhdG9yXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgc2luZ2xlQ2hhckJpZ09wcyA9IHtcbiAgXCJcXHUyMjBGXCI6IFwiXFxcXHByb2RcIixcbiAgXCJcXHUyMjEwXCI6IFwiXFxcXGNvcHJvZFwiLFxuICBcIlxcdTIyMTFcIjogXCJcXFxcc3VtXCIsXG4gIFwiXFx1MjJDMFwiOiBcIlxcXFxiaWd3ZWRnZVwiLFxuICBcIlxcdTIyQzFcIjogXCJcXFxcYmlndmVlXCIsXG4gIFwiXFx1MjJDMlwiOiBcIlxcXFxiaWdjYXBcIixcbiAgXCJcXHUyMkMzXCI6IFwiXFxcXGJpZ2N1cFwiLFxuICBcIlxcdTJBMDBcIjogXCJcXFxcYmlnb2RvdFwiLFxuICBcIlxcdTJBMDFcIjogXCJcXFxcYmlnb3BsdXNcIixcbiAgXCJcXHUyQTAyXCI6IFwiXFxcXGJpZ290aW1lc1wiLFxuICBcIlxcdTJBMDRcIjogXCJcXFxcYmlndXBsdXNcIixcbiAgXCJcXHUyQTA2XCI6IFwiXFxcXGJpZ3NxY3VwXCJcbn07XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxjb3Byb2RcIiwgXCJcXFxcYmlndmVlXCIsIFwiXFxcXGJpZ3dlZGdlXCIsIFwiXFxcXGJpZ3VwbHVzXCIsIFwiXFxcXGJpZ2NhcFwiLCBcIlxcXFxiaWdjdXBcIiwgXCJcXFxcaW50b3BcIiwgXCJcXFxccHJvZFwiLCBcIlxcXFxzdW1cIiwgXCJcXFxcYmlnb3RpbWVzXCIsIFwiXFxcXGJpZ29wbHVzXCIsIFwiXFxcXGJpZ29kb3RcIiwgXCJcXFxcYmlnc3FjdXBcIiwgXCJcXFxcc21hbGxpbnRcIiwgXCJcXHUyMjBGXCIsIFwiXFx1MjIxMFwiLCBcIlxcdTIyMTFcIiwgXCJcXHUyMkMwXCIsIFwiXFx1MjJDMVwiLCBcIlxcdTIyQzJcIiwgXCJcXHUyMkMzXCIsIFwiXFx1MkEwMFwiLCBcIlxcdTJBMDFcIiwgXCJcXHUyQTAyXCIsIFwiXFx1MkEwNFwiLCBcIlxcdTJBMDZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZi5mdW5jTmFtZTtcbiAgICB2YXIgZk5hbWUgPSBmdW5jTmFtZTtcblxuICAgIGlmIChmTmFtZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZOYW1lID0gc2luZ2xlQ2hhckJpZ09wc1tmTmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiB0cnVlLFxuICAgICAgbmFtZTogZk5hbWVcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogb3BfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IG9wX21hdGhtbEJ1aWxkZXJcbn0pOyAvLyBOb3RlOiBjYWxsaW5nIGRlZmluZUZ1bmN0aW9uIHdpdGggYSB0eXBlIHRoYXQncyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBvbmx5XG4vLyB3b3JrcyBiZWNhdXNlIHRoZSBzYW1lIGh0bWxCdWlsZGVyIGFuZCBtYXRobWxCdWlsZGVyIGFyZSBiZWluZyB1c2VkLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxtYXRob3BcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYyLCBhcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYyLnBhcnNlcjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBib2R5OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBvcF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogb3BfbWF0aG1sQnVpbGRlclxufSk7IC8vIFRoZXJlIGFyZSAyIGZsYWdzIGZvciBvcGVyYXRvcnM7IHdoZXRoZXIgdGhleSBwcm9kdWNlIGxpbWl0cyBpblxuLy8gZGlzcGxheXN0eWxlLCBhbmQgd2hldGhlciB0aGV5IGFyZSBzeW1ib2xzIGFuZCBzaG91bGQgZ3JvdyBpblxuLy8gZGlzcGxheXN0eWxlLiBUaGVzZSBmb3VyIGdyb3VwcyBjb3ZlciB0aGUgZm91ciBwb3NzaWJsZSBjaG9pY2VzLlxuXG52YXIgc2luZ2xlQ2hhckludGVncmFscyA9IHtcbiAgXCJcXHUyMjJCXCI6IFwiXFxcXGludFwiLFxuICBcIlxcdTIyMkNcIjogXCJcXFxcaWludFwiLFxuICBcIlxcdTIyMkRcIjogXCJcXFxcaWlpbnRcIixcbiAgXCJcXHUyMjJFXCI6IFwiXFxcXG9pbnRcIixcbiAgXCJcXHUyMjJGXCI6IFwiXFxcXG9paW50XCIsXG4gIFwiXFx1MjIzMFwiOiBcIlxcXFxvaWlpbnRcIlxufTsgLy8gTm8gbGltaXRzLCBub3Qgc3ltYm9sc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxhcmNzaW5cIiwgXCJcXFxcYXJjY29zXCIsIFwiXFxcXGFyY3RhblwiLCBcIlxcXFxhcmN0Z1wiLCBcIlxcXFxhcmNjdGdcIiwgXCJcXFxcYXJnXCIsIFwiXFxcXGNoXCIsIFwiXFxcXGNvc1wiLCBcIlxcXFxjb3NlY1wiLCBcIlxcXFxjb3NoXCIsIFwiXFxcXGNvdFwiLCBcIlxcXFxjb3RnXCIsIFwiXFxcXGNvdGhcIiwgXCJcXFxcY3NjXCIsIFwiXFxcXGN0Z1wiLCBcIlxcXFxjdGhcIiwgXCJcXFxcZGVnXCIsIFwiXFxcXGRpbVwiLCBcIlxcXFxleHBcIiwgXCJcXFxcaG9tXCIsIFwiXFxcXGtlclwiLCBcIlxcXFxsZ1wiLCBcIlxcXFxsblwiLCBcIlxcXFxsb2dcIiwgXCJcXFxcc2VjXCIsIFwiXFxcXHNpblwiLCBcIlxcXFxzaW5oXCIsIFwiXFxcXHNoXCIsIFwiXFxcXHRhblwiLCBcIlxcXFx0YW5oXCIsIFwiXFxcXHRnXCIsIFwiXFxcXHRoXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmMykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmMy5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZjMuZnVuY05hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBuYW1lOiBmdW5jTmFtZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBvcF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogb3BfbWF0aG1sQnVpbGRlclxufSk7IC8vIExpbWl0cywgbm90IHN5bWJvbHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGV0XCIsIFwiXFxcXGdjZFwiLCBcIlxcXFxpbmZcIiwgXCJcXFxcbGltXCIsIFwiXFxcXG1heFwiLCBcIlxcXFxtaW5cIiwgXCJcXFxcUHJcIiwgXCJcXFxcc3VwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmNCkge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmNC5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZjQuZnVuY05hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBmYWxzZSxcbiAgICAgIG5hbWU6IGZ1bmNOYW1lXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IG9wX2h0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiBvcF9tYXRobWxCdWlsZGVyXG59KTsgLy8gTm8gbGltaXRzLCBzeW1ib2xzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXGludFwiLCBcIlxcXFxpaW50XCIsIFwiXFxcXGlpaW50XCIsIFwiXFxcXG9pbnRcIiwgXCJcXFxcb2lpbnRcIiwgXCJcXFxcb2lpaW50XCIsIFwiXFx1MjIyQlwiLCBcIlxcdTIyMkNcIiwgXCJcXHUyMjJEXCIsIFwiXFx1MjIyRVwiLCBcIlxcdTIyMkZcIiwgXCJcXHUyMjMwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmNSkge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmNS5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZjUuZnVuY05hbWU7XG4gICAgdmFyIGZOYW1lID0gZnVuY05hbWU7XG5cbiAgICBpZiAoZk5hbWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBmTmFtZSA9IHNpbmdsZUNoYXJJbnRlZ3JhbHNbZk5hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IHRydWUsXG4gICAgICBuYW1lOiBmTmFtZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBvcF9odG1sQnVpbGRlcixcbiAgbWF0aG1sQnVpbGRlcjogb3BfbWF0aG1sQnVpbGRlclxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvb3BlcmF0b3JuYW1lLmpzXG5cblxuXG5cblxuIC8vIFxcb3BlcmF0b3JuYW1lXG4vLyBhbXNvcG4uZHR4OiBcXG1hdGhvcHsjMVxca2VyblxcekBcXG9wZXJhdG9yQGZvbnQjM31cXG5ld21jb2Rlc0BcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wZXJhdG9ybmFtZVwiLFxuICBuYW1lczogW1wiXFxcXG9wZXJhdG9ybmFtZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BlcmF0b3JuYW1lXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGJvZHkgPSBncm91cC5ib2R5Lm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZTogQ2hlY2sgaWYgdGhlIG5vZGUgaGFzIGEgc3RyaW5nIGB0ZXh0YCBwcm9wZXJ0eS5cbiAgICAgICAgdmFyIGNoaWxkVGV4dCA9IGNoaWxkLnRleHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgICBtb2RlOiBjaGlsZC5tb2RlLFxuICAgICAgICAgICAgdGV4dDogY2hpbGRUZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBDb25zb2xpZGF0ZSBmdW5jdGlvbiBuYW1lcyBpbnRvIHN5bWJvbCBjaGFyYWN0ZXJzLlxuXG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IGJ1aWxkSFRNTF9idWlsZEV4cHJlc3Npb24oYm9keSwgb3B0aW9ucy53aXRoRm9udChcIm1hdGhybVwiKSwgdHJ1ZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBleHByZXNzaW9uW2ldO1xuXG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIGRvbVRyZWVfU3ltYm9sTm9kZSkge1xuICAgICAgICAgIC8vIFBlciBhbXNvcG4gcGFja2FnZSxcbiAgICAgICAgICAvLyBjaGFuZ2UgbWludXMgdG8gaHlwaGVuIGFuZCBcXGFzdCB0byBhc3Rlcmlza1xuICAgICAgICAgIGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL1xcdTIyMTIvLCBcIi1cIikucmVwbGFjZSgvXFx1MjIxNy8sIFwiKlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9wXCJdLCBleHByZXNzaW9uLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcFwiXSwgW10sIG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFRoZSBzdGVwcyB0YWtlbiBoZXJlIGFyZSBzaW1pbGFyIHRvIHRoZSBodG1sIHZlcnNpb24uXG4gICAgdmFyIGV4cHJlc3Npb24gPSBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoRm9udChcIm1hdGhybVwiKSk7IC8vIElzIGV4cHJlc3Npb24gYSBzdHJpbmcgb3IgaGFzIGl0IHNvbWV0aGluZyBsaWtlIGEgZnJhY3Rpb24/XG5cbiAgICB2YXIgaXNBbGxTdHJpbmcgPSB0cnVlOyAvLyBkZWZhdWx0XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gZXhwcmVzc2lvbltpXTtcblxuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBtYXRoTUxUcmVlLlNwYWNlTm9kZSkgey8vIERvIG5vdGhpbmdcbiAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG1hdGhNTFRyZWUuTWF0aE5vZGUpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibWlcIjpcbiAgICAgICAgICBjYXNlIFwibW5cIjpcbiAgICAgICAgICBjYXNlIFwibXNcIjpcbiAgICAgICAgICBjYXNlIFwibXNwYWNlXCI6XG4gICAgICAgICAgY2FzZSBcIm10ZXh0XCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBEbyBub3RoaW5nIHlldC5cblxuICAgICAgICAgIGNhc2UgXCJtb1wiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZCBpbnN0YW5jZW9mIG1hdGhNTFRyZWUuVGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC50ZXh0ID0gY2hpbGQudGV4dC5yZXBsYWNlKC9cXHUyMjEyLywgXCItXCIpLnJlcGxhY2UoL1xcdTIyMTcvLCBcIipcIik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNBbGxTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQWxsU3RyaW5nKSB7XG4gICAgICAvLyBXcml0ZSBhIHNpbmdsZSBUZXh0Tm9kZSBpbnN0ZWFkIG9mIG11bHRpcGxlIG5lc3RlZCB0YWdzLlxuICAgICAgdmFyIHdvcmQgPSBleHByZXNzaW9uLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS50b1RleHQoKTtcbiAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICBleHByZXNzaW9uID0gW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKHdvcmQpXTtcbiAgICB9XG5cbiAgICB2YXIgaWRlbnRpZmllciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgZXhwcmVzc2lvbik7XG4gICAgaWRlbnRpZmllci5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm5vcm1hbFwiKTsgLy8gXFx1MjA2MSBpcyB0aGUgc2FtZSBhcyAmQXBwbHlGdW5jdGlvbjtcbiAgICAvLyByZWY6IGh0dHBzOi8vd3d3Lnczc2Nob29scy5jb20vY2hhcnNldHMvcmVmX2h0bWxfZW50aXRpZXNfYS5hc3BcblxuICAgIHZhciBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW2J1aWxkTWF0aE1MX21ha2VUZXh0KFwiXFx1MjA2MVwiLCBcInRleHRcIildKTtcbiAgICByZXR1cm4gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KFtpZGVudGlmaWVyLCBvcGVyYXRvcl0pO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9vcmRncm91cC5qc1xuXG5cblxuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJvcmRncm91cFwiLFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoZ3JvdXAuc2VtaXNpbXBsZSkge1xuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChidWlsZEhUTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMsIGZhbHNlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0sIGJ1aWxkSFRNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSksIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBvcHRpb25zKTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvb3ZlcmxpbmUuanNcblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3ZlcmxpbmVcIixcbiAgbmFtZXM6IFtcIlxcXFxvdmVybGluZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3ZlcmxpbmVcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIE92ZXJsaW5lcyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBwZyA0NDMsIFJ1bGUgOS5cbiAgICAvLyBCdWlsZCB0aGUgaW5uZXIgZ3JvdXAgaW4gdGhlIGNyYW1wZWQgc3R5bGUuXG4gICAgdmFyIGlubmVyR3JvdXAgPSBidWlsZEhUTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTsgLy8gQ3JlYXRlIHRoZSBsaW5lIGFib3ZlIHRoZSBib2R5XG5cbiAgICB2YXIgbGluZSA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbihcIm92ZXJsaW5lLWxpbmVcIiwgb3B0aW9ucyk7IC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnNcblxuICAgIHZhciB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lckdyb3VwXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiAzICogbGluZS5oZWlnaHRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGxpbmVcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IGxpbmUuaGVpZ2h0XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwib3ZlcmxpbmVcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUyMDNFXCIpXSk7XG4gICAgb3BlcmF0b3Iuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKSwgb3BlcmF0b3JdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudFwiLCBcInRydWVcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZnVuY3Rpb25zL3BoYW50b20uanNcblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicGhhbnRvbVwiLFxuICBuYW1lczogW1wiXFxcXHBoYW50b21cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicGhhbnRvbVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBlbGVtZW50cyA9IGJ1aWxkSFRNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoUGhhbnRvbSgpLCBmYWxzZSk7IC8vIFxccGhhbnRvbSBpc24ndCBzdXBwb3NlZCB0byBhZmZlY3QgdGhlIGVsZW1lbnRzIGl0IGNvbnRhaW5zLlxuICAgIC8vIFNlZSBcImNvbG9yXCIgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbiAgfVxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHBoYW50b21cIixcbiAgbmFtZXM6IFtcIlxcXFxocGhhbnRvbVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmMiwgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmMi5wYXJzZXI7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbYnVpbGRIVE1MX2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoUGhhbnRvbSgpKV0pO1xuICAgIG5vZGUuaGVpZ2h0ID0gMDtcbiAgICBub2RlLmRlcHRoID0gMDtcblxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5oZWlnaHQgPSAwO1xuICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmRlcHRoID0gMDtcbiAgICAgIH1cbiAgICB9IC8vIFNlZSBzbWFzaCBmb3IgY29tbWVudCByZTogdXNlIG9mIG1ha2VWTGlzdFxuXG5cbiAgICBub2RlID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IG5vZGVcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7IC8vIEZvciBzcGFjaW5nLCBUZVggdHJlYXRzIFxcc21hc2ggYXMgYSBtYXRoIGdyb3VwIChzYW1lIHNwYWNpbmcgYXMgb3JkKS5cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLCBbbm9kZV0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50KGdyb3VwLmJvZHkpLCBvcHRpb25zKTtcbiAgICB2YXIgcGhhbnRvbSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgaW5uZXIpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtwaGFudG9tXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIwcHhcIik7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBcIjBweFwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidnBoYW50b21cIixcbiAgbmFtZXM6IFtcIlxcXFx2cGhhbnRvbVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmMywgYXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmMy5wYXJzZXI7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInZwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJpbm5lclwiXSwgW2J1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMud2l0aFBoYW50b20oKSldKTtcbiAgICB2YXIgZml4ID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiZml4XCJdLCBbXSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJybGFwXCJdLCBbaW5uZXIsIGZpeF0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50KGdyb3VwLmJvZHkpLCBvcHRpb25zKTtcbiAgICB2YXIgcGhhbnRvbSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgaW5uZXIpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtwaGFudG9tXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBweFwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvc2l6aW5nLmpzXG5cblxuXG5cblxuZnVuY3Rpb24gc2l6aW5nR3JvdXAodmFsdWUsIG9wdGlvbnMsIGJhc2VPcHRpb25zKSB7XG4gIHZhciBpbm5lciA9IGJ1aWxkSFRNTF9idWlsZEV4cHJlc3Npb24odmFsdWUsIG9wdGlvbnMsIGZhbHNlKTtcbiAgdmFyIG11bHRpcGxpZXIgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gYmFzZU9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7IC8vIEFkZCBzaXplLXJlc2V0dGluZyBjbGFzc2VzIHRvIHRoZSBpbm5lciBsaXN0IGFuZCBzZXQgbWF4Rm9udFNpemVcbiAgLy8gbWFudWFsbHkuIEhhbmRsZSBuZXN0ZWQgc2l6ZSBjaGFuZ2VzLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcG9zID0gaW5uZXJbaV0uY2xhc3Nlcy5pbmRleE9mKFwic2l6aW5nXCIpO1xuXG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGlubmVyW2ldLmNsYXNzZXMsIG9wdGlvbnMuc2l6aW5nQ2xhc3NlcyhiYXNlT3B0aW9ucykpO1xuICAgIH0gZWxzZSBpZiAoaW5uZXJbaV0uY2xhc3Nlc1twb3MgKyAxXSA9PT0gXCJyZXNldC1zaXplXCIgKyBvcHRpb25zLnNpemUpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBuZXN0ZWQgc2l6ZSBjaGFuZ2U6IGUuZy4sIGlubmVyW2ldIGlzIHRoZSBcImJcIiBpblxuICAgICAgLy8gYFxcSHVnZSBhIFxcc21hbGwgYmAuIE92ZXJyaWRlIHRoZSBvbGQgc2l6ZSAodGhlIGByZXNldC1gIGNsYXNzKVxuICAgICAgLy8gYnV0IG5vdCB0aGUgbmV3IHNpemUuXG4gICAgICBpbm5lcltpXS5jbGFzc2VzW3BvcyArIDFdID0gXCJyZXNldC1zaXplXCIgKyBiYXNlT3B0aW9ucy5zaXplO1xuICAgIH1cblxuICAgIGlubmVyW2ldLmhlaWdodCAqPSBtdWx0aXBsaWVyO1xuICAgIGlubmVyW2ldLmRlcHRoICo9IG11bHRpcGxpZXI7XG4gIH1cblxuICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGlubmVyKTtcbn1cbnZhciBzaXplRnVuY3MgPSBbXCJcXFxcdGlueVwiLCBcIlxcXFxzaXhwdHNpemVcIiwgXCJcXFxcc2NyaXB0c2l6ZVwiLCBcIlxcXFxmb290bm90ZXNpemVcIiwgXCJcXFxcc21hbGxcIiwgXCJcXFxcbm9ybWFsc2l6ZVwiLCBcIlxcXFxsYXJnZVwiLCBcIlxcXFxMYXJnZVwiLCBcIlxcXFxMQVJHRVwiLCBcIlxcXFxodWdlXCIsIFwiXFxcXEh1Z2VcIl07XG52YXIgc2l6aW5nX2h0bWxCdWlsZGVyID0gZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgLy8gSGFuZGxlIHNpemluZyBvcGVyYXRvcnMgbGlrZSBcXEh1Z2UuIFJlYWwgVGVYIGRvZXNuJ3QgYWN0dWFsbHkgYWxsb3dcbiAgLy8gdGhlc2UgZnVuY3Rpb25zIGluc2lkZSBvZiBtYXRoIGV4cHJlc3Npb25zLCBzbyB3ZSBkbyBzb21lIHNwZWNpYWxcbiAgLy8gaGFuZGxpbmcuXG4gIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTaXplKGdyb3VwLnNpemUpO1xuICByZXR1cm4gc2l6aW5nR3JvdXAoZ3JvdXAuYm9keSwgbmV3T3B0aW9ucywgb3B0aW9ucyk7XG59O1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInNpemluZ1wiLFxuICBuYW1lczogc2l6ZUZ1bmNzLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgYnJlYWtPblRva2VuVGV4dCA9IF9yZWYuYnJlYWtPblRva2VuVGV4dCxcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lLFxuICAgICAgICBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGJyZWFrT25Ub2tlblRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNpemluZ1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc2l6ZSB0byB1c2UgYmFzZWQgb24gdGhlIGxpc3Qgb2YgZnVuY3Rpb25zIGFib3ZlXG4gICAgICBzaXplOiBzaXplRnVuY3MuaW5kZXhPZihmdW5jTmFtZSkgKyAxLFxuICAgICAgYm9keTogYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBzaXppbmdfaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU2l6ZShncm91cC5zaXplKTtcbiAgICB2YXIgaW5uZXIgPSBidWlsZE1hdGhNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgbmV3T3B0aW9ucyk7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7IC8vIFRPRE8oZW1pbHkpOiBUaGlzIGRvZXNuJ3QgcHJvZHVjZSB0aGUgY29ycmVjdCBzaXplIGZvciBuZXN0ZWQgc2l6ZVxuICAgIC8vIGNoYW5nZXMsIGJlY2F1c2Ugd2UgZG9uJ3Qga2VlcCBzdGF0ZSBvZiB3aGF0IHN0eWxlIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIGluLCBzbyB3ZSBjYW4ndCByZXNldCB0aGUgc2l6ZSB0byBub3JtYWwgYmVmb3JlIGNoYW5naW5nIGl0LiAgTm93XG4gICAgLy8gdGhhdCB3ZSdyZSBwYXNzaW5nIGFuIG9wdGlvbnMgcGFyYW1ldGVyIHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpeFxuICAgIC8vIHRoaXMuXG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhzaXplXCIsIG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIgKyBcImVtXCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9yYWlzZWJveC5qc1xuXG5cblxuXG5cblxuIC8vIEJveCBtYW5pcHVsYXRpb25cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInJhaXNlYm94XCIsXG4gIG5hbWVzOiBbXCJcXFxccmFpc2Vib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcInRleHRcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXI7XG4gICAgdmFyIGFtb3VudCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKS52YWx1ZTtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicmFpc2Vib3hcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZHk6IGFtb3VudCxcbiAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGV4dCA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgbW9kZTogZ3JvdXAubW9kZSxcbiAgICAgIGJvZHk6IGRlZmluZUZ1bmN0aW9uX29yZGFyZ3VtZW50KGdyb3VwLmJvZHkpLFxuICAgICAgZm9udDogXCJtYXRocm1cIiAvLyBzaW11bGF0ZSBcXHRleHRybVxuXG4gICAgfTtcbiAgICB2YXIgc2l6ZWRUZXh0ID0ge1xuICAgICAgdHlwZTogXCJzaXppbmdcIixcbiAgICAgIG1vZGU6IGdyb3VwLm1vZGUsXG4gICAgICBib2R5OiBbdGV4dF0sXG4gICAgICBzaXplOiA2IC8vIHNpbXVsYXRlIFxcbm9ybWFsc2l6ZVxuXG4gICAgfTtcbiAgICB2YXIgYm9keSA9IHNpemluZ19odG1sQnVpbGRlcihzaXplZFRleHQsIG9wdGlvbnMpO1xuICAgIHZhciBkeSA9IHVuaXRzX2NhbGN1bGF0ZVNpemUoZ3JvdXAuZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcInNoaWZ0XCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IC1keSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG4gICAgdmFyIGR5ID0gZ3JvdXAuZHkubnVtYmVyICsgZ3JvdXAuZHkudW5pdDtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgZHkpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9ydWxlLmpzXG5cblxuXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInJ1bGVcIixcbiAgbmFtZXM6IFtcIlxcXFxydWxlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCIsIFwic2l6ZVwiLCBcInNpemVcIl1cbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyO1xuICAgIHZhciBzaGlmdCA9IG9wdEFyZ3NbMF07XG4gICAgdmFyIHdpZHRoID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpO1xuICAgIHZhciBoZWlnaHQgPSBhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcInNpemVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicnVsZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBzaGlmdDogc2hpZnQgJiYgYXNzZXJ0Tm9kZVR5cGUoc2hpZnQsIFwic2l6ZVwiKS52YWx1ZSxcbiAgICAgIHdpZHRoOiB3aWR0aC52YWx1ZSxcbiAgICAgIGhlaWdodDogaGVpZ2h0LnZhbHVlXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gTWFrZSBhbiBlbXB0eSBzcGFuIGZvciB0aGUgcnVsZVxuICAgIHZhciBydWxlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInJ1bGVcIl0sIFtdLCBvcHRpb25zKTsgLy8gQ2FsY3VsYXRlIHRoZSBzaGlmdCwgd2lkdGgsIGFuZCBoZWlnaHQgb2YgdGhlIHJ1bGUsIGFuZCBhY2NvdW50IGZvciB1bml0c1xuXG4gICAgdmFyIHdpZHRoID0gdW5pdHNfY2FsY3VsYXRlU2l6ZShncm91cC53aWR0aCwgb3B0aW9ucyk7XG4gICAgdmFyIGhlaWdodCA9IHVuaXRzX2NhbGN1bGF0ZVNpemUoZ3JvdXAuaGVpZ2h0LCBvcHRpb25zKTtcbiAgICB2YXIgc2hpZnQgPSBncm91cC5zaGlmdCA/IHVuaXRzX2NhbGN1bGF0ZVNpemUoZ3JvdXAuc2hpZnQsIG9wdGlvbnMpIDogMDsgLy8gU3R5bGUgdGhlIHJ1bGUgdG8gdGhlIHJpZ2h0IHNpemVcblxuICAgIHJ1bGUuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IHdpZHRoICsgXCJlbVwiO1xuICAgIHJ1bGUuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBoZWlnaHQgKyBcImVtXCI7XG4gICAgcnVsZS5zdHlsZS5ib3R0b20gPSBzaGlmdCArIFwiZW1cIjsgLy8gUmVjb3JkIHRoZSBoZWlnaHQgYW5kIHdpZHRoXG5cbiAgICBydWxlLndpZHRoID0gd2lkdGg7XG4gICAgcnVsZS5oZWlnaHQgPSBoZWlnaHQgKyBzaGlmdDtcbiAgICBydWxlLmRlcHRoID0gLXNoaWZ0OyAvLyBGb250IHNpemUgaXMgdGhlIG51bWJlciBsYXJnZSBlbm91Z2ggdGhhdCB0aGUgYnJvd3NlciB3aWxsXG4gICAgLy8gcmVzZXJ2ZSBhdCBsZWFzdCBgYWJzSGVpZ2h0YCBzcGFjZSBhYm92ZSB0aGUgYmFzZWxpbmUuXG4gICAgLy8gVGhlIDEuMTI1IGZhY3RvciB3YXMgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZFxuXG4gICAgcnVsZS5tYXhGb250U2l6ZSA9IGhlaWdodCAqIDEuMTI1ICogb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICByZXR1cm4gcnVsZTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciB3aWR0aCA9IHVuaXRzX2NhbGN1bGF0ZVNpemUoZ3JvdXAud2lkdGgsIG9wdGlvbnMpO1xuICAgIHZhciBoZWlnaHQgPSB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLmhlaWdodCwgb3B0aW9ucyk7XG4gICAgdmFyIHNoaWZ0ID0gZ3JvdXAuc2hpZnQgPyB1bml0c19jYWxjdWxhdGVTaXplKGdyb3VwLnNoaWZ0LCBvcHRpb25zKSA6IDA7XG4gICAgdmFyIGNvbG9yID0gb3B0aW9ucy5jb2xvciAmJiBvcHRpb25zLmdldENvbG9yKCkgfHwgXCJibGFja1wiO1xuICAgIHZhciBydWxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJtYXRoYmFja2dyb3VuZFwiLCBjb2xvcik7XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCArIFwiZW1cIik7XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgXCJlbVwiKTtcbiAgICB2YXIgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbcnVsZV0pO1xuXG4gICAgaWYgKHNoaWZ0ID49IDApIHtcbiAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiK1wiICsgc2hpZnQgKyBcImVtXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBzaGlmdCArIFwiZW1cIik7XG4gICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiK1wiICsgLXNoaWZ0ICsgXCJlbVwiKTtcbiAgICB9XG5cbiAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgc2hpZnQgKyBcImVtXCIpO1xuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zbWFzaC5qc1xuLy8gc21hc2gsIHdpdGggb3B0aW9uYWwgW3RiXSwgYXMgaW4gQU1TXG5cblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic21hc2hcIixcbiAgbmFtZXM6IFtcIlxcXFxzbWFzaFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykge1xuICAgIHZhciBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICB2YXIgc21hc2hIZWlnaHQgPSBmYWxzZTtcbiAgICB2YXIgc21hc2hEZXB0aCA9IGZhbHNlO1xuICAgIHZhciB0YkFyZyA9IG9wdEFyZ3NbMF0gJiYgYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgXCJvcmRncm91cFwiKTtcblxuICAgIGlmICh0YkFyZykge1xuICAgICAgLy8gT3B0aW9uYWwgW3RiXSBhcmd1bWVudCBpcyBlbmdhZ2VkLlxuICAgICAgLy8gcmVmOiBhbXNtYXRoOiBcXHJlbmV3Y29tbWFuZHtcXHNtYXNofVsxXVt0Yl17JVxuICAgICAgLy8gICAgICAgICAgICAgICBkZWZcXG1iQHR7XFxodH1cXGRlZlxcbWJAYntcXGRwfVxcZGVmXFxtYkB0YntcXGh0XFx6QFxcekBcXGRwfSVcbiAgICAgIHZhciBsZXR0ZXIgPSBcIlwiO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRiQXJnLmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0YkFyZy5ib2R5W2ldOyAvLyAkRmxvd0ZpeE1lOiBOb3QgZXZlcnkgbm9kZSB0eXBlIGhhcyBhIGB0ZXh0YCBwcm9wZXJ0eS5cblxuICAgICAgICBsZXR0ZXIgPSBub2RlLnRleHQ7XG5cbiAgICAgICAgaWYgKGxldHRlciA9PT0gXCJ0XCIpIHtcbiAgICAgICAgICBzbWFzaEhlaWdodCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcImJcIikge1xuICAgICAgICAgIHNtYXNoRGVwdGggPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNtYXNoSGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgc21hc2hEZXB0aCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNtYXNoSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgIHNtYXNoRGVwdGggPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzbWFzaFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBib2R5LFxuICAgICAgc21hc2hIZWlnaHQ6IHNtYXNoSGVpZ2h0LFxuICAgICAgc21hc2hEZXB0aDogc21hc2hEZXB0aFxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtidWlsZEhUTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgaWYgKCFncm91cC5zbWFzaEhlaWdodCAmJiAhZ3JvdXAuc21hc2hEZXB0aCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnNtYXNoSGVpZ2h0KSB7XG4gICAgICBub2RlLmhlaWdodCA9IDA7IC8vIEluIG9yZGVyIHRvIGluZmx1ZW5jZSBtYWtlVkxpc3QsIHdlIGhhdmUgdG8gcmVzZXQgdGhlIGNoaWxkcmVuLlxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hEZXB0aCkge1xuICAgICAgbm9kZS5kZXB0aCA9IDA7XG5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW5bX2ldLmRlcHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgd2UndmUgcmVzZXQgdGhlIFRlWC1saWtlIGhlaWdodCBhbmQgZGVwdGggdmFsdWVzLlxuICAgIC8vIEJ1dCB0aGUgc3BhbiBzdGlsbCBoYXMgYW4gSFRNTCBsaW5lIGhlaWdodC5cbiAgICAvLyBtYWtlVkxpc3QgYXBwbGllcyBcImRpc3BsYXk6IHRhYmxlLWNlbGxcIiwgd2hpY2ggcHJldmVudHMgdGhlIGJyb3dzZXJcbiAgICAvLyBmcm9tIGFjdGluZyBvbiB0aGF0IGxpbmUgaGVpZ2h0LiBTbyB3ZSdsbCBjYWxsIG1ha2VWTGlzdCBub3cuXG5cblxuICAgIHZhciBzbWFzaGVkTm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBub2RlXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpOyAvLyBGb3Igc3BhY2luZywgVGVYIHRyZWF0cyBcXGhwaGFudG9tIGFzIGEgbWF0aCBncm91cCAoc2FtZSBzcGFjaW5nIGFzIG9yZCkuXG5cbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiXSwgW3NtYXNoZWROb2RlXSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgaWYgKGdyb3VwLnNtYXNoSGVpZ2h0KSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjBweFwiKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hEZXB0aCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBcIjBweFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvc3FydC5qc1xuXG5cblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic3FydFwiLFxuICBuYW1lczogW1wiXFxcXHNxcnRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihfcmVmLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgdmFyIHBhcnNlciA9IF9yZWYucGFyc2VyO1xuICAgIHZhciBpbmRleCA9IG9wdEFyZ3NbMF07XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNxcnRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogYm9keSxcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFNxdWFyZSByb290cyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBwZy4gNDQzLCBSdWxlIDExLlxuICAgIC8vIEZpcnN0LCB3ZSBkbyB0aGUgc2FtZSBzdGVwcyBhcyBpbiBvdmVybGluZSB0byBidWlsZCB0aGUgaW5uZXIgZ3JvdXBcbiAgICAvLyBhbmQgbGluZVxuICAgIHZhciBpbm5lciA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMuaGF2aW5nQ3JhbXBlZFN0eWxlKCkpO1xuXG4gICAgaWYgKGlubmVyLmhlaWdodCA9PT0gMCkge1xuICAgICAgLy8gUmVuZGVyIGEgc21hbGwgc3VyZC5cbiAgICAgIGlubmVyLmhlaWdodCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS54SGVpZ2h0O1xuICAgIH0gLy8gU29tZSBncm91cHMgY2FuIHJldHVybiBkb2N1bWVudCBmcmFnbWVudHMuICBIYW5kbGUgdGhvc2UgYnkgd3JhcHBpbmdcbiAgICAvLyB0aGVtIGluIGEgc3Bhbi5cblxuXG4gICAgaW5uZXIgPSBidWlsZENvbW1vbi53cmFwRnJhZ21lbnQoaW5uZXIsIG9wdGlvbnMpOyAvLyBDYWxjdWxhdGUgdGhlIG1pbmltdW0gc2l6ZSBmb3IgdGhlIFxcc3VyZCBkZWxpbWl0ZXJcblxuICAgIHZhciBtZXRyaWNzID0gb3B0aW9ucy5mb250TWV0cmljcygpO1xuICAgIHZhciB0aGV0YSA9IG1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3M7XG4gICAgdmFyIHBoaSA9IHRoZXRhO1xuXG4gICAgaWYgKG9wdGlvbnMuc3R5bGUuaWQgPCBzcmNfU3R5bGUuVEVYVC5pZCkge1xuICAgICAgcGhpID0gb3B0aW9ucy5mb250TWV0cmljcygpLnhIZWlnaHQ7XG4gICAgfSAvLyBDYWxjdWxhdGUgdGhlIGNsZWFyYW5jZSBiZXR3ZWVuIHRoZSBib2R5IGFuZCBsaW5lXG5cblxuICAgIHZhciBsaW5lQ2xlYXJhbmNlID0gdGhldGEgKyBwaGkgLyA0O1xuICAgIHZhciBtaW5EZWxpbWl0ZXJIZWlnaHQgPSBpbm5lci5oZWlnaHQgKyBpbm5lci5kZXB0aCArIGxpbmVDbGVhcmFuY2UgKyB0aGV0YTsgLy8gQ3JlYXRlIGEgc3FydCBTVkcgb2YgdGhlIHJlcXVpcmVkIG1pbmltdW0gc2l6ZVxuXG4gICAgdmFyIF9kZWxpbWl0ZXIkc3FydEltYWdlID0gZGVsaW1pdGVyLnNxcnRJbWFnZShtaW5EZWxpbWl0ZXJIZWlnaHQsIG9wdGlvbnMpLFxuICAgICAgICBpbWcgPSBfZGVsaW1pdGVyJHNxcnRJbWFnZS5zcGFuLFxuICAgICAgICBydWxlV2lkdGggPSBfZGVsaW1pdGVyJHNxcnRJbWFnZS5ydWxlV2lkdGgsXG4gICAgICAgIGFkdmFuY2VXaWR0aCA9IF9kZWxpbWl0ZXIkc3FydEltYWdlLmFkdmFuY2VXaWR0aDtcblxuICAgIHZhciBkZWxpbURlcHRoID0gaW1nLmhlaWdodCAtIHJ1bGVXaWR0aDsgLy8gQWRqdXN0IHRoZSBjbGVhcmFuY2UgYmFzZWQgb24gdGhlIGRlbGltaXRlciBzaXplXG5cbiAgICBpZiAoZGVsaW1EZXB0aCA+IGlubmVyLmhlaWdodCArIGlubmVyLmRlcHRoICsgbGluZUNsZWFyYW5jZSkge1xuICAgICAgbGluZUNsZWFyYW5jZSA9IChsaW5lQ2xlYXJhbmNlICsgZGVsaW1EZXB0aCAtIGlubmVyLmhlaWdodCAtIGlubmVyLmRlcHRoKSAvIDI7XG4gICAgfSAvLyBTaGlmdCB0aGUgc3FydCBpbWFnZVxuXG5cbiAgICB2YXIgaW1nU2hpZnQgPSBpbWcuaGVpZ2h0IC0gaW5uZXIuaGVpZ2h0IC0gbGluZUNsZWFyYW5jZSAtIHJ1bGVXaWR0aDtcbiAgICBpbm5lci5zdHlsZS5wYWRkaW5nTGVmdCA9IGFkdmFuY2VXaWR0aCArIFwiZW1cIjsgLy8gT3ZlcmxheSB0aGUgaW1hZ2UgYW5kIHRoZSBhcmd1bWVudC5cblxuICAgIHZhciBib2R5ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGlubmVyLFxuICAgICAgICB3cmFwcGVyQ2xhc3NlczogW1wic3ZnLWFsaWduXCJdXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiAtKGlubmVyLmhlaWdodCArIGltZ1NoaWZ0KVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW1nXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBydWxlV2lkdGhcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIWdyb3VwLmluZGV4KSB7XG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInNxcnRcIl0sIFtib2R5XSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhhbmRsZSB0aGUgb3B0aW9uYWwgcm9vdCBpbmRleFxuICAgICAgLy8gVGhlIGluZGV4IGlzIGFsd2F5cyBpbiBzY3JpcHRzY3JpcHQgc3R5bGVcbiAgICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShzcmNfU3R5bGUuU0NSSVBUU0NSSVBUKTtcbiAgICAgIHZhciByb290bSA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKGdyb3VwLmluZGV4LCBuZXdPcHRpb25zLCBvcHRpb25zKTsgLy8gVGhlIGFtb3VudCB0aGUgaW5kZXggaXMgc2hpZnRlZCBieS4gVGhpcyBpcyB0YWtlbiBmcm9tIHRoZSBUZVhcbiAgICAgIC8vIHNvdXJjZSwgaW4gdGhlIGRlZmluaXRpb24gb2YgYFxcckBAdGAuXG5cbiAgICAgIHZhciB0b1NoaWZ0ID0gMC42ICogKGJvZHkuaGVpZ2h0IC0gYm9keS5kZXB0aCk7IC8vIEJ1aWxkIGEgVkxpc3Qgd2l0aCB0aGUgc3VwZXJzY3JpcHQgc2hpZnRlZCB1cCBjb3JyZWN0bHlcblxuICAgICAgdmFyIHJvb3RWTGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJzaGlmdFwiLFxuICAgICAgICBwb3NpdGlvbkRhdGE6IC10b1NoaWZ0LFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiByb290bVxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7IC8vIEFkZCBhIGNsYXNzIHN1cnJvdW5kaW5nIGl0IHNvIHdlIGNhbiBhZGQgb24gdGhlIGFwcHJvcHJpYXRlXG4gICAgICAvLyBrZXJuaW5nXG5cbiAgICAgIHZhciByb290Vkxpc3RXcmFwID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wicm9vdFwiXSwgW3Jvb3RWTGlzdF0pO1xuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJzcXJ0XCJdLCBbcm9vdFZMaXN0V3JhcCwgYm9keV0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBib2R5ID0gZ3JvdXAuYm9keSxcbiAgICAgICAgaW5kZXggPSBncm91cC5pbmRleDtcbiAgICByZXR1cm4gaW5kZXggPyBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb290XCIsIFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGJvZHksIG9wdGlvbnMpLCBidWlsZE1hdGhNTF9idWlsZEdyb3VwKGluZGV4LCBvcHRpb25zKV0pIDogbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3FydFwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChib2R5LCBvcHRpb25zKV0pO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zdHlsaW5nLmpzXG5cblxuXG5cblxudmFyIHN0eWxpbmdfc3R5bGVNYXAgPSB7XG4gIFwiZGlzcGxheVwiOiBzcmNfU3R5bGUuRElTUExBWSxcbiAgXCJ0ZXh0XCI6IHNyY19TdHlsZS5URVhULFxuICBcInNjcmlwdFwiOiBzcmNfU3R5bGUuU0NSSVBULFxuICBcInNjcmlwdHNjcmlwdFwiOiBzcmNfU3R5bGUuU0NSSVBUU0NSSVBUXG59O1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInN0eWxpbmdcIixcbiAgbmFtZXM6IFtcIlxcXFxkaXNwbGF5c3R5bGVcIiwgXCJcXFxcdGV4dHN0eWxlXCIsIFwiXFxcXHNjcmlwdHN0eWxlXCIsIFwiXFxcXHNjcmlwdHNjcmlwdHN0eWxlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgYnJlYWtPblRva2VuVGV4dCA9IF9yZWYuYnJlYWtPblRva2VuVGV4dCxcbiAgICAgICAgZnVuY05hbWUgPSBfcmVmLmZ1bmNOYW1lLFxuICAgICAgICBwYXJzZXIgPSBfcmVmLnBhcnNlcjtcbiAgICAvLyBwYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHlcbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCk7IC8vIFRPRE86IFJlZmFjdG9yIHRvIGF2b2lkIGR1cGxpY2F0aW5nIHN0eWxlTWFwIGluIG11bHRpcGxlIHBsYWNlcyAoZS5nLlxuICAgIC8vIGhlcmUgYW5kIGluIGJ1aWxkSFRNTCBhbmQgZGUtZHVwZSB0aGUgZW51bWVyYXRpb24gb2YgYWxsIHRoZSBzdHlsZXMpLlxuICAgIC8vICRGbG93Rml4TWU6IFRoZSBuYW1lcyBhYm92ZSBleGFjdGx5IG1hdGNoIHRoZSBzdHlsZXMuXG5cbiAgICB2YXIgc3R5bGUgPSBmdW5jTmFtZS5zbGljZSgxLCBmdW5jTmFtZS5sZW5ndGggLSA1KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCBzdHlsZSB0byB1c2UgYnkgcHVsbGluZyBvdXQgdGhlIHN0eWxlIGZyb21cbiAgICAgIC8vIHRoZSBmdW5jdGlvbiBuYW1lXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBib2R5OiBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3R5bGUgY2hhbmdlcyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBvbiBwZy4gNDQyLCBSdWxlIDMuXG4gICAgdmFyIG5ld1N0eWxlID0gc3R5bGluZ19zdHlsZU1hcFtncm91cC5zdHlsZV07XG4gICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG5ld1N0eWxlKS53aXRoRm9udCgnJyk7XG4gICAgcmV0dXJuIHNpemluZ0dyb3VwKGdyb3VwLmJvZHksIG5ld09wdGlvbnMsIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHdlJ3JlIGNoYW5naW5nIHRvLlxuICAgIC8vIFRPRE8oa2V2aW5iKTogZGVkdXBlIHRoaXMgd2l0aCBidWlsZEhUTUwuanNcbiAgICAvLyBUaGlzIHdpbGwgYmUgZWFzaWVyIG9mIGhhbmRsaW5nIG9mIHN0eWxpbmcgbm9kZXMgaXMgaW4gdGhlIHNhbWUgZmlsZS5cbiAgICB2YXIgc3R5bGVNYXAgPSB7XG4gICAgICBcImRpc3BsYXlcIjogc3JjX1N0eWxlLkRJU1BMQVksXG4gICAgICBcInRleHRcIjogc3JjX1N0eWxlLlRFWFQsXG4gICAgICBcInNjcmlwdFwiOiBzcmNfU3R5bGUuU0NSSVBULFxuICAgICAgXCJzY3JpcHRzY3JpcHRcIjogc3JjX1N0eWxlLlNDUklQVFNDUklQVFxuICAgIH07XG4gICAgdmFyIG5ld1N0eWxlID0gc3R5bGVNYXBbZ3JvdXAuc3R5bGVdO1xuICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShuZXdTdHlsZSk7XG4gICAgdmFyIGlubmVyID0gYnVpbGRNYXRoTUxfYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG5ld09wdGlvbnMpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgaW5uZXIpO1xuICAgIHZhciBzdHlsZUF0dHJpYnV0ZXMgPSB7XG4gICAgICBcImRpc3BsYXlcIjogW1wiMFwiLCBcInRydWVcIl0sXG4gICAgICBcInRleHRcIjogW1wiMFwiLCBcImZhbHNlXCJdLFxuICAgICAgXCJzY3JpcHRcIjogW1wiMVwiLCBcImZhbHNlXCJdLFxuICAgICAgXCJzY3JpcHRzY3JpcHRcIjogW1wiMlwiLCBcImZhbHNlXCJdXG4gICAgfTtcbiAgICB2YXIgYXR0ciA9IHN0eWxlQXR0cmlidXRlc1tncm91cC5zdHlsZV07XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBhdHRyWzBdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBhdHRyWzFdKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvc3Vwc3ViLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qKlxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogc3Vic2NyaXB0cyBhdHRhY2hlZCB0byB0aGVtLiBUaGlzIGZ1bmN0aW9uIGxldHMgdGhlIGBzdXBzdWJgIGdyb3VwIGtub3cgdGhhdFxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogaXRzIGlubmVyIGVsZW1lbnQgc2hvdWxkIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGluc3RlYWQgb2ZcbiAqIGhhbmRsaW5nIHRoZW0gaXRzZWxmLlxuICovXG52YXIgc3Vwc3ViX2h0bWxCdWlsZGVyRGVsZWdhdGUgPSBmdW5jdGlvbiBodG1sQnVpbGRlckRlbGVnYXRlKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBiYXNlID0gZ3JvdXAuYmFzZTtcblxuICBpZiAoIWJhc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChiYXNlLnR5cGUgPT09IFwib3BcIikge1xuICAgIC8vIE9wZXJhdG9ycyBoYW5kbGUgc3Vwc3VicyBkaWZmZXJlbnRseSB3aGVuIHRoZXkgaGF2ZSBsaW1pdHNcbiAgICAvLyAoZS5nLiBgXFxkaXNwbGF5c3R5bGVcXHN1bV8yXjNgKVxuICAgIHZhciBkZWxlZ2F0ZSA9IGJhc2UubGltaXRzICYmIChvcHRpb25zLnN0eWxlLnNpemUgPT09IHNyY19TdHlsZS5ESVNQTEFZLnNpemUgfHwgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpO1xuICAgIHJldHVybiBkZWxlZ2F0ZSA/IG9wX2h0bWxCdWlsZGVyIDogbnVsbDtcbiAgfSBlbHNlIGlmIChiYXNlLnR5cGUgPT09IFwiYWNjZW50XCIpIHtcbiAgICByZXR1cm4gdXRpbHMuaXNDaGFyYWN0ZXJCb3goYmFzZS5iYXNlKSA/IGFjY2VudF9odG1sQnVpbGRlciA6IG51bGw7XG4gIH0gZWxzZSBpZiAoYmFzZS50eXBlID09PSBcImhvcml6QnJhY2VcIikge1xuICAgIHZhciBpc1N1cCA9ICFncm91cC5zdWI7XG4gICAgcmV0dXJuIGlzU3VwID09PSBiYXNlLmlzT3ZlciA/IGhvcml6QnJhY2VfaHRtbEJ1aWxkZXIgOiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59OyAvLyBTdXBlciBzY3JpcHRzIGFuZCBzdWJzY3JpcHRzLCB3aG9zZSBwcmVjaXNlIHBsYWNlbWVudCBjYW4gZGVwZW5kIG9uIG90aGVyXG4vLyBmdW5jdGlvbnMgdGhhdCBwcmVjZWRlIHRoZW0uXG5cblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwic3Vwc3ViXCIsXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFN1cGVyc2NyaXB0IGFuZCBzdWJzY3JpcHRzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIG9uIHBhZ2VcbiAgICAvLyA0NDUtNDQ2LCBydWxlcyAxOChhLWYpLlxuICAgIC8vIEhlcmUgaXMgd2hlcmUgd2UgZGVmZXIgdG8gdGhlIGlubmVyIGdyb3VwIGlmIGl0IHNob3VsZCBoYW5kbGVcbiAgICAvLyBzdXBlcnNjcmlwdHMgYW5kIHN1YnNjcmlwdHMgaXRzZWxmLlxuICAgIHZhciBidWlsZGVyRGVsZWdhdGUgPSBzdXBzdWJfaHRtbEJ1aWxkZXJEZWxlZ2F0ZShncm91cCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoYnVpbGRlckRlbGVnYXRlKSB7XG4gICAgICByZXR1cm4gYnVpbGRlckRlbGVnYXRlKGdyb3VwLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVCYXNlID0gZ3JvdXAuYmFzZSxcbiAgICAgICAgdmFsdWVTdXAgPSBncm91cC5zdXAsXG4gICAgICAgIHZhbHVlU3ViID0gZ3JvdXAuc3ViO1xuICAgIHZhciBiYXNlID0gYnVpbGRIVE1MX2J1aWxkR3JvdXAodmFsdWVCYXNlLCBvcHRpb25zKTtcbiAgICB2YXIgc3VwbTtcbiAgICB2YXIgc3VibTtcbiAgICB2YXIgbWV0cmljcyA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKTsgLy8gUnVsZSAxOGFcblxuICAgIHZhciBzdXBTaGlmdCA9IDA7XG4gICAgdmFyIHN1YlNoaWZ0ID0gMDtcbiAgICB2YXIgaXNDaGFyYWN0ZXJCb3ggPSB2YWx1ZUJhc2UgJiYgdXRpbHMuaXNDaGFyYWN0ZXJCb3godmFsdWVCYXNlKTtcblxuICAgIGlmICh2YWx1ZVN1cCkge1xuICAgICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG9wdGlvbnMuc3R5bGUuc3VwKCkpO1xuICAgICAgc3VwbSA9IGJ1aWxkSFRNTF9idWlsZEdyb3VwKHZhbHVlU3VwLCBuZXdPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFpc0NoYXJhY3RlckJveCkge1xuICAgICAgICBzdXBTaGlmdCA9IGJhc2UuaGVpZ2h0IC0gbmV3T3B0aW9ucy5mb250TWV0cmljcygpLnN1cERyb3AgKiBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWVTdWIpIHtcbiAgICAgIHZhciBfbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUob3B0aW9ucy5zdHlsZS5zdWIoKSk7XG5cbiAgICAgIHN1Ym0gPSBidWlsZEhUTUxfYnVpbGRHcm91cCh2YWx1ZVN1YiwgX25ld09wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIWlzQ2hhcmFjdGVyQm94KSB7XG4gICAgICAgIHN1YlNoaWZ0ID0gYmFzZS5kZXB0aCArIF9uZXdPcHRpb25zLmZvbnRNZXRyaWNzKCkuc3ViRHJvcCAqIF9uZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICAgIH1cbiAgICB9IC8vIFJ1bGUgMThjXG5cblxuICAgIHZhciBtaW5TdXBTaGlmdDtcblxuICAgIGlmIChvcHRpb25zLnN0eWxlID09PSBzcmNfU3R5bGUuRElTUExBWSkge1xuICAgICAgbWluU3VwU2hpZnQgPSBtZXRyaWNzLnN1cDE7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnN0eWxlLmNyYW1wZWQpIHtcbiAgICAgIG1pblN1cFNoaWZ0ID0gbWV0cmljcy5zdXAzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW5TdXBTaGlmdCA9IG1ldHJpY3Muc3VwMjtcbiAgICB9IC8vIHNjcmlwdHNwYWNlIGlzIGEgZm9udC1zaXplLWluZGVwZW5kZW50IHNpemUsIHNvIHNjYWxlIGl0XG4gICAgLy8gYXBwcm9wcmlhdGVseSBmb3IgdXNlIGFzIHRoZSBtYXJnaW5SaWdodC5cblxuXG4gICAgdmFyIG11bHRpcGxpZXIgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgIHZhciBtYXJnaW5SaWdodCA9IDAuNSAvIG1ldHJpY3MucHRQZXJFbSAvIG11bHRpcGxpZXIgKyBcImVtXCI7XG4gICAgdmFyIG1hcmdpbkxlZnQgPSBudWxsO1xuXG4gICAgaWYgKHN1Ym0pIHtcbiAgICAgIC8vIFN1YnNjcmlwdHMgc2hvdWxkbid0IGJlIHNoaWZ0ZWQgYnkgdGhlIGJhc2UncyBpdGFsaWMgY29ycmVjdGlvbi5cbiAgICAgIC8vIEFjY291bnQgZm9yIHRoYXQgYnkgc2hpZnRpbmcgdGhlIHN1YnNjcmlwdCBiYWNrIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgLy8gYW1vdW50LiBOb3RlIHdlIG9ubHkgZG8gdGhpcyB3aGVuIHRoZSBiYXNlIGlzIGEgc2luZ2xlIHN5bWJvbC5cbiAgICAgIHZhciBpc09paW50ID0gZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnR5cGUgPT09IFwib3BcIiAmJiBncm91cC5iYXNlLm5hbWUgJiYgKGdyb3VwLmJhc2UubmFtZSA9PT0gXCJcXFxcb2lpbnRcIiB8fCBncm91cC5iYXNlLm5hbWUgPT09IFwiXFxcXG9paWludFwiKTtcblxuICAgICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBkb21UcmVlX1N5bWJvbE5vZGUgfHwgaXNPaWludCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIG1hcmdpbkxlZnQgPSAtYmFzZS5pdGFsaWMgKyBcImVtXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN1cHN1YjtcblxuICAgIGlmIChzdXBtICYmIHN1Ym0pIHtcbiAgICAgIHN1cFNoaWZ0ID0gTWF0aC5tYXgoc3VwU2hpZnQsIG1pblN1cFNoaWZ0LCBzdXBtLmRlcHRoICsgMC4yNSAqIG1ldHJpY3MueEhlaWdodCk7XG4gICAgICBzdWJTaGlmdCA9IE1hdGgubWF4KHN1YlNoaWZ0LCBtZXRyaWNzLnN1YjIpO1xuICAgICAgdmFyIHJ1bGVXaWR0aCA9IG1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3M7IC8vIFJ1bGUgMThlXG5cbiAgICAgIHZhciBtYXhXaWR0aCA9IDQgKiBydWxlV2lkdGg7XG5cbiAgICAgIGlmIChzdXBTaGlmdCAtIHN1cG0uZGVwdGggLSAoc3VibS5oZWlnaHQgLSBzdWJTaGlmdCkgPCBtYXhXaWR0aCkge1xuICAgICAgICBzdWJTaGlmdCA9IG1heFdpZHRoIC0gKHN1cFNoaWZ0IC0gc3VwbS5kZXB0aCkgKyBzdWJtLmhlaWdodDtcbiAgICAgICAgdmFyIHBzaSA9IDAuOCAqIG1ldHJpY3MueEhlaWdodCAtIChzdXBTaGlmdCAtIHN1cG0uZGVwdGgpO1xuXG4gICAgICAgIGlmIChwc2kgPiAwKSB7XG4gICAgICAgICAgc3VwU2hpZnQgKz0gcHNpO1xuICAgICAgICAgIHN1YlNoaWZ0IC09IHBzaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmxpc3RFbGVtID0gW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHN1Ym0sXG4gICAgICAgIHNoaWZ0OiBzdWJTaGlmdCxcbiAgICAgICAgbWFyZ2luUmlnaHQ6IG1hcmdpblJpZ2h0LFxuICAgICAgICBtYXJnaW5MZWZ0OiBtYXJnaW5MZWZ0XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdXBtLFxuICAgICAgICBzaGlmdDogLXN1cFNoaWZ0LFxuICAgICAgICBtYXJnaW5SaWdodDogbWFyZ2luUmlnaHRcbiAgICAgIH1dO1xuICAgICAgc3Vwc3ViID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgICBjaGlsZHJlbjogdmxpc3RFbGVtXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHN1Ym0pIHtcbiAgICAgIC8vIFJ1bGUgMThiXG4gICAgICBzdWJTaGlmdCA9IE1hdGgubWF4KHN1YlNoaWZ0LCBtZXRyaWNzLnN1YjEsIHN1Ym0uaGVpZ2h0IC0gMC44ICogbWV0cmljcy54SGVpZ2h0KTtcbiAgICAgIHZhciBfdmxpc3RFbGVtID0gW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHN1Ym0sXG4gICAgICAgIG1hcmdpbkxlZnQ6IG1hcmdpbkxlZnQsXG4gICAgICAgIG1hcmdpblJpZ2h0OiBtYXJnaW5SaWdodFxuICAgICAgfV07XG4gICAgICBzdXBzdWIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwic2hpZnRcIixcbiAgICAgICAgcG9zaXRpb25EYXRhOiBzdWJTaGlmdCxcbiAgICAgICAgY2hpbGRyZW46IF92bGlzdEVsZW1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoc3VwbSkge1xuICAgICAgLy8gUnVsZSAxOGMsIGRcbiAgICAgIHN1cFNoaWZ0ID0gTWF0aC5tYXgoc3VwU2hpZnQsIG1pblN1cFNoaWZ0LCBzdXBtLmRlcHRoICsgMC4yNSAqIG1ldHJpY3MueEhlaWdodCk7XG4gICAgICBzdXBzdWIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwic2hpZnRcIixcbiAgICAgICAgcG9zaXRpb25EYXRhOiAtc3VwU2hpZnQsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHN1cG0sXG4gICAgICAgICAgbWFyZ2luUmlnaHQ6IG1hcmdpblJpZ2h0XG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3Vwc3ViIG11c3QgaGF2ZSBlaXRoZXIgc3VwIG9yIHN1Yi5cIik7XG4gICAgfSAvLyBXcmFwIHRoZSBzdXBzdWIgdmxpc3QgaW4gYSBzcGFuLm1zdXBzdWIgdG8gcmVzZXQgdGV4dC1hbGlnbi5cblxuXG4gICAgdmFyIG1jbGFzcyA9IGdldFR5cGVPZkRvbVRyZWUoYmFzZSwgXCJyaWdodFwiKSB8fCBcIm1vcmRcIjtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW21jbGFzc10sIFtiYXNlLCBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtc3Vwc3ViXCJdLCBbc3Vwc3ViXSldLCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIElzIHRoZSBpbm5lciBncm91cCBhIHJlbGV2YW50IGhvcml6b25hbCBicmFjZT9cbiAgICB2YXIgaXNCcmFjZSA9IGZhbHNlO1xuICAgIHZhciBpc092ZXI7XG4gICAgdmFyIGlzU3VwO1xuICAgIHZhciBob3JpekJyYWNlID0gY2hlY2tOb2RlVHlwZShncm91cC5iYXNlLCBcImhvcml6QnJhY2VcIik7XG5cbiAgICBpZiAoaG9yaXpCcmFjZSkge1xuICAgICAgaXNTdXAgPSAhIWdyb3VwLnN1cDtcblxuICAgICAgaWYgKGlzU3VwID09PSBob3JpekJyYWNlLmlzT3Zlcikge1xuICAgICAgICBpc0JyYWNlID0gdHJ1ZTtcbiAgICAgICAgaXNPdmVyID0gaG9yaXpCcmFjZS5pc092ZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLmJhc2UgJiYgZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wXCIpIHtcbiAgICAgIGdyb3VwLmJhc2UucGFyZW50SXNTdXBTdWIgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IFtidWlsZE1hdGhNTF9idWlsZEdyb3VwKGdyb3VwLmJhc2UsIG9wdGlvbnMpXTtcblxuICAgIGlmIChncm91cC5zdWIpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5zdWIsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc3VwKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKGJ1aWxkTWF0aE1MX2J1aWxkR3JvdXAoZ3JvdXAuc3VwLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVUeXBlO1xuXG4gICAgaWYgKGlzQnJhY2UpIHtcbiAgICAgIG5vZGVUeXBlID0gaXNPdmVyID8gXCJtb3ZlclwiIDogXCJtdW5kZXJcIjtcbiAgICB9IGVsc2UgaWYgKCFncm91cC5zdWIpIHtcbiAgICAgIHZhciBiYXNlID0gZ3JvdXAuYmFzZTtcblxuICAgICAgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wXCIgJiYgYmFzZS5saW1pdHMgJiYgKG9wdGlvbnMuc3R5bGUgPT09IHNyY19TdHlsZS5ESVNQTEFZIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibW92ZXJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtc3VwXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghZ3JvdXAuc3VwKSB7XG4gICAgICB2YXIgX2Jhc2UgPSBncm91cC5iYXNlO1xuXG4gICAgICBpZiAoX2Jhc2UgJiYgX2Jhc2UudHlwZSA9PT0gXCJvcFwiICYmIF9iYXNlLmxpbWl0cyAmJiAob3B0aW9ucy5zdHlsZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkgfHwgX2Jhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibXVuZGVyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlVHlwZSA9IFwibXN1YlwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2Jhc2UyID0gZ3JvdXAuYmFzZTtcblxuICAgICAgaWYgKF9iYXNlMiAmJiBfYmFzZTIudHlwZSA9PT0gXCJvcFwiICYmIF9iYXNlMi5saW1pdHMgJiYgb3B0aW9ucy5zdHlsZSA9PT0gc3JjX1N0eWxlLkRJU1BMQVkpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlcm92ZXJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtc3Vic3VwXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShub2RlVHlwZSwgY2hpbGRyZW4pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zeW1ib2xzT3AuanNcblxuXG5cbiAvLyBPcGVyYXRvciBQYXJzZU5vZGVzIGNyZWF0ZWQgaW4gUGFyc2VyLmpzIGZyb20gc3ltYm9sIEdyb3VwcyBpbiBzcmMvc3ltYm9scy5qcy5cblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwiYXRvbVwiLFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWF0aHN5bShncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtXCIgKyBncm91cC5mYW1pbHldKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbYnVpbGRNYXRoTUxfbWFrZVRleHQoZ3JvdXAudGV4dCwgZ3JvdXAubW9kZSldKTtcblxuICAgIGlmIChncm91cC5mYW1pbHkgPT09IFwiYmluXCIpIHtcbiAgICAgIHZhciB2YXJpYW50ID0gYnVpbGRNYXRoTUxfZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucyk7XG5cbiAgICAgIGlmICh2YXJpYW50ID09PSBcImJvbGQtaXRhbGljXCIpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJwdW5jdFwiKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInNlcGFyYXRvclwiLCBcInRydWVcIik7XG4gICAgfSBlbHNlIGlmIChncm91cC5mYW1pbHkgPT09IFwib3BlblwiIHx8IGdyb3VwLmZhbWlseSA9PT0gXCJjbG9zZVwiKSB7XG4gICAgICAvLyBEZWxpbXMgYnVpbHQgaGVyZSBzaG91bGQgbm90IHN0cmV0Y2ggdmVydGljYWxseS5cbiAgICAgIC8vIFNlZSBkZWxpbXNpemluZy5qcyBmb3Igc3RyZXRjaHkgZGVsaW1zLlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcImZhbHNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zeW1ib2xzT3JkLmpzXG5cblxuXG5cbi8vIFwibWF0aG9yZFwiIGFuZCBcInRleHRvcmRcIiBQYXJzZU5vZGVzIGNyZWF0ZWQgaW4gUGFyc2VyLmpzIGZyb20gc3ltYm9sIEdyb3VwcyBpblxudmFyIGRlZmF1bHRWYXJpYW50ID0ge1xuICBcIm1pXCI6IFwiaXRhbGljXCIsXG4gIFwibW5cIjogXCJub3JtYWxcIixcbiAgXCJtdGV4dFwiOiBcIm5vcm1hbFwiXG59O1xuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwibWF0aG9yZFwiLFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZU9yZChncm91cCwgb3B0aW9ucywgXCJtYXRob3JkXCIpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFtidWlsZE1hdGhNTF9tYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zKV0pO1xuICAgIHZhciB2YXJpYW50ID0gYnVpbGRNYXRoTUxfZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucykgfHwgXCJpdGFsaWNcIjtcblxuICAgIGlmICh2YXJpYW50ICE9PSBkZWZhdWx0VmFyaWFudFtub2RlLnR5cGVdKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIHZhcmlhbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInRleHRvcmRcIixcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciB0ZXh0ID0gYnVpbGRNYXRoTUxfbWFrZVRleHQoZ3JvdXAudGV4dCwgZ3JvdXAubW9kZSwgb3B0aW9ucyk7XG4gICAgdmFyIHZhcmlhbnQgPSBidWlsZE1hdGhNTF9nZXRWYXJpYW50KGdyb3VwLCBvcHRpb25zKSB8fCBcIm5vcm1hbFwiO1xuICAgIHZhciBub2RlO1xuXG4gICAgaWYgKGdyb3VwLm1vZGUgPT09ICd0ZXh0Jykge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgW3RleHRdKTtcbiAgICB9IGVsc2UgaWYgKC9bMC05XS8udGVzdChncm91cC50ZXh0KSkge1xuICAgICAgLy8gVE9ETyhrZXZpbmIpIG1lcmdlIGFkamFjZW50IDxtbj4gbm9kZXNcbiAgICAgIC8vIGRvIGl0IGFzIGEgcG9zdCBwcm9jZXNzaW5nIHN0ZXBcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1uXCIsIFt0ZXh0XSk7XG4gICAgfSBlbHNlIGlmIChncm91cC50ZXh0ID09PSBcIlxcXFxwcmltZVwiKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbdGV4dF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtaVwiLCBbdGV4dF0pO1xuICAgIH1cblxuICAgIGlmICh2YXJpYW50ICE9PSBkZWZhdWx0VmFyaWFudFtub2RlLnR5cGVdKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIHZhcmlhbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy9zeW1ib2xzU3BhY2luZy5qc1xuXG5cblxuIC8vIEEgbWFwIG9mIENTUy1iYXNlZCBzcGFjaW5nIGZ1bmN0aW9ucyB0byB0aGVpciBDU1MgY2xhc3MuXG5cbnZhciBjc3NTcGFjZSA9IHtcbiAgXCJcXFxcbm9icmVha1wiOiBcIm5vYnJlYWtcIixcbiAgXCJcXFxcYWxsb3dicmVha1wiOiBcImFsbG93YnJlYWtcIlxufTsgLy8gQSBsb29rdXAgdGFibGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBzcGFjaW5nIGZ1bmN0aW9uL3N5bWJvbCBzaG91bGQgYmVcbi8vIHRyZWF0ZWQgbGlrZSBhIHJlZ3VsYXIgc3BhY2UgY2hhcmFjdGVyLiAgSWYgYSBzeW1ib2wgb3IgY29tbWFuZCBpcyBhIGtleVxuLy8gaW4gdGhpcyB0YWJsZSwgdGhlbiBpdCBzaG91bGQgYmUgYSByZWd1bGFyIHNwYWNlIGNoYXJhY3Rlci4gIEZ1cnRoZXJtb3JlLFxuLy8gdGhlIGFzc29jaWF0ZWQgdmFsdWUgbWF5IGhhdmUgYSBgY2xhc3NOYW1lYCBzcGVjaWZ5aW5nIGFuIGV4dHJhIENTUyBjbGFzc1xuLy8gdG8gYWRkIHRvIHRoZSBjcmVhdGVkIGBzcGFuYC5cblxudmFyIHJlZ3VsYXJTcGFjZSA9IHtcbiAgXCIgXCI6IHt9LFxuICBcIlxcXFwgXCI6IHt9LFxuICBcIn5cIjoge1xuICAgIGNsYXNzTmFtZTogXCJub2JyZWFrXCJcbiAgfSxcbiAgXCJcXFxcc3BhY2VcIjoge30sXG4gIFwiXFxcXG5vYnJlYWtzcGFjZVwiOiB7XG4gICAgY2xhc3NOYW1lOiBcIm5vYnJlYWtcIlxuICB9XG59OyAvLyBQYXJzZU5vZGU8XCJzcGFjaW5nXCI+IGNyZWF0ZWQgaW4gUGFyc2VyLmpzIGZyb20gdGhlIFwic3BhY2luZ1wiIHN5bWJvbCBHcm91cHMgaW5cbi8vIHNyYy9zeW1ib2xzLmpzLlxuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJzcGFjaW5nXCIsXG4gIGh0bWxCdWlsZGVyOiBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChyZWd1bGFyU3BhY2UuaGFzT3duUHJvcGVydHkoZ3JvdXAudGV4dCkpIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSByZWd1bGFyU3BhY2VbZ3JvdXAudGV4dF0uY2xhc3NOYW1lIHx8IFwiXCI7IC8vIFNwYWNlcyBhcmUgZ2VuZXJhdGVkIGJ5IGFkZGluZyBhbiBhY3R1YWwgc3BhY2UuIEVhY2ggb2YgdGhlc2VcbiAgICAgIC8vIHRoaW5ncyBoYXMgYW4gZW50cnkgaW4gdGhlIHN5bWJvbHMgdGFibGUsIHNvIHRoZXNlIHdpbGwgYmUgdHVybmVkXG4gICAgICAvLyBpbnRvIGFwcHJvcHJpYXRlIG91dHB1dHMuXG5cbiAgICAgIGlmIChncm91cC5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgICB2YXIgb3JkID0gYnVpbGRDb21tb24ubWFrZU9yZChncm91cCwgb3B0aW9ucywgXCJ0ZXh0b3JkXCIpO1xuICAgICAgICBvcmQuY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgIHJldHVybiBvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibXNwYWNlXCIsIGNsYXNzTmFtZV0sIFtidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLnRleHQsIGdyb3VwLm1vZGUsIG9wdGlvbnMpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjc3NTcGFjZS5oYXNPd25Qcm9wZXJ0eShncm91cC50ZXh0KSkge1xuICAgICAgLy8gU3BhY2VzIGJhc2VkIG9uIGp1c3QgYSBDU1MgY2xhc3MuXG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibXNwYWNlXCIsIGNzc1NwYWNlW2dyb3VwLnRleHRdXSwgW10sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmtub3duIHR5cGUgb2Ygc3BhY2UgXFxcIlwiICsgZ3JvdXAudGV4dCArIFwiXFxcIlwiKTtcbiAgICB9XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZTtcblxuICAgIGlmIChyZWd1bGFyU3BhY2UuaGFzT3duUHJvcGVydHkoZ3JvdXAudGV4dCkpIHtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShcIlxceEEwXCIpXSk7XG4gICAgfSBlbHNlIGlmIChjc3NTcGFjZS5oYXNPd25Qcm9wZXJ0eShncm91cC50ZXh0KSkge1xuICAgICAgLy8gQ1NTLWJhc2VkIE1hdGhNTCBzcGFjZXMgKFxcbm9icmVhaywgXFxhbGxvd2JyZWFrKSBhcmUgaWdub3JlZFxuICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmtub3duIHR5cGUgb2Ygc3BhY2UgXFxcIlwiICsgZ3JvdXAudGV4dCArIFwiXFxcIlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvdGFnLmpzXG5cblxuXG5cbnZhciB0YWdfcGFkID0gZnVuY3Rpb24gcGFkKCkge1xuICB2YXIgcGFkTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtdKTtcbiAgcGFkTm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjUwJVwiKTtcbiAgcmV0dXJuIHBhZE5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJ0YWdcIixcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRhYmxlXCIsIFtuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCBbdGFnX3BhZCgpLCBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBbYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIG9wdGlvbnMpXSksIHRhZ19wYWQoKSwgbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2J1aWxkRXhwcmVzc2lvblJvdyhncm91cC50YWcsIG9wdGlvbnMpXSldKV0pO1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMTAwJVwiKTtcbiAgICByZXR1cm4gdGFibGU7IC8vIFRPRE86IExlZnQtYWxpZ25lZCB0YWdzLlxuICAgIC8vIEN1cnJlbnRseSwgdGhlIGdyb3VwIGFuZCBvcHRpb25zIHBhc3NlZCBoZXJlIGRvIG5vdCBjb250YWluXG4gICAgLy8gZW5vdWdoIGluZm8gdG8gc2V0IHRhZyBhbGlnbm1lbnQuIGBsZXFub2AgaXMgaW4gU2V0dGluZ3MgYnV0IGl0IGlzXG4gICAgLy8gbm90IHBhc3NlZCB0byBPcHRpb25zLiBPbiB0aGUgSFRNTCBzaWRlLCBsZXFubyBpc1xuICAgIC8vIHNldCBieSBhIENTUyBjbGFzcyBhcHBsaWVkIGluIGJ1aWxkVHJlZS5qcy4gVGhhdCB3b3VsZCBoYXZlIHdvcmtlZFxuICAgIC8vIGluIE1hdGhNTCBpZiBicm93c2VycyBzdXBwb3J0ZWQgPG1sYWJlbGVkdHI+LiBTaW5jZSB0aGV5IGRvbid0LCB3ZVxuICAgIC8vIG5lZWQgdG8gcmV3cml0ZSB0aGUgd2F5IHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy90ZXh0LmpzXG5cblxuXG4gLy8gTm9uLW1hdGh5IHRleHQsIHBvc3NpYmx5IGluIGEgZm9udFxuXG52YXIgdGV4dEZvbnRGYW1pbGllcyA9IHtcbiAgXCJcXFxcdGV4dFwiOiB1bmRlZmluZWQsXG4gIFwiXFxcXHRleHRybVwiOiBcInRleHRybVwiLFxuICBcIlxcXFx0ZXh0c2ZcIjogXCJ0ZXh0c2ZcIixcbiAgXCJcXFxcdGV4dHR0XCI6IFwidGV4dHR0XCIsXG4gIFwiXFxcXHRleHRub3JtYWxcIjogXCJ0ZXh0cm1cIlxufTtcbnZhciB0ZXh0Rm9udFdlaWdodHMgPSB7XG4gIFwiXFxcXHRleHRiZlwiOiBcInRleHRiZlwiLFxuICBcIlxcXFx0ZXh0bWRcIjogXCJ0ZXh0bWRcIlxufTtcbnZhciB0ZXh0Rm9udFNoYXBlcyA9IHtcbiAgXCJcXFxcdGV4dGl0XCI6IFwidGV4dGl0XCIsXG4gIFwiXFxcXHRleHR1cFwiOiBcInRleHR1cFwiXG59O1xuXG52YXIgb3B0aW9uc1dpdGhGb250ID0gZnVuY3Rpb24gb3B0aW9uc1dpdGhGb250KGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBmb250ID0gZ3JvdXAuZm9udDsgLy8gQ2hlY2tzIGlmIHRoZSBhcmd1bWVudCBpcyBhIGZvbnQgZmFtaWx5IG9yIGEgZm9udCBzdHlsZS5cblxuICBpZiAoIWZvbnQpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSBlbHNlIGlmICh0ZXh0Rm9udEZhbWlsaWVzW2ZvbnRdKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMud2l0aFRleHRGb250RmFtaWx5KHRleHRGb250RmFtaWxpZXNbZm9udF0pO1xuICB9IGVsc2UgaWYgKHRleHRGb250V2VpZ2h0c1tmb250XSkge1xuICAgIHJldHVybiBvcHRpb25zLndpdGhUZXh0Rm9udFdlaWdodCh0ZXh0Rm9udFdlaWdodHNbZm9udF0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvcHRpb25zLndpdGhUZXh0Rm9udFNoYXBlKHRleHRGb250U2hhcGVzW2ZvbnRdKTtcbiAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIixcbiAgbmFtZXM6IFsvLyBGb250IGZhbWlsaWVzXG4gIFwiXFxcXHRleHRcIiwgXCJcXFxcdGV4dHJtXCIsIFwiXFxcXHRleHRzZlwiLCBcIlxcXFx0ZXh0dHRcIiwgXCJcXFxcdGV4dG5vcm1hbFwiLCAvLyBGb250IHdlaWdodHNcbiAgXCJcXFxcdGV4dGJmXCIsIFwiXFxcXHRleHRtZFwiLCAvLyBGb250IFNoYXBlc1xuICBcIlxcXFx0ZXh0aXRcIiwgXCJcXFxcdGV4dHVwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInRleHRcIl0sXG4gICAgZ3JlZWRpbmVzczogMixcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGNvbnN1bWVNb2RlOiBcInRleHRcIlxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXIsXG4gICAgICAgIGZ1bmNOYW1lID0gX3JlZi5mdW5jTmFtZTtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBkZWZpbmVGdW5jdGlvbl9vcmRhcmd1bWVudChib2R5KSxcbiAgICAgIGZvbnQ6IGZ1bmNOYW1lXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zV2l0aEZvbnQoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIHZhciBpbm5lciA9IGJ1aWxkSFRNTF9idWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgbmV3T3B0aW9ucywgdHJ1ZSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJ0ZXh0XCJdLCBidWlsZENvbW1vbi50cnlDb21iaW5lQ2hhcnMoaW5uZXIpLCBuZXdPcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9uc1dpdGhGb250KGdyb3VwLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIG5ld09wdGlvbnMpO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Z1bmN0aW9ucy91bmRlcmxpbmUuanNcblxuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidW5kZXJsaW5lXCIsXG4gIG5hbWVzOiBbXCJcXFxcdW5kZXJsaW5lXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIgcGFyc2VyID0gX3JlZi5wYXJzZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidW5kZXJsaW5lXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogZnVuY3Rpb24gaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBVbmRlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSAxMC5cbiAgICAvLyBCdWlsZCB0aGUgaW5uZXIgZ3JvdXAuXG4gICAgdmFyIGlubmVyR3JvdXAgPSBidWlsZEhUTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKTsgLy8gQ3JlYXRlIHRoZSBsaW5lIHRvIGdvIGJlbG93IHRoZSBib2R5XG5cbiAgICB2YXIgbGluZSA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbihcInVuZGVybGluZS1saW5lXCIsIG9wdGlvbnMpOyAvLyBHZW5lcmF0ZSB0aGUgdmxpc3QsIHdpdGggdGhlIGFwcHJvcHJpYXRlIGtlcm5zXG5cbiAgICB2YXIgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcInRvcFwiLFxuICAgICAgcG9zaXRpb25EYXRhOiBpbm5lckdyb3VwLmhlaWdodCxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogbGluZS5oZWlnaHRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGxpbmVcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IDMgKiBsaW5lLmhlaWdodFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW5uZXJHcm91cFxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInVuZGVybGluZVwiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShcIlxcdTIwM0VcIildKTtcbiAgICBvcGVyYXRvci5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm11bmRlclwiLCBbYnVpbGRNYXRoTUxfYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKSwgb3BlcmF0b3JdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudHVuZGVyXCIsIFwidHJ1ZVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMvdmVyYi5qc1xuXG5cblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidmVyYlwiLFxuICBuYW1lczogW1wiXFxcXHZlcmJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncykge1xuICAgIC8vIFxcdmVyYiBhbmQgXFx2ZXJiKiBhcmUgZGVhbHQgd2l0aCBkaXJlY3RseSBpbiBQYXJzZXIuanMuXG4gICAgLy8gSWYgd2UgZW5kIHVwIGhlcmUsIGl0J3MgYmVjYXVzZSBvZiBhIGZhaWx1cmUgdG8gbWF0Y2ggdGhlIHR3byBkZWxpbWl0ZXJzXG4gICAgLy8gaW4gdGhlIHJlZ2V4IGluIExleGVyLmpzLiAgTGFUZVggcmFpc2VzIHRoZSBmb2xsb3dpbmcgZXJyb3Igd2hlbiBcXHZlcmIgaXNcbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBsaW5lIChvciBmaWxlKS5cbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcdmVyYiBlbmRlZCBieSBlbmQgb2YgbGluZSBpbnN0ZWFkIG9mIG1hdGNoaW5nIGRlbGltaXRlclwiKTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHRleHQgPSBtYWtlVmVyYihncm91cCk7XG4gICAgdmFyIGJvZHkgPSBbXTsgLy8gXFx2ZXJiIGVudGVycyB0ZXh0IG1vZGUgYW5kIHRoZXJlZm9yZSBpcyBzaXplZCBsaWtlIFxcdGV4dHN0eWxlXG5cbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUob3B0aW9ucy5zdHlsZS50ZXh0KCkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHRleHRbaV07XG5cbiAgICAgIGlmIChjID09PSAnficpIHtcbiAgICAgICAgYyA9ICdcXFxcdGV4dGFzY2lpdGlsZGUnO1xuICAgICAgfVxuXG4gICAgICBib2R5LnB1c2goYnVpbGRDb21tb24ubWFrZVN5bWJvbChjLCBcIlR5cGV3cml0ZXItUmVndWxhclwiLCBncm91cC5tb2RlLCBuZXdPcHRpb25zLCBbXCJtb3JkXCIsIFwidGV4dHR0XCJdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJ0ZXh0XCJdLmNvbmNhdChuZXdPcHRpb25zLnNpemluZ0NsYXNzZXMob3B0aW9ucykpLCBidWlsZENvbW1vbi50cnlDb21iaW5lQ2hhcnMoYm9keSksIG5ld09wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHRleHQgPSBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShtYWtlVmVyYihncm91cCkpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbdGV4dF0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgXCJtb25vc3BhY2VcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuLyoqXG4gKiBDb252ZXJ0cyB2ZXJiIGdyb3VwIGludG8gYm9keSBzdHJpbmcuXG4gKlxuICogXFx2ZXJiKiByZXBsYWNlcyBlYWNoIHNwYWNlIHdpdGggYW4gb3BlbiBib3ggXFx1MjQyM1xuICogXFx2ZXJiIHJlcGxhY2VzIGVhY2ggc3BhY2Ugd2l0aCBhIG5vLWJyZWFrIHNwYWNlIFxceEEwXG4gKi9cblxudmFyIG1ha2VWZXJiID0gZnVuY3Rpb24gbWFrZVZlcmIoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLmJvZHkucmVwbGFjZSgvIC9nLCBncm91cC5zdGFyID8gXCJcXHUyNDIzXCIgOiAnXFx4QTAnKTtcbn07XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9mdW5jdGlvbnMuanNcbi8qKiBJbmNsdWRlIHRoaXMgdG8gZW5zdXJlIHRoYXQgYWxsIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZC4gKi9cblxudmFyIGZ1bmN0aW9ucyA9IF9mdW5jdGlvbnM7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfZnVuY3Rpb25zID0gKGZ1bmN0aW9ucyk7IC8vIFRPRE8oa2V2aW5iKTogaGF2ZSBmdW5jdGlvbnMgcmV0dXJuIGFuIG9iamVjdCBhbmQgY2FsbCBkZWZpbmVGdW5jdGlvbiB3aXRoXG4vLyB0aGF0IG9iamVjdCBpbiB0aGlzIGZpbGUgaW5zdGVhZCBvZiByZWx5aW5nIG9uIHNpZGUtZWZmZWN0cy5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gLy8gRGlzYWJsZWQgdW50aWwgaHR0cHM6Ly9naXRodWIuY29tL0thVGVYL0thVGVYL3B1bGwvMTc5NCBpcyBtZXJnZWQuXG4vLyBpbXBvcnQgXCIuL2Z1bmN0aW9ucy9pbmNsdWRlZ3JhcGhpY3NcIjtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvTGV4ZXIuanNcbi8qKlxuICogVGhlIExleGVyIGNsYXNzIGhhbmRsZXMgdG9rZW5pemluZyB0aGUgaW5wdXQgaW4gdmFyaW91cyB3YXlzLiBTaW5jZSBvdXJcbiAqIHBhcnNlciBleHBlY3RzIHVzIHRvIGJlIGFibGUgdG8gYmFja3RyYWNrLCB0aGUgbGV4ZXIgYWxsb3dzIGxleGluZyBmcm9tIGFueVxuICogZ2l2ZW4gc3RhcnRpbmcgcG9pbnQuXG4gKlxuICogSXRzIG1haW4gZXhwb3NlZCBmdW5jdGlvbiBpcyB0aGUgYGxleGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGEgcG9zaXRpb24gdG9cbiAqIGxleCBmcm9tIGFuZCBhIHR5cGUgb2YgdG9rZW4gdG8gbGV4LiBJdCBkZWZlcnMgdG8gdGhlIGFwcHJvcHJpYXRlIGBfaW5uZXJMZXhgXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgdmFyaW91cyBgX2lubmVyTGV4YCBmdW5jdGlvbnMgcGVyZm9ybSB0aGUgYWN0dWFsIGxleGluZyBvZiBkaWZmZXJlbnRcbiAqIGtpbmRzLlxuICovXG5cblxuXG5cbi8qIFRoZSBmb2xsb3dpbmcgdG9rZW5SZWdleFxuICogLSBtYXRjaGVzIHR5cGljYWwgd2hpdGVzcGFjZSAoYnV0IG5vdCBOQlNQIGV0Yy4pIHVzaW5nIGl0cyBmaXJzdCBncm91cFxuICogLSBkb2VzIG5vdCBtYXRjaCBhbnkgY29udHJvbCBjaGFyYWN0ZXIgXFx4MDAtXFx4MWYgZXhjZXB0IHdoaXRlc3BhY2VcbiAqIC0gZG9lcyBub3QgbWF0Y2ggYSBiYXJlIGJhY2tzbGFzaFxuICogLSBtYXRjaGVzIGFueSBBU0NJSSBjaGFyYWN0ZXIgZXhjZXB0IHRob3NlIGp1c3QgbWVudGlvbmVkXG4gKiAtIGRvZXMgbm90IG1hdGNoIHRoZSBCTVAgcHJpdmF0ZSB1c2UgYXJlYSBcXHVFMDAwLVxcdUY4RkZcbiAqIC0gZG9lcyBub3QgbWF0Y2ggYmFyZSBzdXJyb2dhdGUgY29kZSB1bml0c1xuICogLSBtYXRjaGVzIGFueSBCTVAgY2hhcmFjdGVyIGV4Y2VwdCBmb3IgdGhvc2UganVzdCBkZXNjcmliZWRcbiAqIC0gbWF0Y2hlcyBhbnkgdmFsaWQgVW5pY29kZSBzdXJyb2dhdGUgcGFpclxuICogLSBtYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGxldHRlcnNcbiAqIC0gbWF0Y2hlcyBhIGJhY2tzbGFzaCBmb2xsb3dlZCBieSBhbnkgQk1QIGNoYXJhY3RlciwgaW5jbHVkaW5nIG5ld2xpbmVcbiAqIEp1c3QgYmVjYXVzZSB0aGUgTGV4ZXIgbWF0Y2hlcyBzb21ldGhpbmcgZG9lc24ndCBtZWFuIGl0J3MgdmFsaWQgaW5wdXQ6XG4gKiBJZiB0aGVyZSBpcyBubyBtYXRjaGluZyBmdW5jdGlvbiBvciBzeW1ib2wgZGVmaW5pdGlvbiwgdGhlIFBhcnNlciB3aWxsXG4gKiBzdGlsbCByZWplY3QgdGhlIGlucHV0LlxuICovXG52YXIgc3BhY2VSZWdleFN0cmluZyA9IFwiWyBcXHJcXG5cXHRdXCI7XG52YXIgY29udHJvbFdvcmRSZWdleFN0cmluZyA9IFwiXFxcXFxcXFxbYS16QS1aQF0rXCI7XG52YXIgY29udHJvbFN5bWJvbFJlZ2V4U3RyaW5nID0gXCJcXFxcXFxcXFteXFx1RDgwMC1cXHVERkZGXVwiO1xudmFyIGNvbnRyb2xXb3JkV2hpdGVzcGFjZVJlZ2V4U3RyaW5nID0gXCJcIiArIGNvbnRyb2xXb3JkUmVnZXhTdHJpbmcgKyBzcGFjZVJlZ2V4U3RyaW5nICsgXCIqXCI7XG52YXIgY29udHJvbFdvcmRXaGl0ZXNwYWNlUmVnZXggPSBuZXcgUmVnRXhwKFwiXihcIiArIGNvbnRyb2xXb3JkUmVnZXhTdHJpbmcgKyBcIilcIiArIHNwYWNlUmVnZXhTdHJpbmcgKyBcIiokXCIpO1xudmFyIGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyA9IFwiW1xcdTAzMDAtXFx1MDM2Rl1cIjtcbnZhciBjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtzRW5kUmVnZXggPSBuZXcgUmVnRXhwKGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyArIFwiKyRcIik7XG52YXIgdG9rZW5SZWdleFN0cmluZyA9IFwiKFwiICsgc3BhY2VSZWdleFN0cmluZyArIFwiKyl8XCIgKyAvLyB3aGl0ZXNwYWNlXG5cIihbIS1cXFxcW1xcXFxdLVxcdTIwMjdcXHUyMDJBLVxcdUQ3RkZcXHVGOTAwLVxcdUZGRkZdXCIgKyAoIC8vIHNpbmdsZSBjb2RlcG9pbnRcbmNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyArIFwiKlwiKSArIC8vIC4uLnBsdXMgYWNjZW50c1xuXCJ8W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXVwiICsgKCAvLyBzdXJyb2dhdGUgcGFpclxuY29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nICsgXCIqXCIpICsgLy8gLi4ucGx1cyBhY2NlbnRzXG5cInxcXFxcXFxcXHZlcmJcXFxcKihbXl0pLio/XFxcXDNcIiArIC8vIFxcdmVyYipcblwifFxcXFxcXFxcdmVyYihbXiphLXpBLVpdKS4qP1xcXFw0XCIgKyAoIC8vIFxcdmVyYiB1bnN0YXJyZWRcblwifFwiICsgY29udHJvbFdvcmRXaGl0ZXNwYWNlUmVnZXhTdHJpbmcpICsgKCAvLyBcXG1hY3JvTmFtZSArIHNwYWNlc1xuXCJ8XCIgKyBjb250cm9sU3ltYm9sUmVnZXhTdHJpbmcgKyBcIilcIik7IC8vIFxcXFwsIFxcJywgZXRjLlxuXG4vKiogTWFpbiBMZXhlciBjbGFzcyAqL1xuXG52YXIgTGV4ZXJfTGV4ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvLyBjYXRlZ29yeSBjb2Rlcywgb25seSBzdXBwb3J0cyBjb21tZW50IGNoYXJhY3RlcnMgKDE0KSBmb3Igbm93XG4gIGZ1bmN0aW9uIExleGVyKGlucHV0LCBzZXR0aW5ncykge1xuICAgIHRoaXMuaW5wdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHZvaWQgMDtcbiAgICB0aGlzLnRva2VuUmVnZXggPSB2b2lkIDA7XG4gICAgdGhpcy5jYXRjb2RlcyA9IHZvaWQgMDtcbiAgICAvLyBTZXBhcmF0ZSBhY2NlbnRzIGZyb20gY2hhcmFjdGVyc1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy50b2tlblJlZ2V4ID0gbmV3IFJlZ0V4cCh0b2tlblJlZ2V4U3RyaW5nLCAnZycpO1xuICAgIHRoaXMuY2F0Y29kZXMgPSB7XG4gICAgICBcIiVcIjogMTQgLy8gY29tbWVudCBjaGFyYWN0ZXJcblxuICAgIH07XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTGV4ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXRDYXRjb2RlID0gZnVuY3Rpb24gc2V0Q2F0Y29kZShjaGFyLCBjb2RlKSB7XG4gICAgdGhpcy5jYXRjb2Rlc1tjaGFyXSA9IGNvZGU7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gbGV4ZXMgYSBzaW5nbGUgdG9rZW4uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmxleCA9IGZ1bmN0aW9uIGxleCgpIHtcbiAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgIHZhciBwb3MgPSB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4O1xuXG4gICAgaWYgKHBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuX1Rva2VuKFwiRU9GXCIsIG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBwb3MsIHBvcykpO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IHRoaXMudG9rZW5SZWdleC5leGVjKGlucHV0KTtcblxuICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5pbmRleCAhPT0gcG9zKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlcjogJ1wiICsgaW5wdXRbcG9zXSArIFwiJ1wiLCBuZXcgVG9rZW5fVG9rZW4oaW5wdXRbcG9zXSwgbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHBvcywgcG9zICsgMSkpKTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IG1hdGNoWzJdIHx8IFwiIFwiO1xuXG4gICAgaWYgKHRoaXMuY2F0Y29kZXNbdGV4dF0gPT09IDE0KSB7XG4gICAgICAvLyBjb21tZW50IGNoYXJhY3RlclxuICAgICAgdmFyIG5sSW5kZXggPSBpbnB1dC5pbmRleE9mKCdcXG4nLCB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4KTtcblxuICAgICAgaWYgKG5sSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXggPSBpbnB1dC5sZW5ndGg7IC8vIEVPRlxuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwiY29tbWVudEF0RW5kXCIsIFwiJSBjb21tZW50IGhhcyBubyB0ZXJtaW5hdGluZyBuZXdsaW5lOyBMYVRlWCB3b3VsZCBcIiArIFwiZmFpbCBiZWNhdXNlIG9mIGNvbW1lbnRpbmcgdGhlIGVuZCBvZiBtYXRoIG1vZGUgKGUuZy4gJClcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4ID0gbmxJbmRleCArIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgIH0gLy8gVHJpbSBhbnkgdHJhaWxpbmcgd2hpdGVzcGFjZSBmcm9tIGNvbnRyb2wgd29yZCBtYXRjaFxuXG5cbiAgICB2YXIgY29udHJvbE1hdGNoID0gdGV4dC5tYXRjaChjb250cm9sV29yZFdoaXRlc3BhY2VSZWdleCk7XG5cbiAgICBpZiAoY29udHJvbE1hdGNoKSB7XG4gICAgICB0ZXh0ID0gY29udHJvbE1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVG9rZW5fVG9rZW4odGV4dCwgbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHBvcywgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCkpO1xuICB9O1xuXG4gIHJldHVybiBMZXhlcjtcbn0oKTtcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9OYW1lc3BhY2UuanNcbi8qKlxuICogQSBgTmFtZXNwYWNlYCByZWZlcnMgdG8gYSBzcGFjZSBvZiBuYW1lYWJsZSB0aGluZ3MgbGlrZSBtYWNyb3Mgb3IgbGVuZ3RocyxcbiAqIHdoaWNoIGNhbiBiZSBgc2V0YCBlaXRoZXIgZ2xvYmFsbHkgb3IgbG9jYWwgdG8gYSBuZXN0ZWQgZ3JvdXAsIHVzaW5nIGFuXG4gKiB1bmRvIHN0YWNrIHNpbWlsYXIgdG8gaG93IFRlWCBpbXBsZW1lbnRzIHRoaXMgZnVuY3Rpb25hbGl0eS5cbiAqIFBlcmZvcm1hbmNlLXdpc2UsIGBnZXRgIGFuZCBsb2NhbCBgc2V0YCB0YWtlIGNvbnN0YW50IHRpbWUsIHdoaWxlIGdsb2JhbFxuICogYHNldGAgdGFrZXMgdGltZSBwcm9wb3J0aW9uYWwgdG8gdGhlIGRlcHRoIG9mIGdyb3VwIG5lc3RpbmcuXG4gKi9cblxuXG52YXIgTmFtZXNwYWNlX05hbWVzcGFjZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBCb3RoIGFyZ3VtZW50cyBhcmUgb3B0aW9uYWwuICBUaGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0IG9mXG4gICAqIGJ1aWx0LWluIG1hcHBpbmdzIHdoaWNoIG5ldmVyIGNoYW5nZS4gIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gICAqIG9mIGluaXRpYWwgKGdsb2JhbC1sZXZlbCkgbWFwcGluZ3MsIHdoaWNoIHdpbGwgY29uc3RhbnRseSBjaGFuZ2VcbiAgICogYWNjb3JkaW5nIHRvIGFueSBnbG9iYWwvdG9wLWxldmVsIGBzZXRgcyBkb25lLlxuICAgKi9cbiAgZnVuY3Rpb24gTmFtZXNwYWNlKGJ1aWx0aW5zLCBnbG9iYWxNYWNyb3MpIHtcbiAgICBpZiAoYnVpbHRpbnMgPT09IHZvaWQgMCkge1xuICAgICAgYnVpbHRpbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsTWFjcm9zID09PSB2b2lkIDApIHtcbiAgICAgIGdsb2JhbE1hY3JvcyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmJ1aWx0aW5zID0gdm9pZCAwO1xuICAgIHRoaXMudW5kZWZTdGFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnQgPSBnbG9iYWxNYWNyb3M7XG4gICAgdGhpcy5idWlsdGlucyA9IGJ1aWx0aW5zO1xuICAgIHRoaXMudW5kZWZTdGFjayA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBuZXN0ZWQgZ3JvdXAsIGFmZmVjdGluZyBmdXR1cmUgbG9jYWwgYHNldGBzLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBOYW1lc3BhY2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5iZWdpbkdyb3VwID0gZnVuY3Rpb24gYmVnaW5Hcm91cCgpIHtcbiAgICB0aGlzLnVuZGVmU3RhY2sucHVzaCh7fSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuZCBjdXJyZW50IG5lc3RlZCBncm91cCwgcmVzdG9yaW5nIHZhbHVlcyBiZWZvcmUgdGhlIGdyb3VwIGJlZ2FuLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5lbmRHcm91cCA9IGZ1bmN0aW9uIGVuZEdyb3VwKCkge1xuICAgIGlmICh0aGlzLnVuZGVmU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmJhbGFuY2VkIG5hbWVzcGFjZSBkZXN0cnVjdGlvbjogYXR0ZW1wdCBcIiArIFwidG8gcG9wIGdsb2JhbCBuYW1lc3BhY2U7IHBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1Z1wiKTtcbiAgICB9XG5cbiAgICB2YXIgdW5kZWZzID0gdGhpcy51bmRlZlN0YWNrLnBvcCgpO1xuXG4gICAgZm9yICh2YXIgdW5kZWYgaW4gdW5kZWZzKSB7XG4gICAgICBpZiAodW5kZWZzLmhhc093blByb3BlcnR5KHVuZGVmKSkge1xuICAgICAgICBpZiAodW5kZWZzW3VuZGVmXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuY3VycmVudFt1bmRlZl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50W3VuZGVmXSA9IHVuZGVmc1t1bmRlZl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERldGVjdCB3aGV0aGVyIGBuYW1lYCBoYXMgYSBkZWZpbml0aW9uLiAgRXF1aXZhbGVudCB0b1xuICAgKiBgZ2V0KG5hbWUpICE9IG51bGxgLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnQuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgdGhpcy5idWlsdGlucy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgbmFtZSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgaXMgbm8gdmFsdWUuXG4gICAqXG4gICAqIE5vdGU6IERvIG5vdCB1c2UgYGlmIChuYW1lc3BhY2UuZ2V0KC4uLikpYCB0byBkZXRlY3Qgd2hldGhlciBhIG1hY3JvXG4gICAqIGlzIGRlZmluZWQsIGFzIHRoZSBkZWZpbml0aW9uIG1heSBiZSB0aGUgZW1wdHkgc3RyaW5nIHdoaWNoIGV2YWx1YXRlc1xuICAgKiB0byBgZmFsc2VgIGluIEphdmFTY3JpcHQuICBVc2UgYGlmIChuYW1lc3BhY2UuZ2V0KC4uLikgIT0gbnVsbClgIG9yXG4gICAqIGBpZiAobmFtZXNwYWNlLmhhcyguLi4pKWAuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuYnVpbHRpbnNbbmFtZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBuYW1lLCBhbmQgb3B0aW9uYWxseSBzZXQgaXQgZ2xvYmFsbHkgdG9vLlxuICAgKiBMb2NhbCBzZXQoKSBzZXRzIHRoZSBjdXJyZW50IHZhbHVlIGFuZCAod2hlbiBhcHByb3ByaWF0ZSkgYWRkcyBhbiB1bmRvXG4gICAqIG9wZXJhdGlvbiB0byB0aGUgdW5kbyBzdGFjay4gIEdsb2JhbCBzZXQoKSBtYXkgY2hhbmdlIHRoZSB1bmRvXG4gICAqIG9wZXJhdGlvbiBhdCBldmVyeSBsZXZlbCwgc28gdGFrZXMgdGltZSBsaW5lYXIgaW4gdGhlaXIgbnVtYmVyLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUsIGdsb2JhbCkge1xuICAgIGlmIChnbG9iYWwgPT09IHZvaWQgMCkge1xuICAgICAgZ2xvYmFsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbCkge1xuICAgICAgLy8gR2xvYmFsIHNldCBpcyBlcXVpdmFsZW50IHRvIHNldHRpbmcgaW4gYWxsIGdyb3Vwcy4gIFNpbXVsYXRlIHRoaXNcbiAgICAgIC8vIGJ5IGRlc3Ryb3lpbmcgYW55IHVuZG9zIGN1cnJlbnRseSBzY2hlZHVsZWQgZm9yIHRoaXMgbmFtZSxcbiAgICAgIC8vIGFuZCBhZGRpbmcgYW4gdW5kbyB3aXRoIHRoZSAqbmV3KiB2YWx1ZSAoaW4gY2FzZSBpdCBsYXRlciBnZXRzXG4gICAgICAvLyBsb2NhbGx5IHJlc2V0IHdpdGhpbiB0aGlzIGVudmlyb25tZW50KS5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy51bmRlZlN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVuZGVmU3RhY2tbaV1bbmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnVuZGVmU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnVuZGVmU3RhY2tbdGhpcy51bmRlZlN0YWNrLmxlbmd0aCAtIDFdW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVuZG8gdGhpcyBzZXQgYXQgZW5kIG9mIHRoaXMgZ3JvdXAgKHBvc3NpYmx5IHRvIGB1bmRlZmluZWRgKSxcbiAgICAgIC8vIHVubGVzcyBhbiB1bmRvIGlzIGFscmVhZHkgaW4gcGxhY2UsIGluIHdoaWNoIGNhc2UgdGhhdCBvbGRlclxuICAgICAgLy8gdmFsdWUgaXMgdGhlIGNvcnJlY3Qgb25lLlxuICAgICAgdmFyIHRvcCA9IHRoaXMudW5kZWZTdGFja1t0aGlzLnVuZGVmU3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmICh0b3AgJiYgIXRvcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB0b3BbbmFtZV0gPSB0aGlzLmN1cnJlbnRbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50W25hbWVdID0gdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIE5hbWVzcGFjZTtcbn0oKTtcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tYWNyb3MuanNcbi8qKlxuICogUHJlZGVmaW5lZCBtYWNyb3MgZm9yIEthVGVYLlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBkZWZpbmUgc29tZSBjb21tYW5kcyBpbiB0ZXJtcyBvZiBvdGhlcnMuXG4gKi9cblxuXG5cblxuXG52YXIgYnVpbHRpbk1hY3JvcyA9IHt9O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbWFjcm9zID0gKGJ1aWx0aW5NYWNyb3MpOyAvLyBUaGlzIGZ1bmN0aW9uIG1pZ2h0IG9uZSBkYXkgYWNjZXB0IGFuIGFkZGl0aW9uYWwgYXJndW1lbnQgYW5kIGRvIG1vcmUgdGhpbmdzLlxuXG5mdW5jdGlvbiBkZWZpbmVNYWNybyhuYW1lLCBib2R5KSB7XG4gIGJ1aWx0aW5NYWNyb3NbbmFtZV0gPSBib2R5O1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBtYWNybyB0b29sc1xuLy8gTGFUZVgncyBcXEBmaXJzdG9mdHdveyMxfXsjMn0gZXhwYW5kcyB0byAjMSwgc2tpcHBpbmcgIzJcbi8vIFRlWCBzb3VyY2U6IFxcbG9uZ1xcZGVmXFxAZmlyc3RvZnR3byMxIzJ7IzF9XG5cbmRlZmluZU1hY3JvKFwiXFxcXEBmaXJzdG9mdHdvXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygyKTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbnM6IGFyZ3NbMF0sXG4gICAgbnVtQXJnczogMFxuICB9O1xufSk7IC8vIExhVGVYJ3MgXFxAc2Vjb25kb2Z0d297IzF9eyMyfSBleHBhbmRzIHRvICMyLCBza2lwcGluZyAjMVxuLy8gVGVYIHNvdXJjZTogXFxsb25nXFxkZWZcXEBzZWNvbmRvZnR3byMxIzJ7IzJ9XG5cbmRlZmluZU1hY3JvKFwiXFxcXEBzZWNvbmRvZnR3b1wiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgYXJncyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMik7XG4gIHJldHVybiB7XG4gICAgdG9rZW5zOiBhcmdzWzFdLFxuICAgIG51bUFyZ3M6IDBcbiAgfTtcbn0pOyAvLyBMYVRlWCdzIFxcQGlmbmV4dGNoYXJ7IzF9eyMyfXsjM30gbG9va3MgYWhlYWQgdG8gdGhlIG5leHQgKHVuZXhwYW5kZWQpXG4vLyBzeW1ib2wuICBJZiBpdCBtYXRjaGVzICMxLCB0aGVuIHRoZSBtYWNybyBleHBhbmRzIHRvICMyOyBvdGhlcndpc2UsICMzLlxuLy8gTm90ZSwgaG93ZXZlciwgdGhhdCBpdCBkb2VzIG5vdCBjb25zdW1lIHRoZSBuZXh0IHN5bWJvbCBpbiBlaXRoZXIgY2FzZS5cblxuZGVmaW5lTWFjcm8oXCJcXFxcQGlmbmV4dGNoYXJcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDMpOyAvLyBzeW1ib2wsIGlmLCBlbHNlXG5cbiAgdmFyIG5leHRUb2tlbiA9IGNvbnRleHQuZnV0dXJlKCk7XG5cbiAgaWYgKGFyZ3NbMF0ubGVuZ3RoID09PSAxICYmIGFyZ3NbMF1bMF0udGV4dCA9PT0gbmV4dFRva2VuLnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiBhcmdzWzFdLFxuICAgICAgbnVtQXJnczogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogYXJnc1syXSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9XG59KTsgLy8gTGFUZVgncyBcXEBpZnN0YXJ7IzF9eyMyfSBsb29rcyBhaGVhZCB0byB0aGUgbmV4dCAodW5leHBhbmRlZCkgc3ltYm9sLlxuLy8gSWYgaXQgaXMgYCpgLCB0aGVuIGl0IGNvbnN1bWVzIHRoZSBzeW1ib2wsIGFuZCB0aGUgbWFjcm8gZXhwYW5kcyB0byAjMTtcbi8vIG90aGVyd2lzZSwgdGhlIG1hY3JvIGV4cGFuZHMgdG8gIzIgKHdpdGhvdXQgY29uc3VtaW5nIHRoZSBzeW1ib2wpLlxuLy8gVGVYIHNvdXJjZTogXFxkZWZcXEBpZnN0YXIjMXtcXEBpZm5leHRjaGFyICp7XFxAZmlyc3RvZnR3b3sjMX19fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxAaWZzdGFyXCIsIFwiXFxcXEBpZm5leHRjaGFyICp7XFxcXEBmaXJzdG9mdHdveyMxfX1cIik7IC8vIExhVGVYJ3MgXFxUZXh0T3JNYXRoeyMxfXsjMn0gZXhwYW5kcyB0byAjMSBpbiB0ZXh0IG1vZGUsICMyIGluIG1hdGggbW9kZVxuXG5kZWZpbmVNYWNybyhcIlxcXFxUZXh0T3JNYXRoXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygyKTtcblxuICBpZiAoY29udGV4dC5tb2RlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiBhcmdzWzBdLFxuICAgICAgbnVtQXJnczogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogYXJnc1sxXSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9XG59KTsgLy8gTG9va3VwIHRhYmxlIGZvciBwYXJzaW5nIG51bWJlcnMgaW4gYmFzZSA4IHRocm91Z2ggMTZcblxudmFyIGRpZ2l0VG9OdW1iZXIgPSB7XG4gIFwiMFwiOiAwLFxuICBcIjFcIjogMSxcbiAgXCIyXCI6IDIsXG4gIFwiM1wiOiAzLFxuICBcIjRcIjogNCxcbiAgXCI1XCI6IDUsXG4gIFwiNlwiOiA2LFxuICBcIjdcIjogNyxcbiAgXCI4XCI6IDgsXG4gIFwiOVwiOiA5LFxuICBcImFcIjogMTAsXG4gIFwiQVwiOiAxMCxcbiAgXCJiXCI6IDExLFxuICBcIkJcIjogMTEsXG4gIFwiY1wiOiAxMixcbiAgXCJDXCI6IDEyLFxuICBcImRcIjogMTMsXG4gIFwiRFwiOiAxMyxcbiAgXCJlXCI6IDE0LFxuICBcIkVcIjogMTQsXG4gIFwiZlwiOiAxNSxcbiAgXCJGXCI6IDE1XG59OyAvLyBUZVggXFxjaGFyIG1ha2VzIGEgbGl0ZXJhbCBjaGFyYWN0ZXIgKGNhdGNvZGUgMTIpIHVzaW5nIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4vLyAoc2VlIFRoZSBUZVhCb29rLCBwLiA0Mylcbi8vICAgXFxjaGFyMTIzICAtLSBkZWNpbWFsXG4vLyAgIFxcY2hhcicxMjMgLS0gb2N0YWxcbi8vICAgXFxjaGFyXCIxMjMgLS0gaGV4XG4vLyAgIFxcY2hhcmB4ICAgLS0gY2hhcmFjdGVyIHRoYXQgY2FuIGJlIHdyaXR0ZW4gKGkuZS4gaXNuJ3QgYWN0aXZlKVxuLy8gICBcXGNoYXJgXFx4ICAtLSBjaGFyYWN0ZXIgdGhhdCBjYW5ub3QgYmUgd3JpdHRlbiAoZS5nLiAlKVxuLy8gVGhlc2UgYWxsIHJlZmVyIHRvIGNoYXJhY3RlcnMgZnJvbSB0aGUgZm9udCwgc28gd2UgdHVybiB0aGVtIGludG8gc3BlY2lhbFxuLy8gY2FsbHMgdG8gYSBmdW5jdGlvbiBcXEBjaGFyIGRlYWx0IHdpdGggaW4gdGhlIFBhcnNlci5cblxuZGVmaW5lTWFjcm8oXCJcXFxcY2hhclwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIHZhciBiYXNlO1xuICB2YXIgbnVtYmVyID0gJyc7XG5cbiAgaWYgKHRva2VuLnRleHQgPT09IFwiJ1wiKSB7XG4gICAgYmFzZSA9IDg7XG4gICAgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIH0gZWxzZSBpZiAodG9rZW4udGV4dCA9PT0gJ1wiJykge1xuICAgIGJhc2UgPSAxNjtcbiAgICB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgfSBlbHNlIGlmICh0b2tlbi50ZXh0ID09PSBcImBcIikge1xuICAgIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuXG4gICAgaWYgKHRva2VuLnRleHRbMF0gPT09IFwiXFxcXFwiKSB7XG4gICAgICBudW1iZXIgPSB0b2tlbi50ZXh0LmNoYXJDb2RlQXQoMSk7XG4gICAgfSBlbHNlIGlmICh0b2tlbi50ZXh0ID09PSBcIkVPRlwiKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcY2hhcmAgbWlzc2luZyBhcmd1bWVudFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtYmVyID0gdG9rZW4udGV4dC5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlID0gMTA7XG4gIH1cblxuICBpZiAoYmFzZSkge1xuICAgIC8vIFBhcnNlIGEgbnVtYmVyIGluIHRoZSBnaXZlbiBiYXNlLCBzdGFydGluZyB3aXRoIGZpcnN0IGB0b2tlbmAuXG4gICAgbnVtYmVyID0gZGlnaXRUb051bWJlclt0b2tlbi50ZXh0XTtcblxuICAgIGlmIChudW1iZXIgPT0gbnVsbCB8fCBudW1iZXIgPj0gYmFzZSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBiYXNlLVwiICsgYmFzZSArIFwiIGRpZ2l0IFwiICsgdG9rZW4udGV4dCk7XG4gICAgfVxuXG4gICAgdmFyIGRpZ2l0O1xuXG4gICAgd2hpbGUgKChkaWdpdCA9IGRpZ2l0VG9OdW1iZXJbY29udGV4dC5mdXR1cmUoKS50ZXh0XSkgIT0gbnVsbCAmJiBkaWdpdCA8IGJhc2UpIHtcbiAgICAgIG51bWJlciAqPSBiYXNlO1xuICAgICAgbnVtYmVyICs9IGRpZ2l0O1xuICAgICAgY29udGV4dC5wb3BUb2tlbigpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBcIlxcXFxAY2hhcntcIiArIG51bWJlciArIFwifVwiO1xufSk7IC8vIEJhc2ljIHN1cHBvcnQgZm9yIG1hY3JvIGRlZmluaXRpb25zOlxuLy8gICAgIFxcZGVmXFxtYWNyb3tleHBhbnNpb259XG4vLyAgICAgXFxkZWZcXG1hY3JvIzF7ZXhwYW5zaW9ufVxuLy8gICAgIFxcZGVmXFxtYWNybyMxIzJ7ZXhwYW5zaW9ufVxuLy8gICAgIFxcZGVmXFxtYWNybyMxIzIjMyM0IzUjNiM3IzgjOXtleHBhbnNpb259XG4vLyBBbHNvIHRoZSBcXGdkZWYgYW5kIFxcZ2xvYmFsXFxkZWYgZXF1aXZhbGVudHNcblxudmFyIG1hY3Jvc19kZWYgPSBmdW5jdGlvbiBkZWYoY29udGV4dCwgZ2xvYmFsKSB7XG4gIHZhciBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdO1xuXG4gIGlmIChhcmcubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXGdkZWYncyBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgbWFjcm8gbmFtZVwiKTtcbiAgfVxuXG4gIHZhciBuYW1lID0gYXJnWzBdLnRleHQ7IC8vIENvdW50IGFyZ3VtZW50IHNwZWNpZmllcnMsIGFuZCBjaGVjayB0aGV5IGFyZSBpbiB0aGUgb3JkZXIgIzEgIzIgLi4uXG5cbiAgdmFyIG51bUFyZ3MgPSAwO1xuICBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdO1xuXG4gIHdoaWxlIChhcmcubGVuZ3RoID09PSAxICYmIGFyZ1swXS50ZXh0ID09PSBcIiNcIikge1xuICAgIGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF07XG5cbiAgICBpZiAoYXJnLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBudW1iZXIgbGVuZ3RoIFxcXCJcIiArIGFyZy5sZW5ndGggKyBcIlxcXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKCEvXlsxLTldJC8udGVzdChhcmdbMF0udGV4dCkpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgYXJndW1lbnQgbnVtYmVyIFxcXCJcIiArIGFyZ1swXS50ZXh0ICsgXCJcXFwiXCIpO1xuICAgIH1cblxuICAgIG51bUFyZ3MrKztcblxuICAgIGlmIChwYXJzZUludChhcmdbMF0udGV4dCkgIT09IG51bUFyZ3MpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkFyZ3VtZW50IG51bWJlciBcXFwiXCIgKyBhcmdbMF0udGV4dCArIFwiXFxcIiBvdXQgb2Ygb3JkZXJcIik7XG4gICAgfVxuXG4gICAgYXJnID0gY29udGV4dC5jb25zdW1lQXJncygxKVswXTtcbiAgfSAvLyBGaW5hbCBhcmcgaXMgdGhlIGV4cGFuc2lvbiBvZiB0aGUgbWFjcm9cblxuXG4gIGNvbnRleHQubWFjcm9zLnNldChuYW1lLCB7XG4gICAgdG9rZW5zOiBhcmcsXG4gICAgbnVtQXJnczogbnVtQXJnc1xuICB9LCBnbG9iYWwpO1xuICByZXR1cm4gJyc7XG59O1xuXG5kZWZpbmVNYWNybyhcIlxcXFxnZGVmXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHJldHVybiBtYWNyb3NfZGVmKGNvbnRleHQsIHRydWUpO1xufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxkZWZcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgcmV0dXJuIG1hY3Jvc19kZWYoY29udGV4dCwgZmFsc2UpO1xufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxnbG9iYWxcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIG5leHQgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdO1xuXG4gIGlmIChuZXh0Lmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgY29tbWFuZCBhZnRlciBcXFxcZ2xvYmFsXCIpO1xuICB9XG5cbiAgdmFyIGNvbW1hbmQgPSBuZXh0WzBdLnRleHQ7IC8vIFRPRE86IFNob3VsZCBleHBhbmQgY29tbWFuZFxuXG4gIGlmIChjb21tYW5kID09PSBcIlxcXFxkZWZcIikge1xuICAgIC8vIFxcZ2xvYmFsXFxkZWYgaXMgZXF1aXZhbGVudCB0byBcXGdkZWZcbiAgICByZXR1cm4gbWFjcm9zX2RlZihjb250ZXh0LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIGNvbW1hbmQgJ1wiICsgY29tbWFuZCArIFwiJyBhZnRlciBcXFxcZ2xvYmFsXCIpO1xuICB9XG59KTsgLy8gXFxuZXdjb21tYW5ke1xcbWFjcm99W2FyZ3Nde2RlZmluaXRpb259XG4vLyBcXHJlbmV3Y29tbWFuZHtcXG1hY3JvfVthcmdzXXtkZWZpbml0aW9ufVxuLy8gVE9ETzogT3B0aW9uYWwgYXJndW1lbnRzOiBcXG5ld2NvbW1hbmR7XFxtYWNyb31bYXJnc11bZGVmYXVsdF17ZGVmaW5pdGlvbn1cblxudmFyIG1hY3Jvc19uZXdjb21tYW5kID0gZnVuY3Rpb24gbmV3Y29tbWFuZChjb250ZXh0LCBleGlzdHNPSywgbm9uZXhpc3RzT0spIHtcbiAgdmFyIGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF07XG5cbiAgaWYgKGFyZy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcbmV3Y29tbWFuZCdzIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBtYWNybyBuYW1lXCIpO1xuICB9XG5cbiAgdmFyIG5hbWUgPSBhcmdbMF0udGV4dDtcbiAgdmFyIGV4aXN0cyA9IGNvbnRleHQuaXNEZWZpbmVkKG5hbWUpO1xuXG4gIGlmIChleGlzdHMgJiYgIWV4aXN0c09LKSB7XG4gICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiXFxcXG5ld2NvbW1hbmR7XCIgKyBuYW1lICsgXCJ9IGF0dGVtcHRpbmcgdG8gcmVkZWZpbmUgXCIgKyAobmFtZSArIFwiOyB1c2UgXFxcXHJlbmV3Y29tbWFuZFwiKSk7XG4gIH1cblxuICBpZiAoIWV4aXN0cyAmJiAhbm9uZXhpc3RzT0spIHtcbiAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxccmVuZXdjb21tYW5ke1wiICsgbmFtZSArIFwifSB3aGVuIGNvbW1hbmQgXCIgKyBuYW1lICsgXCIgXCIgKyBcImRvZXMgbm90IHlldCBleGlzdDsgdXNlIFxcXFxuZXdjb21tYW5kXCIpO1xuICB9XG5cbiAgdmFyIG51bUFyZ3MgPSAwO1xuICBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdO1xuXG4gIGlmIChhcmcubGVuZ3RoID09PSAxICYmIGFyZ1swXS50ZXh0ID09PSBcIltcIikge1xuICAgIHZhciBhcmdUZXh0ID0gJyc7XG4gICAgdmFyIHRva2VuID0gY29udGV4dC5leHBhbmROZXh0VG9rZW4oKTtcblxuICAgIHdoaWxlICh0b2tlbi50ZXh0ICE9PSBcIl1cIiAmJiB0b2tlbi50ZXh0ICE9PSBcIkVPRlwiKSB7XG4gICAgICAvLyBUT0RPOiBTaG91bGQgcHJvcGVybHkgZXhwYW5kIGFyZywgZS5nLiwgaWdub3JlIHt9c1xuICAgICAgYXJnVGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgdG9rZW4gPSBjb250ZXh0LmV4cGFuZE5leHRUb2tlbigpO1xuICAgIH1cblxuICAgIGlmICghYXJnVGV4dC5tYXRjaCgvXlxccypbMC05XStcXHMqJC8pKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHM6IFwiICsgYXJnVGV4dCk7XG4gICAgfVxuXG4gICAgbnVtQXJncyA9IHBhcnNlSW50KGFyZ1RleHQpO1xuICAgIGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF07XG4gIH0gLy8gRmluYWwgYXJnIGlzIHRoZSBleHBhbnNpb24gb2YgdGhlIG1hY3JvXG5cblxuICBjb250ZXh0Lm1hY3Jvcy5zZXQobmFtZSwge1xuICAgIHRva2VuczogYXJnLFxuICAgIG51bUFyZ3M6IG51bUFyZ3NcbiAgfSk7XG4gIHJldHVybiAnJztcbn07XG5cbmRlZmluZU1hY3JvKFwiXFxcXG5ld2NvbW1hbmRcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgcmV0dXJuIG1hY3Jvc19uZXdjb21tYW5kKGNvbnRleHQsIGZhbHNlLCB0cnVlKTtcbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVuZXdjb21tYW5kXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHJldHVybiBtYWNyb3NfbmV3Y29tbWFuZChjb250ZXh0LCB0cnVlLCBmYWxzZSk7XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXHByb3ZpZGVjb21tYW5kXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHJldHVybiBtYWNyb3NfbmV3Y29tbWFuZChjb250ZXh0LCB0cnVlLCB0cnVlKTtcbn0pOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBHcm91cGluZ1xuLy8gXFxsZXRcXGJncm91cD17IFxcbGV0XFxlZ3JvdXA9fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxiZ3JvdXBcIiwgXCJ7XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZWdyb3VwXCIsIFwifVwiKTsgLy8gU3ltYm9scyBmcm9tIGxhdGV4Lmx0eDpcbi8vIFxcZGVmXFxscXtgfVxuLy8gXFxkZWZcXHJxeyd9XG4vLyBcXGRlZiBcXGFhIHtcXHIgYX1cbi8vIFxcZGVmIFxcQUEge1xcciBBfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxscVwiLCBcImBcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxycVwiLCBcIidcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhYVwiLCBcIlxcXFxyIGFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxBQVwiLCBcIlxcXFxyIEFcIik7IC8vIENvcHlyaWdodCAoQykgYW5kIHJlZ2lzdGVyZWQgKFIpIHN5bWJvbHMuIFVzZSByYXcgc3ltYm9sIGluIE1hdGhNTC5cbi8vIFxcRGVjbGFyZVRleHRDb21tYW5kRGVmYXVsdHtcXHRleHRjb3B5cmlnaHR9e1xcdGV4dGNpcmNsZWR7Y319XG4vLyBcXERlY2xhcmVUZXh0Q29tbWFuZERlZmF1bHR7XFx0ZXh0cmVnaXN0ZXJlZH17XFx0ZXh0Y2lyY2xlZHslXG4vLyAgICAgIFxcY2hlY2tAbWF0aGZvbnRzXFxmb250c2l6ZVxcc2ZAc2l6ZVxcekBcXG1hdGhAZm9udHNmYWxzZVxcc2VsZWN0Zm9udCBSfX1cbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmR7XFxjb3B5cmlnaHR9eyVcbi8vICAgIFxcaWZtbW9kZXtcXG5mc3NAdGV4dHtcXHRleHRjb3B5cmlnaHR9fVxcZWxzZVxcdGV4dGNvcHlyaWdodFxcZml9XG5cbmRlZmluZU1hY3JvKFwiXFxcXHRleHRjb3B5cmlnaHRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHRleHRjaXJjbGVke2N9fXtcXFxcY2hhcmDCqX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb3B5cmlnaHRcIiwgXCJcXFxcVGV4dE9yTWF0aHtcXFxcdGV4dGNvcHlyaWdodH17XFxcXHRleHR7XFxcXHRleHRjb3B5cmlnaHR9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRleHRyZWdpc3RlcmVkXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFx0ZXh0Y2lyY2xlZHtcXFxcc2NyaXB0c2l6ZSBSfX17XFxcXGNoYXJgwq59XCIpOyAvLyBDaGFyYWN0ZXJzIG9taXR0ZWQgZnJvbSBVbmljb2RlIHJhbmdlIDFENDAw4oCTMUQ3RkZcblxuZGVmaW5lTWFjcm8oXCJcXHUyMTJDXCIsIFwiXFxcXG1hdGhzY3J7Qn1cIik7IC8vIHNjcmlwdFxuXG5kZWZpbmVNYWNybyhcIlxcdTIxMzBcIiwgXCJcXFxcbWF0aHNjcntFfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjEzMVwiLCBcIlxcXFxtYXRoc2Nye0Z9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTBCXCIsIFwiXFxcXG1hdGhzY3J7SH1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMTBcIiwgXCJcXFxcbWF0aHNjcntJfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjExMlwiLCBcIlxcXFxtYXRoc2Nye0x9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTMzXCIsIFwiXFxcXG1hdGhzY3J7TX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMUJcIiwgXCJcXFxcbWF0aHNjcntSfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjEyRFwiLCBcIlxcXFxtYXRoZnJha3tDfVwiKTsgLy8gRnJha3R1clxuXG5kZWZpbmVNYWNybyhcIlxcdTIxMENcIiwgXCJcXFxcbWF0aGZyYWt7SH1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMjhcIiwgXCJcXFxcbWF0aGZyYWt7Wn1cIik7IC8vIERlZmluZSBcXEJiYmsgd2l0aCBhIG1hY3JvIHRoYXQgd29ya3MgaW4gYm90aCBIVE1MIGFuZCBNYXRoTUwuXG5cbmRlZmluZU1hY3JvKFwiXFxcXEJiYmtcIiwgXCJcXFxcQmJie2t9XCIpOyAvLyBVbmljb2RlIG1pZGRsZSBkb3Rcbi8vIFRoZSBLYVRlWCBmb250cyBkbyBub3QgY29udGFpbiBVKzAwQjcuIEluc3RlYWQsIFxcY2RvdHAgZGlzcGxheXNcbi8vIHRoZSBkb3QgYXQgVSsyMkM1IGFuZCBnaXZlcyBpdCBwdW5jdCBzcGFjaW5nLlxuXG5kZWZpbmVNYWNybyhcIlxceEI3XCIsIFwiXFxcXGNkb3RwXCIpOyAvLyBcXGxsYXAgYW5kIFxccmxhcCByZW5kZXIgdGhlaXIgY29udGVudHMgaW4gdGV4dCBtb2RlXG5cbmRlZmluZU1hY3JvKFwiXFxcXGxsYXBcIiwgXCJcXFxcbWF0aGxsYXB7XFxcXHRleHRybXsjMX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmxhcFwiLCBcIlxcXFxtYXRocmxhcHtcXFxcdGV4dHJteyMxfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjbGFwXCIsIFwiXFxcXG1hdGhjbGFwe1xcXFx0ZXh0cm17IzF9fVwiKTsgLy8gXFxub3QgaXMgZGVmaW5lZCBieSBiYXNlL2ZvbnRtYXRoLmx0eCB2aWFcbi8vIFxcRGVjbGFyZU1hdGhTeW1ib2x7XFxub3R9e1xcbWF0aHJlbH17c3ltYm9sc317XCIzNn1cbi8vIEl0J3MgdGh1cyB0cmVhdGVkIGxpa2UgYSBcXG1hdGhyZWwsIGJ1dCBkZWZpbmVkIGJ5IGEgc3ltYm9sIHRoYXQgaGFzIHplcm9cbi8vIHdpZHRoIGJ1dCBleHRlbmRzIHRvIHRoZSByaWdodC4gIFdlIHVzZSBcXHJsYXAgdG8gZ2V0IHRoYXQgc3BhY2luZy5cbi8vIEZvciBNYXRoTUwgd2Ugd3JpdGUgVSswMzM4IGhlcmUuIGJ1aWxkTWF0aE1MLmpzIHdpbGwgdGhlbiBkbyB0aGUgb3ZlcmxheS5cblxuZGVmaW5lTWFjcm8oXCJcXFxcbm90XCIsICdcXFxcaHRtbEBtYXRobWx7XFxcXG1hdGhyZWx7XFxcXG1hdGhybGFwXFxcXEBub3R9fXtcXFxcY2hhclwiMzM4fScpOyAvLyBOZWdhdGVkIHN5bWJvbHMgZnJvbSBiYXNlL2ZvbnRtYXRoLmx0eDpcbi8vIFxcZGVmXFxuZXF7XFxub3Q9fSBcXGxldFxcbmU9XFxuZXFcbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmRcbi8vICAgXFxub3RpbntcXG1hdGhyZWx7XFxtQHRoXFxtYXRocGFsZXR0ZVxcY0BuY2VsXFxpbn19XG4vLyBcXGRlZlxcY0BuY2VsIzEjMntcXG1AdGhcXG9vYWxpZ257JFxcaGZpbCMxXFxta2VybjFtdS9cXGhmaWwkXFxjcmNyJCMxIzIkfX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcbmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxtYXRocmVse1xcXFxub3Q9fX17XFxcXG1hdGhyZWx7XFxcXGNoYXJg4omgfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuZVwiLCBcIlxcXFxuZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNjBcIiwgXCJcXFxcbmVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbm90aW5cIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXG1hdGhyZWx7e1xcXFxpbn1cXFxcbWF0aGxsYXB7L1xcXFxtc2tpcDFtdX19fVwiICsgXCJ7XFxcXG1hdGhyZWx7XFxcXGNoYXJg4oiJfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyMDlcIiwgXCJcXFxcbm90aW5cIik7IC8vIFVuaWNvZGUgc3RhY2tlZCByZWxhdGlvbnNcblxuZGVmaW5lTWFjcm8oXCJcXHUyMjU4XCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHs9XFxcXGtlcm57LTFlbX1cXFxccmFpc2Vib3h7MC40ZW19eyRcXFxcc2NyaXB0c2l6ZVxcXFxmcm93biR9fVwiICsgXCJ9e1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyNTh9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjI1OVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcc3RhY2tyZWx7XFxcXHRpbnlcXFxcd2VkZ2V9ez19fXtcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjU4fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55XFxcXHZlZX17PX19e1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyNUF9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjI1QlwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcc3RhY2tyZWx7XFxcXHNjcmlwdHNpemVcXFxcc3Rhcn17PX19XCIgKyBcIntcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVCfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNURcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55XFxcXG1hdGhybXtkZWZ9fXs9fX1cIiArIFwie1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyNUR9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjI1RVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcc3RhY2tyZWx7XFxcXHRpbnlcXFxcbWF0aHJte219fXs9fX1cIiArIFwie1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyNUV9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjI1RlwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcc3RhY2tyZWx7XFxcXHRpbnk/fXs9fX17XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1Rn19XCIpOyAvLyBNaXNjIFVuaWNvZGVcblxuZGVmaW5lTWFjcm8oXCJcXHUyN0MyXCIsIFwiXFxcXHBlcnBcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIwM0NcIiwgXCJcXFxcbWF0aGNsb3NleyFcXFxcbWtlcm4tMC44bXUhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjIwQ1wiLCBcIlxcXFxub3RuaVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjMxQ1wiLCBcIlxcXFx1bGNvcm5lclwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjMxRFwiLCBcIlxcXFx1cmNvcm5lclwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjMxRVwiLCBcIlxcXFxsbGNvcm5lclwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjMxRlwiLCBcIlxcXFxscmNvcm5lclwiKTtcbmRlZmluZU1hY3JvKFwiXFx4QTlcIiwgXCJcXFxcY29weXJpZ2h0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHhBRVwiLCBcIlxcXFx0ZXh0cmVnaXN0ZXJlZFwiKTtcbmRlZmluZU1hY3JvKFwiXFx1RkUwRlwiLCBcIlxcXFx0ZXh0cmVnaXN0ZXJlZFwiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTGFUZVhfMs61XG4vLyBcXHZkb3Rze1xcdmJveHtcXGJhc2VsaW5lc2tpcDRcXHBAICBcXGxpbmVza2lwbGltaXRcXHpAXG4vLyBcXGtlcm42XFxwQFxcaGJveHsufVxcaGJveHsufVxcaGJveHsufX19XG4vLyBXZSdsbCBjYWxsIFxcdmFydmRvdHMsIHdoaWNoIGdldHMgYSBnbHlwaCBmcm9tIHN5bWJvbHMuanMuXG4vLyBUaGUgemVyby13aWR0aCBydWxlIGdldHMgdXMgYW4gZXF1aXZhbGVudCB0byB0aGUgdmVydGljYWwgNnB0IGtlcm4uXG5cbmRlZmluZU1hY3JvKFwiXFxcXHZkb3RzXCIsIFwiXFxcXG1hdGhvcmR7XFxcXHZhcnZkb3RzXFxcXHJ1bGV7MHB0fXsxNXB0fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyRUVcIiwgXCJcXFxcdmRvdHNcIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGFtc21hdGguc3R5XG4vLyBodHRwOi8vbWlycm9ycy5jb25jZXJ0cGFzcy5jb20vdGV4LWFyY2hpdmUvbWFjcm9zL2xhdGV4L3JlcXVpcmVkL2Ftc21hdGgvYW1zbWF0aC5wZGZcbi8vIEl0YWxpYyBHcmVlayBjYXBpdGFsIGxldHRlcnMuICBBTVMgZGVmaW5lcyB0aGVzZSB3aXRoIFxcRGVjbGFyZU1hdGhTeW1ib2wsXG4vLyBidXQgdGhleSBhcmUgZXF1aXZhbGVudCB0byBcXG1hdGhpdHtcXExldHRlcn0uXG5cbmRlZmluZU1hY3JvKFwiXFxcXHZhckdhbW1hXCIsIFwiXFxcXG1hdGhpdHtcXFxcR2FtbWF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyRGVsdGFcIiwgXCJcXFxcbWF0aGl0e1xcXFxEZWx0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJUaGV0YVwiLCBcIlxcXFxtYXRoaXR7XFxcXFRoZXRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhckxhbWJkYVwiLCBcIlxcXFxtYXRoaXR7XFxcXExhbWJkYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJYaVwiLCBcIlxcXFxtYXRoaXR7XFxcXFhpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclBpXCIsIFwiXFxcXG1hdGhpdHtcXFxcUGl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyU2lnbWFcIiwgXCJcXFxcbWF0aGl0e1xcXFxTaWdtYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJVcHNpbG9uXCIsIFwiXFxcXG1hdGhpdHtcXFxcVXBzaWxvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJQaGlcIiwgXCJcXFxcbWF0aGl0e1xcXFxQaGl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyUHNpXCIsIFwiXFxcXG1hdGhpdHtcXFxcUHNpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhck9tZWdhXCIsIFwiXFxcXG1hdGhpdHtcXFxcT21lZ2F9XCIpOyAvLyBcXHJlbmV3Y29tbWFuZHtcXGNvbG9ufXtcXG5vYnJlYWtcXG1za2lwMm11XFxtYXRocHVuY3R7fVxcbm9uc2NyaXB0XG4vLyBcXG1rZXJuLVxcdGhpbm11c2tpcHs6fVxcbXNraXA2bXVwbHVzMW11XFxyZWxheH1cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25cIiwgXCJcXFxcbm9icmVha1xcXFxtc2tpcDJtdVxcXFxtYXRocHVuY3R7fVwiICsgXCJcXFxcbWF0aGNob2ljZXtcXFxcbWtlcm4tM211fXtcXFxcbWtlcm4tM211fXt9e317On1cXFxcbXNraXA2bXVcIik7IC8vIFxcbmV3Y29tbWFuZHtcXGJveGVkfVsxXXtcXGZib3h7XFxtQHRoJFxcZGlzcGxheXN0eWxlIzEkfX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcYm94ZWRcIiwgXCJcXFxcZmJveHskXFxcXGRpc3BsYXlzdHlsZXsjMX0kfVwiKTsgLy8gXFxkZWZcXGlmZntcXERPVFNCXFw7XFxMb25nbGVmdHJpZ2h0YXJyb3dcXDt9XG4vLyBcXGRlZlxcaW1wbGllc3tcXERPVFNCXFw7XFxMb25ncmlnaHRhcnJvd1xcO31cbi8vIFxcZGVmXFxpbXBsaWVkYnl7XFxET1RTQlxcO1xcTG9uZ2xlZnRhcnJvd1xcO31cblxuZGVmaW5lTWFjcm8oXCJcXFxcaWZmXCIsIFwiXFxcXERPVFNCXFxcXDtcXFxcTG9uZ2xlZnRyaWdodGFycm93XFxcXDtcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbXBsaWVzXCIsIFwiXFxcXERPVFNCXFxcXDtcXFxcTG9uZ3JpZ2h0YXJyb3dcXFxcO1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGltcGxpZWRieVwiLCBcIlxcXFxET1RTQlxcXFw7XFxcXExvbmdsZWZ0YXJyb3dcXFxcO1wiKTsgLy8gQU1TTWF0aCdzIGF1dG9tYXRpYyBcXGRvdHMsIGJhc2VkIG9uIFxcbWRvdHNAQCBtYWNyby5cblxudmFyIGRvdHNCeVRva2VuID0ge1xuICAnLCc6ICdcXFxcZG90c2MnLFxuICAnXFxcXG5vdCc6ICdcXFxcZG90c2InLFxuICAvLyBcXGtleWJpbkAgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOlxuICAnKyc6ICdcXFxcZG90c2InLFxuICAnPSc6ICdcXFxcZG90c2InLFxuICAnPCc6ICdcXFxcZG90c2InLFxuICAnPic6ICdcXFxcZG90c2InLFxuICAnLSc6ICdcXFxcZG90c2InLFxuICAnKic6ICdcXFxcZG90c2InLFxuICAnOic6ICdcXFxcZG90c2InLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxET1RTQjpcbiAgJ1xcXFxET1RTQic6ICdcXFxcZG90c2InLFxuICAnXFxcXGNvcHJvZCc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ3ZlZSc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ3dlZGdlJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlndXBsdXMnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWdjYXAnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWdjdXAnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxwcm9kJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcc3VtJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnb3RpbWVzJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnb3BsdXMnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWdvZG90JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnc3FjdXAnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxBbmQnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxsb25ncmlnaHRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXExvbmdyaWdodGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcbG9uZ2xlZnRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXExvbmdsZWZ0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxsb25nbGVmdHJpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxMb25nbGVmdHJpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxtYXBzdG8nOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxsb25nbWFwc3RvJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcaG9va3JpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxkb3RlcSc6ICdcXFxcZG90c2InLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxtYXRoYmluOlxuICAnXFxcXG1hdGhiaW4nOiAnXFxcXGRvdHNiJyxcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcbWF0aHJlbDpcbiAgJ1xcXFxtYXRocmVsJzogJ1xcXFxkb3RzYicsXG4gICdcXFxccmVsYmFyJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcUmVsYmFyJzogJ1xcXFxkb3RzYicsXG4gICdcXFxceHJpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFx4bGVmdGFycm93JzogJ1xcXFxkb3RzYicsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXERPVFNJOlxuICAnXFxcXERPVFNJJzogJ1xcXFxkb3RzaScsXG4gICdcXFxcaW50JzogJ1xcXFxkb3RzaScsXG4gICdcXFxcb2ludCc6ICdcXFxcZG90c2knLFxuICAnXFxcXGlpbnQnOiAnXFxcXGRvdHNpJyxcbiAgJ1xcXFxpaWludCc6ICdcXFxcZG90c2knLFxuICAnXFxcXGlpaWludCc6ICdcXFxcZG90c2knLFxuICAnXFxcXGlkb3RzaW50JzogJ1xcXFxkb3RzaScsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXERPVFNYOlxuICAnXFxcXERPVFNYJzogJ1xcXFxkb3RzeCdcbn07XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIC8vIFRPRE86IElmIHVzZWQgaW4gdGV4dCBtb2RlLCBzaG91bGQgZXhwYW5kIHRvIFxcdGV4dGVsbGlwc2lzLlxuICAvLyBIb3dldmVyLCBpbiBLYVRlWCwgXFx0ZXh0ZWxsaXBzaXMgYW5kIFxcbGRvdHMgYmVoYXZlIHRoZSBzYW1lXG4gIC8vIChpbiB0ZXh0IG1vZGUpLCBhbmQgaXQncyB1bmxpa2VseSB3ZSdkIHNlZSBhbnkgb2YgdGhlIG1hdGggY29tbWFuZHNcbiAgLy8gdGhhdCBhZmZlY3QgdGhlIGJlaGF2aW9yIG9mIFxcZG90cyB3aGVuIGluIHRleHQgbW9kZS4gIFNvIGZpbmUgZm9yIG5vd1xuICAvLyAodW50aWwgd2Ugc3VwcG9ydCBcXGlmbW1vZGUgLi4uIFxcZWxzZSAuLi4gXFxmaSkuXG4gIHZhciB0aGVkb3RzID0gJ1xcXFxkb3Rzbyc7XG4gIHZhciBuZXh0ID0gY29udGV4dC5leHBhbmRBZnRlckZ1dHVyZSgpLnRleHQ7XG5cbiAgaWYgKG5leHQgaW4gZG90c0J5VG9rZW4pIHtcbiAgICB0aGVkb3RzID0gZG90c0J5VG9rZW5bbmV4dF07XG4gIH0gZWxzZSBpZiAobmV4dC5zdWJzdHIoMCwgNCkgPT09ICdcXFxcbm90Jykge1xuICAgIHRoZWRvdHMgPSAnXFxcXGRvdHNiJztcbiAgfSBlbHNlIGlmIChuZXh0IGluIHNyY19zeW1ib2xzLm1hdGgpIHtcbiAgICBpZiAodXRpbHMuY29udGFpbnMoWydiaW4nLCAncmVsJ10sIHNyY19zeW1ib2xzLm1hdGhbbmV4dF0uZ3JvdXApKSB7XG4gICAgICB0aGVkb3RzID0gJ1xcXFxkb3RzYic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoZWRvdHM7XG59KTtcbnZhciBzcGFjZUFmdGVyRG90cyA9IHtcbiAgLy8gXFxyaWdodGRlbGltQCBjaGVja3MgZm9yIHRoZSBmb2xsb3dpbmc6XG4gICcpJzogdHJ1ZSxcbiAgJ10nOiB0cnVlLFxuICAnXFxcXHJicmFjayc6IHRydWUsXG4gICdcXFxcfSc6IHRydWUsXG4gICdcXFxccmJyYWNlJzogdHJ1ZSxcbiAgJ1xcXFxyYW5nbGUnOiB0cnVlLFxuICAnXFxcXHJjZWlsJzogdHJ1ZSxcbiAgJ1xcXFxyZmxvb3InOiB0cnVlLFxuICAnXFxcXHJncm91cCc6IHRydWUsXG4gICdcXFxccm1vdXN0YWNoZSc6IHRydWUsXG4gICdcXFxccmlnaHQnOiB0cnVlLFxuICAnXFxcXGJpZ3InOiB0cnVlLFxuICAnXFxcXGJpZ2dyJzogdHJ1ZSxcbiAgJ1xcXFxCaWdyJzogdHJ1ZSxcbiAgJ1xcXFxCaWdncic6IHRydWUsXG4gIC8vIFxcZXh0cmFAIGFsc28gdGVzdHMgZm9yIHRoZSBmb2xsb3dpbmc6XG4gICckJzogdHJ1ZSxcbiAgLy8gXFxleHRyYXBAIGNoZWNrcyBmb3IgdGhlIGZvbGxvd2luZzpcbiAgJzsnOiB0cnVlLFxuICAnLic6IHRydWUsXG4gICcsJzogdHJ1ZVxufTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNvXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBuZXh0ID0gY29udGV4dC5mdXR1cmUoKS50ZXh0O1xuXG4gIGlmIChuZXh0IGluIHNwYWNlQWZ0ZXJEb3RzKSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcIjtcbiAgfVxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzY1wiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgbmV4dCA9IGNvbnRleHQuZnV0dXJlKCkudGV4dDsgLy8gXFxkb3RzYyB1c2VzIFxcZXh0cmFAIGJ1dCBub3QgXFxleHRyYXBALCBpbnN0ZWFkIHNwZWNpYWxseSBjaGVja2luZyBmb3JcbiAgLy8gJzsnIGFuZCAnLicsIGJ1dCBkb2Vzbid0IGNoZWNrIGZvciAnLCcuXG5cbiAgaWYgKG5leHQgaW4gc3BhY2VBZnRlckRvdHMgJiYgbmV4dCAhPT0gJywnKSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcIjtcbiAgfVxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxjZG90c1wiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgbmV4dCA9IGNvbnRleHQuZnV0dXJlKCkudGV4dDtcblxuICBpZiAobmV4dCBpbiBzcGFjZUFmdGVyRG90cykge1xuICAgIHJldHVybiBcIlxcXFxAY2RvdHNcXFxcLFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlxcXFxAY2RvdHNcIjtcbiAgfVxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzYlwiLCBcIlxcXFxjZG90c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNtXCIsIFwiXFxcXGNkb3RzXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c2lcIiwgXCJcXFxcIVxcXFxjZG90c1wiKTsgLy8gYW1zbWF0aCBkb2Vzbid0IGFjdHVhbGx5IGRlZmluZSBcXGRvdHN4LCBidXQgXFxkb3RzIGZvbGxvd2VkIGJ5IGEgbWFjcm9cbi8vIHN0YXJ0aW5nIHdpdGggXFxET1RTWCBpbXBsaWVzIFxcZG90c28sIGFuZCB0aGVuIFxcZXh0cmFAIGRldGVjdHMgdGhpcyBjYXNlXG4vLyBhbmQgZm9yY2VzIHRoZSBhZGRlZCBgXFwsYC5cblxuZGVmaW5lTWFjcm8oXCJcXFxcZG90c3hcIiwgXCJcXFxcbGRvdHNcXFxcLFwiKTsgLy8gXFxsZXRcXERPVFNJXFxyZWxheFxuLy8gXFxsZXRcXERPVFNCXFxyZWxheFxuLy8gXFxsZXRcXERPVFNYXFxyZWxheFxuXG5kZWZpbmVNYWNybyhcIlxcXFxET1RTSVwiLCBcIlxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERPVFNCXCIsIFwiXFxcXHJlbGF4XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRE9UU1hcIiwgXCJcXFxccmVsYXhcIik7IC8vIFNwYWNpbmcsIGJhc2VkIG9uIGFtc21hdGguc3R5J3Mgb3ZlcnJpZGUgb2YgTGFUZVggZGVmYXVsdHNcbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmR7XFx0bXNwYWNlfVszXXslXG4vLyAgIFxcaWZtbW9kZVxcbXNraXAjMSMyXFxlbHNlXFxrZXJuIzEjM1xcZmlcXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFx0bXNwYWNlXCIsIFwiXFxcXFRleHRPck1hdGh7XFxcXGtlcm4jMSMzfXtcXFxcbXNraXAjMSMyfVxcXFxyZWxheFwiKTsgLy8gXFxyZW5ld2NvbW1hbmR7XFwsfXtcXHRtc3BhY2UrXFx0aGlubXVza2lwey4xNjY3ZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFx0aGlubXVza2lwXG5cbmRlZmluZU1hY3JvKFwiXFxcXCxcIiwgXCJcXFxcdG1zcGFjZSt7M211fXsuMTY2N2VtfVwiKTsgLy8gXFxsZXRcXHRoaW5zcGFjZVxcLFxuXG5kZWZpbmVNYWNybyhcIlxcXFx0aGluc3BhY2VcIiwgXCJcXFxcLFwiKTsgLy8gXFxkZWZcXD57XFxtc2tpcFxcbWVkbXVza2lwfVxuLy8gXFxyZW5ld2NvbW1hbmR7XFw6fXtcXHRtc3BhY2UrXFxtZWRtdXNraXB7LjIyMjJlbX19XG4vLyBUT0RPOiBcXD4gYW5kIG1hdGggbW9kZSBvZiBcXDogc2hvdWxkIHVzZSBcXG1lZG11c2tpcCA9IDRtdSBwbHVzIDJtdSBtaW51cyA0bXVcblxuZGVmaW5lTWFjcm8oXCJcXFxcPlwiLCBcIlxcXFxtc2tpcHs0bXV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcOlwiLCBcIlxcXFx0bXNwYWNlK3s0bXV9ey4yMjIyZW19XCIpOyAvLyBcXGxldFxcbWVkc3BhY2VcXDpcblxuZGVmaW5lTWFjcm8oXCJcXFxcbWVkc3BhY2VcIiwgXCJcXFxcOlwiKTsgLy8gXFxyZW5ld2NvbW1hbmR7XFw7fXtcXHRtc3BhY2UrXFx0aGlja211c2tpcHsuMjc3N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpY2ttdXNraXAgPSA1bXUgcGx1cyA1bXVcblxuZGVmaW5lTWFjcm8oXCJcXFxcO1wiLCBcIlxcXFx0bXNwYWNlK3s1bXV9ey4yNzc3ZW19XCIpOyAvLyBcXGxldFxcdGhpY2tzcGFjZVxcO1xuXG5kZWZpbmVNYWNybyhcIlxcXFx0aGlja3NwYWNlXCIsIFwiXFxcXDtcIik7IC8vIFxccmVuZXdjb21tYW5ke1xcIX17XFx0bXNwYWNlLVxcdGhpbm11c2tpcHsuMTY2N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpbm11c2tpcFxuXG5kZWZpbmVNYWNybyhcIlxcXFwhXCIsIFwiXFxcXHRtc3BhY2UtezNtdX17LjE2NjdlbX1cIik7IC8vIFxcbGV0XFxuZWd0aGluc3BhY2VcXCFcblxuZGVmaW5lTWFjcm8oXCJcXFxcbmVndGhpbnNwYWNlXCIsIFwiXFxcXCFcIik7IC8vIFxcbmV3Y29tbWFuZHtcXG5lZ21lZHNwYWNlfXtcXHRtc3BhY2UtXFxtZWRtdXNraXB7LjIyMjJlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXG1lZG11c2tpcFxuXG5kZWZpbmVNYWNybyhcIlxcXFxuZWdtZWRzcGFjZVwiLCBcIlxcXFx0bXNwYWNlLXs0bXV9ey4yMjIyZW19XCIpOyAvLyBcXG5ld2NvbW1hbmR7XFxuZWd0aGlja3NwYWNlfXtcXHRtc3BhY2UtXFx0aGlja211c2tpcHsuMjc3N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpY2ttdXNraXBcblxuZGVmaW5lTWFjcm8oXCJcXFxcbmVndGhpY2tzcGFjZVwiLCBcIlxcXFx0bXNwYWNlLXs1bXV9ey4yNzdlbX1cIik7IC8vIFxcZGVmXFxlbnNwYWNle1xca2Vybi41ZW0gfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxlbnNwYWNlXCIsIFwiXFxcXGtlcm4uNWVtIFwiKTsgLy8gXFxkZWZcXGVuc2tpcHtcXGhza2lwLjVlbVxccmVsYXh9XG5cbmRlZmluZU1hY3JvKFwiXFxcXGVuc2tpcFwiLCBcIlxcXFxoc2tpcC41ZW1cXFxccmVsYXhcIik7IC8vIFxcZGVmXFxxdWFke1xcaHNraXAxZW1cXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxxdWFkXCIsIFwiXFxcXGhza2lwMWVtXFxcXHJlbGF4XCIpOyAvLyBcXGRlZlxccXF1YWR7XFxoc2tpcDJlbVxccmVsYXh9XG5cbmRlZmluZU1hY3JvKFwiXFxcXHFxdWFkXCIsIFwiXFxcXGhza2lwMmVtXFxcXHJlbGF4XCIpOyAvLyBcXHRhZ0BpbkBkaXNwbGF5IGZvcm0gb2YgXFx0YWdcblxuZGVmaW5lTWFjcm8oXCJcXFxcdGFnXCIsIFwiXFxcXEBpZnN0YXJcXFxcdGFnQGxpdGVyYWxcXFxcdGFnQHBhcmVuXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGFnQHBhcmVuXCIsIFwiXFxcXHRhZ0BsaXRlcmFseyh7IzF9KX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0YWdAbGl0ZXJhbFwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICBpZiAoY29udGV4dC5tYWNyb3MuZ2V0KFwiXFxcXGRmQHRhZ1wiKSkge1xuICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIk11bHRpcGxlIFxcXFx0YWdcIik7XG4gIH1cblxuICByZXR1cm4gXCJcXFxcZ2RlZlxcXFxkZkB0YWd7XFxcXHRleHR7IzF9fVwiO1xufSk7IC8vIFxccmVuZXdjb21tYW5ke1xcYm1vZH17XFxub25zY3JpcHRcXG1za2lwLVxcbWVkbXVza2lwXFxta2VybjVtdVxcbWF0aGJpblxuLy8gICB7XFxvcGVyYXRvckBmb250IG1vZH1cXHBlbmFsdHk5MDBcbi8vICAgXFxta2VybjVtdVxcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcH1cbi8vIFxcbmV3Y29tbWFuZHtcXHBvZH1bMV17XFxhbGxvd2JyZWFrXG4vLyAgIFxcaWZAZGlzcGxheVxcbWtlcm4xOG11XFxlbHNlXFxta2VybjhtdVxcZmkoIzEpfVxuLy8gXFxyZW5ld2NvbW1hbmR7XFxwbW9kfVsxXXtcXHBvZHt7XFxvcGVyYXRvckBmb250IG1vZH1cXG1rZXJuNm11IzF9fVxuLy8gXFxuZXdjb21tYW5ke1xcbW9kfVsxXXtcXGFsbG93YnJlYWtcXGlmQGRpc3BsYXlcXG1rZXJuMThtdVxuLy8gICBcXGVsc2VcXG1rZXJuMTJtdVxcZml7XFxvcGVyYXRvckBmb250IG1vZH1cXCxcXCwjMX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcbWVkbXVza2lwID0gNG11IHBsdXMgMm11IG1pbnVzIDRtdVxuXG5kZWZpbmVNYWNybyhcIlxcXFxibW9kXCIsIFwiXFxcXG1hdGhjaG9pY2V7XFxcXG1za2lwMW11fXtcXFxcbXNraXAxbXV9e1xcXFxtc2tpcDVtdX17XFxcXG1za2lwNW11fVwiICsgXCJcXFxcbWF0aGJpbntcXFxccm0gbW9kfVwiICsgXCJcXFxcbWF0aGNob2ljZXtcXFxcbXNraXAxbXV9e1xcXFxtc2tpcDFtdX17XFxcXG1za2lwNW11fXtcXFxcbXNraXA1bXV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccG9kXCIsIFwiXFxcXGFsbG93YnJlYWtcIiArIFwiXFxcXG1hdGhjaG9pY2V7XFxcXG1rZXJuMThtdX17XFxcXG1rZXJuOG11fXtcXFxcbWtlcm44bXV9e1xcXFxta2VybjhtdX0oIzEpXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccG1vZFwiLCBcIlxcXFxwb2R7e1xcXFxybSBtb2R9XFxcXG1rZXJuNm11IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbW9kXCIsIFwiXFxcXGFsbG93YnJlYWtcIiArIFwiXFxcXG1hdGhjaG9pY2V7XFxcXG1rZXJuMThtdX17XFxcXG1rZXJuMTJtdX17XFxcXG1rZXJuMTJtdX17XFxcXG1rZXJuMTJtdX1cIiArIFwie1xcXFxybSBtb2R9XFxcXCxcXFxcLCMxXCIpOyAvLyBcXHBtYiAgICAtLSAgIEEgc2ltdWxhdGlvbiBvZiBib2xkLlxuLy8gSXQgd29ya3MgYnkgdHlwZXNldHRpbmcgdGhyZWUgY29waWVzIG9mIHRoZSBhcmd1bWVudCB3aXRoIHNtYWxsIG9mZnNldHMuXG4vLyBSZWY6IGEgcmF0aGVyIGxlbmd0aHkgbWFjcm8gaW4gYW1ic3kuc3R5XG5cbmRlZmluZU1hY3JvKFwiXFxcXHBtYlwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGJpbnJlbHsjMX17XCIgKyBcIlxcXFxtYXRocmxhcHsjMX1cIiArIFwiXFxcXG1hdGhybGFwe1xcXFxta2VybjAuNG11XFxcXHJhaXNlYm94ezAuNG11fXskIzEkfX1cIiArIFwie1xcXFxta2VybjAuOG11IzF9XCIgKyBcIn19e1xcXFxtYXRoYmZ7IzF9fVwiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTGFUZVggc291cmNlMmVcbi8vIFxcXFwgZGVmYXVsdHMgdG8gXFxuZXdsaW5lLCBidXQgY2hhbmdlcyB0byBcXGNyIHdpdGhpbiBhcnJheSBlbnZpcm9ubWVudFxuXG5kZWZpbmVNYWNybyhcIlxcXFxcXFxcXCIsIFwiXFxcXG5ld2xpbmVcIik7IC8vIFxcZGVmXFxUZVh7VFxca2Vybi0uMTY2N2VtXFxsb3dlci41ZXhcXGhib3h7RX1cXGtlcm4tLjEyNWVtWFxcQH1cbi8vIFRPRE86IERvZXNuJ3Qgbm9ybWFsbHkgd29yayBpbiBtYXRoIG1vZGUgYmVjYXVzZSBcXEAgZmFpbHMuICBLYVRlWCBkb2Vzbid0XG4vLyBzdXBwb3J0IFxcQCB5ZXQsIHNvIHRoYXQncyBvbWl0dGVkLCBhbmQgd2UgYWRkIFxcdGV4dCBzbyB0aGF0IHRoZSByZXN1bHRcbi8vIGRvZXNuJ3QgbG9vayBmdW5ueSBpbiBtYXRoIG1vZGUuXG5cbmRlZmluZU1hY3JvKFwiXFxcXFRlWFwiLCBcIlxcXFx0ZXh0cm17XFxcXGh0bWxAbWF0aG1se1wiICsgXCJUXFxcXGtlcm4tLjE2NjdlbVxcXFxyYWlzZWJveHstLjVleH17RX1cXFxca2Vybi0uMTI1ZW1YXCIgKyBcIn17VGVYfX1cIik7IC8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmR7XFxMYVRlWH17TFxca2Vybi0uMzZlbSVcbi8vICAgICAgICAge1xcc2JveFxcekAgVCVcbi8vICAgICAgICAgIFxcdmJveCB0b1xcaHRcXHpAe1xcaGJveHtcXGNoZWNrQG1hdGhmb250c1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxmb250c2l6ZVxcc2ZAc2l6ZVxcekBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbWF0aEBmb250c2ZhbHNlXFxzZWxlY3Rmb250XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBfSVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIFxcdnNzfSVcbi8vICAgICAgICAgfSVcbi8vICAgICAgICAgXFxrZXJuLS4xNWVtJVxuLy8gICAgICAgICBcXFRlWH1cbi8vIFRoaXMgY29kZSBhbGlnbnMgdGhlIHRvcCBvZiB0aGUgQSB3aXRoIHRoZSBUIChmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiBUZVgnc1xuLy8gYm94ZXMsIHRob3VnaCB2aXN1YWxseSB0aGUgQSBhcHBlYXJzIHRvIGV4dGVuZCBhYm92ZSBzbGlnaHRseSkuXG4vLyBXZSBjb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIFxccmFpc2Vib3ggd2hlbiBBIGlzIHJlbmRlcmVkIGF0IFxcc2NyaXB0c2l6ZSxcbi8vIHdoaWNoIGlzIHNpemUzLCB3aGljaCBoYXMgYSBzY2FsZSBmYWN0b3Igb2YgMC43IChzZWUgT3B0aW9ucy5qcykuXG5cbnZhciBsYXRleFJhaXNlQSA9IGZvbnRNZXRyaWNzRGF0YVsnTWFpbi1SZWd1bGFyJ11bXCJUXCIuY2hhckNvZGVBdCgwKV1bMV0gLSAwLjcgKiBmb250TWV0cmljc0RhdGFbJ01haW4tUmVndWxhciddW1wiQVwiLmNoYXJDb2RlQXQoMCldWzFdICsgXCJlbVwiO1xuZGVmaW5lTWFjcm8oXCJcXFxcTGFUZVhcIiwgXCJcXFxcdGV4dHJte1xcXFxodG1sQG1hdGhtbHtcIiArIChcIkxcXFxca2Vybi0uMzZlbVxcXFxyYWlzZWJveHtcIiArIGxhdGV4UmFpc2VBICsgXCJ9e1xcXFxzY3JpcHRzaXplIEF9XCIpICsgXCJcXFxca2Vybi0uMTVlbVxcXFxUZVh9e0xhVGVYfX1cIik7IC8vIE5ldyBLYVRlWCBsb2dvIGJhc2VkIG9uIHR3ZWFraW5nIExhVGVYIGxvZ29cblxuZGVmaW5lTWFjcm8oXCJcXFxcS2FUZVhcIiwgXCJcXFxcdGV4dHJte1xcXFxodG1sQG1hdGhtbHtcIiArIChcIktcXFxca2Vybi0uMTdlbVxcXFxyYWlzZWJveHtcIiArIGxhdGV4UmFpc2VBICsgXCJ9e1xcXFxzY3JpcHRzaXplIEF9XCIpICsgXCJcXFxca2Vybi0uMTVlbVxcXFxUZVh9e0thVGVYfX1cIik7IC8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmRcXGhzcGFjZXtcXEBpZnN0YXJcXEBoc3BhY2VyXFxAaHNwYWNlfVxuLy8gXFxkZWZcXEBoc3BhY2UjMXtcXGhza2lwICAjMVxccmVsYXh9XG4vLyBcXGRlZlxcQGhzcGFjZXIjMXtcXHZydWxlIFxcQHdpZHRoXFx6QFxcbm9icmVha1xuLy8gICAgICAgICAgICAgICAgIFxcaHNraXAgIzFcXGhza2lwIFxcekBza2lwfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxoc3BhY2VcIiwgXCJcXFxcQGlmc3RhclxcXFxAaHNwYWNlclxcXFxAaHNwYWNlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQGhzcGFjZVwiLCBcIlxcXFxoc2tpcCAjMVxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEBoc3BhY2VyXCIsIFwiXFxcXHJ1bGV7MHB0fXswcHR9XFxcXGhza2lwICMxXFxcXHJlbGF4XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBtYXRodG9vbHMuc3R5XG4vL1xccHJvdmlkZWNvbW1hbmRcXG9yZGluYXJ5Y29sb257On1cblxuZGVmaW5lTWFjcm8oXCJcXFxcb3JkaW5hcnljb2xvblwiLCBcIjpcIik7IC8vXFxkZWZcXHZjZW50Y29sb257XFxtYXRocmVse1xcbWF0aG9wXFxvcmRpbmFyeWNvbG9ufX1cbi8vVE9ETyhlZGVtYWluZSk6IE5vdCB5ZXQgY2VudGVyZWQuIEZpeCB2aWEgXFxyYWlzZWJveCBvciAjNzI2XG5cbmRlZmluZU1hY3JvKFwiXFxcXHZjZW50Y29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcbWF0aG9wXFxcXG9yZGluYXJ5Y29sb259XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcZGJsY29sb257XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tLjltdX1cXHZjZW50Y29sb259XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRibGNvbG9uXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0uOW11fVxcXFx2Y2VudGNvbG9ufX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjIzN319XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25lcXF7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9PX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25lcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFx2Y2VudGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fT19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjU0fX1cIik7IC8vIOKJlFxuLy8gXFxwcm92aWRlY29tbWFuZCpcXENvbG9uZXFxe1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX09fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXGRibGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fT19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3XFxcXGNoYXJcXFwiM2R9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXGNvbG9uZXF7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxtYXRocmVsey19fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcbWF0aHJlbHstfX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjNhXFxcXGNoYXJcXFwiMjIxMn19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25lcXtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxtYXRocmVsey19fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcZGJsY29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXG1hdGhyZWx7LX19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3XFxcXGNoYXJcXFwiMjIxMn19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcZXFxY29sb257PVxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcdmNlbnRjb2xvbn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcZXFxY29sb25cIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVsez1cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXHZjZW50Y29sb259fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjU1fX1cIik7IC8vIOKJlVxuLy8gXFxwcm92aWRlY29tbWFuZCpcXEVxcWNvbG9uez1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGRibGNvbG9ufVxuXG5kZWZpbmVNYWNybyhcIlxcXFxFcXFjb2xvblwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7PVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcZGJsY29sb259fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIzZFxcXFxjaGFyXFxcIjIyMzd9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXGVxY29sb257XFxtYXRocmVsey19XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFx2Y2VudGNvbG9ufVxuXG5kZWZpbmVNYWNybyhcIlxcXFxlcWNvbG9uXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcbWF0aHJlbHstfVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcdmNlbnRjb2xvbn19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzl9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXEVxY29sb257XFxtYXRocmVsey19XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxkYmxjb2xvbn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcRXFjb2xvblwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXG1hdGhyZWx7LX1cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXGRibGNvbG9ufX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjIxMlxcXFxjaGFyXFxcIjIyMzd9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXGNvbG9uYXBwcm94e1xcdmNlbnRjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcYXBwcm94fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmFwcHJveFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXHZjZW50Y29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXGFwcHJveH19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjNhXFxcXGNoYXJcXFwiMjI0OH19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25hcHByb3h7XFxkYmxjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcYXBwcm94fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmFwcHJveFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXGRibGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxhcHByb3h9fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3XFxcXGNoYXJcXFwiMjI0OH19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25zaW17XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxzaW19XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uc2ltXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcc2ltfX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiM2FcXFxcY2hhclxcXCIyMjNjfX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbnNpbXtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxzaW19XG5cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uc2ltXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcZGJsY29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXHNpbX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzdcXFxcY2hhclxcXCIyMjNjfX1cIik7IC8vIFNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzIGFyZSBpbXBsZW1lbnRlZCB3aXRoIG1hY3JvcyB0byBtYXRodG9vbHMgZnVuY3Rpb25zLlxuXG5kZWZpbmVNYWNybyhcIlxcdTIyMzdcIiwgXCJcXFxcZGJsY29sb25cIik7IC8vIDo6XG5cbmRlZmluZU1hY3JvKFwiXFx1MjIzOVwiLCBcIlxcXFxlcWNvbG9uXCIpOyAvLyAtOlxuXG5kZWZpbmVNYWNybyhcIlxcdTIyNTRcIiwgXCJcXFxcY29sb25lcXFcIik7IC8vIDo9XG5cbmRlZmluZU1hY3JvKFwiXFx1MjI1NVwiLCBcIlxcXFxlcXFjb2xvblwiKTsgLy8gPTpcblxuZGVmaW5lTWFjcm8oXCJcXHUyQTc0XCIsIFwiXFxcXENvbG9uZXFxXCIpOyAvLyA6Oj1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbG9uZXF1YWxzLnN0eVxuLy8gQWx0ZXJuYXRlIG5hbWVzIGZvciBtYXRodG9vbHMncyBtYWNyb3M6XG5cbmRlZmluZU1hY3JvKFwiXFxcXHJhdGlvXCIsIFwiXFxcXHZjZW50Y29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uXCIsIFwiXFxcXGRibGNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25lcXVhbHNcIiwgXCJcXFxcY29sb25lcXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uZXF1YWxzXCIsIFwiXFxcXENvbG9uZXFxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXF1YWxzY29sb25cIiwgXCJcXFxcZXFxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlcXVhbHNjb2xvbmNvbG9uXCIsIFwiXFxcXEVxcWNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25taW51c1wiLCBcIlxcXFxjb2xvbmVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbm1pbnVzXCIsIFwiXFxcXENvbG9uZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW51c2NvbG9uXCIsIFwiXFxcXGVxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW51c2NvbG9uY29sb25cIiwgXCJcXFxcRXFjb2xvblwiKTsgLy8gXFxjb2xvbmFwcHJveCBuYW1lIGlzIHNhbWUgaW4gbWF0aHRvb2xzIGFuZCBjb2xvbmVxdWFscy5cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbmFwcHJveFwiLCBcIlxcXFxDb2xvbmFwcHJveFwiKTsgLy8gXFxjb2xvbnNpbSBuYW1lIGlzIHNhbWUgaW4gbWF0aHRvb2xzIGFuZCBjb2xvbmVxdWFscy5cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbnNpbVwiLCBcIlxcXFxDb2xvbnNpbVwiKTsgLy8gQWRkaXRpb25hbCBtYWNyb3MsIGltcGxlbWVudGVkIGJ5IGFuYWxvZ3kgd2l0aCBtYXRodG9vbHMgZGVmaW5pdGlvbnM6XG5cbmRlZmluZU1hY3JvKFwiXFxcXHNpbWNvbG9uXCIsIFwiXFxcXG1hdGhyZWx7XFxcXHNpbVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcdmNlbnRjb2xvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzaW1jb2xvbmNvbG9uXCIsIFwiXFxcXG1hdGhyZWx7XFxcXHNpbVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcZGJsY29sb259XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYXBwcm94Y29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcYXBwcm94XFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFx2Y2VudGNvbG9ufVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFwcHJveGNvbG9uY29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcYXBwcm94XFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxkYmxjb2xvbn1cIik7IC8vIFByZXNlbnQgaW4gbmV3dHhtYXRoLCBweGZvbnRzIGFuZCB0eGZvbnRzXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5vdG5pXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxub3RcXFxcbml9e1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyMEN9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxpbXN1cFwiLCBcIlxcXFxET1RTQlxcXFxtYXRob3B7XFxcXG9wZXJhdG9ybmFtZXtsaW1cXFxcLHN1cH19XFxcXGxpbWl0c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxpbWluZlwiLCBcIlxcXFxET1RTQlxcXFxtYXRob3B7XFxcXG9wZXJhdG9ybmFtZXtsaW1cXFxcLGluZn19XFxcXGxpbWl0c1wiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTWF0aE1MIGFsdGVybmF0ZXMgZm9yIEthVGVYIGdseXBocyBpbiB0aGUgVW5pY29kZSBwcml2YXRlIGFyZWFcblxuZGVmaW5lTWFjcm8oXCJcXFxcZ3ZlcnRuZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAZ3ZlcnRuZXFxfXtcXHUyMjY5fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGx2ZXJ0bmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGx2ZXJ0bmVxcX17XFx1MjI2OH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuZ2VxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5nZXFxfXtcXHUyMjcxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5nZXFzbGFudFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5nZXFzbGFudH17XFx1MjI3MX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxubGVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5sZXFxfXtcXHUyMjcwfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5sZXFzbGFudFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5sZXFzbGFudH17XFx1MjI3MH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuc2hvcnRtaWRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBuc2hvcnRtaWR9e+KIpH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuc2hvcnRwYXJhbGxlbFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5zaG9ydHBhcmFsbGVsfXviiKZ9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbnN1YnNldGVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5zdWJzZXRlcXF9e1xcdTIyODh9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbnN1cHNldGVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5zdXBzZXRlcXF9e1xcdTIyODl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyc3Vic2V0bmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAdmFyc3Vic2V0bmVxfXviiop9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyc3Vic2V0bmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQHZhcnN1YnNldG5lcXF9e+Kri31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJzdXBzZXRuZXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEB2YXJzdXBzZXRuZXF9e+KKi31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJzdXBzZXRuZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAdmFyc3Vwc2V0bmVxcX174quMfVwiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gc3RtYXJ5cmQgYW5kIHNlbWFudGljXG4vLyBUaGUgc3RtYXJ5cmQgYW5kIHNlbWFudGljIHBhY2thZ2VzIHJlbmRlciB0aGUgbmV4dCBmb3VyIGl0ZW1zIGJ5IGNhbGxpbmcgYVxuLy8gZ2x5cGguIFRob3NlIGdseXBocyBkbyBub3QgZXhpc3QgaW4gdGhlIEthVGVYIGZvbnRzLiBIZW5jZSB0aGUgbWFjcm9zLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxsbGJyYWNrZXRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRob3BlbntbXFxcXG1rZXJuLTMuMm11W319XCIgKyBcIntcXFxcbWF0aG9wZW57XFxcXGNoYXJgXFx1MjdFNn19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccnJicmFja2V0XCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aGNsb3Nle11cXFxcbWtlcm4tMy4ybXVdfX1cIiArIFwie1xcXFxtYXRoY2xvc2V7XFxcXGNoYXJgXFx1MjdFN319XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyN0U2XCIsIFwiXFxcXGxsYnJhY2tldFwiKTsgLy8gYmxhY2tib2FyZCBib2xkIFtcblxuZGVmaW5lTWFjcm8oXCJcXHUyN0U3XCIsIFwiXFxcXHJyYnJhY2tldFwiKTsgLy8gYmxhY2tib2FyZCBib2xkIF1cblxuZGVmaW5lTWFjcm8oXCJcXFxcbEJyYWNlXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aG9wZW57XFxcXHtcXFxcbWtlcm4tMy4ybXVbfX1cIiArIFwie1xcXFxtYXRob3BlbntcXFxcY2hhcmBcXHUyOTgzfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyQnJhY2VcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRoY2xvc2V7XVxcXFxta2Vybi0zLjJtdVxcXFx9fX1cIiArIFwie1xcXFxtYXRoY2xvc2V7XFxcXGNoYXJgXFx1Mjk4NH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyOTgzXCIsIFwiXFxcXGxCcmFjZVwiKTsgLy8gYmxhY2tib2FyZCBib2xkIHtcblxuZGVmaW5lTWFjcm8oXCJcXHUyOTg0XCIsIFwiXFxcXHJCcmFjZVwiKTsgLy8gYmxhY2tib2FyZCBib2xkIH1cbi8vIFRPRE86IENyZWF0ZSB2YXJpYWJsZSBzaXplZCB2ZXJzaW9ucyBvZiB0aGUgbGFzdCB0d28gaXRlbXMuIEkgYmVsaWV2ZSB0aGF0XG4vLyB3aWxsIHJlcXVpcmUgbmV3IGZvbnQgZ2x5cGhzLlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdGV4dmMuc3R5XG4vLyBUaGUgdGV4dmMgcGFja2FnZSBjb250YWlucyBtYWNyb3MgYXZhaWxhYmxlIGluIG1lZGlhd2lraSBwYWdlcy5cbi8vIFdlIG9taXQgdGhlIGZ1bmN0aW9ucyBkZXByZWNhdGVkIGF0XG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWxwOkRpc3BsYXlpbmdfYV9mb3JtdWxhI0RlcHJlY2F0ZWRfc3ludGF4XG4vLyBXZSBhbHNvIG9taXQgdGV4dmMncyBcXE8sIHdoaWNoIGNvbmZsaWN0cyB3aXRoIFxcdGV4dHtcXE99XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRhcnJcIiwgXCJcXFxcZG93bmFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZEFyclwiLCBcIlxcXFxEb3duYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxEYXJyXCIsIFwiXFxcXERvd25hcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxhbmdcIiwgXCJcXFxcbGFuZ2xlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmFuZ1wiLCBcIlxcXFxyYW5nbGVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1YXJyXCIsIFwiXFxcXHVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1QXJyXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxVYXJyXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxOXCIsIFwiXFxcXG1hdGhiYntOfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJcIiwgXCJcXFxcbWF0aGJie1J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcWlwiLCBcIlxcXFxtYXRoYmJ7Wn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhbGVmXCIsIFwiXFxcXGFsZXBoXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWxlZnN5bVwiLCBcIlxcXFxhbGVwaFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEFscGhhXCIsIFwiXFxcXG1hdGhybXtBfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEJldGFcIiwgXCJcXFxcbWF0aHJte0J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYnVsbFwiLCBcIlxcXFxidWxsZXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxDaGlcIiwgXCJcXFxcbWF0aHJte1h9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY2x1YnNcIiwgXCJcXFxcY2x1YnN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjbnVtc1wiLCBcIlxcXFxtYXRoYmJ7Q31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxDb21wbGV4XCIsIFwiXFxcXG1hdGhiYntDfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERhZ2dlclwiLCBcIlxcXFxkZGFnZ2VyXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZGlhbW9uZHNcIiwgXCJcXFxcZGlhbW9uZHN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlbXB0eVwiLCBcIlxcXFxlbXB0eXNldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEVwc2lsb25cIiwgXCJcXFxcbWF0aHJte0V9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRXRhXCIsIFwiXFxcXG1hdGhybXtIfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGV4aXN0XCIsIFwiXFxcXGV4aXN0c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhhcnJcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxoQXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcSGFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhlYXJ0c1wiLCBcIlxcXFxoZWFydHN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbWFnZVwiLCBcIlxcXFxJbVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGluZmluXCIsIFwiXFxcXGluZnR5XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcSW90YVwiLCBcIlxcXFxtYXRocm17SX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpc2luXCIsIFwiXFxcXGluXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcS2FwcGFcIiwgXCJcXFxcbWF0aHJte0t9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGFyclwiLCBcIlxcXFxsZWZ0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsQXJyXCIsIFwiXFxcXExlZnRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXExhcnJcIiwgXCJcXFxcTGVmdGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbHJhcnJcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsckFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXExyYXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTXVcIiwgXCJcXFxcbWF0aHJte019XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmF0bnVtc1wiLCBcIlxcXFxtYXRoYmJ7Tn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxOdVwiLCBcIlxcXFxtYXRocm17Tn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxPbWljcm9uXCIsIFwiXFxcXG1hdGhybXtPfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBsdXNtblwiLCBcIlxcXFxwbVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJhcnJcIiwgXCJcXFxccmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJBcnJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJhcnJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlYWxcIiwgXCJcXFxcUmVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWFsc1wiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSZWFsc1wiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSaG9cIiwgXCJcXFxcbWF0aHJte1B9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2RvdFwiLCBcIlxcXFxjZG90XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2VjdFwiLCBcIlxcXFxTXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3BhZGVzXCIsIFwiXFxcXHNwYWRlc3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHN1YlwiLCBcIlxcXFxzdWJzZXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzdWJlXCIsIFwiXFxcXHN1YnNldGVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3VwZVwiLCBcIlxcXFxzdXBzZXRlcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFRhdVwiLCBcIlxcXFxtYXRocm17VH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0aGV0YXN5bVwiLCBcIlxcXFx2YXJ0aGV0YVwiKTsgLy8gVE9ETzogZGVmaW5lTWFjcm8oXCJcXFxcdmFyY29wcGFcIiwgXCJcXFxcXFxtYm94e1xcXFxjb3BwYX1cIik7XG5cbmRlZmluZU1hY3JvKFwiXFxcXHdlaWVycFwiLCBcIlxcXFx3cFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFpldGFcIiwgXCJcXFxcbWF0aHJte1p9XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBzdGF0bWF0aC5zdHlcbi8vIGh0dHBzOi8vY3Rhbi5tYXRoLmlsbGlub2lzLmVkdS9tYWNyb3MvbGF0ZXgvY29udHJpYi9zdGF0bWF0aC9zdGF0bWF0aC5wZGZcblxuZGVmaW5lTWFjcm8oXCJcXFxcYXJnbWluXCIsIFwiXFxcXERPVFNCXFxcXG1hdGhvcHtcXFxcb3BlcmF0b3JuYW1le2FyZ1xcXFwsbWlufX1cXFxcbGltaXRzXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYXJnbWF4XCIsIFwiXFxcXERPVFNCXFxcXG1hdGhvcHtcXFxcb3BlcmF0b3JuYW1le2FyZ1xcXFwsbWF4fX1cXFxcbGltaXRzXCIpOyAvLyBDdXN0b20gS2hhbiBBY2FkZW15IGNvbG9ycywgc2hvdWxkIGJlIG1vdmVkIHRvIGFuIG9wdGlvbmFsIHBhY2thZ2VcblxuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM2NDk1ZWR9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG9yYW5nZVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZmE1MDB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBpbmtcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmYwMGFmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWRcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZGYwMDMwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlblwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMyOGFlN2J9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlcIiwgXCJcXFxcdGV4dGNvbG9ye2dyYXl9eyMjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdXJwbGVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjOWQzOGJkfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxibHVlQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNjY2ZhZmZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJsdWVCXCIsIFwiXFxcXHRleHRjb2xvcnsjIzgwZjZmZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZUNcIiwgXCJcXFxcdGV4dGNvbG9yeyMjNjNkOWVhfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxibHVlRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMxMWFjY2R9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJsdWVFXCIsIFwiXFxcXHRleHRjb2xvcnsjIzBjN2Y5OX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGVhbEFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjOTRmZmY1fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0ZWFsQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMyNmVkZDV9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRlYWxDXCIsIFwiXFxcXHRleHRjb2xvcnsjIzAxZDFjMX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGVhbERcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMDFhOTk1fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0ZWFsRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMyMDgxNzB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyZWVuQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNiNmZmYjB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyZWVuQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM4YWYyODF9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyZWVuQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyM3NGNmNzB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyZWVuRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMxZmFiNTR9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyZWVuRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMwZDkyM2Z9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdvbGRBXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmZDBhOX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ29sZEJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmZiYjcxfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxnb2xkQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZjljMzl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdvbGREXCIsIFwiXFxcXHRleHRjb2xvcnsjI2UwN2QxMH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ29sZEVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjYTc1YTA1fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWRBXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZjYTlhOX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVkQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZjg0ODJ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlZENcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZjk2ODVkfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWREXCIsIFwiXFxcXHRleHRjb2xvcnsjI2U4NGQzOX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVkRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNiYzI2MTJ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1hcm9vbkFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmZiZGUwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXJvb25CXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmOTJjNn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWFyb29uQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNlZDVmYTZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1hcm9vbkRcIiwgXCJcXFxcdGV4dGNvbG9yeyMjY2EzMzdjfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXJvb25FXCIsIFwiXFxcXHRleHRjb2xvcnsjIzllMDM0ZX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHVycGxlQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNkZGQ3ZmZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB1cnBsZUJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjYzZiOWZjfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdXJwbGVDXCIsIFwiXFxcXHRleHRjb2xvcnsjI2FhODdmZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHVycGxlRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM3ODU0YWJ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB1cnBsZUVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjNTQzYjc4fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW50QVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmNWY5ZTh9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1pbnRCXCIsIFwiXFxcXHRleHRjb2xvcnsjI2VkZjJkZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWludENcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZTBlNWNjfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5QVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmNmY3Zjd9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlCXCIsIFwiXFxcXHRleHRjb2xvcnsjI2YwZjFmMn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUNcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZTNlNWU2fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5RFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNkNmQ4ZGF9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlFXCIsIFwiXFxcXHRleHRjb2xvcnsjI2JhYmVjMn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUZcIiwgXCJcXFxcdGV4dGNvbG9yeyMjODg4ZDkzfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5R1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyM2MjY1Njl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlIXCIsIFwiXFxcXHRleHRjb2xvcnsjIzNiM2U0MH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUlcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMjEyNDJjfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxrYUJsdWVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMzE0NDUzfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxrYUdyZWVuXCIsIFwiXFxcXHRleHRjb2xvcnsjIzcxQjMwN317IzF9XCIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvTWFjcm9FeHBhbmRlci5qc1xuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIOKAnGd1bGxldOKAnSB3aGVyZSBtYWNyb3MgYXJlIGV4cGFuZGVkXG4gKiB1bnRpbCBvbmx5IG5vbi1tYWNybyB0b2tlbnMgcmVtYWluLlxuICovXG5cblxuXG5cblxuXG5cbi8vIExpc3Qgb2YgY29tbWFuZHMgdGhhdCBhY3QgbGlrZSBtYWNyb3MgYnV0IGFyZW4ndCBkZWZpbmVkIGFzIGEgbWFjcm8sXG4vLyBmdW5jdGlvbiwgb3Igc3ltYm9sLiAgVXNlZCBpbiBgaXNEZWZpbmVkYC5cbnZhciBpbXBsaWNpdENvbW1hbmRzID0ge1xuICBcIlxcXFxyZWxheFwiOiB0cnVlLFxuICAvLyBNYWNyb0V4cGFuZGVyLmpzXG4gIFwiXlwiOiB0cnVlLFxuICAvLyBQYXJzZXIuanNcbiAgXCJfXCI6IHRydWUsXG4gIC8vIFBhcnNlci5qc1xuICBcIlxcXFxsaW1pdHNcIjogdHJ1ZSxcbiAgLy8gUGFyc2VyLmpzXG4gIFwiXFxcXG5vbGltaXRzXCI6IHRydWUgLy8gUGFyc2VyLmpzXG5cbn07XG5cbnZhciBNYWNyb0V4cGFuZGVyX01hY3JvRXhwYW5kZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYWNyb0V4cGFuZGVyKGlucHV0LCBzZXR0aW5ncywgbW9kZSkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy5leHBhbnNpb25Db3VudCA9IHZvaWQgMDtcbiAgICB0aGlzLmxleGVyID0gdm9pZCAwO1xuICAgIHRoaXMubWFjcm9zID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5tb2RlID0gdm9pZCAwO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmV4cGFuc2lvbkNvdW50ID0gMDtcbiAgICB0aGlzLmZlZWQoaW5wdXQpOyAvLyBNYWtlIG5ldyBnbG9iYWwgbmFtZXNwYWNlXG5cbiAgICB0aGlzLm1hY3JvcyA9IG5ldyBOYW1lc3BhY2VfTmFtZXNwYWNlKG1hY3Jvcywgc2V0dGluZ3MubWFjcm9zKTtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMuc3RhY2sgPSBbXTsgLy8gY29udGFpbnMgdG9rZW5zIGluIFJFVkVSU0Ugb3JkZXJcbiAgfVxuICAvKipcbiAgICogRmVlZCBhIG5ldyBpbnB1dCBzdHJpbmcgdG8gdGhlIHNhbWUgTWFjcm9FeHBhbmRlclxuICAgKiAod2l0aCBleGlzdGluZyBtYWNyb3MgZXRjLikuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IE1hY3JvRXhwYW5kZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5mZWVkID0gZnVuY3Rpb24gZmVlZChpbnB1dCkge1xuICAgIHRoaXMubGV4ZXIgPSBuZXcgTGV4ZXJfTGV4ZXIoaW5wdXQsIHRoaXMuc2V0dGluZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBiZXR3ZWVuIFwidGV4dFwiIGFuZCBcIm1hdGhcIiBtb2Rlcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uc3dpdGNoTW9kZSA9IGZ1bmN0aW9uIHN3aXRjaE1vZGUobmV3TW9kZSkge1xuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IGEgbmV3IGdyb3VwIG5lc3Rpbmcgd2l0aGluIGFsbCBuYW1lc3BhY2VzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5iZWdpbkdyb3VwID0gZnVuY3Rpb24gYmVnaW5Hcm91cCgpIHtcbiAgICB0aGlzLm1hY3Jvcy5iZWdpbkdyb3VwKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuZCBjdXJyZW50IGdyb3VwIG5lc3Rpbmcgd2l0aGluIGFsbCBuYW1lc3BhY2VzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5lbmRHcm91cCA9IGZ1bmN0aW9uIGVuZEdyb3VwKCkge1xuICAgIHRoaXMubWFjcm9zLmVuZEdyb3VwKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvcG1vc3QgdG9rZW4gb24gdGhlIHN0YWNrLCB3aXRob3V0IGV4cGFuZGluZyBpdC5cbiAgICogU2ltaWxhciBpbiBiZWhhdmlvciB0byBUZVgncyBgXFxmdXR1cmVsZXRgLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5mdXR1cmUgPSBmdW5jdGlvbiBmdXR1cmUoKSB7XG4gICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnB1c2hUb2tlbih0aGlzLmxleGVyLmxleCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYW5kIHJldHVybiB0aGUgbmV4dCB1bmV4cGFuZGVkIHRva2VuLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wb3BUb2tlbiA9IGZ1bmN0aW9uIHBvcFRva2VuKCkge1xuICAgIHRoaXMuZnV0dXJlKCk7IC8vIGVuc3VyZSBub24tZW1wdHkgc3RhY2tcblxuICAgIHJldHVybiB0aGlzLnN0YWNrLnBvcCgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBnaXZlbiB0b2tlbiB0byB0aGUgdG9rZW4gc3RhY2suICBJbiBwYXJ0aWN1bGFyLCB0aGlzIGdldCBiZSB1c2VkXG4gICAqIHRvIHB1dCBiYWNrIGEgdG9rZW4gcmV0dXJuZWQgZnJvbSBvbmUgb2YgdGhlIG90aGVyIG1ldGhvZHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnB1c2hUb2tlbiA9IGZ1bmN0aW9uIHB1c2hUb2tlbih0b2tlbikge1xuICAgIHRoaXMuc3RhY2sucHVzaCh0b2tlbik7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZCBhbiBhcnJheSBvZiB0b2tlbnMgdG8gdGhlIHRva2VuIHN0YWNrLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wdXNoVG9rZW5zID0gZnVuY3Rpb24gcHVzaFRva2Vucyh0b2tlbnMpIHtcbiAgICB2YXIgX3RoaXMkc3RhY2s7XG5cbiAgICAoX3RoaXMkc3RhY2sgPSB0aGlzLnN0YWNrKS5wdXNoLmFwcGx5KF90aGlzJHN0YWNrLCB0b2tlbnMpO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdW1lIGFsbCBmb2xsb3dpbmcgc3BhY2UgdG9rZW5zLCB3aXRob3V0IGV4cGFuc2lvbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY29uc3VtZVNwYWNlcyA9IGZ1bmN0aW9uIGNvbnN1bWVTcGFjZXMoKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIHRva2VuID0gdGhpcy5mdXR1cmUoKTtcblxuICAgICAgaWYgKHRva2VuLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnN1bWUgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYXJndW1lbnRzIGZyb20gdGhlIHRva2VuIHN0cmVhbSxcbiAgICogYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY29uc3VtZUFyZ3MgPSBmdW5jdGlvbiBjb25zdW1lQXJncyhudW1BcmdzKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTsgLy8gb2J0YWluIGFyZ3VtZW50cywgZWl0aGVyIHNpbmdsZSB0b2tlbiBvciBiYWxhbmNlZCB74oCmfSBncm91cFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1BcmdzOyArK2kpIHtcbiAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpOyAvLyBpZ25vcmUgc3BhY2VzIGJlZm9yZSBlYWNoIGFyZ3VtZW50XG5cbiAgICAgIHZhciBzdGFydE9mQXJnID0gdGhpcy5wb3BUb2tlbigpO1xuXG4gICAgICBpZiAoc3RhcnRPZkFyZy50ZXh0ID09PSBcIntcIikge1xuICAgICAgICB2YXIgYXJnID0gW107XG4gICAgICAgIHZhciBkZXB0aCA9IDE7XG5cbiAgICAgICAgd2hpbGUgKGRlcHRoICE9PSAwKSB7XG4gICAgICAgICAgdmFyIHRvayA9IHRoaXMucG9wVG9rZW4oKTtcbiAgICAgICAgICBhcmcucHVzaCh0b2spO1xuXG4gICAgICAgICAgaWYgKHRvay50ZXh0ID09PSBcIntcIikge1xuICAgICAgICAgICAgKytkZXB0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSBcIn1cIikge1xuICAgICAgICAgICAgLS1kZXB0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSBcIkVPRlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJFbmQgb2YgaW5wdXQgaW4gbWFjcm8gYXJndW1lbnRcIiwgc3RhcnRPZkFyZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJnLnBvcCgpOyAvLyByZW1vdmUgbGFzdCB9XG5cbiAgICAgICAgYXJnLnJldmVyc2UoKTsgLy8gbGlrZSBhYm92ZSwgdG8gZml0IGluIHdpdGggc3RhY2sgb3JkZXJcblxuICAgICAgICBhcmdzW2ldID0gYXJnO1xuICAgICAgfSBlbHNlIGlmIChzdGFydE9mQXJnLnRleHQgPT09IFwiRU9GXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRW5kIG9mIGlucHV0IGV4cGVjdGluZyBtYWNybyBhcmd1bWVudFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3NbaV0gPSBbc3RhcnRPZkFyZ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cbiAgLyoqXG4gICAqIEV4cGFuZCB0aGUgbmV4dCB0b2tlbiBvbmx5IG9uY2UgaWYgcG9zc2libGUuXG4gICAqXG4gICAqIElmIHRoZSB0b2tlbiBpcyBleHBhbmRlZCwgdGhlIHJlc3VsdGluZyB0b2tlbnMgd2lsbCBiZSBwdXNoZWQgb250b1xuICAgKiB0aGUgc3RhY2sgaW4gcmV2ZXJzZSBvcmRlciBhbmQgd2lsbCBiZSByZXR1cm5lZCBhcyBhbiBhcnJheSxcbiAgICogYWxzbyBpbiByZXZlcnNlIG9yZGVyLlxuICAgKlxuICAgKiBJZiBub3QsIHRoZSBuZXh0IHRva2VuIHdpbGwgYmUgcmV0dXJuZWQgd2l0aG91dCByZW1vdmluZyBpdFxuICAgKiBmcm9tIHRoZSBzdGFjay4gIFRoaXMgY2FzZSBjYW4gYmUgZGV0ZWN0ZWQgYnkgYSBgVG9rZW5gIHJldHVybiB2YWx1ZVxuICAgKiBpbnN0ZWFkIG9mIGFuIGBBcnJheWAgcmV0dXJuIHZhbHVlLlxuICAgKlxuICAgKiBJbiBlaXRoZXIgY2FzZSwgdGhlIG5leHQgdG9rZW4gd2lsbCBiZSBvbiB0aGUgdG9wIG9mIHRoZSBzdGFjayxcbiAgICogb3IgdGhlIHN0YWNrIHdpbGwgYmUgZW1wdHkuXG4gICAqXG4gICAqIFVzZWQgdG8gaW1wbGVtZW50IGBleHBhbmRBZnRlckZ1dHVyZWAgYW5kIGBleHBhbmROZXh0VG9rZW5gLlxuICAgKlxuICAgKiBBdCB0aGUgbW9tZW50LCBtYWNybyBleHBhbnNpb24gZG9lc24ndCBoYW5kbGUgZGVsaW1pdGVkIG1hY3JvcyxcbiAgICogaS5lLiB0aGluZ3MgbGlrZSB0aG9zZSBkZWZpbmVkIGJ5IFxcZGVmXFxmb28jMVxcZW5ke+KApn0uXG4gICAqIFNlZSB0aGUgVGVYIGJvb2sgcGFnZSAyMDJmZi4gZm9yIGRldGFpbHMgb24gaG93IHRob3NlIHNob3VsZCBiZWhhdmUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmV4cGFuZE9uY2UgPSBmdW5jdGlvbiBleHBhbmRPbmNlKCkge1xuICAgIHZhciB0b3BUb2tlbiA9IHRoaXMucG9wVG9rZW4oKTtcbiAgICB2YXIgbmFtZSA9IHRvcFRva2VuLnRleHQ7XG5cbiAgICB2YXIgZXhwYW5zaW9uID0gdGhpcy5fZ2V0RXhwYW5zaW9uKG5hbWUpO1xuXG4gICAgaWYgKGV4cGFuc2lvbiA9PSBudWxsKSB7XG4gICAgICAvLyBtYWlubHkgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZCBoZXJlXG4gICAgICAvLyBGdWxseSBleHBhbmRlZFxuICAgICAgdGhpcy5wdXNoVG9rZW4odG9wVG9rZW4pO1xuICAgICAgcmV0dXJuIHRvcFRva2VuO1xuICAgIH1cblxuICAgIHRoaXMuZXhwYW5zaW9uQ291bnQrKztcblxuICAgIGlmICh0aGlzLmV4cGFuc2lvbkNvdW50ID4gdGhpcy5zZXR0aW5ncy5tYXhFeHBhbmQpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlRvbyBtYW55IGV4cGFuc2lvbnM6IGluZmluaXRlIGxvb3Agb3IgXCIgKyBcIm5lZWQgdG8gaW5jcmVhc2UgbWF4RXhwYW5kIHNldHRpbmdcIik7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IGV4cGFuc2lvbi50b2tlbnM7XG5cbiAgICBpZiAoZXhwYW5zaW9uLm51bUFyZ3MpIHtcbiAgICAgIHZhciBhcmdzID0gdGhpcy5jb25zdW1lQXJncyhleHBhbnNpb24ubnVtQXJncyk7IC8vIHBhc3RlIGFyZ3VtZW50cyBpbiBwbGFjZSBvZiB0aGUgcGxhY2Vob2xkZXJzXG5cbiAgICAgIHRva2VucyA9IHRva2Vucy5zbGljZSgpOyAvLyBtYWtlIGEgc2hhbGxvdyBjb3B5XG5cbiAgICAgIGZvciAodmFyIGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHRvayA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAodG9rLnRleHQgPT09IFwiI1wiKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkluY29tcGxldGUgcGxhY2Vob2xkZXIgYXQgZW5kIG9mIG1hY3JvIGJvZHlcIiwgdG9rKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2sgPSB0b2tlbnNbLS1pXTsgLy8gbmV4dCB0b2tlbiBvbiBzdGFja1xuXG4gICAgICAgICAgaWYgKHRvay50ZXh0ID09PSBcIiNcIikge1xuICAgICAgICAgICAgLy8gIyMg4oaSICNcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSArIDEsIDEpOyAvLyBkcm9wIGZpcnN0ICNcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eWzEtOV0kLy50ZXN0KHRvay50ZXh0KSkge1xuICAgICAgICAgICAgdmFyIF90b2tlbnM7XG5cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIHdpdGggdGhlIGluZGljYXRlZCBhcmd1bWVudFxuICAgICAgICAgICAgKF90b2tlbnMgPSB0b2tlbnMpLnNwbGljZS5hcHBseShfdG9rZW5zLCBbaSwgMl0uY29uY2F0KGFyZ3NbK3Rvay50ZXh0IC0gMV0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiTm90IGEgdmFsaWQgYXJndW1lbnQgbnVtYmVyXCIsIHRvayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBDb25jYXRlbmF0ZSBleHBhbnNpb24gb250byB0b3Agb2Ygc3RhY2suXG5cblxuICAgIHRoaXMucHVzaFRva2Vucyh0b2tlbnMpO1xuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cbiAgLyoqXG4gICAqIEV4cGFuZCB0aGUgbmV4dCB0b2tlbiBvbmx5IG9uY2UgKGlmIHBvc3NpYmxlKSwgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nXG4gICAqIHRvcCB0b2tlbiBvbiB0aGUgc3RhY2sgKHdpdGhvdXQgcmVtb3ZpbmcgYW55dGhpbmcgZnJvbSB0aGUgc3RhY2spLlxuICAgKiBTaW1pbGFyIGluIGJlaGF2aW9yIHRvIFRlWCdzIGBcXGV4cGFuZGFmdGVyXFxmdXR1cmVsZXRgLlxuICAgKiBFcXVpdmFsZW50IHRvIGV4cGFuZE9uY2UoKSBmb2xsb3dlZCBieSBmdXR1cmUoKS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZXhwYW5kQWZ0ZXJGdXR1cmUgPSBmdW5jdGlvbiBleHBhbmRBZnRlckZ1dHVyZSgpIHtcbiAgICB0aGlzLmV4cGFuZE9uY2UoKTtcbiAgICByZXR1cm4gdGhpcy5mdXR1cmUoKTtcbiAgfVxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgZXhwYW5kIGZpcnN0IHRva2VuLCB0aGVuIHJldHVybiBmaXJzdCBub24tZXhwYW5kYWJsZSB0b2tlbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZXhwYW5kTmV4dFRva2VuID0gZnVuY3Rpb24gZXhwYW5kTmV4dFRva2VuKCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBleHBhbmRlZCA9IHRoaXMuZXhwYW5kT25jZSgpOyAvLyBleHBhbmRPbmNlIHJldHVybnMgVG9rZW4gaWYgYW5kIG9ubHkgaWYgaXQncyBmdWxseSBleHBhbmRlZC5cblxuICAgICAgaWYgKGV4cGFuZGVkIGluc3RhbmNlb2YgVG9rZW5fVG9rZW4pIHtcbiAgICAgICAgLy8gXFxyZWxheCBzdG9wcyB0aGUgZXhwYW5zaW9uLCBidXQgc2hvdWxkbid0IGdldCByZXR1cm5lZCAoYVxuICAgICAgICAvLyBudWxsIHJldHVybiB2YWx1ZSBjb3VsZG4ndCBnZXQgaW1wbGVtZW50ZWQgYXMgYSBmdW5jdGlvbikuXG4gICAgICAgIGlmIChleHBhbmRlZC50ZXh0ID09PSBcIlxcXFxyZWxheFwiKSB7XG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdGFjay5wb3AoKTsgLy8gPT09IGV4cGFuZGVkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEZsb3cgdW5hYmxlIHRvIGZpZ3VyZSBvdXQgdGhhdCB0aGlzIHBhdGh3YXkgaXMgaW1wb3NzaWJsZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNDgwOFxuXG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnJlYWNoYWJsZVxuICB9XG4gIC8qKlxuICAgKiBGdWxseSBleHBhbmQgdGhlIGdpdmVuIG1hY3JvIG5hbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGxpc3Qgb2ZcbiAgICogdG9rZW5zLCBvciByZXR1cm4gYHVuZGVmaW5lZGAgaWYgbm8gc3VjaCBtYWNybyBpcyBkZWZpbmVkLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5leHBhbmRNYWNybyA9IGZ1bmN0aW9uIGV4cGFuZE1hY3JvKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMubWFjcm9zLmdldChuYW1lKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIG9sZFN0YWNrTGVuZ3RoID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgdGhpcy5wdXNoVG9rZW4obmV3IFRva2VuX1Rva2VuKG5hbWUpKTtcblxuICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IG9sZFN0YWNrTGVuZ3RoKSB7XG4gICAgICB2YXIgZXhwYW5kZWQgPSB0aGlzLmV4cGFuZE9uY2UoKTsgLy8gZXhwYW5kT25jZSByZXR1cm5zIFRva2VuIGlmIGFuZCBvbmx5IGlmIGl0J3MgZnVsbHkgZXhwYW5kZWQuXG5cbiAgICAgIGlmIChleHBhbmRlZCBpbnN0YW5jZW9mIFRva2VuX1Rva2VuKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEZ1bGx5IGV4cGFuZCB0aGUgZ2l2ZW4gbWFjcm8gbmFtZSBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBzdHJpbmcsXG4gICAqIG9yIHJldHVybiBgdW5kZWZpbmVkYCBpZiBubyBzdWNoIG1hY3JvIGlzIGRlZmluZWQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmV4cGFuZE1hY3JvQXNUZXh0ID0gZnVuY3Rpb24gZXhwYW5kTWFjcm9Bc1RleHQobmFtZSkge1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLmV4cGFuZE1hY3JvKG5hbWUpO1xuXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgcmV0dXJuIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi50ZXh0O1xuICAgICAgfSkuam9pbihcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV4cGFuZGVkIG1hY3JvIGFzIGEgcmV2ZXJzZWQgYXJyYXkgb2YgdG9rZW5zIGFuZCBhIG1hY3JvXG4gICAqIGFyZ3VtZW50IGNvdW50LiAgT3IgcmV0dXJucyBgbnVsbGAgaWYgbm8gc3VjaCBtYWNyby5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uX2dldEV4cGFuc2lvbiA9IGZ1bmN0aW9uIF9nZXRFeHBhbnNpb24obmFtZSkge1xuICAgIHZhciBkZWZpbml0aW9uID0gdGhpcy5tYWNyb3MuZ2V0KG5hbWUpO1xuXG4gICAgaWYgKGRlZmluaXRpb24gPT0gbnVsbCkge1xuICAgICAgLy8gbWFpbmx5IGNoZWNraW5nIGZvciB1bmRlZmluZWQgaGVyZVxuICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuXG4gICAgdmFyIGV4cGFuc2lvbiA9IHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBkZWZpbml0aW9uKHRoaXMpIDogZGVmaW5pdGlvbjtcblxuICAgIGlmICh0eXBlb2YgZXhwYW5zaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YXIgbnVtQXJncyA9IDA7XG5cbiAgICAgIGlmIChleHBhbnNpb24uaW5kZXhPZihcIiNcIikgIT09IC0xKSB7XG4gICAgICAgIHZhciBzdHJpcHBlZCA9IGV4cGFuc2lvbi5yZXBsYWNlKC8jIy9nLCBcIlwiKTtcblxuICAgICAgICB3aGlsZSAoc3RyaXBwZWQuaW5kZXhPZihcIiNcIiArIChudW1BcmdzICsgMSkpICE9PSAtMSkge1xuICAgICAgICAgICsrbnVtQXJncztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYm9keUxleGVyID0gbmV3IExleGVyX0xleGVyKGV4cGFuc2lvbiwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICB2YXIgdG9rID0gYm9keUxleGVyLmxleCgpO1xuXG4gICAgICB3aGlsZSAodG9rLnRleHQgIT09IFwiRU9GXCIpIHtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rKTtcbiAgICAgICAgdG9rID0gYm9keUxleGVyLmxleCgpO1xuICAgICAgfVxuXG4gICAgICB0b2tlbnMucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayB1c2luZyBwdXNoIGFuZCBwb3BcblxuICAgICAgdmFyIGV4cGFuZGVkID0ge1xuICAgICAgICB0b2tlbnM6IHRva2VucyxcbiAgICAgICAgbnVtQXJnczogbnVtQXJnc1xuICAgICAgfTtcbiAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwYW5zaW9uO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIGNvbW1hbmQgaXMgY3VycmVudGx5IFwiZGVmaW5lZFwiIChoYXMgc29tZVxuICAgKiBmdW5jdGlvbmFsaXR5KSwgbWVhbmluZyB0aGF0IGl0J3MgYSBtYWNybyAoaW4gdGhlIGN1cnJlbnQgZ3JvdXApLFxuICAgKiBhIGZ1bmN0aW9uLCBhIHN5bWJvbCwgb3Igb25lIG9mIHRoZSBzcGVjaWFsIGNvbW1hbmRzIGxpc3RlZCBpblxuICAgKiBgaW1wbGljaXRDb21tYW5kc2AuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmlzRGVmaW5lZCA9IGZ1bmN0aW9uIGlzRGVmaW5lZChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFjcm9zLmhhcyhuYW1lKSB8fCBzcmNfZnVuY3Rpb25zLmhhc093blByb3BlcnR5KG5hbWUpIHx8IHNyY19zeW1ib2xzLm1hdGguaGFzT3duUHJvcGVydHkobmFtZSkgfHwgc3JjX3N5bWJvbHMudGV4dC5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBpbXBsaWNpdENvbW1hbmRzLmhhc093blByb3BlcnR5KG5hbWUpO1xuICB9O1xuXG4gIHJldHVybiBNYWNyb0V4cGFuZGVyO1xufSgpO1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3VuaWNvZGVBY2NlbnRzLmpzXG4vLyBNYXBwaW5nIG9mIFVuaWNvZGUgYWNjZW50IGNoYXJhY3RlcnMgdG8gdGhlaXIgTGFUZVggZXF1aXZhbGVudCBpbiB0ZXh0IGFuZFxuLy8gbWF0aCBtb2RlICh3aGVuIHRoZXkgZXhpc3QpLlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdW5pY29kZUFjY2VudHMgPSAoe1xuICBcIlxcdTAzMDFcIjoge1xuICAgIHRleHQ6IFwiXFxcXCdcIixcbiAgICBtYXRoOiAnXFxcXGFjdXRlJ1xuICB9LFxuICBcIlxcdTAzMDBcIjoge1xuICAgIHRleHQ6ICdcXFxcYCcsXG4gICAgbWF0aDogJ1xcXFxncmF2ZSdcbiAgfSxcbiAgXCJcXHUwMzA4XCI6IHtcbiAgICB0ZXh0OiAnXFxcXFwiJyxcbiAgICBtYXRoOiAnXFxcXGRkb3QnXG4gIH0sXG4gIFwiXFx1MDMwM1wiOiB7XG4gICAgdGV4dDogJ1xcXFx+JyxcbiAgICBtYXRoOiAnXFxcXHRpbGRlJ1xuICB9LFxuICBcIlxcdTAzMDRcIjoge1xuICAgIHRleHQ6ICdcXFxcPScsXG4gICAgbWF0aDogJ1xcXFxiYXInXG4gIH0sXG4gIFwiXFx1MDMwNlwiOiB7XG4gICAgdGV4dDogXCJcXFxcdVwiLFxuICAgIG1hdGg6ICdcXFxcYnJldmUnXG4gIH0sXG4gIFwiXFx1MDMwQ1wiOiB7XG4gICAgdGV4dDogJ1xcXFx2JyxcbiAgICBtYXRoOiAnXFxcXGNoZWNrJ1xuICB9LFxuICBcIlxcdTAzMDJcIjoge1xuICAgIHRleHQ6ICdcXFxcXicsXG4gICAgbWF0aDogJ1xcXFxoYXQnXG4gIH0sXG4gIFwiXFx1MDMwN1wiOiB7XG4gICAgdGV4dDogJ1xcXFwuJyxcbiAgICBtYXRoOiAnXFxcXGRvdCdcbiAgfSxcbiAgXCJcXHUwMzBBXCI6IHtcbiAgICB0ZXh0OiAnXFxcXHInLFxuICAgIG1hdGg6ICdcXFxcbWF0aHJpbmcnXG4gIH0sXG4gIFwiXFx1MDMwQlwiOiB7XG4gICAgdGV4dDogJ1xcXFxIJ1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3VuaWNvZGVTeW1ib2xzLmpzXG4vLyBUaGlzIGZpbGUgaXMgR0VORVJBVEVEIGJ5IHVuaWNvZGVNYWtlLmpzLiBETyBOT1QgTU9ESUZZLlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdW5pY29kZVN5bWJvbHMgPSAoe1xuICBcIlxceEUxXCI6IFwiYVxcdTAzMDFcIixcbiAgLy8gw6EgPSBcXCd7YX1cbiAgXCJcXHhFMFwiOiBcImFcXHUwMzAwXCIsXG4gIC8vIMOgID0gXFxge2F9XG4gIFwiXFx4RTRcIjogXCJhXFx1MDMwOFwiLFxuICAvLyDDpCA9IFxcXCJ7YX1cbiAgXCJcXHUwMURGXCI6IFwiYVxcdTAzMDhcXHUwMzA0XCIsXG4gIC8vIMefID0gXFxcIlxcPXthfVxuICBcIlxceEUzXCI6IFwiYVxcdTAzMDNcIixcbiAgLy8gw6MgPSBcXH57YX1cbiAgXCJcXHUwMTAxXCI6IFwiYVxcdTAzMDRcIixcbiAgLy8gxIEgPSBcXD17YX1cbiAgXCJcXHUwMTAzXCI6IFwiYVxcdTAzMDZcIixcbiAgLy8gxIMgPSBcXHV7YX1cbiAgXCJcXHUxRUFGXCI6IFwiYVxcdTAzMDZcXHUwMzAxXCIsXG4gIC8vIOG6ryA9IFxcdVxcJ3thfVxuICBcIlxcdTFFQjFcIjogXCJhXFx1MDMwNlxcdTAzMDBcIixcbiAgLy8g4bqxID0gXFx1XFxge2F9XG4gIFwiXFx1MUVCNVwiOiBcImFcXHUwMzA2XFx1MDMwM1wiLFxuICAvLyDhurUgPSBcXHVcXH57YX1cbiAgXCJcXHUwMUNFXCI6IFwiYVxcdTAzMENcIixcbiAgLy8gx44gPSBcXHZ7YX1cbiAgXCJcXHhFMlwiOiBcImFcXHUwMzAyXCIsXG4gIC8vIMOiID0gXFxee2F9XG4gIFwiXFx1MUVBNVwiOiBcImFcXHUwMzAyXFx1MDMwMVwiLFxuICAvLyDhuqUgPSBcXF5cXCd7YX1cbiAgXCJcXHUxRUE3XCI6IFwiYVxcdTAzMDJcXHUwMzAwXCIsXG4gIC8vIOG6pyA9IFxcXlxcYHthfVxuICBcIlxcdTFFQUJcIjogXCJhXFx1MDMwMlxcdTAzMDNcIixcbiAgLy8g4bqrID0gXFxeXFx+e2F9XG4gIFwiXFx1MDIyN1wiOiBcImFcXHUwMzA3XCIsXG4gIC8vIMinID0gXFwue2F9XG4gIFwiXFx1MDFFMVwiOiBcImFcXHUwMzA3XFx1MDMwNFwiLFxuICAvLyDHoSA9IFxcLlxcPXthfVxuICBcIlxceEU1XCI6IFwiYVxcdTAzMEFcIixcbiAgLy8gw6UgPSBcXHJ7YX1cbiAgXCJcXHUwMUZCXCI6IFwiYVxcdTAzMEFcXHUwMzAxXCIsXG4gIC8vIMe7ID0gXFxyXFwne2F9XG4gIFwiXFx1MUUwM1wiOiBcImJcXHUwMzA3XCIsXG4gIC8vIOG4gyA9IFxcLntifVxuICBcIlxcdTAxMDdcIjogXCJjXFx1MDMwMVwiLFxuICAvLyDEhyA9IFxcJ3tjfVxuICBcIlxcdTAxMERcIjogXCJjXFx1MDMwQ1wiLFxuICAvLyDEjSA9IFxcdntjfVxuICBcIlxcdTAxMDlcIjogXCJjXFx1MDMwMlwiLFxuICAvLyDEiSA9IFxcXntjfVxuICBcIlxcdTAxMEJcIjogXCJjXFx1MDMwN1wiLFxuICAvLyDEiyA9IFxcLntjfVxuICBcIlxcdTAxMEZcIjogXCJkXFx1MDMwQ1wiLFxuICAvLyDEjyA9IFxcdntkfVxuICBcIlxcdTFFMEJcIjogXCJkXFx1MDMwN1wiLFxuICAvLyDhuIsgPSBcXC57ZH1cbiAgXCJcXHhFOVwiOiBcImVcXHUwMzAxXCIsXG4gIC8vIMOpID0gXFwne2V9XG4gIFwiXFx4RThcIjogXCJlXFx1MDMwMFwiLFxuICAvLyDDqCA9IFxcYHtlfVxuICBcIlxceEVCXCI6IFwiZVxcdTAzMDhcIixcbiAgLy8gw6sgPSBcXFwie2V9XG4gIFwiXFx1MUVCRFwiOiBcImVcXHUwMzAzXCIsXG4gIC8vIOG6vSA9IFxcfntlfVxuICBcIlxcdTAxMTNcIjogXCJlXFx1MDMwNFwiLFxuICAvLyDEkyA9IFxcPXtlfVxuICBcIlxcdTFFMTdcIjogXCJlXFx1MDMwNFxcdTAzMDFcIixcbiAgLy8g4biXID0gXFw9XFwne2V9XG4gIFwiXFx1MUUxNVwiOiBcImVcXHUwMzA0XFx1MDMwMFwiLFxuICAvLyDhuJUgPSBcXD1cXGB7ZX1cbiAgXCJcXHUwMTE1XCI6IFwiZVxcdTAzMDZcIixcbiAgLy8gxJUgPSBcXHV7ZX1cbiAgXCJcXHUwMTFCXCI6IFwiZVxcdTAzMENcIixcbiAgLy8gxJsgPSBcXHZ7ZX1cbiAgXCJcXHhFQVwiOiBcImVcXHUwMzAyXCIsXG4gIC8vIMOqID0gXFxee2V9XG4gIFwiXFx1MUVCRlwiOiBcImVcXHUwMzAyXFx1MDMwMVwiLFxuICAvLyDhur8gPSBcXF5cXCd7ZX1cbiAgXCJcXHUxRUMxXCI6IFwiZVxcdTAzMDJcXHUwMzAwXCIsXG4gIC8vIOG7gSA9IFxcXlxcYHtlfVxuICBcIlxcdTFFQzVcIjogXCJlXFx1MDMwMlxcdTAzMDNcIixcbiAgLy8g4buFID0gXFxeXFx+e2V9XG4gIFwiXFx1MDExN1wiOiBcImVcXHUwMzA3XCIsXG4gIC8vIMSXID0gXFwue2V9XG4gIFwiXFx1MUUxRlwiOiBcImZcXHUwMzA3XCIsXG4gIC8vIOG4nyA9IFxcLntmfVxuICBcIlxcdTAxRjVcIjogXCJnXFx1MDMwMVwiLFxuICAvLyDHtSA9IFxcJ3tnfVxuICBcIlxcdTFFMjFcIjogXCJnXFx1MDMwNFwiLFxuICAvLyDhuKEgPSBcXD17Z31cbiAgXCJcXHUwMTFGXCI6IFwiZ1xcdTAzMDZcIixcbiAgLy8gxJ8gPSBcXHV7Z31cbiAgXCJcXHUwMUU3XCI6IFwiZ1xcdTAzMENcIixcbiAgLy8gx6cgPSBcXHZ7Z31cbiAgXCJcXHUwMTFEXCI6IFwiZ1xcdTAzMDJcIixcbiAgLy8gxJ0gPSBcXF57Z31cbiAgXCJcXHUwMTIxXCI6IFwiZ1xcdTAzMDdcIixcbiAgLy8gxKEgPSBcXC57Z31cbiAgXCJcXHUxRTI3XCI6IFwiaFxcdTAzMDhcIixcbiAgLy8g4binID0gXFxcIntofVxuICBcIlxcdTAyMUZcIjogXCJoXFx1MDMwQ1wiLFxuICAvLyDInyA9IFxcdntofVxuICBcIlxcdTAxMjVcIjogXCJoXFx1MDMwMlwiLFxuICAvLyDEpSA9IFxcXntofVxuICBcIlxcdTFFMjNcIjogXCJoXFx1MDMwN1wiLFxuICAvLyDhuKMgPSBcXC57aH1cbiAgXCJcXHhFRFwiOiBcImlcXHUwMzAxXCIsXG4gIC8vIMOtID0gXFwne2l9XG4gIFwiXFx4RUNcIjogXCJpXFx1MDMwMFwiLFxuICAvLyDDrCA9IFxcYHtpfVxuICBcIlxceEVGXCI6IFwiaVxcdTAzMDhcIixcbiAgLy8gw68gPSBcXFwie2l9XG4gIFwiXFx1MUUyRlwiOiBcImlcXHUwMzA4XFx1MDMwMVwiLFxuICAvLyDhuK8gPSBcXFwiXFwne2l9XG4gIFwiXFx1MDEyOVwiOiBcImlcXHUwMzAzXCIsXG4gIC8vIMSpID0gXFx+e2l9XG4gIFwiXFx1MDEyQlwiOiBcImlcXHUwMzA0XCIsXG4gIC8vIMSrID0gXFw9e2l9XG4gIFwiXFx1MDEyRFwiOiBcImlcXHUwMzA2XCIsXG4gIC8vIMStID0gXFx1e2l9XG4gIFwiXFx1MDFEMFwiOiBcImlcXHUwMzBDXCIsXG4gIC8vIMeQID0gXFx2e2l9XG4gIFwiXFx4RUVcIjogXCJpXFx1MDMwMlwiLFxuICAvLyDDriA9IFxcXntpfVxuICBcIlxcdTAxRjBcIjogXCJqXFx1MDMwQ1wiLFxuICAvLyDHsCA9IFxcdntqfVxuICBcIlxcdTAxMzVcIjogXCJqXFx1MDMwMlwiLFxuICAvLyDEtSA9IFxcXntqfVxuICBcIlxcdTFFMzFcIjogXCJrXFx1MDMwMVwiLFxuICAvLyDhuLEgPSBcXCd7a31cbiAgXCJcXHUwMUU5XCI6IFwia1xcdTAzMENcIixcbiAgLy8gx6kgPSBcXHZ7a31cbiAgXCJcXHUwMTNBXCI6IFwibFxcdTAzMDFcIixcbiAgLy8gxLogPSBcXCd7bH1cbiAgXCJcXHUwMTNFXCI6IFwibFxcdTAzMENcIixcbiAgLy8gxL4gPSBcXHZ7bH1cbiAgXCJcXHUxRTNGXCI6IFwibVxcdTAzMDFcIixcbiAgLy8g4bi/ID0gXFwne219XG4gIFwiXFx1MUU0MVwiOiBcIm1cXHUwMzA3XCIsXG4gIC8vIOG5gSA9IFxcLnttfVxuICBcIlxcdTAxNDRcIjogXCJuXFx1MDMwMVwiLFxuICAvLyDFhCA9IFxcJ3tufVxuICBcIlxcdTAxRjlcIjogXCJuXFx1MDMwMFwiLFxuICAvLyDHuSA9IFxcYHtufVxuICBcIlxceEYxXCI6IFwiblxcdTAzMDNcIixcbiAgLy8gw7EgPSBcXH57bn1cbiAgXCJcXHUwMTQ4XCI6IFwiblxcdTAzMENcIixcbiAgLy8gxYggPSBcXHZ7bn1cbiAgXCJcXHUxRTQ1XCI6IFwiblxcdTAzMDdcIixcbiAgLy8g4bmFID0gXFwue259XG4gIFwiXFx4RjNcIjogXCJvXFx1MDMwMVwiLFxuICAvLyDDsyA9IFxcJ3tvfVxuICBcIlxceEYyXCI6IFwib1xcdTAzMDBcIixcbiAgLy8gw7IgPSBcXGB7b31cbiAgXCJcXHhGNlwiOiBcIm9cXHUwMzA4XCIsXG4gIC8vIMO2ID0gXFxcIntvfVxuICBcIlxcdTAyMkJcIjogXCJvXFx1MDMwOFxcdTAzMDRcIixcbiAgLy8gyKsgPSBcXFwiXFw9e299XG4gIFwiXFx4RjVcIjogXCJvXFx1MDMwM1wiLFxuICAvLyDDtSA9IFxcfntvfVxuICBcIlxcdTFFNERcIjogXCJvXFx1MDMwM1xcdTAzMDFcIixcbiAgLy8g4bmNID0gXFx+XFwne299XG4gIFwiXFx1MUU0RlwiOiBcIm9cXHUwMzAzXFx1MDMwOFwiLFxuICAvLyDhuY8gPSBcXH5cXFwie299XG4gIFwiXFx1MDIyRFwiOiBcIm9cXHUwMzAzXFx1MDMwNFwiLFxuICAvLyDIrSA9IFxcflxcPXtvfVxuICBcIlxcdTAxNERcIjogXCJvXFx1MDMwNFwiLFxuICAvLyDFjSA9IFxcPXtvfVxuICBcIlxcdTFFNTNcIjogXCJvXFx1MDMwNFxcdTAzMDFcIixcbiAgLy8g4bmTID0gXFw9XFwne299XG4gIFwiXFx1MUU1MVwiOiBcIm9cXHUwMzA0XFx1MDMwMFwiLFxuICAvLyDhuZEgPSBcXD1cXGB7b31cbiAgXCJcXHUwMTRGXCI6IFwib1xcdTAzMDZcIixcbiAgLy8gxY8gPSBcXHV7b31cbiAgXCJcXHUwMUQyXCI6IFwib1xcdTAzMENcIixcbiAgLy8gx5IgPSBcXHZ7b31cbiAgXCJcXHhGNFwiOiBcIm9cXHUwMzAyXCIsXG4gIC8vIMO0ID0gXFxee299XG4gIFwiXFx1MUVEMVwiOiBcIm9cXHUwMzAyXFx1MDMwMVwiLFxuICAvLyDhu5EgPSBcXF5cXCd7b31cbiAgXCJcXHUxRUQzXCI6IFwib1xcdTAzMDJcXHUwMzAwXCIsXG4gIC8vIOG7kyA9IFxcXlxcYHtvfVxuICBcIlxcdTFFRDdcIjogXCJvXFx1MDMwMlxcdTAzMDNcIixcbiAgLy8g4buXID0gXFxeXFx+e299XG4gIFwiXFx1MDIyRlwiOiBcIm9cXHUwMzA3XCIsXG4gIC8vIMivID0gXFwue299XG4gIFwiXFx1MDIzMVwiOiBcIm9cXHUwMzA3XFx1MDMwNFwiLFxuICAvLyDIsSA9IFxcLlxcPXtvfVxuICBcIlxcdTAxNTFcIjogXCJvXFx1MDMwQlwiLFxuICAvLyDFkSA9IFxcSHtvfVxuICBcIlxcdTFFNTVcIjogXCJwXFx1MDMwMVwiLFxuICAvLyDhuZUgPSBcXCd7cH1cbiAgXCJcXHUxRTU3XCI6IFwicFxcdTAzMDdcIixcbiAgLy8g4bmXID0gXFwue3B9XG4gIFwiXFx1MDE1NVwiOiBcInJcXHUwMzAxXCIsXG4gIC8vIMWVID0gXFwne3J9XG4gIFwiXFx1MDE1OVwiOiBcInJcXHUwMzBDXCIsXG4gIC8vIMWZID0gXFx2e3J9XG4gIFwiXFx1MUU1OVwiOiBcInJcXHUwMzA3XCIsXG4gIC8vIOG5mSA9IFxcLntyfVxuICBcIlxcdTAxNUJcIjogXCJzXFx1MDMwMVwiLFxuICAvLyDFmyA9IFxcJ3tzfVxuICBcIlxcdTFFNjVcIjogXCJzXFx1MDMwMVxcdTAzMDdcIixcbiAgLy8g4bmlID0gXFwnXFwue3N9XG4gIFwiXFx1MDE2MVwiOiBcInNcXHUwMzBDXCIsXG4gIC8vIMWhID0gXFx2e3N9XG4gIFwiXFx1MUU2N1wiOiBcInNcXHUwMzBDXFx1MDMwN1wiLFxuICAvLyDhuacgPSBcXHZcXC57c31cbiAgXCJcXHUwMTVEXCI6IFwic1xcdTAzMDJcIixcbiAgLy8gxZ0gPSBcXF57c31cbiAgXCJcXHUxRTYxXCI6IFwic1xcdTAzMDdcIixcbiAgLy8g4bmhID0gXFwue3N9XG4gIFwiXFx1MUU5N1wiOiBcInRcXHUwMzA4XCIsXG4gIC8vIOG6lyA9IFxcXCJ7dH1cbiAgXCJcXHUwMTY1XCI6IFwidFxcdTAzMENcIixcbiAgLy8gxaUgPSBcXHZ7dH1cbiAgXCJcXHUxRTZCXCI6IFwidFxcdTAzMDdcIixcbiAgLy8g4bmrID0gXFwue3R9XG4gIFwiXFx4RkFcIjogXCJ1XFx1MDMwMVwiLFxuICAvLyDDuiA9IFxcJ3t1fVxuICBcIlxceEY5XCI6IFwidVxcdTAzMDBcIixcbiAgLy8gw7kgPSBcXGB7dX1cbiAgXCJcXHhGQ1wiOiBcInVcXHUwMzA4XCIsXG4gIC8vIMO8ID0gXFxcInt1fVxuICBcIlxcdTAxRDhcIjogXCJ1XFx1MDMwOFxcdTAzMDFcIixcbiAgLy8gx5ggPSBcXFwiXFwne3V9XG4gIFwiXFx1MDFEQ1wiOiBcInVcXHUwMzA4XFx1MDMwMFwiLFxuICAvLyDHnCA9IFxcXCJcXGB7dX1cbiAgXCJcXHUwMUQ2XCI6IFwidVxcdTAzMDhcXHUwMzA0XCIsXG4gIC8vIMeWID0gXFxcIlxcPXt1fVxuICBcIlxcdTAxREFcIjogXCJ1XFx1MDMwOFxcdTAzMENcIixcbiAgLy8gx5ogPSBcXFwiXFx2e3V9XG4gIFwiXFx1MDE2OVwiOiBcInVcXHUwMzAzXCIsXG4gIC8vIMWpID0gXFx+e3V9XG4gIFwiXFx1MUU3OVwiOiBcInVcXHUwMzAzXFx1MDMwMVwiLFxuICAvLyDhubkgPSBcXH5cXCd7dX1cbiAgXCJcXHUwMTZCXCI6IFwidVxcdTAzMDRcIixcbiAgLy8gxasgPSBcXD17dX1cbiAgXCJcXHUxRTdCXCI6IFwidVxcdTAzMDRcXHUwMzA4XCIsXG4gIC8vIOG5uyA9IFxcPVxcXCJ7dX1cbiAgXCJcXHUwMTZEXCI6IFwidVxcdTAzMDZcIixcbiAgLy8gxa0gPSBcXHV7dX1cbiAgXCJcXHUwMUQ0XCI6IFwidVxcdTAzMENcIixcbiAgLy8gx5QgPSBcXHZ7dX1cbiAgXCJcXHhGQlwiOiBcInVcXHUwMzAyXCIsXG4gIC8vIMO7ID0gXFxee3V9XG4gIFwiXFx1MDE2RlwiOiBcInVcXHUwMzBBXCIsXG4gIC8vIMWvID0gXFxye3V9XG4gIFwiXFx1MDE3MVwiOiBcInVcXHUwMzBCXCIsXG4gIC8vIMWxID0gXFxIe3V9XG4gIFwiXFx1MUU3RFwiOiBcInZcXHUwMzAzXCIsXG4gIC8vIOG5vSA9IFxcfnt2fVxuICBcIlxcdTFFODNcIjogXCJ3XFx1MDMwMVwiLFxuICAvLyDhuoMgPSBcXCd7d31cbiAgXCJcXHUxRTgxXCI6IFwid1xcdTAzMDBcIixcbiAgLy8g4bqBID0gXFxge3d9XG4gIFwiXFx1MUU4NVwiOiBcIndcXHUwMzA4XCIsXG4gIC8vIOG6hSA9IFxcXCJ7d31cbiAgXCJcXHUwMTc1XCI6IFwid1xcdTAzMDJcIixcbiAgLy8gxbUgPSBcXF57d31cbiAgXCJcXHUxRTg3XCI6IFwid1xcdTAzMDdcIixcbiAgLy8g4bqHID0gXFwue3d9XG4gIFwiXFx1MUU5OFwiOiBcIndcXHUwMzBBXCIsXG4gIC8vIOG6mCA9IFxccnt3fVxuICBcIlxcdTFFOERcIjogXCJ4XFx1MDMwOFwiLFxuICAvLyDhuo0gPSBcXFwie3h9XG4gIFwiXFx1MUU4QlwiOiBcInhcXHUwMzA3XCIsXG4gIC8vIOG6iyA9IFxcLnt4fVxuICBcIlxceEZEXCI6IFwieVxcdTAzMDFcIixcbiAgLy8gw70gPSBcXCd7eX1cbiAgXCJcXHUxRUYzXCI6IFwieVxcdTAzMDBcIixcbiAgLy8g4buzID0gXFxge3l9XG4gIFwiXFx4RkZcIjogXCJ5XFx1MDMwOFwiLFxuICAvLyDDvyA9IFxcXCJ7eX1cbiAgXCJcXHUxRUY5XCI6IFwieVxcdTAzMDNcIixcbiAgLy8g4bu5ID0gXFx+e3l9XG4gIFwiXFx1MDIzM1wiOiBcInlcXHUwMzA0XCIsXG4gIC8vIMizID0gXFw9e3l9XG4gIFwiXFx1MDE3N1wiOiBcInlcXHUwMzAyXCIsXG4gIC8vIMW3ID0gXFxee3l9XG4gIFwiXFx1MUU4RlwiOiBcInlcXHUwMzA3XCIsXG4gIC8vIOG6jyA9IFxcLnt5fVxuICBcIlxcdTFFOTlcIjogXCJ5XFx1MDMwQVwiLFxuICAvLyDhupkgPSBcXHJ7eX1cbiAgXCJcXHUwMTdBXCI6IFwielxcdTAzMDFcIixcbiAgLy8gxbogPSBcXCd7en1cbiAgXCJcXHUwMTdFXCI6IFwielxcdTAzMENcIixcbiAgLy8gxb4gPSBcXHZ7en1cbiAgXCJcXHUxRTkxXCI6IFwielxcdTAzMDJcIixcbiAgLy8g4bqRID0gXFxee3p9XG4gIFwiXFx1MDE3Q1wiOiBcInpcXHUwMzA3XCIsXG4gIC8vIMW8ID0gXFwue3p9XG4gIFwiXFx4QzFcIjogXCJBXFx1MDMwMVwiLFxuICAvLyDDgSA9IFxcJ3tBfVxuICBcIlxceEMwXCI6IFwiQVxcdTAzMDBcIixcbiAgLy8gw4AgPSBcXGB7QX1cbiAgXCJcXHhDNFwiOiBcIkFcXHUwMzA4XCIsXG4gIC8vIMOEID0gXFxcIntBfVxuICBcIlxcdTAxREVcIjogXCJBXFx1MDMwOFxcdTAzMDRcIixcbiAgLy8gx54gPSBcXFwiXFw9e0F9XG4gIFwiXFx4QzNcIjogXCJBXFx1MDMwM1wiLFxuICAvLyDDgyA9IFxcfntBfVxuICBcIlxcdTAxMDBcIjogXCJBXFx1MDMwNFwiLFxuICAvLyDEgCA9IFxcPXtBfVxuICBcIlxcdTAxMDJcIjogXCJBXFx1MDMwNlwiLFxuICAvLyDEgiA9IFxcdXtBfVxuICBcIlxcdTFFQUVcIjogXCJBXFx1MDMwNlxcdTAzMDFcIixcbiAgLy8g4bquID0gXFx1XFwne0F9XG4gIFwiXFx1MUVCMFwiOiBcIkFcXHUwMzA2XFx1MDMwMFwiLFxuICAvLyDhurAgPSBcXHVcXGB7QX1cbiAgXCJcXHUxRUI0XCI6IFwiQVxcdTAzMDZcXHUwMzAzXCIsXG4gIC8vIOG6tCA9IFxcdVxcfntBfVxuICBcIlxcdTAxQ0RcIjogXCJBXFx1MDMwQ1wiLFxuICAvLyDHjSA9IFxcdntBfVxuICBcIlxceEMyXCI6IFwiQVxcdTAzMDJcIixcbiAgLy8gw4IgPSBcXF57QX1cbiAgXCJcXHUxRUE0XCI6IFwiQVxcdTAzMDJcXHUwMzAxXCIsXG4gIC8vIOG6pCA9IFxcXlxcJ3tBfVxuICBcIlxcdTFFQTZcIjogXCJBXFx1MDMwMlxcdTAzMDBcIixcbiAgLy8g4bqmID0gXFxeXFxge0F9XG4gIFwiXFx1MUVBQVwiOiBcIkFcXHUwMzAyXFx1MDMwM1wiLFxuICAvLyDhuqogPSBcXF5cXH57QX1cbiAgXCJcXHUwMjI2XCI6IFwiQVxcdTAzMDdcIixcbiAgLy8gyKYgPSBcXC57QX1cbiAgXCJcXHUwMUUwXCI6IFwiQVxcdTAzMDdcXHUwMzA0XCIsXG4gIC8vIMegID0gXFwuXFw9e0F9XG4gIFwiXFx4QzVcIjogXCJBXFx1MDMwQVwiLFxuICAvLyDDhSA9IFxccntBfVxuICBcIlxcdTAxRkFcIjogXCJBXFx1MDMwQVxcdTAzMDFcIixcbiAgLy8gx7ogPSBcXHJcXCd7QX1cbiAgXCJcXHUxRTAyXCI6IFwiQlxcdTAzMDdcIixcbiAgLy8g4biCID0gXFwue0J9XG4gIFwiXFx1MDEwNlwiOiBcIkNcXHUwMzAxXCIsXG4gIC8vIMSGID0gXFwne0N9XG4gIFwiXFx1MDEwQ1wiOiBcIkNcXHUwMzBDXCIsXG4gIC8vIMSMID0gXFx2e0N9XG4gIFwiXFx1MDEwOFwiOiBcIkNcXHUwMzAyXCIsXG4gIC8vIMSIID0gXFxee0N9XG4gIFwiXFx1MDEwQVwiOiBcIkNcXHUwMzA3XCIsXG4gIC8vIMSKID0gXFwue0N9XG4gIFwiXFx1MDEwRVwiOiBcIkRcXHUwMzBDXCIsXG4gIC8vIMSOID0gXFx2e0R9XG4gIFwiXFx1MUUwQVwiOiBcIkRcXHUwMzA3XCIsXG4gIC8vIOG4iiA9IFxcLntEfVxuICBcIlxceEM5XCI6IFwiRVxcdTAzMDFcIixcbiAgLy8gw4kgPSBcXCd7RX1cbiAgXCJcXHhDOFwiOiBcIkVcXHUwMzAwXCIsXG4gIC8vIMOIID0gXFxge0V9XG4gIFwiXFx4Q0JcIjogXCJFXFx1MDMwOFwiLFxuICAvLyDDiyA9IFxcXCJ7RX1cbiAgXCJcXHUxRUJDXCI6IFwiRVxcdTAzMDNcIixcbiAgLy8g4bq8ID0gXFx+e0V9XG4gIFwiXFx1MDExMlwiOiBcIkVcXHUwMzA0XCIsXG4gIC8vIMSSID0gXFw9e0V9XG4gIFwiXFx1MUUxNlwiOiBcIkVcXHUwMzA0XFx1MDMwMVwiLFxuICAvLyDhuJYgPSBcXD1cXCd7RX1cbiAgXCJcXHUxRTE0XCI6IFwiRVxcdTAzMDRcXHUwMzAwXCIsXG4gIC8vIOG4lCA9IFxcPVxcYHtFfVxuICBcIlxcdTAxMTRcIjogXCJFXFx1MDMwNlwiLFxuICAvLyDElCA9IFxcdXtFfVxuICBcIlxcdTAxMUFcIjogXCJFXFx1MDMwQ1wiLFxuICAvLyDEmiA9IFxcdntFfVxuICBcIlxceENBXCI6IFwiRVxcdTAzMDJcIixcbiAgLy8gw4ogPSBcXF57RX1cbiAgXCJcXHUxRUJFXCI6IFwiRVxcdTAzMDJcXHUwMzAxXCIsXG4gIC8vIOG6viA9IFxcXlxcJ3tFfVxuICBcIlxcdTFFQzBcIjogXCJFXFx1MDMwMlxcdTAzMDBcIixcbiAgLy8g4buAID0gXFxeXFxge0V9XG4gIFwiXFx1MUVDNFwiOiBcIkVcXHUwMzAyXFx1MDMwM1wiLFxuICAvLyDhu4QgPSBcXF5cXH57RX1cbiAgXCJcXHUwMTE2XCI6IFwiRVxcdTAzMDdcIixcbiAgLy8gxJYgPSBcXC57RX1cbiAgXCJcXHUxRTFFXCI6IFwiRlxcdTAzMDdcIixcbiAgLy8g4bieID0gXFwue0Z9XG4gIFwiXFx1MDFGNFwiOiBcIkdcXHUwMzAxXCIsXG4gIC8vIMe0ID0gXFwne0d9XG4gIFwiXFx1MUUyMFwiOiBcIkdcXHUwMzA0XCIsXG4gIC8vIOG4oCA9IFxcPXtHfVxuICBcIlxcdTAxMUVcIjogXCJHXFx1MDMwNlwiLFxuICAvLyDEniA9IFxcdXtHfVxuICBcIlxcdTAxRTZcIjogXCJHXFx1MDMwQ1wiLFxuICAvLyDHpiA9IFxcdntHfVxuICBcIlxcdTAxMUNcIjogXCJHXFx1MDMwMlwiLFxuICAvLyDEnCA9IFxcXntHfVxuICBcIlxcdTAxMjBcIjogXCJHXFx1MDMwN1wiLFxuICAvLyDEoCA9IFxcLntHfVxuICBcIlxcdTFFMjZcIjogXCJIXFx1MDMwOFwiLFxuICAvLyDhuKYgPSBcXFwie0h9XG4gIFwiXFx1MDIxRVwiOiBcIkhcXHUwMzBDXCIsXG4gIC8vIMieID0gXFx2e0h9XG4gIFwiXFx1MDEyNFwiOiBcIkhcXHUwMzAyXCIsXG4gIC8vIMSkID0gXFxee0h9XG4gIFwiXFx1MUUyMlwiOiBcIkhcXHUwMzA3XCIsXG4gIC8vIOG4oiA9IFxcLntIfVxuICBcIlxceENEXCI6IFwiSVxcdTAzMDFcIixcbiAgLy8gw40gPSBcXCd7SX1cbiAgXCJcXHhDQ1wiOiBcIklcXHUwMzAwXCIsXG4gIC8vIMOMID0gXFxge0l9XG4gIFwiXFx4Q0ZcIjogXCJJXFx1MDMwOFwiLFxuICAvLyDDjyA9IFxcXCJ7SX1cbiAgXCJcXHUxRTJFXCI6IFwiSVxcdTAzMDhcXHUwMzAxXCIsXG4gIC8vIOG4riA9IFxcXCJcXCd7SX1cbiAgXCJcXHUwMTI4XCI6IFwiSVxcdTAzMDNcIixcbiAgLy8gxKggPSBcXH57SX1cbiAgXCJcXHUwMTJBXCI6IFwiSVxcdTAzMDRcIixcbiAgLy8gxKogPSBcXD17SX1cbiAgXCJcXHUwMTJDXCI6IFwiSVxcdTAzMDZcIixcbiAgLy8gxKwgPSBcXHV7SX1cbiAgXCJcXHUwMUNGXCI6IFwiSVxcdTAzMENcIixcbiAgLy8gx48gPSBcXHZ7SX1cbiAgXCJcXHhDRVwiOiBcIklcXHUwMzAyXCIsXG4gIC8vIMOOID0gXFxee0l9XG4gIFwiXFx1MDEzMFwiOiBcIklcXHUwMzA3XCIsXG4gIC8vIMSwID0gXFwue0l9XG4gIFwiXFx1MDEzNFwiOiBcIkpcXHUwMzAyXCIsXG4gIC8vIMS0ID0gXFxee0p9XG4gIFwiXFx1MUUzMFwiOiBcIktcXHUwMzAxXCIsXG4gIC8vIOG4sCA9IFxcJ3tLfVxuICBcIlxcdTAxRThcIjogXCJLXFx1MDMwQ1wiLFxuICAvLyDHqCA9IFxcdntLfVxuICBcIlxcdTAxMzlcIjogXCJMXFx1MDMwMVwiLFxuICAvLyDEuSA9IFxcJ3tMfVxuICBcIlxcdTAxM0RcIjogXCJMXFx1MDMwQ1wiLFxuICAvLyDEvSA9IFxcdntMfVxuICBcIlxcdTFFM0VcIjogXCJNXFx1MDMwMVwiLFxuICAvLyDhuL4gPSBcXCd7TX1cbiAgXCJcXHUxRTQwXCI6IFwiTVxcdTAzMDdcIixcbiAgLy8g4bmAID0gXFwue019XG4gIFwiXFx1MDE0M1wiOiBcIk5cXHUwMzAxXCIsXG4gIC8vIMWDID0gXFwne059XG4gIFwiXFx1MDFGOFwiOiBcIk5cXHUwMzAwXCIsXG4gIC8vIMe4ID0gXFxge059XG4gIFwiXFx4RDFcIjogXCJOXFx1MDMwM1wiLFxuICAvLyDDkSA9IFxcfntOfVxuICBcIlxcdTAxNDdcIjogXCJOXFx1MDMwQ1wiLFxuICAvLyDFhyA9IFxcdntOfVxuICBcIlxcdTFFNDRcIjogXCJOXFx1MDMwN1wiLFxuICAvLyDhuYQgPSBcXC57Tn1cbiAgXCJcXHhEM1wiOiBcIk9cXHUwMzAxXCIsXG4gIC8vIMOTID0gXFwne099XG4gIFwiXFx4RDJcIjogXCJPXFx1MDMwMFwiLFxuICAvLyDDkiA9IFxcYHtPfVxuICBcIlxceEQ2XCI6IFwiT1xcdTAzMDhcIixcbiAgLy8gw5YgPSBcXFwie099XG4gIFwiXFx1MDIyQVwiOiBcIk9cXHUwMzA4XFx1MDMwNFwiLFxuICAvLyDIqiA9IFxcXCJcXD17T31cbiAgXCJcXHhENVwiOiBcIk9cXHUwMzAzXCIsXG4gIC8vIMOVID0gXFx+e099XG4gIFwiXFx1MUU0Q1wiOiBcIk9cXHUwMzAzXFx1MDMwMVwiLFxuICAvLyDhuYwgPSBcXH5cXCd7T31cbiAgXCJcXHUxRTRFXCI6IFwiT1xcdTAzMDNcXHUwMzA4XCIsXG4gIC8vIOG5jiA9IFxcflxcXCJ7T31cbiAgXCJcXHUwMjJDXCI6IFwiT1xcdTAzMDNcXHUwMzA0XCIsXG4gIC8vIMisID0gXFx+XFw9e099XG4gIFwiXFx1MDE0Q1wiOiBcIk9cXHUwMzA0XCIsXG4gIC8vIMWMID0gXFw9e099XG4gIFwiXFx1MUU1MlwiOiBcIk9cXHUwMzA0XFx1MDMwMVwiLFxuICAvLyDhuZIgPSBcXD1cXCd7T31cbiAgXCJcXHUxRTUwXCI6IFwiT1xcdTAzMDRcXHUwMzAwXCIsXG4gIC8vIOG5kCA9IFxcPVxcYHtPfVxuICBcIlxcdTAxNEVcIjogXCJPXFx1MDMwNlwiLFxuICAvLyDFjiA9IFxcdXtPfVxuICBcIlxcdTAxRDFcIjogXCJPXFx1MDMwQ1wiLFxuICAvLyDHkSA9IFxcdntPfVxuICBcIlxceEQ0XCI6IFwiT1xcdTAzMDJcIixcbiAgLy8gw5QgPSBcXF57T31cbiAgXCJcXHUxRUQwXCI6IFwiT1xcdTAzMDJcXHUwMzAxXCIsXG4gIC8vIOG7kCA9IFxcXlxcJ3tPfVxuICBcIlxcdTFFRDJcIjogXCJPXFx1MDMwMlxcdTAzMDBcIixcbiAgLy8g4buSID0gXFxeXFxge099XG4gIFwiXFx1MUVENlwiOiBcIk9cXHUwMzAyXFx1MDMwM1wiLFxuICAvLyDhu5YgPSBcXF5cXH57T31cbiAgXCJcXHUwMjJFXCI6IFwiT1xcdTAzMDdcIixcbiAgLy8gyK4gPSBcXC57T31cbiAgXCJcXHUwMjMwXCI6IFwiT1xcdTAzMDdcXHUwMzA0XCIsXG4gIC8vIMiwID0gXFwuXFw9e099XG4gIFwiXFx1MDE1MFwiOiBcIk9cXHUwMzBCXCIsXG4gIC8vIMWQID0gXFxIe099XG4gIFwiXFx1MUU1NFwiOiBcIlBcXHUwMzAxXCIsXG4gIC8vIOG5lCA9IFxcJ3tQfVxuICBcIlxcdTFFNTZcIjogXCJQXFx1MDMwN1wiLFxuICAvLyDhuZYgPSBcXC57UH1cbiAgXCJcXHUwMTU0XCI6IFwiUlxcdTAzMDFcIixcbiAgLy8gxZQgPSBcXCd7Un1cbiAgXCJcXHUwMTU4XCI6IFwiUlxcdTAzMENcIixcbiAgLy8gxZggPSBcXHZ7Un1cbiAgXCJcXHUxRTU4XCI6IFwiUlxcdTAzMDdcIixcbiAgLy8g4bmYID0gXFwue1J9XG4gIFwiXFx1MDE1QVwiOiBcIlNcXHUwMzAxXCIsXG4gIC8vIMWaID0gXFwne1N9XG4gIFwiXFx1MUU2NFwiOiBcIlNcXHUwMzAxXFx1MDMwN1wiLFxuICAvLyDhuaQgPSBcXCdcXC57U31cbiAgXCJcXHUwMTYwXCI6IFwiU1xcdTAzMENcIixcbiAgLy8gxaAgPSBcXHZ7U31cbiAgXCJcXHUxRTY2XCI6IFwiU1xcdTAzMENcXHUwMzA3XCIsXG4gIC8vIOG5piA9IFxcdlxcLntTfVxuICBcIlxcdTAxNUNcIjogXCJTXFx1MDMwMlwiLFxuICAvLyDFnCA9IFxcXntTfVxuICBcIlxcdTFFNjBcIjogXCJTXFx1MDMwN1wiLFxuICAvLyDhuaAgPSBcXC57U31cbiAgXCJcXHUwMTY0XCI6IFwiVFxcdTAzMENcIixcbiAgLy8gxaQgPSBcXHZ7VH1cbiAgXCJcXHUxRTZBXCI6IFwiVFxcdTAzMDdcIixcbiAgLy8g4bmqID0gXFwue1R9XG4gIFwiXFx4REFcIjogXCJVXFx1MDMwMVwiLFxuICAvLyDDmiA9IFxcJ3tVfVxuICBcIlxceEQ5XCI6IFwiVVxcdTAzMDBcIixcbiAgLy8gw5kgPSBcXGB7VX1cbiAgXCJcXHhEQ1wiOiBcIlVcXHUwMzA4XCIsXG4gIC8vIMOcID0gXFxcIntVfVxuICBcIlxcdTAxRDdcIjogXCJVXFx1MDMwOFxcdTAzMDFcIixcbiAgLy8gx5cgPSBcXFwiXFwne1V9XG4gIFwiXFx1MDFEQlwiOiBcIlVcXHUwMzA4XFx1MDMwMFwiLFxuICAvLyDHmyA9IFxcXCJcXGB7VX1cbiAgXCJcXHUwMUQ1XCI6IFwiVVxcdTAzMDhcXHUwMzA0XCIsXG4gIC8vIMeVID0gXFxcIlxcPXtVfVxuICBcIlxcdTAxRDlcIjogXCJVXFx1MDMwOFxcdTAzMENcIixcbiAgLy8gx5kgPSBcXFwiXFx2e1V9XG4gIFwiXFx1MDE2OFwiOiBcIlVcXHUwMzAzXCIsXG4gIC8vIMWoID0gXFx+e1V9XG4gIFwiXFx1MUU3OFwiOiBcIlVcXHUwMzAzXFx1MDMwMVwiLFxuICAvLyDhubggPSBcXH5cXCd7VX1cbiAgXCJcXHUwMTZBXCI6IFwiVVxcdTAzMDRcIixcbiAgLy8gxaogPSBcXD17VX1cbiAgXCJcXHUxRTdBXCI6IFwiVVxcdTAzMDRcXHUwMzA4XCIsXG4gIC8vIOG5uiA9IFxcPVxcXCJ7VX1cbiAgXCJcXHUwMTZDXCI6IFwiVVxcdTAzMDZcIixcbiAgLy8gxawgPSBcXHV7VX1cbiAgXCJcXHUwMUQzXCI6IFwiVVxcdTAzMENcIixcbiAgLy8gx5MgPSBcXHZ7VX1cbiAgXCJcXHhEQlwiOiBcIlVcXHUwMzAyXCIsXG4gIC8vIMObID0gXFxee1V9XG4gIFwiXFx1MDE2RVwiOiBcIlVcXHUwMzBBXCIsXG4gIC8vIMWuID0gXFxye1V9XG4gIFwiXFx1MDE3MFwiOiBcIlVcXHUwMzBCXCIsXG4gIC8vIMWwID0gXFxIe1V9XG4gIFwiXFx1MUU3Q1wiOiBcIlZcXHUwMzAzXCIsXG4gIC8vIOG5vCA9IFxcfntWfVxuICBcIlxcdTFFODJcIjogXCJXXFx1MDMwMVwiLFxuICAvLyDhuoIgPSBcXCd7V31cbiAgXCJcXHUxRTgwXCI6IFwiV1xcdTAzMDBcIixcbiAgLy8g4bqAID0gXFxge1d9XG4gIFwiXFx1MUU4NFwiOiBcIldcXHUwMzA4XCIsXG4gIC8vIOG6hCA9IFxcXCJ7V31cbiAgXCJcXHUwMTc0XCI6IFwiV1xcdTAzMDJcIixcbiAgLy8gxbQgPSBcXF57V31cbiAgXCJcXHUxRTg2XCI6IFwiV1xcdTAzMDdcIixcbiAgLy8g4bqGID0gXFwue1d9XG4gIFwiXFx1MUU4Q1wiOiBcIlhcXHUwMzA4XCIsXG4gIC8vIOG6jCA9IFxcXCJ7WH1cbiAgXCJcXHUxRThBXCI6IFwiWFxcdTAzMDdcIixcbiAgLy8g4bqKID0gXFwue1h9XG4gIFwiXFx4RERcIjogXCJZXFx1MDMwMVwiLFxuICAvLyDDnSA9IFxcJ3tZfVxuICBcIlxcdTFFRjJcIjogXCJZXFx1MDMwMFwiLFxuICAvLyDhu7IgPSBcXGB7WX1cbiAgXCJcXHUwMTc4XCI6IFwiWVxcdTAzMDhcIixcbiAgLy8gxbggPSBcXFwie1l9XG4gIFwiXFx1MUVGOFwiOiBcIllcXHUwMzAzXCIsXG4gIC8vIOG7uCA9IFxcfntZfVxuICBcIlxcdTAyMzJcIjogXCJZXFx1MDMwNFwiLFxuICAvLyDIsiA9IFxcPXtZfVxuICBcIlxcdTAxNzZcIjogXCJZXFx1MDMwMlwiLFxuICAvLyDFtiA9IFxcXntZfVxuICBcIlxcdTFFOEVcIjogXCJZXFx1MDMwN1wiLFxuICAvLyDhuo4gPSBcXC57WX1cbiAgXCJcXHUwMTc5XCI6IFwiWlxcdTAzMDFcIixcbiAgLy8gxbkgPSBcXCd7Wn1cbiAgXCJcXHUwMTdEXCI6IFwiWlxcdTAzMENcIixcbiAgLy8gxb0gPSBcXHZ7Wn1cbiAgXCJcXHUxRTkwXCI6IFwiWlxcdTAzMDJcIixcbiAgLy8g4bqQID0gXFxee1p9XG4gIFwiXFx1MDE3QlwiOiBcIlpcXHUwMzA3XCIsXG4gIC8vIMW7ID0gXFwue1p9XG4gIFwiXFx1MDNBQ1wiOiBcIlxcdTAzQjFcXHUwMzAxXCIsXG4gIC8vIM6sID0gXFwne86xfVxuICBcIlxcdTFGNzBcIjogXCJcXHUwM0IxXFx1MDMwMFwiLFxuICAvLyDhvbAgPSBcXGB7zrF9XG4gIFwiXFx1MUZCMVwiOiBcIlxcdTAzQjFcXHUwMzA0XCIsXG4gIC8vIOG+sSA9IFxcPXvOsX1cbiAgXCJcXHUxRkIwXCI6IFwiXFx1MDNCMVxcdTAzMDZcIixcbiAgLy8g4b6wID0gXFx1e86xfVxuICBcIlxcdTAzQURcIjogXCJcXHUwM0I1XFx1MDMwMVwiLFxuICAvLyDOrSA9IFxcJ3vOtX1cbiAgXCJcXHUxRjcyXCI6IFwiXFx1MDNCNVxcdTAzMDBcIixcbiAgLy8g4b2yID0gXFxge861fVxuICBcIlxcdTAzQUVcIjogXCJcXHUwM0I3XFx1MDMwMVwiLFxuICAvLyDOriA9IFxcJ3vOt31cbiAgXCJcXHUxRjc0XCI6IFwiXFx1MDNCN1xcdTAzMDBcIixcbiAgLy8g4b20ID0gXFxge863fVxuICBcIlxcdTAzQUZcIjogXCJcXHUwM0I5XFx1MDMwMVwiLFxuICAvLyDOryA9IFxcJ3vOuX1cbiAgXCJcXHUxRjc2XCI6IFwiXFx1MDNCOVxcdTAzMDBcIixcbiAgLy8g4b22ID0gXFxge865fVxuICBcIlxcdTAzQ0FcIjogXCJcXHUwM0I5XFx1MDMwOFwiLFxuICAvLyDPiiA9IFxcXCJ7zrl9XG4gIFwiXFx1MDM5MFwiOiBcIlxcdTAzQjlcXHUwMzA4XFx1MDMwMVwiLFxuICAvLyDOkCA9IFxcXCJcXCd7zrl9XG4gIFwiXFx1MUZEMlwiOiBcIlxcdTAzQjlcXHUwMzA4XFx1MDMwMFwiLFxuICAvLyDhv5IgPSBcXFwiXFxge865fVxuICBcIlxcdTFGRDFcIjogXCJcXHUwM0I5XFx1MDMwNFwiLFxuICAvLyDhv5EgPSBcXD17zrl9XG4gIFwiXFx1MUZEMFwiOiBcIlxcdTAzQjlcXHUwMzA2XCIsXG4gIC8vIOG/kCA9IFxcdXvOuX1cbiAgXCJcXHUwM0NDXCI6IFwiXFx1MDNCRlxcdTAzMDFcIixcbiAgLy8gz4wgPSBcXCd7zr99XG4gIFwiXFx1MUY3OFwiOiBcIlxcdTAzQkZcXHUwMzAwXCIsXG4gIC8vIOG9uCA9IFxcYHvOv31cbiAgXCJcXHUwM0NEXCI6IFwiXFx1MDNDNVxcdTAzMDFcIixcbiAgLy8gz40gPSBcXCd7z4V9XG4gIFwiXFx1MUY3QVwiOiBcIlxcdTAzQzVcXHUwMzAwXCIsXG4gIC8vIOG9uiA9IFxcYHvPhX1cbiAgXCJcXHUwM0NCXCI6IFwiXFx1MDNDNVxcdTAzMDhcIixcbiAgLy8gz4sgPSBcXFwie8+FfVxuICBcIlxcdTAzQjBcIjogXCJcXHUwM0M1XFx1MDMwOFxcdTAzMDFcIixcbiAgLy8gzrAgPSBcXFwiXFwne8+FfVxuICBcIlxcdTFGRTJcIjogXCJcXHUwM0M1XFx1MDMwOFxcdTAzMDBcIixcbiAgLy8g4b+iID0gXFxcIlxcYHvPhX1cbiAgXCJcXHUxRkUxXCI6IFwiXFx1MDNDNVxcdTAzMDRcIixcbiAgLy8g4b+hID0gXFw9e8+FfVxuICBcIlxcdTFGRTBcIjogXCJcXHUwM0M1XFx1MDMwNlwiLFxuICAvLyDhv6AgPSBcXHV7z4V9XG4gIFwiXFx1MDNDRVwiOiBcIlxcdTAzQzlcXHUwMzAxXCIsXG4gIC8vIM+OID0gXFwne8+JfVxuICBcIlxcdTFGN0NcIjogXCJcXHUwM0M5XFx1MDMwMFwiLFxuICAvLyDhvbwgPSBcXGB7z4l9XG4gIFwiXFx1MDM4RVwiOiBcIlxcdTAzQTVcXHUwMzAxXCIsXG4gIC8vIM6OID0gXFwne86lfVxuICBcIlxcdTFGRUFcIjogXCJcXHUwM0E1XFx1MDMwMFwiLFxuICAvLyDhv6ogPSBcXGB7zqV9XG4gIFwiXFx1MDNBQlwiOiBcIlxcdTAzQTVcXHUwMzA4XCIsXG4gIC8vIM6rID0gXFxcInvOpX1cbiAgXCJcXHUxRkU5XCI6IFwiXFx1MDNBNVxcdTAzMDRcIixcbiAgLy8g4b+pID0gXFw9e86lfVxuICBcIlxcdTFGRThcIjogXCJcXHUwM0E1XFx1MDMwNlwiLFxuICAvLyDhv6ggPSBcXHV7zqV9XG4gIFwiXFx1MDM4RlwiOiBcIlxcdTAzQTlcXHUwMzAxXCIsXG4gIC8vIM6PID0gXFwne86pfVxuICBcIlxcdTFGRkFcIjogXCJcXHUwM0E5XFx1MDMwMFwiIC8vIOG/uiA9IFxcYHvOqX1cblxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9QYXJzZXIuanNcbi8qIGVzbGludCBuby1jb25zdGFudC1jb25kaXRpb246MCAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIHBhcnNlciB1c2VkIHRvIHBhcnNlIG91dCBhIFRlWCBleHByZXNzaW9uIGZyb20gdGhlXG4gKiBpbnB1dC4gU2luY2UgVGVYIGlzbid0IGNvbnRleHQtZnJlZSwgc3RhbmRhcmQgcGFyc2VycyBkb24ndCB3b3JrIHBhcnRpY3VsYXJseVxuICogd2VsbC5cbiAqXG4gKiBUaGUgc3RyYXRlZ3kgb2YgdGhpcyBwYXJzZXIgaXMgYXMgc3VjaDpcbiAqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbnMgKHRoZSBgLnBhcnNlLi4uYCBvbmVzKSB0YWtlIGEgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcbiAqIHBhcnNlIHN0cmluZyB0byBwYXJzZSB0b2tlbnMgZnJvbS4gVGhlIGxleGVyIChmb3VuZCBpbiBMZXhlci5qcywgc3RvcmVkIGF0XG4gKiB0aGlzLmd1bGxldC5sZXhlcikgYWxzbyBzdXBwb3J0cyBwdWxsaW5nIG91dCB0b2tlbnMgYXQgYXJiaXRyYXJ5IHBsYWNlcy4gV2hlblxuICogaW5kaXZpZHVhbCB0b2tlbnMgYXJlIG5lZWRlZCBhdCBhIHBvc2l0aW9uLCB0aGUgbGV4ZXIgaXMgY2FsbGVkIHRvIHB1bGwgb3V0IGFcbiAqIHRva2VuLCB3aGljaCBpcyB0aGVuIHVzZWQuXG4gKlxuICogVGhlIHBhcnNlciBoYXMgYSBwcm9wZXJ0eSBjYWxsZWQgXCJtb2RlXCIgaW5kaWNhdGluZyB0aGUgbW9kZSB0aGF0XG4gKiB0aGUgcGFyc2VyIGlzIGN1cnJlbnRseSBpbi4gQ3VycmVudGx5IGl0IGhhcyB0byBiZSBvbmUgb2YgXCJtYXRoXCIgb3JcbiAqIFwidGV4dFwiLCB3aGljaCBkZW5vdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgYSBtYXRoLXlcbiAqIG9uZSBvciBhIHRleHQteSBvbmUgKGUuZy4gaW5zaWRlIFxcdGV4dCkuIEN1cnJlbnRseSwgdGhpcyBzZXJ2ZXMgdG9cbiAqIGxpbWl0IHRoZSBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIHVzZWQgaW4gdGV4dCBtb2RlLlxuICpcbiAqIFRoZSBtYWluIGZ1bmN0aW9ucyB0aGVuIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIHVzZWZ1bCBkYXRhIHRoYXRcbiAqIHdhcyBwYXJzZWQgYXQgaXRzIGdpdmVuIHBvaW50LCBhbmQgYSBuZXcgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgcGFyc2VkXG4gKiBkYXRhLiBUaGUgbWFpbiBmdW5jdGlvbnMgY2FuIGNhbGwgZWFjaCBvdGhlciBhbmQgY29udGludWUgdGhlIHBhcnNpbmcgYnlcbiAqIHVzaW5nIHRoZSByZXR1cm5lZCBwb3NpdGlvbiBhcyBhIG5ldyBzdGFydGluZyBwb2ludC5cbiAqXG4gKiBUaGVyZSBhcmUgYWxzbyBleHRyYSBgLmhhbmRsZS4uLmAgZnVuY3Rpb25zLCB3aGljaCBwdWxsIG91dCBzb21lIHJldXNlZFxuICogZnVuY3Rpb25hbGl0eSBpbnRvIHNlbGYtY29udGFpbmVkIGZ1bmN0aW9ucy5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIHJldHVybiBQYXJzZU5vZGVzLlxuICovXG52YXIgUGFyc2VyX1BhcnNlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhcnNlcihpbnB1dCwgc2V0dGluZ3MpIHtcbiAgICB0aGlzLm1vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5ndWxsZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHZvaWQgMDtcbiAgICB0aGlzLmxlZnRyaWdodERlcHRoID0gdm9pZCAwO1xuICAgIHRoaXMubmV4dFRva2VuID0gdm9pZCAwO1xuICAgIC8vIFN0YXJ0IGluIG1hdGggbW9kZVxuICAgIHRoaXMubW9kZSA9IFwibWF0aFwiOyAvLyBDcmVhdGUgYSBuZXcgbWFjcm8gZXhwYW5kZXIgKGd1bGxldCkgYW5kIChpbmRpcmVjdGx5IHZpYSB0aGF0KSBhbHNvIGFcbiAgICAvLyBuZXcgbGV4ZXIgKG1vdXRoKSBmb3IgdGhpcyBwYXJzZXIgKHN0b21hY2gsIGluIHRoZSBsYW5ndWFnZSBvZiBUZVgpXG5cbiAgICB0aGlzLmd1bGxldCA9IG5ldyBNYWNyb0V4cGFuZGVyX01hY3JvRXhwYW5kZXIoaW5wdXQsIHNldHRpbmdzLCB0aGlzLm1vZGUpOyAvLyBTdG9yZSB0aGUgc2V0dGluZ3MgZm9yIHVzZSBpbiBwYXJzaW5nXG5cbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7IC8vIENvdW50IGxlZnRyaWdodCBkZXB0aCAoZm9yIFxcbWlkZGxlIGVycm9ycylcblxuICAgIHRoaXMubGVmdHJpZ2h0RGVwdGggPSAwO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgYSByZXN1bHQgdG8gbWFrZSBzdXJlIGl0IGhhcyB0aGUgcmlnaHQgdHlwZSwgYW5kIHRocm93cyBhblxuICAgKiBhcHByb3ByaWF0ZSBlcnJvciBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmV4cGVjdCA9IGZ1bmN0aW9uIGV4cGVjdCh0ZXh0LCBjb25zdW1lKSB7XG4gICAgaWYgKGNvbnN1bWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3VtZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmV4dFRva2VuLnRleHQgIT09IHRleHQpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkV4cGVjdGVkICdcIiArIHRleHQgKyBcIicsIGdvdCAnXCIgKyB0aGlzLm5leHRUb2tlbi50ZXh0ICsgXCInXCIsIHRoaXMubmV4dFRva2VuKTtcbiAgICB9XG5cbiAgICBpZiAoY29uc3VtZSkge1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb25zaWRlcnMgdGhlIGN1cnJlbnQgbG9vayBhaGVhZCB0b2tlbiBhcyBjb25zdW1lZCxcbiAgICogYW5kIGZldGNoZXMgdGhlIG9uZSBhZnRlciB0aGF0IGFzIHRoZSBuZXcgbG9vayBhaGVhZC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY29uc3VtZSA9IGZ1bmN0aW9uIGNvbnN1bWUoKSB7XG4gICAgdGhpcy5uZXh0VG9rZW4gPSB0aGlzLmd1bGxldC5leHBhbmROZXh0VG9rZW4oKTtcbiAgfVxuICAvKipcbiAgICogU3dpdGNoZXMgYmV0d2VlbiBcInRleHRcIiBhbmQgXCJtYXRoXCIgbW9kZXMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnN3aXRjaE1vZGUgPSBmdW5jdGlvbiBzd2l0Y2hNb2RlKG5ld01vZGUpIHtcbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgIHRoaXMuZ3VsbGV0LnN3aXRjaE1vZGUobmV3TW9kZSk7XG4gIH1cbiAgLyoqXG4gICAqIE1haW4gcGFyc2luZyBmdW5jdGlvbiwgd2hpY2ggcGFyc2VzIGFuIGVudGlyZSBpbnB1dC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICAvLyBDcmVhdGUgYSBncm91cCBuYW1lc3BhY2UgZm9yIHRoZSBtYXRoIGV4cHJlc3Npb24uXG4gICAgLy8gKExhVGVYIGNyZWF0ZXMgYSBuZXcgZ3JvdXAgZm9yIGV2ZXJ5ICQuLi4kLCAkJC4uLiQkLCBcXFsuLi5cXF0uKVxuICAgIHRoaXMuZ3VsbGV0LmJlZ2luR3JvdXAoKTsgLy8gVXNlIG9sZCBcXGNvbG9yIGJlaGF2aW9yIChzYW1lIGFzIExhVGVYJ3MgXFx0ZXh0Y29sb3IpIGlmIHJlcXVlc3RlZC5cbiAgICAvLyBXZSBkbyB0aGlzIHdpdGhpbiB0aGUgZ3JvdXAgZm9yIHRoZSBtYXRoIGV4cHJlc3Npb24sIHNvIGl0IGRvZXNuJ3RcbiAgICAvLyBwb2xsdXRlIHNldHRpbmdzLm1hY3Jvcy5cblxuICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbG9ySXNUZXh0Q29sb3IpIHtcbiAgICAgIHRoaXMuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcY29sb3JcIiwgXCJcXFxcdGV4dGNvbG9yXCIpO1xuICAgIH0gLy8gVHJ5IHRvIHBhcnNlIHRoZSBpbnB1dFxuXG5cbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB2YXIgcGFyc2UgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSk7IC8vIElmIHdlIHN1Y2NlZWRlZCwgbWFrZSBzdXJlIHRoZXJlJ3MgYW4gRU9GIGF0IHRoZSBlbmRcblxuICAgIHRoaXMuZXhwZWN0KFwiRU9GXCIsIGZhbHNlKTsgLy8gRW5kIHRoZSBncm91cCBuYW1lc3BhY2UgZm9yIHRoZSBleHByZXNzaW9uXG5cbiAgICB0aGlzLmd1bGxldC5lbmRHcm91cCgpO1xuICAgIHJldHVybiBwYXJzZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGJyZWFrT25JbmZpeCwgYnJlYWtPblRva2VuVGV4dCkge1xuICAgIHZhciBib2R5ID0gW107IC8vIEtlZXAgYWRkaW5nIGF0b21zIHRvIHRoZSBib2R5IHVudGlsIHdlIGNhbid0IHBhcnNlIGFueSBtb3JlIGF0b21zIChlaXRoZXJcbiAgICAvLyB3ZSByZWFjaGVkIHRoZSBlbmQsIGEgfSwgb3IgYSBcXHJpZ2h0KVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIElnbm9yZSBzcGFjZXMgaW4gbWF0aCBtb2RlXG4gICAgICBpZiAodGhpcy5tb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxleCA9IHRoaXMubmV4dFRva2VuO1xuXG4gICAgICBpZiAoUGFyc2VyLmVuZE9mRXhwcmVzc2lvbi5pbmRleE9mKGxleC50ZXh0KSAhPT0gLTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChicmVha09uVG9rZW5UZXh0ICYmIGxleC50ZXh0ID09PSBicmVha09uVG9rZW5UZXh0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnJlYWtPbkluZml4ICYmIHNyY19mdW5jdGlvbnNbbGV4LnRleHRdICYmIHNyY19mdW5jdGlvbnNbbGV4LnRleHRdLmluZml4KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXRvbSA9IHRoaXMucGFyc2VBdG9tKGJyZWFrT25Ub2tlblRleHQpO1xuXG4gICAgICBpZiAoIWF0b20pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGJvZHkucHVzaChhdG9tKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgdGhpcy5mb3JtTGlnYXR1cmVzKGJvZHkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmhhbmRsZUluZml4Tm9kZXMoYm9keSk7XG4gIH1cbiAgLyoqXG4gICAqIFJld3JpdGVzIGluZml4IG9wZXJhdG9ycyBzdWNoIGFzIFxcb3ZlciB3aXRoIGNvcnJlc3BvbmRpbmcgY29tbWFuZHMgc3VjaFxuICAgKiBhcyBcXGZyYWMuXG4gICAqXG4gICAqIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBpbmZpeCBvcGVyYXRvciBwZXIgZ3JvdXAuICBJZiB0aGVyZSdzIG1vcmUgdGhhbiBvbmVcbiAgICogdGhlbiB0aGUgZXhwcmVzc2lvbiBpcyBhbWJpZ3VvdXMuICBUaGlzIGNhbiBiZSByZXNvbHZlZCBieSBhZGRpbmcge30uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmhhbmRsZUluZml4Tm9kZXMgPSBmdW5jdGlvbiBoYW5kbGVJbmZpeE5vZGVzKGJvZHkpIHtcbiAgICB2YXIgb3ZlckluZGV4ID0gLTE7XG4gICAgdmFyIGZ1bmNOYW1lO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IGNoZWNrTm9kZVR5cGUoYm9keVtpXSwgXCJpbmZpeFwiKTtcblxuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJvbmx5IG9uZSBpbmZpeCBvcGVyYXRvciBwZXIgZ3JvdXBcIiwgbm9kZS50b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBvdmVySW5kZXggPSBpO1xuICAgICAgICBmdW5jTmFtZSA9IG5vZGUucmVwbGFjZVdpdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG92ZXJJbmRleCAhPT0gLTEgJiYgZnVuY05hbWUpIHtcbiAgICAgIHZhciBudW1lck5vZGU7XG4gICAgICB2YXIgZGVub21Ob2RlO1xuICAgICAgdmFyIG51bWVyQm9keSA9IGJvZHkuc2xpY2UoMCwgb3ZlckluZGV4KTtcbiAgICAgIHZhciBkZW5vbUJvZHkgPSBib2R5LnNsaWNlKG92ZXJJbmRleCArIDEpO1xuXG4gICAgICBpZiAobnVtZXJCb2R5Lmxlbmd0aCA9PT0gMSAmJiBudW1lckJvZHlbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICAgIG51bWVyTm9kZSA9IG51bWVyQm9keVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG51bWVyTm9kZSA9IHtcbiAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGJvZHk6IG51bWVyQm9keVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVub21Cb2R5Lmxlbmd0aCA9PT0gMSAmJiBkZW5vbUJvZHlbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICAgIGRlbm9tTm9kZSA9IGRlbm9tQm9keVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbm9tTm9kZSA9IHtcbiAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGJvZHk6IGRlbm9tQm9keVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgX25vZGU7XG5cbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcXFxcXGFib3ZlZnJhY1wiKSB7XG4gICAgICAgIF9ub2RlID0gdGhpcy5jYWxsRnVuY3Rpb24oZnVuY05hbWUsIFtudW1lck5vZGUsIGJvZHlbb3ZlckluZGV4XSwgZGVub21Ob2RlXSwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX25vZGUgPSB0aGlzLmNhbGxGdW5jdGlvbihmdW5jTmFtZSwgW251bWVyTm9kZSwgZGVub21Ob2RlXSwgW10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW19ub2RlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuICB9IC8vIFRoZSBncmVlZGluZXNzIG9mIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0XG4gIDtcblxuICAvKipcbiAgICogSGFuZGxlIGEgc3Vic2NyaXB0IG9yIHN1cGVyc2NyaXB0IHdpdGggbmljZSBlcnJvcnMuXG4gICAqL1xuICBfcHJvdG8uaGFuZGxlU3VwU3Vic2NyaXB0ID0gZnVuY3Rpb24gaGFuZGxlU3VwU3Vic2NyaXB0KG5hbWUpIHtcbiAgICB2YXIgc3ltYm9sVG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB2YXIgc3ltYm9sID0gc3ltYm9sVG9rZW4udGV4dDtcbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTsgLy8gaWdub3JlIHNwYWNlcyBiZWZvcmUgc3VwL3N1YnNjcmlwdCBhcmd1bWVudFxuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5wYXJzZUdyb3VwKG5hbWUsIGZhbHNlLCBQYXJzZXIuU1VQU1VCX0dSRUVESU5FU1MpO1xuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRXhwZWN0ZWQgZ3JvdXAgYWZ0ZXIgJ1wiICsgc3ltYm9sICsgXCInXCIsIHN5bWJvbFRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXA7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0dWFsIGlucHV0IG9mIGFuIHVuc3VwcG9ydGVkIGNvbW1hbmQgaW50byBhIHRleHQgbm9kZVxuICAgKiBjb250YWluZWQgd2l0aGluIGEgY29sb3Igbm9kZSB3aG9zZSBjb2xvciBpcyBkZXRlcm1pbmVkIGJ5IGVycm9yQ29sb3JcbiAgICovXG4gIDtcblxuICBfcHJvdG8uaGFuZGxlVW5zdXBwb3J0ZWRDbWQgPSBmdW5jdGlvbiBoYW5kbGVVbnN1cHBvcnRlZENtZCgpIHtcbiAgICB2YXIgdGV4dCA9IHRoaXMubmV4dFRva2VuLnRleHQ7XG4gICAgdmFyIHRleHRvcmRBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0ZXh0b3JkQXJyYXkucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgdGV4dDogdGV4dFtpXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHRleHROb2RlID0ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBib2R5OiB0ZXh0b3JkQXJyYXlcbiAgICB9O1xuICAgIHZhciBjb2xvck5vZGUgPSB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBjb2xvcjogdGhpcy5zZXR0aW5ncy5lcnJvckNvbG9yLFxuICAgICAgYm9keTogW3RleHROb2RlXVxuICAgIH07XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgcmV0dXJuIGNvbG9yTm9kZTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAgd2l0aCBvcHRpb25hbCBzdXBlci9zdWJzY3JpcHRzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUF0b20gPSBmdW5jdGlvbiBwYXJzZUF0b20oYnJlYWtPblRva2VuVGV4dCkge1xuICAgIC8vIFRoZSBib2R5IG9mIGFuIGF0b20gaXMgYW4gaW1wbGljaXQgZ3JvdXAsIHNvIHRoYXQgdGhpbmdzIGxpa2VcbiAgICAvLyBcXGxlZnQoeFxccmlnaHQpXjIgd29yayBjb3JyZWN0bHkuXG4gICAgdmFyIGJhc2UgPSB0aGlzLnBhcnNlR3JvdXAoXCJhdG9tXCIsIGZhbHNlLCBudWxsLCBicmVha09uVG9rZW5UZXh0KTsgLy8gSW4gdGV4dCBtb2RlLCB3ZSBkb24ndCBoYXZlIHN1cGVyc2NyaXB0cyBvciBzdWJzY3JpcHRzXG5cbiAgICBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfSAvLyBOb3RlIHRoYXQgYmFzZSBtYXkgYmUgZW1wdHkgKGkuZS4gbnVsbCkgYXQgdGhpcyBwb2ludC5cblxuXG4gICAgdmFyIHN1cGVyc2NyaXB0O1xuICAgIHZhciBzdWJzY3JpcHQ7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gR3VhcmFudGVlZCBpbiBtYXRoIG1vZGUsIHNvIGVhdCBhbnkgc3BhY2VzIGZpcnN0LlxuICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7IC8vIExleCB0aGUgZmlyc3QgdG9rZW5cblxuICAgICAgdmFyIGxleCA9IHRoaXMubmV4dFRva2VuO1xuXG4gICAgICBpZiAobGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiIHx8IGxleC50ZXh0ID09PSBcIlxcXFxub2xpbWl0c1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIGxpbWl0IGNvbnRyb2xcbiAgICAgICAgdmFyIG9wTm9kZSA9IGNoZWNrTm9kZVR5cGUoYmFzZSwgXCJvcFwiKTtcblxuICAgICAgICBpZiAob3BOb2RlKSB7XG4gICAgICAgICAgdmFyIGxpbWl0cyA9IGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIjtcbiAgICAgICAgICBvcE5vZGUubGltaXRzID0gbGltaXRzO1xuICAgICAgICAgIG9wTm9kZS5hbHdheXNIYW5kbGVTdXBTdWIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkxpbWl0IGNvbnRyb2xzIG11c3QgZm9sbG93IGEgbWF0aCBvcGVyYXRvclwiLCBsZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIl5cIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBzdXBlcnNjcmlwdCBzdGFydFxuICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJEb3VibGUgc3VwZXJzY3JpcHRcIiwgbGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyc2NyaXB0ID0gdGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdXBlcnNjcmlwdFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobGV4LnRleHQgPT09IFwiX1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIHN1YnNjcmlwdCBzdGFydFxuICAgICAgICBpZiAoc3Vic2NyaXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRG91YmxlIHN1YnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3Vic2NyaXB0ID0gdGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdWJzY3JpcHRcIik7XG4gICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIidcIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBwcmltZVxuICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJEb3VibGUgc3VwZXJzY3JpcHRcIiwgbGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmltZSA9IHtcbiAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgdGV4dDogXCJcXFxccHJpbWVcIlxuICAgICAgICB9OyAvLyBNYW55IHByaW1lcyBjYW4gYmUgZ3JvdXBlZCB0b2dldGhlciwgc28gd2UgaGFuZGxlIHRoaXMgaGVyZVxuXG4gICAgICAgIHZhciBwcmltZXMgPSBbcHJpbWVdO1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTsgLy8gS2VlcCBsZXhpbmcgdG9rZW5zIHVudGlsIHdlIGdldCBzb21ldGhpbmcgdGhhdCdzIG5vdCBhIHByaW1lXG5cbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dFRva2VuLnRleHQgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgLy8gRm9yIGVhY2ggb25lLCBhZGQgYW5vdGhlciBwcmltZSB0byB0aGUgbGlzdFxuICAgICAgICAgIHByaW1lcy5wdXNoKHByaW1lKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfSAvLyBJZiB0aGVyZSdzIGEgc3VwZXJzY3JpcHQgZm9sbG93aW5nIHRoZSBwcmltZXMsIGNvbWJpbmUgdGhhdFxuICAgICAgICAvLyBzdXBlcnNjcmlwdCBpbiB3aXRoIHRoZSBwcmltZXMuXG5cblxuICAgICAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCA9PT0gXCJeXCIpIHtcbiAgICAgICAgICBwcmltZXMucHVzaCh0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1cGVyc2NyaXB0XCIpKTtcbiAgICAgICAgfSAvLyBQdXQgZXZlcnl0aGluZyBpbnRvIGFuIG9yZGdyb3VwIGFzIHRoZSBzdXBlcnNjcmlwdFxuXG5cbiAgICAgICAgc3VwZXJzY3JpcHQgPSB7XG4gICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBib2R5OiBwcmltZXNcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGl0IHdhc24ndCBeLCBfLCBvciAnLCBzdG9wIHBhcnNpbmcgc3VwZXIvc3Vic2NyaXB0c1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIEJhc2UgbXVzdCBiZSBzZXQgaWYgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0IGFyZSBzZXQgcGVyIGxvZ2ljIGFib3ZlLFxuICAgIC8vIGJ1dCBuZWVkIHRvIGNoZWNrIGhlcmUgZm9yIHR5cGUgY2hlY2sgdG8gcGFzcy5cblxuXG4gICAgaWYgKHN1cGVyc2NyaXB0IHx8IHN1YnNjcmlwdCkge1xuICAgICAgLy8gSWYgd2UgZ290IGVpdGhlciBhIHN1cGVyc2NyaXB0IG9yIHN1YnNjcmlwdCwgY3JlYXRlIGEgc3Vwc3ViXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1cHN1YlwiLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHN1cDogc3VwZXJzY3JpcHQsXG4gICAgICAgIHN1Yjogc3Vic2NyaXB0XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIHRoZSBvcmlnaW5hbCBib2R5XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBlbnRpcmUgZnVuY3Rpb24sIGluY2x1ZGluZyBpdHMgYmFzZSBhbmQgYWxsIG9mIGl0cyBhcmd1bWVudHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlRnVuY3Rpb24gPSBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uKGJyZWFrT25Ub2tlblRleHQsIG5hbWUsIC8vIEZvciBlcnJvciByZXBvcnRpbmcuXG4gIGdyZWVkaW5lc3MpIHtcbiAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB2YXIgZnVuYyA9IHRva2VuLnRleHQ7XG4gICAgdmFyIGZ1bmNEYXRhID0gc3JjX2Z1bmN0aW9uc1tmdW5jXTtcblxuICAgIGlmICghZnVuY0RhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChncmVlZGluZXNzICE9IG51bGwgJiYgZnVuY0RhdGEuZ3JlZWRpbmVzcyA8PSBncmVlZGluZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJHb3QgZnVuY3Rpb24gJ1wiICsgZnVuYyArIFwiJyB3aXRoIG5vIGFyZ3VtZW50c1wiICsgKG5hbWUgPyBcIiBhcyBcIiArIG5hbWUgOiBcIlwiKSwgdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIiAmJiAhZnVuY0RhdGEuYWxsb3dlZEluVGV4dCkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiQ2FuJ3QgdXNlIGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgaW4gdGV4dCBtb2RlXCIsIHRva2VuKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gXCJtYXRoXCIgJiYgZnVuY0RhdGEuYWxsb3dlZEluTWF0aCA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkNhbid0IHVzZSBmdW5jdGlvbiAnXCIgKyBmdW5jICsgXCInIGluIG1hdGggbW9kZVwiLCB0b2tlbik7XG4gICAgfSAvLyBoeXBlcnJlZiBwYWNrYWdlIHNldHMgdGhlIGNhdGNvZGUgb2YgJSBhcyBhbiBhY3RpdmUgY2hhcmFjdGVyXG5cblxuICAgIGlmIChmdW5jRGF0YS5hcmdUeXBlcyAmJiBmdW5jRGF0YS5hcmdUeXBlc1swXSA9PT0gXCJ1cmxcIikge1xuICAgICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZShcIiVcIiwgMTMpO1xuICAgIH0gLy8gQ29uc3VtZSB0aGUgY29tbWFuZCB0b2tlbiBhZnRlciBwb3NzaWJseSBzd2l0Y2hpbmcgdG8gdGhlXG4gICAgLy8gbW9kZSBzcGVjaWZpZWQgYnkgdGhlIGZ1bmN0aW9uIChmb3IgaW5zdGFudCBtb2RlIHN3aXRjaGluZyksXG4gICAgLy8gYW5kIHRoZW4gaW1tZWRpYXRlbHkgc3dpdGNoIGJhY2suXG5cblxuICAgIGlmIChmdW5jRGF0YS5jb25zdW1lTW9kZSkge1xuICAgICAgdmFyIG9sZE1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICB0aGlzLnN3aXRjaE1vZGUoZnVuY0RhdGEuY29uc3VtZU1vZGUpO1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB0aGlzLnN3aXRjaE1vZGUob2xkTW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRwYXJzZUFyZ3VtZW50cyA9IHRoaXMucGFyc2VBcmd1bWVudHMoZnVuYywgZnVuY0RhdGEpLFxuICAgICAgICBhcmdzID0gX3RoaXMkcGFyc2VBcmd1bWVudHMuYXJncyxcbiAgICAgICAgb3B0QXJncyA9IF90aGlzJHBhcnNlQXJndW1lbnRzLm9wdEFyZ3M7XG5cbiAgICByZXR1cm4gdGhpcy5jYWxsRnVuY3Rpb24oZnVuYywgYXJncywgb3B0QXJncywgdG9rZW4sIGJyZWFrT25Ub2tlblRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gaGFuZGxlciB3aXRoIGEgc3VpdGFibGUgY29udGV4dCBhbmQgYXJndW1lbnRzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jYWxsRnVuY3Rpb24gPSBmdW5jdGlvbiBjYWxsRnVuY3Rpb24obmFtZSwgYXJncywgb3B0QXJncywgdG9rZW4sIGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgIGZ1bmNOYW1lOiBuYW1lLFxuICAgICAgcGFyc2VyOiB0aGlzLFxuICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgYnJlYWtPblRva2VuVGV4dDogYnJlYWtPblRva2VuVGV4dFxuICAgIH07XG4gICAgdmFyIGZ1bmMgPSBzcmNfZnVuY3Rpb25zW25hbWVdO1xuXG4gICAgaWYgKGZ1bmMgJiYgZnVuYy5oYW5kbGVyKSB7XG4gICAgICByZXR1cm4gZnVuYy5oYW5kbGVyKGNvbnRleHQsIGFyZ3MsIG9wdEFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJObyBmdW5jdGlvbiBoYW5kbGVyIGZvciBcIiArIG5hbWUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFyc2VzIHRoZSBhcmd1bWVudHMgb2YgYSBmdW5jdGlvbiBvciBlbnZpcm9ubWVudFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZUFyZ3VtZW50cyA9IGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKGZ1bmMsIC8vIFNob3VsZCBsb29rIGxpa2UgXCJcXG5hbWVcIiBvciBcIlxcYmVnaW57bmFtZX1cIi5cbiAgZnVuY0RhdGEpIHtcbiAgICB2YXIgdG90YWxBcmdzID0gZnVuY0RhdGEubnVtQXJncyArIGZ1bmNEYXRhLm51bU9wdGlvbmFsQXJncztcblxuICAgIGlmICh0b3RhbEFyZ3MgPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICBvcHRBcmdzOiBbXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZUdyZWVkaW5lc3MgPSBmdW5jRGF0YS5ncmVlZGluZXNzO1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIG9wdEFyZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxBcmdzOyBpKyspIHtcbiAgICAgIHZhciBhcmdUeXBlID0gZnVuY0RhdGEuYXJnVHlwZXMgJiYgZnVuY0RhdGEuYXJnVHlwZXNbaV07XG4gICAgICB2YXIgaXNPcHRpb25hbCA9IGkgPCBmdW5jRGF0YS5udW1PcHRpb25hbEFyZ3M7IC8vIElnbm9yZSBzcGFjZXMgYmV0d2VlbiBhcmd1bWVudHMuICBBcyB0aGUgVGVYYm9vayBzYXlzOlxuICAgICAgLy8gXCJBZnRlciB5b3UgaGF2ZSBzYWlkIOKAmFxcZGVmXFxyb3cjMSMyey4uLn3igJksIHlvdSBhcmUgYWxsb3dlZCB0b1xuICAgICAgLy8gIHB1dCBzcGFjZXMgYmV0d2VlbiB0aGUgYXJndW1lbnRzIChlLmcuLCDigJhcXHJvdyB4IG7igJkpLCBiZWNhdXNlXG4gICAgICAvLyAgVGVYIGRvZXNu4oCZdCB1c2Ugc2luZ2xlIHNwYWNlcyBhcyB1bmRlbGltaXRlZCBhcmd1bWVudHMuXCJcblxuICAgICAgaWYgKGkgPiAwICYmICFpc09wdGlvbmFsKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpO1xuICAgICAgfSAvLyBBbHNvIGNvbnN1bWUgbGVhZGluZyBzcGFjZXMgaW4gbWF0aCBtb2RlLCBhcyBwYXJzZVN5bWJvbFxuICAgICAgLy8gd29uJ3Qga25vdyB3aGF0IHRvIGRvIHdpdGggdGhlbS4gIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHdpdGhcbiAgICAgIC8vIG1hY3JvcywgZS5nLiBcXGZyYWNcXGZvb1xcZm9vIHdoZXJlIFxcZm9vIGV4cGFuZHMgdG8gYSBzcGFjZSBzeW1ib2wuXG4gICAgICAvLyBJbiBMYVRlWCwgdGhlIFxcZm9vJ3MgZ2V0IHRyZWF0ZWQgYXMgKGJsYW5rKSBhcmd1bWVudHMpLlxuICAgICAgLy8gSW4gS2FUZVgsIGZvciBub3csIGJvdGggc3BhY2VzIHdpbGwgZ2V0IGNvbnN1bWVkLlxuICAgICAgLy8gVE9ETyhlZGVtYWluZSlcblxuXG4gICAgICBpZiAoaSA9PT0gMCAmJiAhaXNPcHRpb25hbCAmJiB0aGlzLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG4gICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZUdyb3VwT2ZUeXBlKFwiYXJndW1lbnQgdG8gJ1wiICsgZnVuYyArIFwiJ1wiLCBhcmdUeXBlLCBpc09wdGlvbmFsLCBiYXNlR3JlZWRpbmVzcyk7XG5cbiAgICAgIGlmICghYXJnKSB7XG4gICAgICAgIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICAgICAgb3B0QXJncy5wdXNoKG51bGwpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRXhwZWN0ZWQgZ3JvdXAgYWZ0ZXIgJ1wiICsgZnVuYyArIFwiJ1wiLCBuZXh0VG9rZW4pO1xuICAgICAgfVxuXG4gICAgICAoaXNPcHRpb25hbCA/IG9wdEFyZ3MgOiBhcmdzKS5wdXNoKGFyZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICBvcHRBcmdzOiBvcHRBcmdzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAgd2hlbiB0aGUgbW9kZSBpcyBjaGFuZ2luZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VHcm91cE9mVHlwZSA9IGZ1bmN0aW9uIHBhcnNlR3JvdXBPZlR5cGUobmFtZSwgdHlwZSwgb3B0aW9uYWwsIGdyZWVkaW5lc3MpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNvbG9yR3JvdXAob3B0aW9uYWwpO1xuXG4gICAgICBjYXNlIFwic2l6ZVwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNpemVHcm91cChvcHRpb25hbCk7XG5cbiAgICAgIGNhc2UgXCJ1cmxcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVcmxHcm91cChvcHRpb25hbCk7XG5cbiAgICAgIGNhc2UgXCJtYXRoXCI6XG4gICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUdyb3VwKG5hbWUsIG9wdGlvbmFsLCBncmVlZGluZXNzLCB1bmRlZmluZWQsIHR5cGUpO1xuXG4gICAgICBjYXNlIFwicmF3XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAob3B0aW9uYWwgJiYgdGhpcy5uZXh0VG9rZW4udGV4dCA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMucGFyc2VTdHJpbmdHcm91cChcInJhd1wiLCBvcHRpb25hbCwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwicmF3XCIsXG4gICAgICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICBzdHJpbmc6IHRva2VuLnRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkV4cGVjdGVkIHJhdyBncm91cFwiLCB0aGlzLm5leHRUb2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJvcmlnaW5hbFwiOlxuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlR3JvdXAobmFtZSwgb3B0aW9uYWwsIGdyZWVkaW5lc3MpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJVbmtub3duIGdyb3VwIHR5cGUgYXMgXCIgKyBuYW1lLCB0aGlzLm5leHRUb2tlbik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb25zdW1lU3BhY2VzID0gZnVuY3Rpb24gY29uc3VtZVNwYWNlcygpIHtcbiAgICB3aGlsZSAodGhpcy5uZXh0VG9rZW4udGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAsIGVzc2VudGlhbGx5IHJldHVybmluZyB0aGUgc3RyaW5nIGZvcm1lZCBieSB0aGVcbiAgICogYnJhY2UtZW5jbG9zZWQgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VTdHJpbmdHcm91cCA9IGZ1bmN0aW9uIHBhcnNlU3RyaW5nR3JvdXAobW9kZU5hbWUsIC8vIFVzZWQgdG8gZGVzY3JpYmUgdGhlIG1vZGUgaW4gZXJyb3IgbWVzc2FnZXMuXG4gIG9wdGlvbmFsLCByYXcpIHtcbiAgICB2YXIgZ3JvdXBCZWdpbiA9IG9wdGlvbmFsID8gXCJbXCIgOiBcIntcIjtcbiAgICB2YXIgZ3JvdXBFbmQgPSBvcHRpb25hbCA/IFwiXVwiIDogXCJ9XCI7XG4gICAgdmFyIG5leHRUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuXG4gICAgaWYgKG5leHRUb2tlbi50ZXh0ICE9PSBncm91cEJlZ2luKSB7XG4gICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHJhdyAmJiBuZXh0VG9rZW4udGV4dCAhPT0gXCJFT0ZcIiAmJiAvW157fVtcXF1dLy50ZXN0KG5leHRUb2tlbi50ZXh0KSkge1xuICAgICAgICAvLyBhbGxvdyBhIHNpbmdsZSBjaGFyYWN0ZXIgaW4gcmF3IHN0cmluZyBncm91cFxuICAgICAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiJVwiLCAxNCk7IC8vIHJlc2V0IHRoZSBjYXRjb2RlIG9mICVcblxuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgcmV0dXJuIG5leHRUb2tlbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb3V0ZXJNb2RlID0gdGhpcy5tb2RlO1xuICAgIHRoaXMubW9kZSA9IFwidGV4dFwiO1xuICAgIHRoaXMuZXhwZWN0KGdyb3VwQmVnaW4pO1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHZhciBmaXJzdFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG4gICAgdmFyIG5lc3RlZCA9IDA7IC8vIGFsbG93IG5lc3RlZCBicmFjZXMgaW4gcmF3IHN0cmluZyBncm91cFxuXG4gICAgdmFyIGxhc3RUb2tlbiA9IGZpcnN0VG9rZW47XG5cbiAgICB3aGlsZSAocmF3ICYmIG5lc3RlZCA+IDAgfHwgdGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gZ3JvdXBFbmQpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5uZXh0VG9rZW4udGV4dCkge1xuICAgICAgICBjYXNlIFwiRU9GXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQgaW4gXCIgKyBtb2RlTmFtZSwgZmlyc3RUb2tlbi5yYW5nZShsYXN0VG9rZW4sIHN0cikpO1xuXG4gICAgICAgIGNhc2UgZ3JvdXBCZWdpbjpcbiAgICAgICAgICBuZXN0ZWQrKztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGdyb3VwRW5kOlxuICAgICAgICAgIG5lc3RlZC0tO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsYXN0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICAgIHN0ciArPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cblxuICAgIHRoaXMubW9kZSA9IG91dGVyTW9kZTtcbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiJVwiLCAxNCk7IC8vIHJlc2V0IHRoZSBjYXRjb2RlIG9mICVcblxuICAgIHRoaXMuZXhwZWN0KGdyb3VwRW5kKTtcbiAgICByZXR1cm4gZmlyc3RUb2tlbi5yYW5nZShsYXN0VG9rZW4sIHN0cik7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHJlZ2V4LWRlbGltaXRlZCBncm91cDogdGhlIGxhcmdlc3Qgc2VxdWVuY2Ugb2YgdG9rZW5zXG4gICAqIHdob3NlIGNvbmNhdGVuYXRlZCBzdHJpbmdzIG1hdGNoIGByZWdleGAuIFJldHVybnMgdGhlIHN0cmluZ1xuICAgKiBmb3JtZWQgYnkgdGhlIHRva2VucyBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlUmVnZXhHcm91cCA9IGZ1bmN0aW9uIHBhcnNlUmVnZXhHcm91cChyZWdleCwgbW9kZU5hbWUpIHtcbiAgICB2YXIgb3V0ZXJNb2RlID0gdGhpcy5tb2RlO1xuICAgIHRoaXMubW9kZSA9IFwidGV4dFwiO1xuICAgIHZhciBmaXJzdFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG4gICAgdmFyIGxhc3RUb2tlbiA9IGZpcnN0VG9rZW47XG4gICAgdmFyIHN0ciA9IFwiXCI7XG5cbiAgICB3aGlsZSAodGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gXCJFT0ZcIiAmJiByZWdleC50ZXN0KHN0ciArIHRoaXMubmV4dFRva2VuLnRleHQpKSB7XG4gICAgICBsYXN0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICAgIHN0ciArPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cblxuICAgIGlmIChzdHIgPT09IFwiXCIpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgXCIgKyBtb2RlTmFtZSArIFwiOiAnXCIgKyBmaXJzdFRva2VuLnRleHQgKyBcIidcIiwgZmlyc3RUb2tlbik7XG4gICAgfVxuXG4gICAgdGhpcy5tb2RlID0gb3V0ZXJNb2RlO1xuICAgIHJldHVybiBmaXJzdFRva2VuLnJhbmdlKGxhc3RUb2tlbiwgc3RyKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgY29sb3IgZGVzY3JpcHRpb24uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlQ29sb3JHcm91cCA9IGZ1bmN0aW9uIHBhcnNlQ29sb3JHcm91cChvcHRpb25hbCkge1xuICAgIHZhciByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJjb2xvclwiLCBvcHRpb25hbCk7XG5cbiAgICBpZiAoIXJlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gL14oI1thLWYwLTldezN9fCM/W2EtZjAtOV17Nn18W2Etel0rKSQvaS5leGVjKHJlcy50ZXh0KTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgY29sb3I6ICdcIiArIHJlcy50ZXh0ICsgXCInXCIsIHJlcyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yID0gbWF0Y2hbMF07XG5cbiAgICBpZiAoL15bMC05YS1mXXs2fSQvaS50ZXN0KGNvbG9yKSkge1xuICAgICAgLy8gV2UgYWxsb3cgYSA2LWRpZ2l0IEhUTUwgY29sb3Igc3BlYyB3aXRob3V0IGEgbGVhZGluZyBcIiNcIi5cbiAgICAgIC8vIFRoaXMgZm9sbG93cyB0aGUgeGNvbG9yIHBhY2thZ2UncyBIVE1MIGNvbG9yIG1vZGVsLlxuICAgICAgLy8gUHJlZGVmaW5lZCBjb2xvciBuYW1lcyBhcmUgYWxsIG1pc3NlZCBieSB0aGlzIFJlZ0V4IHBhdHRlcm4uXG4gICAgICBjb2xvciA9IFwiI1wiICsgY29sb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29sb3ItdG9rZW5cIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGNvbG9yOiBjb2xvclxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHNpemUgc3BlY2lmaWNhdGlvbiwgY29uc2lzdGluZyBvZiBtYWduaXR1ZGUgYW5kIHVuaXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBhcnNlU2l6ZUdyb3VwID0gZnVuY3Rpb24gcGFyc2VTaXplR3JvdXAob3B0aW9uYWwpIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBpc0JsYW5rID0gZmFsc2U7XG5cbiAgICBpZiAoIW9wdGlvbmFsICYmIHRoaXMubmV4dFRva2VuLnRleHQgIT09IFwie1wiKSB7XG4gICAgICByZXMgPSB0aGlzLnBhcnNlUmVnZXhHcm91cCgvXlstK10/ICooPzokfFxcZCt8XFxkK1xcLlxcZCp8XFwuXFxkKikgKlthLXpdezAsMn0gKiQvLCBcInNpemVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHRoaXMucGFyc2VTdHJpbmdHcm91cChcInNpemVcIiwgb3B0aW9uYWwpO1xuICAgIH1cblxuICAgIGlmICghcmVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbmFsICYmIHJlcy50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gQmVjYXVzZSB3ZSd2ZSB0ZXN0ZWQgZm9yIHdoYXQgaXMgIW9wdGlvbmFsLCB0aGlzIGJsb2NrIHdvbid0XG4gICAgICAvLyBhZmZlY3QgXFxrZXJuLCBcXGhzcGFjZSwgZXRjLiBJdCB3aWxsIGNhcHR1cmUgdGhlIG1hbmRhdG9yeSBhcmd1bWVudHNcbiAgICAgIC8vIHRvIFxcZ2VuZnJhYyBhbmQgXFxhYm92ZS5cbiAgICAgIHJlcy50ZXh0ID0gXCIwcHRcIjsgLy8gRW5hYmxlIFxcYWJvdmV7fVxuXG4gICAgICBpc0JsYW5rID0gdHJ1ZTsgLy8gVGhpcyBpcyBoZXJlIHNwZWNpZmljYWxseSBmb3IgXFxnZW5mcmFjXG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gLyhbLStdPykgKihcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspICooW2Etel17Mn0pLy5leGVjKHJlcy50ZXh0KTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIkludmFsaWQgc2l6ZTogJ1wiICsgcmVzLnRleHQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIG51bWJlcjogKyhtYXRjaFsxXSArIG1hdGNoWzJdKSxcbiAgICAgIC8vIHNpZ24gKyBtYWduaXR1ZGUsIGNhc3QgdG8gbnVtYmVyXG4gICAgICB1bml0OiBtYXRjaFszXVxuICAgIH07XG5cbiAgICBpZiAoIXZhbGlkVW5pdChkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBkYXRhLnVuaXQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzaXplXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICAgIGlzQmxhbms6IGlzQmxhbmtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gVVJMLCBjaGVja2luZyBlc2NhcGVkIGxldHRlcnMgYW5kIGFsbG93ZWQgcHJvdG9jb2xzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wYXJzZVVybEdyb3VwID0gZnVuY3Rpb24gcGFyc2VVcmxHcm91cChvcHRpb25hbCkge1xuICAgIHZhciByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJ1cmxcIiwgb3B0aW9uYWwsIHRydWUpOyAvLyBnZXQgcmF3IHN0cmluZ1xuXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gaHlwZXJyZWYgcGFja2FnZSBhbGxvd3MgYmFja3NsYXNoZXMgYWxvbmUgaW4gaHJlZiwgYnV0IGRvZXNuJ3RcbiAgICAvLyBnZW5lcmF0ZSB2YWxpZCBsaW5rcyBpbiBzdWNoIGNhc2VzOyB3ZSBpbnRlcnByZXQgdGhpcyBhc1xuICAgIC8vIFwidW5kZWZpbmVkXCIgYmVoYXZpb3VyLCBhbmQga2VlcCB0aGVtIGFzLWlzLiBTb21lIGJyb3dzZXIgd2lsbFxuICAgIC8vIHJlcGxhY2UgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkIHNsYXNoZXMuXG5cblxuICAgIHZhciB1cmwgPSByZXMudGV4dC5yZXBsYWNlKC9cXFxcKFsjJCUmfl9ee31dKS9nLCAnJDEnKTtcbiAgICB2YXIgcHJvdG9jb2wgPSAvXlxccyooW15cXFxcLyNdKj8pKD86OnwmIzAqNTh8JiN4MCozYSkvaS5leGVjKHVybCk7XG4gICAgcHJvdG9jb2wgPSBwcm90b2NvbCAhPSBudWxsID8gcHJvdG9jb2xbMV0gOiBcIl9yZWxhdGl2ZVwiO1xuICAgIHZhciBhbGxvd2VkID0gdGhpcy5zZXR0aW5ncy5hbGxvd2VkUHJvdG9jb2xzO1xuXG4gICAgaWYgKCF1dGlscy5jb250YWlucyhhbGxvd2VkLCBcIipcIikgJiYgIXV0aWxzLmNvbnRhaW5zKGFsbG93ZWQsIHByb3RvY29sKSkge1xuICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiRm9yYmlkZGVuIHByb3RvY29sICdcIiArIHByb3RvY29sICsgXCInXCIsIHJlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidXJsXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICB1cmw6IHVybFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIElmIGBvcHRpb25hbGAgaXMgZmFsc2Ugb3IgYWJzZW50LCB0aGlzIHBhcnNlcyBhbiBvcmRpbmFyeSBncm91cCxcbiAgICogd2hpY2ggaXMgZWl0aGVyIGEgc2luZ2xlIG51Y2xldXMgKGxpa2UgXCJ4XCIpIG9yIGFuIGV4cHJlc3Npb25cbiAgICogaW4gYnJhY2VzIChsaWtlIFwie3greX1cIikgb3IgYW4gaW1wbGljaXQgZ3JvdXAsIGEgZ3JvdXAgdGhhdCBzdGFydHNcbiAgICogYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCBlbmRzIHJpZ2h0IGJlZm9yZSBhIGhpZ2hlciBleHBsaWNpdFxuICAgKiBncm91cCBlbmRzLCBvciBhdCBFT0YuXG4gICAqIElmIGBvcHRpb25hbGAgaXMgdHJ1ZSwgaXQgcGFyc2VzIGVpdGhlciBhIGJyYWNrZXQtZGVsaW1pdGVkIGV4cHJlc3Npb25cbiAgICogKGxpa2UgXCJbeCt5XVwiKSBvciByZXR1cm5zIG51bGwgdG8gaW5kaWNhdGUgdGhlIGFic2VuY2Ugb2YgYVxuICAgKiBicmFja2V0LWVuY2xvc2VkIGdyb3VwLlxuICAgKiBJZiBgbW9kZWAgaXMgcHJlc2VudCwgc3dpdGNoZXMgdG8gdGhhdCBtb2RlIHdoaWxlIHBhcnNpbmcgdGhlIGdyb3VwLFxuICAgKiBhbmQgc3dpdGNoZXMgYmFjayBhZnRlci5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VHcm91cCA9IGZ1bmN0aW9uIHBhcnNlR3JvdXAobmFtZSwgLy8gRm9yIGVycm9yIHJlcG9ydGluZy5cbiAgb3B0aW9uYWwsIGdyZWVkaW5lc3MsIGJyZWFrT25Ub2tlblRleHQsIG1vZGUpIHtcbiAgICB2YXIgb3V0ZXJNb2RlID0gdGhpcy5tb2RlO1xuICAgIHZhciBmaXJzdFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG4gICAgdmFyIHRleHQgPSBmaXJzdFRva2VuLnRleHQ7IC8vIFN3aXRjaCB0byBzcGVjaWZpZWQgbW9kZVxuXG4gICAgaWYgKG1vZGUpIHtcbiAgICAgIHRoaXMuc3dpdGNoTW9kZShtb2RlKTtcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXBFbmQ7XG4gICAgdmFyIHJlc3VsdDsgLy8gVHJ5IHRvIHBhcnNlIGFuIG9wZW4gYnJhY2Ugb3IgXFxiZWdpbmdyb3VwXG5cbiAgICBpZiAob3B0aW9uYWwgPyB0ZXh0ID09PSBcIltcIiA6IHRleHQgPT09IFwie1wiIHx8IHRleHQgPT09IFwiXFxcXGJlZ2luZ3JvdXBcIikge1xuICAgICAgZ3JvdXBFbmQgPSBQYXJzZXIuZW5kT2ZHcm91cFt0ZXh0XTsgLy8gU3RhcnQgYSBuZXcgZ3JvdXAgbmFtZXNwYWNlXG5cbiAgICAgIHRoaXMuZ3VsbGV0LmJlZ2luR3JvdXAoKTsgLy8gSWYgd2UgZ2V0IGEgYnJhY2UsIHBhcnNlIGFuIGV4cHJlc3Npb25cblxuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBncm91cEVuZCk7XG4gICAgICB2YXIgbGFzdFRva2VuID0gdGhpcy5uZXh0VG9rZW47IC8vIEVuZCBncm91cCBuYW1lc3BhY2UgYmVmb3JlIGNvbnN1bWluZyBzeW1ib2wgYWZ0ZXIgY2xvc2UgYnJhY2VcblxuICAgICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoZmlyc3RUb2tlbiwgbGFzdFRva2VuKSxcbiAgICAgICAgYm9keTogZXhwcmVzc2lvbixcbiAgICAgICAgLy8gQSBncm91cCBmb3JtZWQgYnkgXFxiZWdpbmdyb3VwLi4uXFxlbmRncm91cCBpcyBhIHNlbWktc2ltcGxlIGdyb3VwXG4gICAgICAgIC8vIHdoaWNoIGRvZXNuJ3QgYWZmZWN0IHNwYWNpbmcgaW4gbWF0aCBtb2RlLCBpLmUuLCBpcyB0cmFuc3BhcmVudC5cbiAgICAgICAgLy8gaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE5MzAvd2hlbi1zaG91bGQtb25lLVxuICAgICAgICAvLyB1c2UtYmVnaW5ncm91cC1pbnN0ZWFkLW9mLWJncm91cFxuICAgICAgICBzZW1pc2ltcGxlOiB0ZXh0ID09PSBcIlxcXFxiZWdpbmdyb3VwXCIgfHwgdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0aW9uYWwpIHtcbiAgICAgIC8vIFJldHVybiBub3RoaW5nIGZvciBhbiBvcHRpb25hbCBncm91cFxuICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUgZXhpc3RzIGEgZnVuY3Rpb24gd2l0aCB0aGlzIG5hbWUsIHBhcnNlIHRoZSBmdW5jdGlvbi5cbiAgICAgIC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gYSBudWNsZXVzXG4gICAgICByZXN1bHQgPSB0aGlzLnBhcnNlRnVuY3Rpb24oYnJlYWtPblRva2VuVGV4dCwgbmFtZSwgZ3JlZWRpbmVzcykgfHwgdGhpcy5wYXJzZVN5bWJvbCgpO1xuXG4gICAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgdGV4dFswXSA9PT0gXCJcXFxcXCIgJiYgIWltcGxpY2l0Q29tbWFuZHMuaGFzT3duUHJvcGVydHkodGV4dCkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNyY19QYXJzZUVycm9yKFwiVW5kZWZpbmVkIGNvbnRyb2wgc2VxdWVuY2U6IFwiICsgdGV4dCwgZmlyc3RUb2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSB0aGlzLmhhbmRsZVVuc3VwcG9ydGVkQ21kKCk7XG4gICAgICB9XG4gICAgfSAvLyBTd2l0Y2ggbW9kZSBiYWNrXG5cblxuICAgIGlmIChtb2RlKSB7XG4gICAgICB0aGlzLnN3aXRjaE1vZGUob3V0ZXJNb2RlKTtcbiAgICB9IC8vIE1ha2Ugc3VyZSB3ZSBnb3QgYSBjbG9zZSBicmFjZVxuXG5cbiAgICBpZiAoZ3JvdXBFbmQpIHtcbiAgICAgIHRoaXMuZXhwZWN0KGdyb3VwRW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBGb3JtIGxpZ2F0dXJlLWxpa2UgY29tYmluYXRpb25zIG9mIGNoYXJhY3RlcnMgZm9yIHRleHQgbW9kZS5cbiAgICogVGhpcyBpbmNsdWRlcyBpbnB1dHMgbGlrZSBcIi0tXCIsIFwiLS0tXCIsIFwiYGBcIiBhbmQgXCInJ1wiLlxuICAgKiBUaGUgcmVzdWx0IHdpbGwgc2ltcGx5IHJlcGxhY2UgbXVsdGlwbGUgdGV4dG9yZCBub2RlcyB3aXRoIGEgc2luZ2xlXG4gICAqIGNoYXJhY3RlciBpbiBlYWNoIHZhbHVlIGJ5IGEgc2luZ2xlIHRleHRvcmQgbm9kZSBoYXZpbmcgbXVsdGlwbGVcbiAgICogY2hhcmFjdGVycyBpbiBpdHMgdmFsdWUuICBUaGUgcmVwcmVzZW50YXRpb24gaXMgc3RpbGwgQVNDSUkgc291cmNlLlxuICAgKiBUaGUgZ3JvdXAgd2lsbCBiZSBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZm9ybUxpZ2F0dXJlcyA9IGZ1bmN0aW9uIGZvcm1MaWdhdHVyZXMoZ3JvdXApIHtcbiAgICB2YXIgbiA9IGdyb3VwLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIGEgPSBncm91cFtpXTsgLy8gJEZsb3dGaXhNZTogTm90IGV2ZXJ5IG5vZGUgdHlwZSBoYXMgYSBgdGV4dGAgcHJvcGVydHkuXG5cbiAgICAgIHZhciB2ID0gYS50ZXh0O1xuXG4gICAgICBpZiAodiA9PT0gXCItXCIgJiYgZ3JvdXBbaSArIDFdLnRleHQgPT09IFwiLVwiKSB7XG4gICAgICAgIGlmIChpICsgMSA8IG4gJiYgZ3JvdXBbaSArIDJdLnRleHQgPT09IFwiLVwiKSB7XG4gICAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDMsIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGEsIGdyb3VwW2kgKyAyXSksXG4gICAgICAgICAgICB0ZXh0OiBcIi0tLVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbiAtPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMV0pLFxuICAgICAgICAgICAgdGV4dDogXCItLVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbiAtPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgodiA9PT0gXCInXCIgfHwgdiA9PT0gXCJgXCIpICYmIGdyb3VwW2kgKyAxXS50ZXh0ID09PSB2KSB7XG4gICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMV0pLFxuICAgICAgICAgIHRleHQ6IHYgKyB2XG4gICAgICAgIH0pO1xuICAgICAgICBuIC09IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIHNpbmdsZSBzeW1ib2wgb3V0IG9mIHRoZSBzdHJpbmcuIEhlcmUsIHdlIGhhbmRsZSBzaW5nbGUgY2hhcmFjdGVyXG4gICAqIHN5bWJvbHMgYW5kIHNwZWNpYWwgZnVuY3Rpb25zIGxpa2UgdmVyYmF0aW1cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucGFyc2VTeW1ib2wgPSBmdW5jdGlvbiBwYXJzZVN5bWJvbCgpIHtcbiAgICB2YXIgbnVjbGV1cyA9IHRoaXMubmV4dFRva2VuO1xuICAgIHZhciB0ZXh0ID0gbnVjbGV1cy50ZXh0O1xuXG4gICAgaWYgKC9eXFxcXHZlcmJbXmEtekEtWl0vLnRlc3QodGV4dCkpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgdmFyIGFyZyA9IHRleHQuc2xpY2UoNSk7XG4gICAgICB2YXIgc3RhciA9IGFyZy5jaGFyQXQoMCkgPT09IFwiKlwiO1xuXG4gICAgICBpZiAoc3Rhcikge1xuICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSk7XG4gICAgICB9IC8vIExleGVyJ3MgdG9rZW5SZWdleCBpcyBjb25zdHJ1Y3RlZCB0byBhbHdheXMgaGF2ZSBtYXRjaGluZ1xuICAgICAgLy8gZmlyc3QvbGFzdCBjaGFyYWN0ZXJzLlxuXG5cbiAgICAgIGlmIChhcmcubGVuZ3RoIDwgMiB8fCBhcmcuY2hhckF0KDApICE9PSBhcmcuc2xpY2UoLTEpKSB7XG4gICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlxcXFx2ZXJiIGFzc2VydGlvbiBmYWlsZWQgLS1cXG4gICAgICAgICAgICAgICAgICAgIHBsZWFzZSByZXBvcnQgd2hhdCBpbnB1dCBjYXVzZWQgdGhpcyBidWdcIik7XG4gICAgICB9XG5cbiAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7IC8vIHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBjaGFyXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidmVyYlwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgYm9keTogYXJnLFxuICAgICAgICBzdGFyOiBzdGFyXG4gICAgICB9O1xuICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGhhdmUgYSBzeW1ib2wsIHBvc3NpYmx5IHdpdGggYWNjZW50cy5cbiAgICAvLyBGaXJzdCBleHBhbmQgYW55IGFjY2VudGVkIGJhc2Ugc3ltYm9sIGFjY29yZGluZyB0byB1bmljb2RlU3ltYm9scy5cblxuXG4gICAgaWYgKHVuaWNvZGVTeW1ib2xzLmhhc093blByb3BlcnR5KHRleHRbMF0pICYmICFzcmNfc3ltYm9sc1t0aGlzLm1vZGVdW3RleHRbMF1dKSB7XG4gICAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIG5vdCBzdHJpY3QgKFhlVGVYLWNvbXBhdGlibGUpIGluIG1hdGggbW9kZS5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0cmljdCAmJiB0aGlzLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwidW5pY29kZVRleHRJbk1hdGhNb2RlXCIsIFwiQWNjZW50ZWQgVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiIHVzZWQgaW4gXCIgKyBcIm1hdGggbW9kZVwiLCBudWNsZXVzKTtcbiAgICAgIH1cblxuICAgICAgdGV4dCA9IHVuaWNvZGVTeW1ib2xzW3RleHRbMF1dICsgdGV4dC5zdWJzdHIoMSk7XG4gICAgfSAvLyBTdHJpcCBvZmYgYW55IGNvbWJpbmluZyBjaGFyYWN0ZXJzXG5cblxuICAgIHZhciBtYXRjaCA9IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya3NFbmRSZWdleC5leGVjKHRleHQpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgbWF0Y2guaW5kZXgpO1xuXG4gICAgICBpZiAodGV4dCA9PT0gJ2knKSB7XG4gICAgICAgIHRleHQgPSBcIlxcdTAxMzFcIjsgLy8gZG90bGVzcyBpLCBpbiBtYXRoIGFuZCB0ZXh0IG1vZGVcbiAgICAgIH0gZWxzZSBpZiAodGV4dCA9PT0gJ2onKSB7XG4gICAgICAgIHRleHQgPSBcIlxcdTAyMzdcIjsgLy8gZG90bGVzcyBqLCBpbiBtYXRoIGFuZCB0ZXh0IG1vZGVcbiAgICAgIH1cbiAgICB9IC8vIFJlY29nbml6ZSBiYXNlIHN5bWJvbFxuXG5cbiAgICB2YXIgc3ltYm9sO1xuXG4gICAgaWYgKHNyY19zeW1ib2xzW3RoaXMubW9kZV1bdGV4dF0pIHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0cmljdCAmJiB0aGlzLm1vZGUgPT09ICdtYXRoJyAmJiBleHRyYUxhdGluLmluZGV4T2YodGV4dCkgPj0gMCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcInVuaWNvZGVUZXh0SW5NYXRoTW9kZVwiLCBcIkxhdGluLTEvVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiIHVzZWQgaW4gXCIgKyBcIm1hdGggbW9kZVwiLCBudWNsZXVzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyb3VwID0gc3JjX3N5bWJvbHNbdGhpcy5tb2RlXVt0ZXh0XS5ncm91cDtcbiAgICAgIHZhciBsb2MgPSBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKTtcbiAgICAgIHZhciBzO1xuXG4gICAgICBpZiAoQVRPTVMuaGFzT3duUHJvcGVydHkoZ3JvdXApKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgdmFyIGZhbWlseSA9IGdyb3VwO1xuICAgICAgICBzID0ge1xuICAgICAgICAgIHR5cGU6IFwiYXRvbVwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBmYW1pbHk6IGZhbWlseSxcbiAgICAgICAgICBsb2M6IGxvYyxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIHMgPSB7XG4gICAgICAgICAgdHlwZTogZ3JvdXAsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGxvYzogbG9jLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc3ltYm9sID0gcztcbiAgICB9IGVsc2UgaWYgKHRleHQuY2hhckNvZGVBdCgwKSA+PSAweDgwKSB7XG4gICAgICAvLyBubyBzeW1ib2wgZm9yIGUuZy4gXlxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICAgIGlmICghc3VwcG9ydGVkQ29kZXBvaW50KHRleHQuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcInVua25vd25TeW1ib2xcIiwgXCJVbnJlY29nbml6ZWQgVW5pY29kZSBjaGFyYWN0ZXIgXFxcIlwiICsgdGV4dFswXSArIFwiXFxcIlwiICsgKFwiIChcIiArIHRleHQuY2hhckNvZGVBdCgwKSArIFwiKVwiKSwgbnVjbGV1cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwidW5pY29kZVRleHRJbk1hdGhNb2RlXCIsIFwiVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiIHVzZWQgaW4gbWF0aCBtb2RlXCIsIG51Y2xldXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN5bWJvbCA9IHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKSxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIEVPRiwgXiwgXywgeywgfSwgZXRjLlxuICAgIH1cblxuICAgIHRoaXMuY29uc3VtZSgpOyAvLyBUcmFuc2Zvcm0gY29tYmluaW5nIGNoYXJhY3RlcnMgaW50byBhY2NlbnRzXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFjY2VudCA9IG1hdGNoWzBdW2ldO1xuXG4gICAgICAgIGlmICghdW5pY29kZUFjY2VudHNbYWNjZW50XSkge1xuICAgICAgICAgIHRocm93IG5ldyBzcmNfUGFyc2VFcnJvcihcIlVua25vd24gYWNjZW50ICcgXCIgKyBhY2NlbnQgKyBcIidcIiwgbnVjbGV1cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tbWFuZCA9IHVuaWNvZGVBY2NlbnRzW2FjY2VudF1bdGhpcy5tb2RlXTtcblxuICAgICAgICBpZiAoIWNvbW1hbmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJBY2NlbnQgXCIgKyBhY2NlbnQgKyBcIiB1bnN1cHBvcnRlZCBpbiBcIiArIHRoaXMubW9kZSArIFwiIG1vZGVcIiwgbnVjbGV1cyk7XG4gICAgICAgIH1cblxuICAgICAgICBzeW1ib2wgPSB7XG4gICAgICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKSxcbiAgICAgICAgICBsYWJlbDogY29tbWFuZCxcbiAgICAgICAgICBpc1N0cmV0Y2h5OiBmYWxzZSxcbiAgICAgICAgICBpc1NoaWZ0eTogdHJ1ZSxcbiAgICAgICAgICBiYXNlOiBzeW1ib2xcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3ltYm9sO1xuICB9O1xuXG4gIHJldHVybiBQYXJzZXI7XG59KCk7XG5cblBhcnNlcl9QYXJzZXIuZW5kT2ZFeHByZXNzaW9uID0gW1wifVwiLCBcIlxcXFxlbmRncm91cFwiLCBcIlxcXFxlbmRcIiwgXCJcXFxccmlnaHRcIiwgXCImXCJdO1xuUGFyc2VyX1BhcnNlci5lbmRPZkdyb3VwID0ge1xuICBcIltcIjogXCJdXCIsXG4gIFwie1wiOiBcIn1cIixcbiAgXCJcXFxcYmVnaW5ncm91cFwiOiBcIlxcXFxlbmRncm91cFwiXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gXCJleHByZXNzaW9uXCIsIHdoaWNoIGlzIGEgbGlzdCBvZiBhdG9tcy5cbiAgICpcbiAgICogYGJyZWFrT25JbmZpeGA6IFNob3VsZCB0aGUgcGFyc2luZyBzdG9wIHdoZW4gd2UgaGl0IGluZml4IG5vZGVzPyBUaGlzXG4gICAqICAgICAgICAgICAgICAgICBoYXBwZW5zIHdoZW4gZnVuY3Rpb25zIGhhdmUgaGlnaGVyIHByZWNlbmRlbmNlIGhhbiBpbmZpeFxuICAgKiAgICAgICAgICAgICAgICAgbm9kZXMgaW4gaW1wbGljaXQgcGFyc2VzLlxuICAgKlxuICAgKiBgYnJlYWtPblRva2VuVGV4dGA6IFRoZSB0ZXh0IG9mIHRoZSB0b2tlbiB0aGF0IHRoZSBleHByZXNzaW9uIHNob3VsZCBlbmRcbiAgICogICAgICAgICAgICAgICAgICAgICB3aXRoLCBvciBgbnVsbGAgaWYgc29tZXRoaW5nIGVsc2Ugc2hvdWxkIGVuZCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLlxuICAgKi9cblxufTtcblBhcnNlcl9QYXJzZXIuU1VQU1VCX0dSRUVESU5FU1MgPSAxO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9wYXJzZVRyZWUuanNcbi8qKlxuICogUHJvdmlkZXMgYSBzaW5nbGUgZnVuY3Rpb24gZm9yIHBhcnNpbmcgYW4gZXhwcmVzc2lvbiB1c2luZyBhIFBhcnNlclxuICogVE9ETyhlbWlseSk6IFJlbW92ZSB0aGlzXG4gKi9cblxuXG5cbi8qKlxuICogUGFyc2VzIGFuIGV4cHJlc3Npb24gdXNpbmcgYSBQYXJzZXIsIHRoZW4gcmV0dXJucyB0aGUgcGFyc2VkIHJlc3VsdC5cbiAqL1xudmFyIHBhcnNlVHJlZV9wYXJzZVRyZWUgPSBmdW5jdGlvbiBwYXJzZVRyZWUodG9QYXJzZSwgc2V0dGluZ3MpIHtcbiAgaWYgKCEodHlwZW9mIHRvUGFyc2UgPT09ICdzdHJpbmcnIHx8IHRvUGFyc2UgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2FUZVggY2FuIG9ubHkgcGFyc2Ugc3RyaW5nIHR5cGVkIGV4cHJlc3Npb24nKTtcbiAgfVxuXG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyX1BhcnNlcih0b1BhcnNlLCBzZXR0aW5ncyk7IC8vIEJsYW5rIG91dCBhbnkgXFxkZkB0YWcgdG8gYXZvaWQgc3B1cmlvdXMgXCJEdXBsaWNhdGUgXFx0YWdcIiBlcnJvcnNcblxuICBkZWxldGUgcGFyc2VyLmd1bGxldC5tYWNyb3MuY3VycmVudFtcIlxcXFxkZkB0YWdcIl07XG4gIHZhciB0cmVlID0gcGFyc2VyLnBhcnNlKCk7IC8vIElmIHRoZSBpbnB1dCB1c2VkIFxcdGFnLCBpdCB3aWxsIHNldCB0aGUgXFxkZkB0YWcgbWFjcm8gdG8gdGhlIHRhZy5cbiAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBzZXBhcmF0ZWx5IHBhcnNlIHRoZSB0YWcgYW5kIHdyYXAgdGhlIHRyZWUuXG5cbiAgaWYgKHBhcnNlci5ndWxsZXQubWFjcm9zLmdldChcIlxcXFxkZkB0YWdcIikpIHtcbiAgICBpZiAoIXNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJcXFxcdGFnIHdvcmtzIG9ubHkgaW4gZGlzcGxheSBlcXVhdGlvbnNcIik7XG4gICAgfVxuXG4gICAgcGFyc2VyLmd1bGxldC5mZWVkKFwiXFxcXGRmQHRhZ1wiKTtcbiAgICB0cmVlID0gW3tcbiAgICAgIHR5cGU6IFwidGFnXCIsXG4gICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgIGJvZHk6IHRyZWUsXG4gICAgICB0YWc6IHBhcnNlci5wYXJzZSgpXG4gICAgfV07XG4gIH1cblxuICByZXR1cm4gdHJlZTtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19wYXJzZVRyZWUgPSAocGFyc2VUcmVlX3BhcnNlVHJlZSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2thdGV4LmpzXG4vKiBlc2xpbnQgbm8tY29uc29sZTowICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgS2FUZVguIEhlcmUsIHdlIGV4cG9zZSBmdW5jdGlvbnMgZm9yXG4gKiByZW5kZXJpbmcgZXhwcmVzc2lvbnMgZWl0aGVyIHRvIERPTSBub2RlcyBvciB0byBtYXJrdXAgc3RyaW5ncy5cbiAqXG4gKiBXZSBhbHNvIGV4cG9zZSB0aGUgUGFyc2VFcnJvciBjbGFzcyB0byBjaGVjayBpZiBlcnJvcnMgdGhyb3duIGZyb20gS2FUZVggYXJlXG4gKiBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24sIG9yIGVycm9ycyBpbiBqYXZhc2NyaXB0IGhhbmRsaW5nLlxuICovXG5cblxuXG5cblxuXG5cblxuXG5cbi8qKlxuICogUGFyc2UgYW5kIGJ1aWxkIGFuIGV4cHJlc3Npb24sIGFuZCBwbGFjZSB0aGF0IGV4cHJlc3Npb24gaW4gdGhlIERPTSBub2RlXG4gKiBnaXZlbi5cbiAqL1xudmFyIGthdGV4X3JlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihleHByZXNzaW9uLCBiYXNlTm9kZSwgb3B0aW9ucykge1xuICBiYXNlTm9kZS50ZXh0Q29udGVudCA9IFwiXCI7XG4gIHZhciBub2RlID0ga2F0ZXhfcmVuZGVyVG9Eb21UcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpLnRvTm9kZSgpO1xuICBiYXNlTm9kZS5hcHBlbmRDaGlsZChub2RlKTtcbn07IC8vIEthVGVYJ3Mgc3R5bGVzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gcXVpcmtzIG1vZGUuIFByaW50IG91dCBhbiBlcnJvciwgYW5kXG4vLyBkaXNhYmxlIHJlbmRlcmluZy5cblxuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGlmIChkb2N1bWVudC5jb21wYXRNb2RlICE9PSBcIkNTUzFDb21wYXRcIikge1xuICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihcIldhcm5pbmc6IEthVGVYIGRvZXNuJ3Qgd29yayBpbiBxdWlya3MgbW9kZS4gTWFrZSBzdXJlIHlvdXIgXCIgKyBcIndlYnNpdGUgaGFzIGEgc3VpdGFibGUgZG9jdHlwZS5cIik7XG5cbiAgICBrYXRleF9yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgc3JjX1BhcnNlRXJyb3IoXCJLYVRlWCBkb2Vzbid0IHdvcmsgaW4gcXVpcmtzIG1vZGUuXCIpO1xuICAgIH07XG4gIH1cbn1cbi8qKlxuICogUGFyc2UgYW5kIGJ1aWxkIGFuIGV4cHJlc3Npb24sIGFuZCByZXR1cm4gdGhlIG1hcmt1cCBmb3IgdGhhdC5cbiAqL1xuXG5cbnZhciByZW5kZXJUb1N0cmluZyA9IGZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgdmFyIG1hcmt1cCA9IGthdGV4X3JlbmRlclRvRG9tVHJlZShleHByZXNzaW9uLCBvcHRpb25zKS50b01hcmt1cCgpO1xuICByZXR1cm4gbWFya3VwO1xufTtcbi8qKlxuICogUGFyc2UgYW4gZXhwcmVzc2lvbiBhbmQgcmV0dXJuIHRoZSBwYXJzZSB0cmVlLlxuICovXG5cblxudmFyIGthdGV4X2dlbmVyYXRlUGFyc2VUcmVlID0gZnVuY3Rpb24gZ2VuZXJhdGVQYXJzZVRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICB2YXIgc2V0dGluZ3MgPSBuZXcgc3JjX1NldHRpbmdzKG9wdGlvbnMpO1xuICByZXR1cm4gc3JjX3BhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG59O1xuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYSBLYVRlWCBQYXJzZUVycm9yIGFuZCBvcHRpb25zLnRocm93T25FcnJvciBpcyBmYWxzZSxcbiAqIHJlbmRlcnMgdGhlIGludmFsaWQgTGFUZVggYXMgYSBzcGFuIHdpdGggaG92ZXIgdGl0bGUgZ2l2aW5nIHRoZSBLYVRlWFxuICogZXJyb3IgbWVzc2FnZS4gIE90aGVyd2lzZSwgc2ltcGx5IHRocm93cyB0aGUgZXJyb3IuXG4gKi9cblxuXG52YXIga2F0ZXhfcmVuZGVyRXJyb3IgPSBmdW5jdGlvbiByZW5kZXJFcnJvcihlcnJvciwgZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50aHJvd09uRXJyb3IgfHwgIShlcnJvciBpbnN0YW5jZW9mIHNyY19QYXJzZUVycm9yKSkge1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJrYXRleC1lcnJvclwiXSwgW25ldyBkb21UcmVlX1N5bWJvbE5vZGUoZXhwcmVzc2lvbildKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBlcnJvci50b1N0cmluZygpKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImNvbG9yOlwiICsgb3B0aW9ucy5lcnJvckNvbG9yKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgdGhlIGthdGV4IGJ1aWxkIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgYWR2YW5jZWRcbiAqIHVzZSBjYXNlcyAobGlrZSByZW5kZXJpbmcgdG8gY3VzdG9tIG91dHB1dCkuXG4gKi9cblxuXG52YXIga2F0ZXhfcmVuZGVyVG9Eb21UcmVlID0gZnVuY3Rpb24gcmVuZGVyVG9Eb21UcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgdmFyIHNldHRpbmdzID0gbmV3IHNyY19TZXR0aW5ncyhvcHRpb25zKTtcblxuICB0cnkge1xuICAgIHZhciB0cmVlID0gc3JjX3BhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgcmV0dXJuIGJ1aWxkVHJlZV9idWlsZFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBrYXRleF9yZW5kZXJFcnJvcihlcnJvciwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICB9XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgdGhlIGthdGV4IGJ1aWxkIHRyZWUsIHdpdGgganVzdCBIVE1MIChubyBNYXRoTUwpLlxuICogVGhpcyBpcyB1c2VkIGZvciBhZHZhbmNlZCB1c2UgY2FzZXMgKGxpa2UgcmVuZGVyaW5nIHRvIGN1c3RvbSBvdXRwdXQpLlxuICovXG5cblxudmFyIGthdGV4X3JlbmRlclRvSFRNTFRyZWUgPSBmdW5jdGlvbiByZW5kZXJUb0hUTUxUcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgdmFyIHNldHRpbmdzID0gbmV3IHNyY19TZXR0aW5ncyhvcHRpb25zKTtcblxuICB0cnkge1xuICAgIHZhciB0cmVlID0gc3JjX3BhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgcmV0dXJuIGJ1aWxkVHJlZV9idWlsZEhUTUxUcmVlKHRyZWUsIGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ga2F0ZXhfcmVuZGVyRXJyb3IoZXJyb3IsIGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbiAgfVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIga2F0ZXhfMCA9ICh7XG4gIC8qKlxuICAgKiBDdXJyZW50IEthVGVYIHZlcnNpb25cbiAgICovXG4gIHZlcnNpb246IFwiMC4xMC4yXCIsXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIExhVGVYIGludG8gYW4gSFRNTCtNYXRoTUwgY29tYmluYXRpb24sIGFuZCBhZGRzXG4gICAqIGl0IGFzIGEgY2hpbGQgdG8gdGhlIHNwZWNpZmllZCBET00gbm9kZS5cbiAgICovXG4gIHJlbmRlcjoga2F0ZXhfcmVuZGVyLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwrTWF0aE1MIGNvbWJpbmF0aW9uIHN0cmluZyxcbiAgICogZm9yIHNlbmRpbmcgdG8gdGhlIGNsaWVudC5cbiAgICovXG4gIHJlbmRlclRvU3RyaW5nOiByZW5kZXJUb1N0cmluZyxcblxuICAvKipcbiAgICogS2FUZVggZXJyb3IsIHVzdWFsbHkgZHVyaW5nIHBhcnNpbmcuXG4gICAqL1xuICBQYXJzZUVycm9yOiBzcmNfUGFyc2VFcnJvcixcblxuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIEthVGVYJ3MgaW50ZXJuYWwgcGFyc2UgdHJlZSBzdHJ1Y3R1cmUsXG4gICAqIHdpdGhvdXQgcmVuZGVyaW5nIHRvIEhUTUwgb3IgTWF0aE1MLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgKiBUaGUgaW50ZXJuYWwgdHJlZSByZXByZXNlbnRhdGlvbiBpcyB1bnN0YWJsZSBhbmQgaXMgdmVyeSBsaWtlbHlcbiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIF9fcGFyc2U6IGthdGV4X2dlbmVyYXRlUGFyc2VUcmVlLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwrTWF0aE1MIGludGVybmFsIERPTSB0cmVlXG4gICAqIHJlcHJlc2VudGF0aW9uLCB3aXRob3V0IGZsYXR0ZW5pbmcgdGhhdCByZXByZXNlbnRhdGlvbiB0byBhIHN0cmluZy5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX3JlbmRlclRvRG9tVHJlZToga2F0ZXhfcmVuZGVyVG9Eb21UcmVlLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwgaW50ZXJuYWwgRE9NIHRyZWUgcmVwcmVzZW50YXRpb24sXG4gICAqIHdpdGhvdXQgTWF0aE1MIGFuZCB3aXRob3V0IGZsYXR0ZW5pbmcgdGhhdCByZXByZXNlbnRhdGlvbiB0byBhIHN0cmluZy5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX3JlbmRlclRvSFRNTFRyZWU6IGthdGV4X3JlbmRlclRvSFRNTFRyZWUsXG5cbiAgLyoqXG4gICAqIGV4dGVuZHMgaW50ZXJuYWwgZm9udCBtZXRyaWNzIG9iamVjdCB3aXRoIGEgbmV3IG9iamVjdFxuICAgKiBlYWNoIGtleSBpbiB0aGUgbmV3IG9iamVjdCByZXByZXNlbnRzIGEgZm9udCBuYW1lXG4gICovXG4gIF9fc2V0Rm9udE1ldHJpY3M6IHNldEZvbnRNZXRyaWNzLFxuXG4gIC8qKlxuICAgKiBhZGRzIGEgbmV3IHN5bWJvbCB0byBidWlsdGluIHN5bWJvbHMgdGFibGVcbiAgICovXG4gIF9fZGVmaW5lU3ltYm9sOiBkZWZpbmVTeW1ib2wsXG5cbiAgLyoqXG4gICAqIGFkZHMgYSBuZXcgbWFjcm8gdG8gYnVpbHRpbiBtYWNybyBsaXN0XG4gICAqL1xuICBfX2RlZmluZU1hY3JvOiBkZWZpbmVNYWNybyxcblxuICAvKipcbiAgICogRXhwb3NlIHRoZSBkb20gdHJlZSBub2RlIHR5cGVzLCB3aGljaCBjYW4gYmUgdXNlZnVsIGZvciB0eXBlIGNoZWNraW5nIG5vZGVzLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgKiBUaGUgaW50ZXJuYWwgdHJlZSByZXByZXNlbnRhdGlvbiBpcyB1bnN0YWJsZSBhbmQgaXMgdmVyeSBsaWtlbHlcbiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIF9fZG9tVHJlZToge1xuICAgIFNwYW46IGRvbVRyZWVfU3BhbixcbiAgICBBbmNob3I6IGRvbVRyZWVfQW5jaG9yLFxuICAgIFN5bWJvbE5vZGU6IGRvbVRyZWVfU3ltYm9sTm9kZSxcbiAgICBTdmdOb2RlOiBTdmdOb2RlLFxuICAgIFBhdGhOb2RlOiBkb21UcmVlX1BhdGhOb2RlLFxuICAgIExpbmVOb2RlOiBMaW5lTm9kZVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4va2F0ZXgud2VicGFjay5qc1xuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWJwYWNrIGVudHJ5IHBvaW50IGZvciBLYVRlWC4gQXMgRUNNQVNjcmlwdCwgZmxvd1sxXSBhbmQgamVzdFsyXVxuICogZG9lc24ndCBzdXBwb3J0IENTUyBtb2R1bGVzIG5hdGl2ZWx5LCBhIHNlcGFyYXRlIGVudHJ5IHBvaW50IGlzIHVzZWQgYW5kXG4gKiBpdCBpcyBub3QgZmxvd3R5cGVkLlxuICpcbiAqIFsxXSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9sYW1iZGFoYW5kcy9kMTllMGRhOTYyODViNzQ5ZjBlZlxuICogWzJdIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL2plc3QvZG9jcy9lbi93ZWJwYWNrLmh0bWxcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGthdGV4X3dlYnBhY2sgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChrYXRleF8wKTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pW1wiZGVmYXVsdFwiXTtcbn0pOyIsIi8qZ2xvYmFsIGRlZmluZTpmYWxzZSAqL1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE3IENyYWlnIENhbXBiZWxsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogTW91c2V0cmFwIGlzIGEgc2ltcGxlIGtleWJvYXJkIHNob3J0Y3V0IGxpYnJhcnkgZm9yIEphdmFzY3JpcHQgd2l0aFxuICogbm8gZXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKlxuICogQHZlcnNpb24gMS42LjVcbiAqIEB1cmwgY3JhaWcuaXMva2lsbGluZy9taWNlXG4gKi9cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblxuICAgIC8vIENoZWNrIGlmIG1vdXNldHJhcCBpcyB1c2VkIGluc2lkZSBicm93c2VyLCBpZiBub3QsIHJldHVyblxuICAgIGlmICghd2luZG93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYXBwaW5nIG9mIHNwZWNpYWwga2V5Y29kZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBrZXlzXG4gICAgICpcbiAgICAgKiBldmVyeXRoaW5nIGluIHRoaXMgZGljdGlvbmFyeSBjYW5ub3QgdXNlIGtleXByZXNzIGV2ZW50c1xuICAgICAqIHNvIGl0IGhhcyB0byBiZSBoZXJlIHRvIG1hcCB0byB0aGUgY29ycmVjdCBrZXljb2RlcyBmb3JcbiAgICAgKiBrZXl1cC9rZXlkb3duIGV2ZW50c1xuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgX01BUCA9IHtcbiAgICAgICAgODogJ2JhY2tzcGFjZScsXG4gICAgICAgIDk6ICd0YWInLFxuICAgICAgICAxMzogJ2VudGVyJyxcbiAgICAgICAgMTY6ICdzaGlmdCcsXG4gICAgICAgIDE3OiAnY3RybCcsXG4gICAgICAgIDE4OiAnYWx0JyxcbiAgICAgICAgMjA6ICdjYXBzbG9jaycsXG4gICAgICAgIDI3OiAnZXNjJyxcbiAgICAgICAgMzI6ICdzcGFjZScsXG4gICAgICAgIDMzOiAncGFnZXVwJyxcbiAgICAgICAgMzQ6ICdwYWdlZG93bicsXG4gICAgICAgIDM1OiAnZW5kJyxcbiAgICAgICAgMzY6ICdob21lJyxcbiAgICAgICAgMzc6ICdsZWZ0JyxcbiAgICAgICAgMzg6ICd1cCcsXG4gICAgICAgIDM5OiAncmlnaHQnLFxuICAgICAgICA0MDogJ2Rvd24nLFxuICAgICAgICA0NTogJ2lucycsXG4gICAgICAgIDQ2OiAnZGVsJyxcbiAgICAgICAgOTE6ICdtZXRhJyxcbiAgICAgICAgOTM6ICdtZXRhJyxcbiAgICAgICAgMjI0OiAnbWV0YSdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogbWFwcGluZyBmb3Igc3BlY2lhbCBjaGFyYWN0ZXJzIHNvIHRoZXkgY2FuIHN1cHBvcnRcbiAgICAgKlxuICAgICAqIHRoaXMgZGljdGlvbmFyeSBpcyBvbmx5IHVzZWQgaW5jYXNlIHlvdSB3YW50IHRvIGJpbmQgYVxuICAgICAqIGtleXVwIG9yIGtleWRvd24gZXZlbnQgdG8gb25lIG9mIHRoZXNlIGtleXNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIF9LRVlDT0RFX01BUCA9IHtcbiAgICAgICAgMTA2OiAnKicsXG4gICAgICAgIDEwNzogJysnLFxuICAgICAgICAxMDk6ICctJyxcbiAgICAgICAgMTEwOiAnLicsXG4gICAgICAgIDExMSA6ICcvJyxcbiAgICAgICAgMTg2OiAnOycsXG4gICAgICAgIDE4NzogJz0nLFxuICAgICAgICAxODg6ICcsJyxcbiAgICAgICAgMTg5OiAnLScsXG4gICAgICAgIDE5MDogJy4nLFxuICAgICAgICAxOTE6ICcvJyxcbiAgICAgICAgMTkyOiAnYCcsXG4gICAgICAgIDIxOTogJ1snLFxuICAgICAgICAyMjA6ICdcXFxcJyxcbiAgICAgICAgMjIxOiAnXScsXG4gICAgICAgIDIyMjogJ1xcJydcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGhpcyBpcyBhIG1hcHBpbmcgb2Yga2V5cyB0aGF0IHJlcXVpcmUgc2hpZnQgb24gYSBVUyBrZXlwYWRcbiAgICAgKiBiYWNrIHRvIHRoZSBub24gc2hpZnQgZXF1aXZlbGVudHNcbiAgICAgKlxuICAgICAqIHRoaXMgaXMgc28geW91IGNhbiB1c2Uga2V5dXAgZXZlbnRzIHdpdGggdGhlc2Uga2V5c1xuICAgICAqXG4gICAgICogbm90ZSB0aGF0IHRoaXMgd2lsbCBvbmx5IHdvcmsgcmVsaWFibHkgb24gVVMga2V5Ym9hcmRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBfU0hJRlRfTUFQID0ge1xuICAgICAgICAnfic6ICdgJyxcbiAgICAgICAgJyEnOiAnMScsXG4gICAgICAgICdAJzogJzInLFxuICAgICAgICAnIyc6ICczJyxcbiAgICAgICAgJyQnOiAnNCcsXG4gICAgICAgICclJzogJzUnLFxuICAgICAgICAnXic6ICc2JyxcbiAgICAgICAgJyYnOiAnNycsXG4gICAgICAgICcqJzogJzgnLFxuICAgICAgICAnKCc6ICc5JyxcbiAgICAgICAgJyknOiAnMCcsXG4gICAgICAgICdfJzogJy0nLFxuICAgICAgICAnKyc6ICc9JyxcbiAgICAgICAgJzonOiAnOycsXG4gICAgICAgICdcXFwiJzogJ1xcJycsXG4gICAgICAgICc8JzogJywnLFxuICAgICAgICAnPic6ICcuJyxcbiAgICAgICAgJz8nOiAnLycsXG4gICAgICAgICd8JzogJ1xcXFwnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRoaXMgaXMgYSBsaXN0IG9mIHNwZWNpYWwgc3RyaW5ncyB5b3UgY2FuIHVzZSB0byBtYXBcbiAgICAgKiB0byBtb2RpZmllciBrZXlzIHdoZW4geW91IHNwZWNpZnkgeW91ciBrZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIF9TUEVDSUFMX0FMSUFTRVMgPSB7XG4gICAgICAgICdvcHRpb24nOiAnYWx0JyxcbiAgICAgICAgJ2NvbW1hbmQnOiAnbWV0YScsXG4gICAgICAgICdyZXR1cm4nOiAnZW50ZXInLFxuICAgICAgICAnZXNjYXBlJzogJ2VzYycsXG4gICAgICAgICdwbHVzJzogJysnLFxuICAgICAgICAnbW9kJzogL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgPyAnbWV0YScgOiAnY3RybCdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdmFyaWFibGUgdG8gc3RvcmUgdGhlIGZsaXBwZWQgdmVyc2lvbiBvZiBfTUFQIGZyb20gYWJvdmVcbiAgICAgKiBuZWVkZWQgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHVzZSBrZXlwcmVzcyBvciBub3Qgd2hlbiBubyBhY3Rpb25cbiAgICAgKiBpcyBzcGVjaWZpZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHZhciBfUkVWRVJTRV9NQVA7XG5cbiAgICAvKipcbiAgICAgKiBsb29wIHRocm91Z2ggdGhlIGYga2V5cywgZjEgdG8gZjE5IGFuZCBhZGQgdGhlbSB0byB0aGUgbWFwXG4gICAgICogcHJvZ3JhbWF0aWNhbGx5XG4gICAgICovXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAyMDsgKytpKSB7XG4gICAgICAgIF9NQVBbMTExICsgaV0gPSAnZicgKyBpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxvb3AgdGhyb3VnaCB0byBtYXAgbnVtYmVycyBvbiB0aGUgbnVtZXJpYyBrZXlwYWRcbiAgICAgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDw9IDk7ICsraSkge1xuXG4gICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gdXNlIGEgc3RyaW5nIGNhdXNlIG90aGVyd2lzZSBzaW5jZSAwIGlzIGZhbHNleVxuICAgICAgICAvLyBtb3VzZXRyYXAgd2lsbCBuZXZlciBmaXJlIGZvciBudW1wYWQgMCBwcmVzc2VkIGFzIHBhcnQgb2YgYSBrZXlkb3duXG4gICAgICAgIC8vIGV2ZW50LlxuICAgICAgICAvL1xuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jY2FtcGJlbGwvbW91c2V0cmFwL3B1bGwvMjU4XG4gICAgICAgIF9NQVBbaSArIDk2XSA9IGkudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcm9zcyBicm93c2VyIGFkZCBldmVudCBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxIVE1MRG9jdW1lbnR9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2FkZEV2ZW50KG9iamVjdCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKG9iamVjdC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBvYmplY3QuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqZWN0LmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGFrZXMgdGhlIGV2ZW50IGFuZCByZXR1cm5zIHRoZSBrZXkgY2hhcmFjdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9jaGFyYWN0ZXJGcm9tRXZlbnQoZSkge1xuXG4gICAgICAgIC8vIGZvciBrZXlwcmVzcyBldmVudHMgd2Ugc2hvdWxkIHJldHVybiB0aGUgY2hhcmFjdGVyIGFzIGlzXG4gICAgICAgIGlmIChlLnR5cGUgPT0gJ2tleXByZXNzJykge1xuICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS53aGljaCk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBzaGlmdCBrZXkgaXMgbm90IHByZXNzZWQgdGhlbiBpdCBpcyBzYWZlIHRvIGFzc3VtZVxuICAgICAgICAgICAgLy8gdGhhdCB3ZSB3YW50IHRoZSBjaGFyYWN0ZXIgdG8gYmUgbG93ZXJjYXNlLiAgdGhpcyBtZWFucyBpZlxuICAgICAgICAgICAgLy8geW91IGFjY2lkZW50YWxseSBoYXZlIGNhcHMgbG9jayBvbiB0aGVuIHlvdXIga2V5IGJpbmRpbmdzXG4gICAgICAgICAgICAvLyB3aWxsIGNvbnRpbnVlIHRvIHdvcmtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGUgb25seSBzaWRlIGVmZmVjdCB0aGF0IG1pZ2h0IG5vdCBiZSBkZXNpcmVkIGlzIGlmIHlvdVxuICAgICAgICAgICAgLy8gYmluZCBzb21ldGhpbmcgbGlrZSAnQScgY2F1c2UgeW91IHdhbnQgdG8gdHJpZ2dlciBhblxuICAgICAgICAgICAgLy8gZXZlbnQgd2hlbiBjYXBpdGFsIEEgaXMgcHJlc3NlZCBjYXBzIGxvY2sgd2lsbCBubyBsb25nZXJcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgdGhlIGV2ZW50LiAgc2hpZnQrYSB3aWxsIHRob3VnaC5cbiAgICAgICAgICAgIGlmICghZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGNoYXJhY3RlciA9IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2hhcmFjdGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yIG5vbiBrZXlwcmVzcyBldmVudHMgdGhlIHNwZWNpYWwgbWFwcyBhcmUgbmVlZGVkXG4gICAgICAgIGlmIChfTUFQW2Uud2hpY2hdKSB7XG4gICAgICAgICAgICByZXR1cm4gX01BUFtlLndoaWNoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfS0VZQ09ERV9NQVBbZS53aGljaF0pIHtcbiAgICAgICAgICAgIHJldHVybiBfS0VZQ09ERV9NQVBbZS53aGljaF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpdCBpcyBub3QgaW4gdGhlIHNwZWNpYWwgbWFwXG5cbiAgICAgICAgLy8gd2l0aCBrZXlkb3duIGFuZCBrZXl1cCBldmVudHMgdGhlIGNoYXJhY3RlciBzZWVtcyB0byBhbHdheXNcbiAgICAgICAgLy8gY29tZSBpbiBhcyBhbiB1cHBlcmNhc2UgY2hhcmFjdGVyIHdoZXRoZXIgeW91IGFyZSBwcmVzc2luZyBzaGlmdFxuICAgICAgICAvLyBvciBub3QuICB3ZSBzaG91bGQgbWFrZSBzdXJlIGl0IGlzIGFsd2F5cyBsb3dlcmNhc2UgZm9yIGNvbXBhcmlzb25zXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hlY2tzIGlmIHR3byBhcnJheXMgYXJlIGVxdWFsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMxXG4gICAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzMlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9tb2RpZmllcnNNYXRjaChtb2RpZmllcnMxLCBtb2RpZmllcnMyKSB7XG4gICAgICAgIHJldHVybiBtb2RpZmllcnMxLnNvcnQoKS5qb2luKCcsJykgPT09IG1vZGlmaWVyczIuc29ydCgpLmpvaW4oJywnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0YWtlcyBhIGtleSBldmVudCBhbmQgZmlndXJlcyBvdXQgd2hhdCB0aGUgbW9kaWZpZXJzIGFyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZXZlbnRNb2RpZmllcnMoZSkge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gW107XG5cbiAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdzaGlmdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUuYWx0S2V5KSB7XG4gICAgICAgICAgICBtb2RpZmllcnMucHVzaCgnYWx0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICBtb2RpZmllcnMucHVzaCgnY3RybCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUubWV0YUtleSkge1xuICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ21ldGEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2RpZmllcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJldmVudHMgZGVmYXVsdCBmb3IgdGhpcyBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfcHJldmVudERlZmF1bHQoZSkge1xuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHN0b3BzIHByb3BvZ2F0aW9uIGZvciB0aGlzIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9zdG9wUHJvcGFnYXRpb24oZSkge1xuICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGV0ZXJtaW5lcyBpZiB0aGUga2V5Y29kZSBzcGVjaWZpZWQgaXMgYSBtb2RpZmllciBrZXkgb3Igbm90XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2lzTW9kaWZpZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NoaWZ0JyB8fCBrZXkgPT0gJ2N0cmwnIHx8IGtleSA9PSAnYWx0JyB8fCBrZXkgPT0gJ21ldGEnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldmVyc2VzIHRoZSBtYXAgbG9va3VwIHNvIHRoYXQgd2UgY2FuIGxvb2sgZm9yIHNwZWNpZmljIGtleXNcbiAgICAgKiB0byBzZWUgd2hhdCBjYW4gYW5kIGNhbid0IHVzZSBrZXlwcmVzc1xuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9nZXRSZXZlcnNlTWFwKCkge1xuICAgICAgICBpZiAoIV9SRVZFUlNFX01BUCkge1xuICAgICAgICAgICAgX1JFVkVSU0VfTUFQID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gX01BUCkge1xuXG4gICAgICAgICAgICAgICAgLy8gcHVsbCBvdXQgdGhlIG51bWVyaWMga2V5cGFkIGZyb20gaGVyZSBjYXVzZSBrZXlwcmVzcyBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBiZSBhYmxlIHRvIGRldGVjdCB0aGUga2V5cyBmcm9tIHRoZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID4gOTUgJiYga2V5IDwgMTEyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfTUFQLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX1JFVkVSU0VfTUFQW19NQVBba2V5XV0gPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfUkVWRVJTRV9NQVA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGlja3MgdGhlIGJlc3QgYWN0aW9uIGJhc2VkIG9uIHRoZSBrZXkgY29tYmluYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBjaGFyYWN0ZXIgZm9yIGtleVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uIHBhc3NlZCBpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9waWNrQmVzdEFjdGlvbihrZXksIG1vZGlmaWVycywgYWN0aW9uKSB7XG5cbiAgICAgICAgLy8gaWYgbm8gYWN0aW9uIHdhcyBwaWNrZWQgaW4gd2Ugc2hvdWxkIHRyeSB0byBwaWNrIHRoZSBvbmVcbiAgICAgICAgLy8gdGhhdCB3ZSB0aGluayB3b3VsZCB3b3JrIGJlc3QgZm9yIHRoaXMga2V5XG4gICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBfZ2V0UmV2ZXJzZU1hcCgpW2tleV0gPyAna2V5ZG93bicgOiAna2V5cHJlc3MnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW9kaWZpZXIga2V5cyBkb24ndCB3b3JrIGFzIGV4cGVjdGVkIHdpdGgga2V5cHJlc3MsXG4gICAgICAgIC8vIHN3aXRjaCB0byBrZXlkb3duXG4gICAgICAgIGlmIChhY3Rpb24gPT0gJ2tleXByZXNzJyAmJiBtb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSAna2V5ZG93bic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGZyb20gYSBzdHJpbmcga2V5IGNvbWJpbmF0aW9uIHRvIGFuIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbWJpbmF0aW9uIGxpa2UgXCJjb21tYW5kK3NoaWZ0K2xcIlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9rZXlzRnJvbVN0cmluZyhjb21iaW5hdGlvbikge1xuICAgICAgICBpZiAoY29tYmluYXRpb24gPT09ICcrJykge1xuICAgICAgICAgICAgcmV0dXJuIFsnKyddO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tYmluYXRpb24gPSBjb21iaW5hdGlvbi5yZXBsYWNlKC9cXCt7Mn0vZywgJytwbHVzJyk7XG4gICAgICAgIHJldHVybiBjb21iaW5hdGlvbi5zcGxpdCgnKycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaW5mbyBmb3IgYSBzcGVjaWZpYyBrZXkgY29tYmluYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29tYmluYXRpb24ga2V5IGNvbWJpbmF0aW9uIChcImNvbW1hbmQrc1wiIG9yIFwiYVwiIG9yIFwiKlwiKVxuICAgICAqIEBwYXJhbSAge3N0cmluZz19IGFjdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldEtleUluZm8oY29tYmluYXRpb24sIGFjdGlvbikge1xuICAgICAgICB2YXIga2V5cztcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSBbXTtcblxuICAgICAgICAvLyB0YWtlIHRoZSBrZXlzIGZyb20gdGhpcyBwYXR0ZXJuIGFuZCBmaWd1cmUgb3V0IHdoYXQgdGhlIGFjdHVhbFxuICAgICAgICAvLyBwYXR0ZXJuIGlzIGFsbCBhYm91dFxuICAgICAgICBrZXlzID0gX2tleXNGcm9tU3RyaW5nKGNvbWJpbmF0aW9uKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGtleSBuYW1lc1xuICAgICAgICAgICAgaWYgKF9TUEVDSUFMX0FMSUFTRVNba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleSA9IF9TUEVDSUFMX0FMSUFTRVNba2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBrZXlwcmVzcyBldmVudCB0aGVuIHdlIHNob3VsZFxuICAgICAgICAgICAgLy8gYmUgc21hcnQgYWJvdXQgdXNpbmcgc2hpZnQga2V5c1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG9ubHkgd29yayBmb3IgVVMga2V5Ym9hcmRzIGhvd2V2ZXJcbiAgICAgICAgICAgIGlmIChhY3Rpb24gJiYgYWN0aW9uICE9ICdrZXlwcmVzcycgJiYgX1NISUZUX01BUFtrZXldKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gX1NISUZUX01BUFtrZXldO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdzaGlmdCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGtleSBpcyBhIG1vZGlmaWVyIHRoZW4gYWRkIGl0IHRvIHRoZSBsaXN0IG9mIG1vZGlmaWVyc1xuICAgICAgICAgICAgaWYgKF9pc01vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHdoYXQgdGhlIGtleSBjb21iaW5hdGlvbiBpc1xuICAgICAgICAvLyB3ZSB3aWxsIHRyeSB0byBwaWNrIHRoZSBiZXN0IGV2ZW50IGZvciBpdFxuICAgICAgICBhY3Rpb24gPSBfcGlja0Jlc3RBY3Rpb24oa2V5LCBtb2RpZmllcnMsIGFjdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9iZWxvbmdzVG8oZWxlbWVudCwgYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtZW50ID09PSBhbmNlc3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2JlbG9uZ3NUbyhlbGVtZW50LnBhcmVudE5vZGUsIGFuY2VzdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNb3VzZXRyYXAodGFyZ2V0RWxlbWVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGFyZ2V0RWxlbWVudCA9IHRhcmdldEVsZW1lbnQgfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIE1vdXNldHJhcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW91c2V0cmFwKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGVsZW1lbnQgdG8gYXR0YWNoIGtleSBldmVudHMgdG9cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnRhcmdldCA9IHRhcmdldEVsZW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGEgbGlzdCBvZiBhbGwgdGhlIGNhbGxiYWNrcyBzZXR1cCB2aWEgTW91c2V0cmFwLmJpbmQoKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5fY2FsbGJhY2tzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRpcmVjdCBtYXAgb2Ygc3RyaW5nIGNvbWJpbmF0aW9ucyB0byBjYWxsYmFja3MgdXNlZCBmb3IgdHJpZ2dlcigpXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLl9kaXJlY3RNYXAgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICoga2VlcHMgdHJhY2sgb2Ygd2hhdCBsZXZlbCBlYWNoIHNlcXVlbmNlIGlzIGF0IHNpbmNlIG11bHRpcGxlXG4gICAgICAgICAqIHNlcXVlbmNlcyBjYW4gc3RhcnQgb3V0IHdpdGggdGhlIHNhbWUgc2VxdWVuY2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfc2VxdWVuY2VMZXZlbHMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdmFyaWFibGUgdG8gc3RvcmUgdGhlIHNldFRpbWVvdXQgY2FsbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7bnVsbHxudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3Jlc2V0VGltZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRlbXBvcmFyeSBzdGF0ZSB3aGVyZSB3ZSB3aWxsIGlnbm9yZSB0aGUgbmV4dCBrZXl1cFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbnxzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX2lnbm9yZU5leHRLZXl1cCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0ZW1wb3Jhcnkgc3RhdGUgd2hlcmUgd2Ugd2lsbCBpZ25vcmUgdGhlIG5leHQga2V5cHJlc3NcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX2lnbm9yZU5leHRLZXlwcmVzcyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhcmUgd2UgY3VycmVudGx5IGluc2lkZSBvZiBhIHNlcXVlbmNlP1xuICAgICAgICAgKiB0eXBlIG9mIGFjdGlvbiAoXCJrZXl1cFwiIG9yIFwia2V5ZG93blwiIG9yIFwia2V5cHJlc3NcIikgb3IgZmFsc2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW58c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF9uZXh0RXhwZWN0ZWRBY3Rpb24gPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmVzZXRzIGFsbCBzZXF1ZW5jZSBjb3VudGVycyBleGNlcHQgZm9yIHRoZSBvbmVzIHBhc3NlZCBpblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZG9Ob3RSZXNldFxuICAgICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfcmVzZXRTZXF1ZW5jZXMoZG9Ob3RSZXNldCkge1xuICAgICAgICAgICAgZG9Ob3RSZXNldCA9IGRvTm90UmVzZXQgfHwge307XG5cbiAgICAgICAgICAgIHZhciBhY3RpdmVTZXF1ZW5jZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgICAgIGZvciAoa2V5IGluIF9zZXF1ZW5jZUxldmVscykge1xuICAgICAgICAgICAgICAgIGlmIChkb05vdFJlc2V0W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlU2VxdWVuY2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9zZXF1ZW5jZUxldmVsc1trZXldID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFhY3RpdmVTZXF1ZW5jZXMpIHtcbiAgICAgICAgICAgICAgICBfbmV4dEV4cGVjdGVkQWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZmluZHMgYWxsIGNhbGxiYWNrcyB0aGF0IG1hdGNoIGJhc2VkIG9uIHRoZSBrZXljb2RlLCBtb2RpZmllcnMsXG4gICAgICAgICAqIGFuZCBhY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAgICAgICAgICogQHBhcmFtIHtFdmVudHxPYmplY3R9IGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBzZXF1ZW5jZU5hbWUgLSBuYW1lIG9mIHRoZSBzZXF1ZW5jZSB3ZSBhcmUgbG9va2luZyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBjb21iaW5hdGlvblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IGxldmVsXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9nZXRNYXRjaGVzKGNoYXJhY3RlciwgbW9kaWZpZXJzLCBlLCBzZXF1ZW5jZU5hbWUsIGNvbWJpbmF0aW9uLCBsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2s7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGUudHlwZTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGV2ZW50cyByZWxhdGVkIHRvIHRoaXMga2V5Y29kZVxuICAgICAgICAgICAgaWYgKCFzZWxmLl9jYWxsYmFja3NbY2hhcmFjdGVyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYSBtb2RpZmllciBrZXkgaXMgY29taW5nIHVwIG9uIGl0cyBvd24gd2Ugc2hvdWxkIGFsbG93IGl0XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09ICdrZXl1cCcgJiYgX2lzTW9kaWZpZXIoY2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVycyA9IFtjaGFyYWN0ZXJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIGNhbGxiYWNrcyBmb3IgdGhlIGtleSB0aGF0IHdhcyBwcmVzc2VkXG4gICAgICAgICAgICAvLyBhbmQgc2VlIGlmIGFueSBvZiB0aGVtIG1hdGNoXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi5fY2FsbGJhY2tzW2NoYXJhY3Rlcl0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHNlbGYuX2NhbGxiYWNrc1tjaGFyYWN0ZXJdW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgYSBzZXF1ZW5jZSBuYW1lIGlzIG5vdCBzcGVjaWZpZWQsIGJ1dCB0aGlzIGlzIGEgc2VxdWVuY2UgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgd3JvbmcgbGV2ZWwgdGhlbiBtb3ZlIG9udG8gdGhlIG5leHQgbWF0Y2hcbiAgICAgICAgICAgICAgICBpZiAoIXNlcXVlbmNlTmFtZSAmJiBjYWxsYmFjay5zZXEgJiYgX3NlcXVlbmNlTGV2ZWxzW2NhbGxiYWNrLnNlcV0gIT0gY2FsbGJhY2subGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFjdGlvbiB3ZSBhcmUgbG9va2luZyBmb3IgZG9lc24ndCBtYXRjaCB0aGUgYWN0aW9uIHdlIGdvdFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIGtlZXAgZ29pbmdcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9IGNhbGxiYWNrLmFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEga2V5cHJlc3MgZXZlbnQgYW5kIHRoZSBtZXRhIGtleSBhbmQgY29udHJvbCBrZXlcbiAgICAgICAgICAgICAgICAvLyBhcmUgbm90IHByZXNzZWQgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gb25seSBsb29rIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgb3RoZXJ3aXNlIGNoZWNrIHRoZSBtb2RpZmllcnMgYXMgd2VsbFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gY2hyb21lIHdpbGwgbm90IGZpcmUgYSBrZXlwcmVzcyBpZiBtZXRhIG9yIGNvbnRyb2wgaXMgZG93blxuICAgICAgICAgICAgICAgIC8vIHNhZmFyaSB3aWxsIGZpcmUgYSBrZXlwcmVzcyBpZiBtZXRhIG9yIG1ldGErc2hpZnQgaXMgZG93blxuICAgICAgICAgICAgICAgIC8vIGZpcmVmb3ggd2lsbCBmaXJlIGEga2V5cHJlc3MgaWYgbWV0YSBvciBjb250cm9sIGlzIGRvd25cbiAgICAgICAgICAgICAgICBpZiAoKGFjdGlvbiA9PSAna2V5cHJlc3MnICYmICFlLm1ldGFLZXkgJiYgIWUuY3RybEtleSkgfHwgX21vZGlmaWVyc01hdGNoKG1vZGlmaWVycywgY2FsbGJhY2subW9kaWZpZXJzKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4geW91IGJpbmQgYSBjb21iaW5hdGlvbiBvciBzZXF1ZW5jZSBhIHNlY29uZCB0aW1lIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZS4gIGlmIGEgc2VxdWVuY2VOYW1lIG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbWJpbmF0aW9uIGlzIHNwZWNpZmllZCBpbiB0aGlzIGNhbGwgaXQgZG9lcyBqdXN0IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gQHRvZG8gbWFrZSBkZWxldGluZyBpdHMgb3duIG1ldGhvZD9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZUNvbWJvID0gIXNlcXVlbmNlTmFtZSAmJiBjYWxsYmFjay5jb21ibyA9PSBjb21iaW5hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZVNlcXVlbmNlID0gc2VxdWVuY2VOYW1lICYmIGNhbGxiYWNrLnNlcSA9PSBzZXF1ZW5jZU5hbWUgJiYgY2FsbGJhY2subGV2ZWwgPT0gbGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVDb21ibyB8fCBkZWxldGVTZXF1ZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2FsbGJhY2tzW2NoYXJhY3Rlcl0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFjdHVhbGx5IGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBpZiB5b3VyIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UgdGhpcyB3aWxsIHVzZSB0aGUganF1ZXJ5XG4gICAgICAgICAqIGNvbnZlbnRpb24gLSBwcmV2ZW50IGRlZmF1bHQgYW5kIHN0b3AgcHJvcG9nYXRpb24gb24gdGhlIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZpcmVDYWxsYmFjayhjYWxsYmFjaywgZSwgY29tYm8sIHNlcXVlbmNlKSB7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZXZlbnQgc2hvdWxkIG5vdCBoYXBwZW4gc3RvcCBoZXJlXG4gICAgICAgICAgICBpZiAoc2VsZi5zdG9wQ2FsbGJhY2soZSwgZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LCBjb21ibywgc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soZSwgY29tYm8pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIF9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICAgICAgICBfc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhhbmRsZXMgYSBjaGFyYWN0ZXIga2V5IGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5faGFuZGxlS2V5ID0gZnVuY3Rpb24oY2hhcmFjdGVyLCBtb2RpZmllcnMsIGUpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBfZ2V0TWF0Y2hlcyhjaGFyYWN0ZXIsIG1vZGlmaWVycywgZSk7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBkb05vdFJlc2V0ID0ge307XG4gICAgICAgICAgICB2YXIgbWF4TGV2ZWwgPSAwO1xuICAgICAgICAgICAgdmFyIHByb2Nlc3NlZFNlcXVlbmNlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBtYXhMZXZlbCBmb3Igc2VxdWVuY2VzIHNvIHdlIGNhbiBvbmx5IGV4ZWN1dGUgdGhlIGxvbmdlc3QgY2FsbGJhY2sgc2VxdWVuY2VcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldLnNlcSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhMZXZlbCA9IE1hdGgubWF4KG1heExldmVsLCBjYWxsYmFja3NbaV0ubGV2ZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIG1hdGNoaW5nIGNhbGxiYWNrcyBmb3IgdGhpcyBrZXkgZXZlbnRcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgICAgIC8vIGZpcmUgZm9yIGFsbCBzZXF1ZW5jZSBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGJlY2F1c2UgaWYgZm9yIGV4YW1wbGUgeW91IGhhdmUgbXVsdGlwbGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gYm91bmQgc3VjaCBhcyBcImcgaVwiIGFuZCBcImcgdFwiIHRoZXkgYm90aCBuZWVkIHRvIGZpcmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2FsbGJhY2sgZm9yIG1hdGNoaW5nIGcgY2F1c2Ugb3RoZXJ3aXNlIHlvdSBjYW4gb25seSBldmVyXG4gICAgICAgICAgICAgICAgLy8gbWF0Y2ggdGhlIGZpcnN0IG9uZVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja3NbaV0uc2VxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBmaXJlIGNhbGxiYWNrcyBmb3IgdGhlIG1heExldmVsIHRvIHByZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVuY2VzIGZyb20gYWxzbyBmaXJpbmdcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUgJ2Egb3B0aW9uIGInIHNob3VsZCBub3QgY2F1c2UgJ29wdGlvbiBiJyB0byBmaXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gdGhvdWdoICdvcHRpb24gYicgaXMgcGFydCBvZiB0aGUgb3RoZXIgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gYW55IHNlcXVlbmNlcyB0aGF0IGRvIG5vdCBtYXRjaCBoZXJlIHdpbGwgYmUgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlbG93IGJ5IHRoZSBfcmVzZXRTZXF1ZW5jZXMgY2FsbFxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldLmxldmVsICE9IG1heExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZFNlcXVlbmNlQ2FsbGJhY2sgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgYSBsaXN0IG9mIHdoaWNoIHNlcXVlbmNlcyB3ZXJlIG1hdGNoZXMgZm9yIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIGRvTm90UmVzZXRbY2FsbGJhY2tzW2ldLnNlcV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBfZmlyZUNhbGxiYWNrKGNhbGxiYWNrc1tpXS5jYWxsYmFjaywgZSwgY2FsbGJhY2tzW2ldLmNvbWJvLCBjYWxsYmFja3NbaV0uc2VxKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2VyZSBubyBzZXF1ZW5jZSBtYXRjaGVzIGJ1dCB3ZSBhcmUgc3RpbGwgaGVyZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgbWVhbnMgdGhpcyBpcyBhIHJlZ3VsYXIgbWF0Y2ggc28gd2Ugc2hvdWxkIGZpcmUgdGhhdFxuICAgICAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkU2VxdWVuY2VDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBfZmlyZUNhbGxiYWNrKGNhbGxiYWNrc1tpXS5jYWxsYmFjaywgZSwgY2FsbGJhY2tzW2ldLmNvbWJvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBrZXkgeW91IHByZXNzZWQgbWF0Y2hlcyB0aGUgdHlwZSBvZiBzZXF1ZW5jZSB3aXRob3V0XG4gICAgICAgICAgICAvLyBiZWluZyBhIG1vZGlmaWVyIChpZSBcImtleXVwXCIgb3IgXCJrZXlwcmVzc1wiKSB0aGVuIHdlIHNob3VsZFxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIHNlcXVlbmNlcyB0aGF0IHdlcmUgbm90IG1hdGNoZWQgYnkgdGhpcyBldmVudFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgc28sIGZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSB0aGUgc2VxdWVuY2UgXCJoIGEgdFwiIGFuZCB5b3VcbiAgICAgICAgICAgIC8vIHR5cGUgXCJoIGUgYSByIHRcIiBpdCBkb2VzIG5vdCBtYXRjaC4gIGluIHRoaXMgY2FzZSB0aGUgXCJlXCIgd2lsbFxuICAgICAgICAgICAgLy8gY2F1c2UgdGhlIHNlcXVlbmNlIHRvIHJlc2V0XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gbW9kaWZpZXIga2V5cyBhcmUgaWdub3JlZCBiZWNhdXNlIHlvdSBjYW4gaGF2ZSBhIHNlcXVlbmNlXG4gICAgICAgICAgICAvLyB0aGF0IGNvbnRhaW5zIG1vZGlmaWVycyBzdWNoIGFzIFwiZW50ZXIgY3RybCtzcGFjZVwiIGFuZCBpbiBtb3N0XG4gICAgICAgICAgICAvLyBjYXNlcyB0aGUgbW9kaWZpZXIga2V5IHdpbGwgYmUgcHJlc3NlZCBiZWZvcmUgdGhlIG5leHQga2V5XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gYWxzbyBpZiB5b3UgaGF2ZSBhIHNlcXVlbmNlIHN1Y2ggYXMgXCJjdHJsK2IgYVwiIHRoZW4gcHJlc3NpbmcgdGhlXG4gICAgICAgICAgICAvLyBcImJcIiBrZXkgd2lsbCB0cmlnZ2VyIGEgXCJrZXlwcmVzc1wiIGFuZCBhIFwia2V5ZG93blwiXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdGhlIFwia2V5ZG93blwiIGlzIGV4cGVjdGVkIHdoZW4gdGhlcmUgaXMgYSBtb2RpZmllciwgYnV0IHRoZVxuICAgICAgICAgICAgLy8gXCJrZXlwcmVzc1wiIGVuZHMgdXAgbWF0Y2hpbmcgdGhlIF9uZXh0RXhwZWN0ZWRBY3Rpb24gc2luY2UgaXQgb2NjdXJzXG4gICAgICAgICAgICAvLyBhZnRlciBhbmQgdGhhdCBjYXVzZXMgdGhlIHNlcXVlbmNlIHRvIHJlc2V0XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gd2UgaWdub3JlIGtleXByZXNzZXMgaW4gYSBzZXF1ZW5jZSB0aGF0IGRpcmVjdGx5IGZvbGxvdyBhIGtleWRvd25cbiAgICAgICAgICAgIC8vIGZvciB0aGUgc2FtZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhciBpZ25vcmVUaGlzS2V5cHJlc3MgPSBlLnR5cGUgPT0gJ2tleXByZXNzJyAmJiBfaWdub3JlTmV4dEtleXByZXNzO1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PSBfbmV4dEV4cGVjdGVkQWN0aW9uICYmICFfaXNNb2RpZmllcihjaGFyYWN0ZXIpICYmICFpZ25vcmVUaGlzS2V5cHJlc3MpIHtcbiAgICAgICAgICAgICAgICBfcmVzZXRTZXF1ZW5jZXMoZG9Ob3RSZXNldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9pZ25vcmVOZXh0S2V5cHJlc3MgPSBwcm9jZXNzZWRTZXF1ZW5jZUNhbGxiYWNrICYmIGUudHlwZSA9PSAna2V5ZG93bic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhhbmRsZXMgYSBrZXlkb3duIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2hhbmRsZUtleUV2ZW50KGUpIHtcblxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGUud2hpY2ggZm9yIGtleSBldmVudHNcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80Mjg1NjI3L2phdmFzY3JpcHQta2V5Y29kZS12cy1jaGFyY29kZS11dHRlci1jb25mdXNpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZS53aGljaCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBlLndoaWNoID0gZS5rZXlDb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gX2NoYXJhY3RlckZyb21FdmVudChlKTtcblxuICAgICAgICAgICAgLy8gbm8gY2hhcmFjdGVyIGZvdW5kIHRoZW4gc3RvcFxuICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5lZWQgdG8gdXNlID09PSBmb3IgdGhlIGNoYXJhY3RlciBjaGVjayBiZWNhdXNlIHRoZSBjaGFyYWN0ZXIgY2FuIGJlIDBcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT0gJ2tleXVwJyAmJiBfaWdub3JlTmV4dEtleXVwID09PSBjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICBfaWdub3JlTmV4dEtleXVwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmhhbmRsZUtleShjaGFyYWN0ZXIsIF9ldmVudE1vZGlmaWVycyhlKSwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogY2FsbGVkIHRvIHNldCBhIDEgc2Vjb25kIHRpbWVvdXQgb24gdGhlIHNwZWNpZmllZCBzZXF1ZW5jZVxuICAgICAgICAgKlxuICAgICAgICAgKiB0aGlzIGlzIHNvIGFmdGVyIGVhY2gga2V5IHByZXNzIGluIHRoZSBzZXF1ZW5jZSB5b3UgaGF2ZSAxIHNlY29uZFxuICAgICAgICAgKiB0byBwcmVzcyB0aGUgbmV4dCBrZXkgYmVmb3JlIHlvdSBoYXZlIHRvIHN0YXJ0IG92ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX3Jlc2V0U2VxdWVuY2VUaW1lcigpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfcmVzZXRUaW1lcik7XG4gICAgICAgICAgICBfcmVzZXRUaW1lciA9IHNldFRpbWVvdXQoX3Jlc2V0U2VxdWVuY2VzLCAxMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiaW5kcyBhIGtleSBzZXF1ZW5jZSB0byBhbiBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tYm8gLSBjb21ibyBzcGVjaWZpZWQgaW4gYmluZCBjYWxsXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXNcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBhY3Rpb25cbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2JpbmRTZXF1ZW5jZShjb21ibywga2V5cywgY2FsbGJhY2ssIGFjdGlvbikge1xuXG4gICAgICAgICAgICAvLyBzdGFydCBvZmYgYnkgYWRkaW5nIGEgc2VxdWVuY2UgbGV2ZWwgcmVjb3JkIGZvciB0aGlzIGNvbWJpbmF0aW9uXG4gICAgICAgICAgICAvLyBhbmQgc2V0dGluZyB0aGUgbGV2ZWwgdG8gMFxuICAgICAgICAgICAgX3NlcXVlbmNlTGV2ZWxzW2NvbWJvXSA9IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogY2FsbGJhY2sgdG8gaW5jcmVhc2UgdGhlIHNlcXVlbmNlIGxldmVsIGZvciB0aGlzIHNlcXVlbmNlIGFuZCByZXNldFxuICAgICAgICAgICAgICogYWxsIG90aGVyIHNlcXVlbmNlcyB0aGF0IHdlcmUgYWN0aXZlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRBY3Rpb25cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX2luY3JlYXNlU2VxdWVuY2UobmV4dEFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgX25leHRFeHBlY3RlZEFjdGlvbiA9IG5leHRBY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICsrX3NlcXVlbmNlTGV2ZWxzW2NvbWJvXTtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc2V0U2VxdWVuY2VUaW1lcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogd3JhcHMgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBpbnNpZGUgb2YgYW5vdGhlciBmdW5jdGlvbiBpbiBvcmRlclxuICAgICAgICAgICAgICogdG8gcmVzZXQgYWxsIHNlcXVlbmNlIGNvdW50ZXJzIGFzIHNvb24gYXMgdGhpcyBzZXF1ZW5jZSBpcyBkb25lXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBfY2FsbGJhY2tBbmRSZXNldChlKSB7XG4gICAgICAgICAgICAgICAgX2ZpcmVDYWxsYmFjayhjYWxsYmFjaywgZSwgY29tYm8pO1xuXG4gICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGlnbm9yZSB0aGUgbmV4dCBrZXkgdXAgaWYgdGhlIGFjdGlvbiBpcyBrZXkgZG93blxuICAgICAgICAgICAgICAgIC8vIG9yIGtleXByZXNzLiAgdGhpcyBpcyBzbyBpZiB5b3UgZmluaXNoIGEgc2VxdWVuY2UgYW5kXG4gICAgICAgICAgICAgICAgLy8gcmVsZWFzZSB0aGUga2V5IHRoZSBmaW5hbCBrZXkgd2lsbCBub3QgdHJpZ2dlciBhIGtleXVwXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2tleXVwJykge1xuICAgICAgICAgICAgICAgICAgICBfaWdub3JlTmV4dEtleXVwID0gX2NoYXJhY3RlckZyb21FdmVudChlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB3ZWlyZCByYWNlIGNvbmRpdGlvbiBpZiBhIHNlcXVlbmNlIGVuZHMgd2l0aCB0aGUga2V5XG4gICAgICAgICAgICAgICAgLy8gYW5vdGhlciBzZXF1ZW5jZSBiZWdpbnMgd2l0aFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoX3Jlc2V0U2VxdWVuY2VzLCAxMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBrZXlzIG9uZSBhdCBhIHRpbWUgYW5kIGJpbmQgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrXG4gICAgICAgICAgICAvLyBmdW5jdGlvbi4gIGZvciBhbnkga2V5IGxlYWRpbmcgdXAgdG8gdGhlIGZpbmFsIG9uZSBpdCBzaG91bGRcbiAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBzZXF1ZW5jZS4gYWZ0ZXIgdGhlIGZpbmFsLCBpdCBzaG91bGQgcmVzZXQgYWxsIHNlcXVlbmNlc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlmIGFuIGFjdGlvbiBpcyBzcGVjaWZpZWQgaW4gdGhlIG9yaWdpbmFsIGJpbmQgY2FsbCB0aGVuIHRoYXQgd2lsbFxuICAgICAgICAgICAgLy8gYmUgdXNlZCB0aHJvdWdob3V0LiAgb3RoZXJ3aXNlIHdlIHdpbGwgcGFzcyB0aGUgYWN0aW9uIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBuZXh0IGtleSBpbiB0aGUgc2VxdWVuY2Ugc2hvdWxkIG1hdGNoLiAgdGhpcyBhbGxvd3MgYSBzZXF1ZW5jZVxuICAgICAgICAgICAgLy8gdG8gbWl4IGFuZCBtYXRjaCBrZXlwcmVzcyBhbmQga2V5ZG93biBldmVudHMgZGVwZW5kaW5nIG9uIHdoaWNoXG4gICAgICAgICAgICAvLyBvbmVzIGFyZSBiZXR0ZXIgc3VpdGVkIHRvIHRoZSBrZXkgcHJvdmlkZWRcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpc0ZpbmFsID0gaSArIDEgPT09IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkQ2FsbGJhY2sgPSBpc0ZpbmFsID8gX2NhbGxiYWNrQW5kUmVzZXQgOiBfaW5jcmVhc2VTZXF1ZW5jZShhY3Rpb24gfHwgX2dldEtleUluZm8oa2V5c1tpICsgMV0pLmFjdGlvbik7XG4gICAgICAgICAgICAgICAgX2JpbmRTaW5nbGUoa2V5c1tpXSwgd3JhcHBlZENhbGxiYWNrLCBhY3Rpb24sIGNvbWJvLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiaW5kcyBhIHNpbmdsZSBrZXlib2FyZCBjb21iaW5hdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tYmluYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBhY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBzZXF1ZW5jZU5hbWUgLSBuYW1lIG9mIHNlcXVlbmNlIGlmIHBhcnQgb2Ygc2VxdWVuY2VcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBsZXZlbCAtIHdoYXQgcGFydCBvZiB0aGUgc2VxdWVuY2UgdGhlIGNvbW1hbmQgaXNcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2JpbmRTaW5nbGUoY29tYmluYXRpb24sIGNhbGxiYWNrLCBhY3Rpb24sIHNlcXVlbmNlTmFtZSwgbGV2ZWwpIHtcblxuICAgICAgICAgICAgLy8gc3RvcmUgYSBkaXJlY3QgbWFwcGVkIHJlZmVyZW5jZSBmb3IgdXNlIHdpdGggTW91c2V0cmFwLnRyaWdnZXJcbiAgICAgICAgICAgIHNlbGYuX2RpcmVjdE1hcFtjb21iaW5hdGlvbiArICc6JyArIGFjdGlvbl0gPSBjYWxsYmFjaztcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG11bHRpcGxlIHNwYWNlcyBpbiBhIHJvdyBiZWNvbWUgYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICAgIGNvbWJpbmF0aW9uID0gY29tYmluYXRpb24ucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuXG4gICAgICAgICAgICB2YXIgc2VxdWVuY2UgPSBjb21iaW5hdGlvbi5zcGxpdCgnICcpO1xuICAgICAgICAgICAgdmFyIGluZm87XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgcGF0dGVybiBpcyBhIHNlcXVlbmNlIG9mIGtleXMgdGhlbiBydW4gdGhyb3VnaCB0aGlzIG1ldGhvZFxuICAgICAgICAgICAgLy8gdG8gcmVwcm9jZXNzIGVhY2ggcGF0dGVybiBvbmUga2V5IGF0IGEgdGltZVxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBfYmluZFNlcXVlbmNlKGNvbWJpbmF0aW9uLCBzZXF1ZW5jZSwgY2FsbGJhY2ssIGFjdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmZvID0gX2dldEtleUluZm8oY29tYmluYXRpb24sIGFjdGlvbik7XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbml0aWFsaXplIGFycmF5IGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIC8vIGEgY2FsbGJhY2sgaXMgYWRkZWQgZm9yIHRoaXMga2V5XG4gICAgICAgICAgICBzZWxmLl9jYWxsYmFja3NbaW5mby5rZXldID0gc2VsZi5fY2FsbGJhY2tzW2luZm8ua2V5XSB8fCBbXTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGFuIGV4aXN0aW5nIG1hdGNoIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICAgICAgX2dldE1hdGNoZXMoaW5mby5rZXksIGluZm8ubW9kaWZpZXJzLCB7dHlwZTogaW5mby5hY3Rpb259LCBzZXF1ZW5jZU5hbWUsIGNvbWJpbmF0aW9uLCBsZXZlbCk7XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGlzIGNhbGwgYmFjayB0byB0aGUgYXJyYXlcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgc2VxdWVuY2UgcHV0IGl0IGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgIC8vIGlmIG5vdCBwdXQgaXQgYXQgdGhlIGVuZFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIHdheSB0aGVzZSBhcmUgcHJvY2Vzc2VkIGV4cGVjdHNcbiAgICAgICAgICAgIC8vIHRoZSBzZXF1ZW5jZSBvbmVzIHRvIGNvbWUgZmlyc3RcbiAgICAgICAgICAgIHNlbGYuX2NhbGxiYWNrc1tpbmZvLmtleV1bc2VxdWVuY2VOYW1lID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXSh7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyczogaW5mby5tb2RpZmllcnMsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBpbmZvLmFjdGlvbixcbiAgICAgICAgICAgICAgICBzZXE6IHNlcXVlbmNlTmFtZSxcbiAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICAgICAgY29tYm86IGNvbWJpbmF0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiaW5kcyBtdWx0aXBsZSBjb21iaW5hdGlvbnMgdG8gdGhlIHNhbWUgY2FsbGJhY2tcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gY29tYmluYXRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gYWN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuX2JpbmRNdWx0aXBsZSA9IGZ1bmN0aW9uKGNvbWJpbmF0aW9ucywgY2FsbGJhY2ssIGFjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21iaW5hdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBfYmluZFNpbmdsZShjb21iaW5hdGlvbnNbaV0sIGNhbGxiYWNrLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHN0YXJ0IVxuICAgICAgICBfYWRkRXZlbnQodGFyZ2V0RWxlbWVudCwgJ2tleXByZXNzJywgX2hhbmRsZUtleUV2ZW50KTtcbiAgICAgICAgX2FkZEV2ZW50KHRhcmdldEVsZW1lbnQsICdrZXlkb3duJywgX2hhbmRsZUtleUV2ZW50KTtcbiAgICAgICAgX2FkZEV2ZW50KHRhcmdldEVsZW1lbnQsICdrZXl1cCcsIF9oYW5kbGVLZXlFdmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYmluZHMgYW4gZXZlbnQgdG8gbW91c2V0cmFwXG4gICAgICpcbiAgICAgKiBjYW4gYmUgYSBzaW5nbGUga2V5LCBhIGNvbWJpbmF0aW9uIG9mIGtleXMgc2VwYXJhdGVkIHdpdGggKyxcbiAgICAgKiBhbiBhcnJheSBvZiBrZXlzLCBvciBhIHNlcXVlbmNlIG9mIGtleXMgc2VwYXJhdGVkIGJ5IHNwYWNlc1xuICAgICAqXG4gICAgICogYmUgc3VyZSB0byBsaXN0IHRoZSBtb2RpZmllciBrZXlzIGZpcnN0IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZVxuICAgICAqIGNvcnJlY3Qga2V5IGVuZHMgdXAgZ2V0dGluZyBib3VuZCAodGhlIGxhc3Qga2V5IGluIHRoZSBwYXR0ZXJuKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IGtleXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uIC0gJ2tleXByZXNzJywgJ2tleWRvd24nLCBvciAna2V5dXAnXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIE1vdXNldHJhcC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGtleXMsIGNhbGxiYWNrLCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBrZXlzID0ga2V5cyBpbnN0YW5jZW9mIEFycmF5ID8ga2V5cyA6IFtrZXlzXTtcbiAgICAgICAgc2VsZi5fYmluZE11bHRpcGxlLmNhbGwoc2VsZiwga2V5cywgY2FsbGJhY2ssIGFjdGlvbik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmRzIGFuIGV2ZW50IHRvIG1vdXNldHJhcFxuICAgICAqXG4gICAgICogdGhlIHVuYmluZGluZyBzZXRzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGtleSBjb21ib1xuICAgICAqIHRvIGFuIGVtcHR5IGZ1bmN0aW9uIGFuZCBkZWxldGVzIHRoZSBjb3JyZXNwb25kaW5nIGtleSBpbiB0aGVcbiAgICAgKiBfZGlyZWN0TWFwIGRpY3QuXG4gICAgICpcbiAgICAgKiBUT0RPOiBhY3R1YWxseSByZW1vdmUgdGhpcyBmcm9tIHRoZSBfY2FsbGJhY2tzIGRpY3Rpb25hcnkgaW5zdGVhZFxuICAgICAqIG9mIGJpbmRpbmcgYW4gZW1wdHkgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIHRoZSBrZXljb21ibythY3Rpb24gaGFzIHRvIGJlIGV4YWN0bHkgdGhlIHNhbWUgYXNcbiAgICAgKiBpdCB3YXMgZGVmaW5lZCBpbiB0aGUgYmluZCBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBrZXlzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBNb3VzZXRyYXAucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKGtleXMsIGFjdGlvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzZWxmLmJpbmQuY2FsbChzZWxmLCBrZXlzLCBmdW5jdGlvbigpIHt9LCBhY3Rpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0cmlnZ2VycyBhbiBldmVudCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlzXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBhY3Rpb25cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oa2V5cywgYWN0aW9uKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYuX2RpcmVjdE1hcFtrZXlzICsgJzonICsgYWN0aW9uXSkge1xuICAgICAgICAgICAgc2VsZi5fZGlyZWN0TWFwW2tleXMgKyAnOicgKyBhY3Rpb25dKHt9LCBrZXlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVzZXRzIHRoZSBsaWJyYXJ5IGJhY2sgdG8gaXRzIGluaXRpYWwgc3RhdGUuICB0aGlzIGlzIHVzZWZ1bFxuICAgICAqIGlmIHlvdSB3YW50IHRvIGNsZWFyIG91dCB0aGUgY3VycmVudCBrZXlib2FyZCBzaG9ydGN1dHMgYW5kIGJpbmRcbiAgICAgKiBuZXcgb25lcyAtIGZvciBleGFtcGxlIGlmIHlvdSBzd2l0Y2ggdG8gYW5vdGhlciBwYWdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICBzZWxmLl9kaXJlY3RNYXAgPSB7fTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNob3VsZCB3ZSBzdG9wIHRoaXMgZXZlbnQgYmVmb3JlIGZpcmluZyBvZmYgY2FsbGJhY2tzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBNb3VzZXRyYXAucHJvdG90eXBlLnN0b3BDYWxsYmFjayA9IGZ1bmN0aW9uKGUsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3MgXCJtb3VzZXRyYXBcIiB0aGVuIG5vIG5lZWQgdG8gc3RvcFxuICAgICAgICBpZiAoKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgbW91c2V0cmFwICcpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfYmVsb25nc1RvKGVsZW1lbnQsIHNlbGYudGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXZlbnRzIG9yaWdpbmF0aW5nIGZyb20gYSBzaGFkb3cgRE9NIGFyZSByZS10YXJnZXR0ZWQgYW5kIGBlLnRhcmdldGAgaXMgdGhlIHNoYWRvdyBob3N0LFxuICAgICAgICAvLyBub3QgdGhlIGluaXRpYWwgZXZlbnQgdGFyZ2V0IGluIHRoZSBzaGFkb3cgdHJlZS4gTm90ZSB0aGF0IG5vdCBhbGwgZXZlbnRzIGNyb3NzIHRoZVxuICAgICAgICAvLyBzaGFkb3cgYm91bmRhcnkuXG4gICAgICAgIC8vIEZvciBzaGFkb3cgdHJlZXMgd2l0aCBgbW9kZTogJ29wZW4nYCwgdGhlIGluaXRpYWwgZXZlbnQgdGFyZ2V0IGlzIHRoZSBmaXJzdCBlbGVtZW50IGluXG4gICAgICAgIC8vIHRoZSBldmVudOKAmXMgY29tcG9zZWQgcGF0aC4gRm9yIHNoYWRvdyB0cmVlcyB3aXRoIGBtb2RlOiAnY2xvc2VkJ2AsIHRoZSBpbml0aWFsIGV2ZW50XG4gICAgICAgIC8vIHRhcmdldCBjYW5ub3QgYmUgb2J0YWluZWQuXG4gICAgICAgIGlmICgnY29tcG9zZWRQYXRoJyBpbiBlICYmIHR5cGVvZiBlLmNvbXBvc2VkUGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gRm9yIG9wZW4gc2hhZG93IHRyZWVzLCB1cGRhdGUgYGVsZW1lbnRgIHNvIHRoYXQgdGhlIGZvbGxvd2luZyBjaGVjayB3b3Jrcy5cbiAgICAgICAgICAgIHZhciBpbml0aWFsRXZlbnRUYXJnZXQgPSBlLmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxFdmVudFRhcmdldCAhPT0gZS50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gaW5pdGlhbEV2ZW50VGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcCBmb3IgaW5wdXQsIHNlbGVjdCwgYW5kIHRleHRhcmVhXG4gICAgICAgIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT0gJ0lOUFVUJyB8fCBlbGVtZW50LnRhZ05hbWUgPT0gJ1NFTEVDVCcgfHwgZWxlbWVudC50YWdOYW1lID09ICdURVhUQVJFQScgfHwgZWxlbWVudC5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZXhwb3NlcyBfaGFuZGxlS2V5IHB1YmxpY2x5IHNvIGl0IGNhbiBiZSBvdmVyd3JpdHRlbiBieSBleHRlbnNpb25zXG4gICAgICovXG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS5oYW5kbGVLZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VsZi5faGFuZGxlS2V5LmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFsbG93IGN1c3RvbSBrZXkgbWFwcGluZ3NcbiAgICAgKi9cbiAgICBNb3VzZXRyYXAuYWRkS2V5Y29kZXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgX01BUFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX1JFVkVSU0VfTUFQID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdCB0aGUgZ2xvYmFsIG1vdXNldHJhcCBmdW5jdGlvbnNcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5lZWRlZCB0byBhbGxvdyB0aGUgZ2xvYmFsIG1vdXNldHJhcCBmdW5jdGlvbnMgdG8gd29ya1xuICAgICAqIG5vdyB0aGF0IG1vdXNldHJhcCBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIE1vdXNldHJhcC5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb2N1bWVudE1vdXNldHJhcCA9IE1vdXNldHJhcChkb2N1bWVudCk7XG4gICAgICAgIGZvciAodmFyIG1ldGhvZCBpbiBkb2N1bWVudE1vdXNldHJhcCkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZC5jaGFyQXQoMCkgIT09ICdfJykge1xuICAgICAgICAgICAgICAgIE1vdXNldHJhcFttZXRob2RdID0gKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRNb3VzZXRyYXBbbWV0aG9kXS5hcHBseShkb2N1bWVudE1vdXNldHJhcCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IChtZXRob2QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBNb3VzZXRyYXAuaW5pdCgpO1xuXG4gICAgLy8gZXhwb3NlIG1vdXNldHJhcCB0byB0aGUgZ2xvYmFsIG9iamVjdFxuICAgIHdpbmRvdy5Nb3VzZXRyYXAgPSBNb3VzZXRyYXA7XG5cbiAgICAvLyBleHBvc2UgYXMgYSBjb21tb24ganMgbW9kdWxlXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gTW91c2V0cmFwO1xuICAgIH1cblxuICAgIC8vIGV4cG9zZSBtb3VzZXRyYXAgYXMgYW4gQU1EIG1vZHVsZVxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1vdXNldHJhcDtcbiAgICAgICAgfSk7XG4gICAgfVxufSkgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogbnVsbCwgdHlwZW9mICB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBzdGRDYXRUb1N0cmluZyh4KXtcbiAgICBpZih4ID09PSB1bmRlZmluZWQpe1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZih4LmdldFN0cmluZ2lmeWluZ01hcEtleSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgcmV0dXJuIHguZ2V0U3RyaW5naWZ5aW5nTWFwS2V5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHgudG9TdHJpbmcoKTtcbiAgICB9XG59XG5cbnZhciBTdHJpbmdpZnlpbmdNYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ2lmeWluZ01hcChjYXRUb1N0cmluZykge1xuICAgICAgICBpZihjYXRUb1N0cmluZyA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGNhdFRvU3RyaW5nID0gc3RkQ2F0VG9TdHJpbmdcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhdFRvU3RyaW5nID0gY2F0VG9TdHJpbmc7XG4gICAgICAgIHRoaXMubSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5rZXlfc3RyaW5nX3RvX2tleV9vYmplY3QgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIFN0cmluZ2lmeWluZ01hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgbGV0IGtleV9zdHJpbmcgPSB0aGlzLmNhdFRvU3RyaW5nKGspO1xuICAgICAgICBpZihrZXlfc3RyaW5nID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGVuY29kaW5nIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXlfc3RyaW5nX3RvX2tleV9vYmplY3Quc2V0KGtleV9zdHJpbmcsIGspO1xuICAgICAgICBsZXQgcyA9IHRoaXMubS5zZXQoa2V5X3N0cmluZywgdik7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyaW5naWZ5aW5nTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaykge1xuICAgICAgICBsZXQga2V5X3N0cmluZyA9IHRoaXMuY2F0VG9TdHJpbmcoayk7XG4gICAgICAgIGlmKGtleV9zdHJpbmcgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm0uZ2V0KHRoaXMuY2F0VG9TdHJpbmcoaykpO1xuICAgIH07XG4gICAgU3RyaW5naWZ5aW5nTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoaykge1xuICAgICAgICB0aGlzLmtleV9zdHJpbmdfdG9fa2V5X29iamVjdC5kZWxldGUodGhpcy5jYXRUb1N0cmluZyhrKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm0uZGVsZXRlKHRoaXMuY2F0VG9TdHJpbmcoaykpO1xuICAgIH07XG4gICAgU3RyaW5naWZ5aW5nTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoaykge1xuICAgICAgICBpZihrID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm0uaGFzKHRoaXMuY2F0VG9TdHJpbmcoaykpO1xuICAgIH07ICAgIFxuXG4gICAgU3RyaW5naWZ5aW5nTWFwLnByb3RvdHlwZS5nZXRPckVsc2UgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoa2V5KSA/IHRoaXMuZ2V0KGtleSkgOiB2YWx1ZTtcbiAgICB9O1xuICAgIFxuICAgIFN0cmluZ2lmeWluZ01hcC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKigpe1xuICAgICAgICBmb3IobGV0IGsgb2YgdGhpcy5tKXtcbiAgICAgICAgICAgIHlpZWxkIFt0aGlzLmtleV9zdHJpbmdfdG9fa2V5X29iamVjdC5nZXQoa1swXSksa1sxXV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU3RyaW5naWZ5aW5nTWFwLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5X3N0cmluZ190b19rZXlfb2JqZWN0LnZhbHVlcygpO1xuICAgIH07XG5cbiAgICBTdHJpbmdpZnlpbmdNYXAucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBbLi4udGhpc107XG4gICAgfVxuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmdpZnlpbmdNYXAucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm0uc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFN0cmluZ2lmeWluZ01hcDtcbn0oKSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmdpZnlpbmdNYXA7XG4iLCJleHBvcnRzLklORklOSVRZID0gNjU1MzU7IiwiXCJ1c2Ugc3RyaWN0XCJcblxubGV0IERpc3BsYXkgPSByZXF1aXJlKFwiLi9EaXNwbGF5LmpzXCIpLkRpc3BsYXk7XG5sZXQgVG9vbHRpcCA9IHJlcXVpcmUoXCIuL1Rvb2x0aXAuanNcIikuVG9vbHRpcDtcbmxldCBJbnRlcmZhY2UgPSByZXF1aXJlKFwiLi9JbnRlcmZhY2UuanNcIik7XG5sZXQgTW91c2V0cmFwID0gcmVxdWlyZShcIm1vdXNldHJhcFwiKTtcblxuY2xhc3MgQmFzaWNEaXNwbGF5IGV4dGVuZHMgRGlzcGxheSB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBzc2VxLCBrd2FyZ3MpIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyLCBzc2VxKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgIHRoaXMucGFnZV9pbmRpY2F0b3JfZGl2ID0gdGhpcy5jb250YWluZXIuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwicGFnZV9pbmRpY2F0b3JcIilcbiAgICAgICAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIilcbiAgICAgICAgICAgIC5zdHlsZShcImxlZnRcIiwgXCIyMHB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0b3BcIixcIjEwcHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsXCJBcmlhbFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxNXB4XCIpO1xuXG4gICAgICAgIHRoaXMudG9vbHRpcCA9IG5ldyBUb29sdGlwKHRoaXMpO1xuICAgICAgICB0aGlzLm9uKFwibW91c2VvdmVyXCIsIChub2RlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuc2V0SFRNTCh0aGlzLmdldENsYXNzVG9vbHRpcEhUTUwobm9kZSwgdGhpcy5wYWdlKSk7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuc2hvdyhub2RlLl9jYW52YXNfeCwgbm9kZS5fY2FudmFzX3kpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbihcIm1vdXNlb3V0XCIsICgpID0+IHRoaXMudG9vbHRpcC5oaWRlKCkpO1xuXG4gICAgICAgIE1vdXNldHJhcC5iaW5kKCdsZWZ0JywgIHRoaXMucHJldmlvdXNQYWdlKTtcbiAgICAgICAgTW91c2V0cmFwLmJpbmQoJ3JpZ2h0JywgdGhpcy5uZXh0UGFnZSk7XG4gICAgICAgIE1vdXNldHJhcC5iaW5kKCd4JyxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm1vdXNlb3Zlcl9ub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5tb3VzZW92ZXJfbm9kZS5jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5vbihcInBhZ2UtY2hhbmdlXCIsIHIgPT4gdGhpcy5wYWdlX2luZGljYXRvcl9kaXYuaHRtbCh0aGlzLmdldFBhZ2VEZXNjcmlwdG9yKHIpKSk7XG5cbiAgICAgICAgLy8gVHJpZ2dlciBwYWdlLWNoYW5nZSB0byBzZXQgaW5pdGlhbCBwYWdlX2luZGljYXRvcl9kaXZcbiAgICAgICAgdGhpcy5zZXRQYWdlKCk7XG5cbiAgICAgICAgdGhpcy5zdGF0dXNfZGl2ID0gdGhpcy5jb250YWluZXIuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwic3RhdHVzXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsIGAyMHB4YClcbiAgICAgICAgICAgIC5zdHlsZShcImJvdHRvbVwiLGAyMHB4YClcbiAgICAgICAgICAgIC5zdHlsZShcInotaW5kZXhcIiwgMTAwMCk7XG4gICAgfVxuXG4gICAgc2V0U3RhdHVzKGh0bWwpe1xuICAgICAgICBpZih0aGlzLnN0YXR1c19kaXZfdGltZXIpe1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc3RhdHVzX2Rpdl90aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0dXNfZGl2Lmh0bWwoaHRtbCk7XG4gICAgfVxuXG4gICAgZGVsYXllZFNldFN0YXR1cyhodG1sLCBkZWxheSl7XG4gICAgICAgIHRoaXMuc3RhdHVzX2Rpdl90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gc2V0U3RhdHVzKGh0bWwpLCBkZWxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdG9vbHRpcCBmb3IgdGhlIGN1cnJlbnQgY2xhc3Mgb24gdGhlIGdpdmVuIHBhZ2UgKGN1cnJlbnRseSBpZ25vcmVzIHRoZSBwYWdlKS5cbiAgICAgKiBAcGFyYW0gY1xuICAgICAqIEBwYXJhbSBwYWdlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDbGFzc1Rvb2x0aXAoYywgcGFnZSkge1xuICAgICAgICBsZXQgdG9vbHRpcCA9IGMuZ2V0TmFtZUNvb3JkKCk7XG4gICAgICAgIGxldCBleHRyYV9pbmZvID0gQmFzaWNEaXNwbGF5LnRvVG9vbHRpcFN0cmluZyhjLmV4dHJhX2luZm8sIHBhZ2UpO1xuXG4gICAgICAgIGlmIChleHRyYV9pbmZvKVxuICAgICAgICAgICAgdG9vbHRpcCArPSBleHRyYV9pbmZvO1xuXG4gICAgICAgIHJldHVybiB0b29sdGlwO1xuICAgIH1cblxuICAgIGdldENsYXNzVG9vbHRpcEhUTUwoYywgcGFnZSkge1xuICAgICAgICByZXR1cm4gSW50ZXJmYWNlLnJlbmRlckxhdGV4KHRoaXMuZ2V0Q2xhc3NUb29sdGlwKGMscGFnZSkpO1xuICAgIH0gICAgXG5cbiAgICBzdGF0aWMgdG9Ub29sdGlwU3RyaW5nKG9iaiwgcGFnZSkge1xuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYob2JqLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpe1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoubWFwKCh4KSA9PiBUb29sdGlwLnRvVG9vbHRpcFN0cmluZyh4LCBwYWdlKSkuZmlsdGVyKCh4KSA9PiB4KS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYob2JqLmNvbnN0cnVjdG9yID09PSBNYXApe1xuICAgICAgICAgICAgbGV0IGxhc3RrZXk7XG4gICAgICAgICAgICBmb3IgKGxldCBrIG9mIG9iai5rZXlzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoayA+IHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RrZXkgPSBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEJhc2ljRGlzcGxheS50b1Rvb2x0aXBTdHJpbmcob2JqLmdldChsYXN0a2V5KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5leHBvcnRzLkJhc2ljRGlzcGxheSA9IEJhc2ljRGlzcGxheTtcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxubGV0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIik7XHJcbmxldCBkMyA9IE9iamVjdC5hc3NpZ24oe30sIFxyXG4gICAgcmVxdWlyZShcImQzLXNlbGVjdGlvblwiKSwgXHJcbiAgICByZXF1aXJlKFwiZDMtem9vbVwiKSwgXHJcbiAgICByZXF1aXJlKFwiZDMtc2NhbGVcIiksIFxyXG4gICAgcmVxdWlyZShcImQzLXRpbWVyXCIpXHJcbik7XHJcblxyXG5sZXQgSU5GSU5JVFkgPSByZXF1aXJlKFwiLi4vaW5maW5pdHkuanNcIikuSU5GSU5JVFlcclxuXHJcbmNvbnN0IGdyaWRHbyA9IFwiZ29cIjtcclxuY29uc3QgZ3JpZENoZXNzID0gXCJjaGVzc1wiO1xyXG5cclxuY2xhc3MgRGlzcGxheSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICAvLyBjb250YWluZXIgaXMgZWl0aGVyIGFuIGlkIChlLmcuIFwiI21haW5cIikgb3IgYSBET00gb2JqZWN0XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHNzZXEpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLmxlZnRNYXJnaW4gPSA0MDtcclxuICAgICAgICB0aGlzLnJpZ2h0TWFyZ2luID0gNTtcclxuICAgICAgICB0aGlzLnRvcE1hcmdpbiA9IDQ1O1xyXG4gICAgICAgIHRoaXMuYm90dG9tTWFyZ2luID0gNTA7XHJcbiAgICAgICAgdGhpcy5kb21haW5PZmZzZXQgPSAxIC8gMjtcclxuXHJcbiAgICAgICAgdGhpcy5ncmlkU3R5bGUgPSBncmlkR287XHJcbiAgICAgICAgdGhpcy5ncmlkQ29sb3IgPSBcIiNjNmM2YzZcIjtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRfY29sb3IgPSBcIiNGRkZGRkZcIjtcclxuICAgICAgICB0aGlzLmdyaWRTdHJva2VXaWR0aCA9IDAuMztcclxuICAgICAgICB0aGlzLlRJQ0tfU1RFUF9MT0dfQkFTRSA9IDEuMTsgLy8gVXNlZCBmb3IgZGVjaWRpbmcgd2hlbiB0byBjaGFuZ2UgdGljayBzdGVwLlxyXG5cclxuICAgICAgICB0aGlzLmhpZGRlblN0cnVjdGxpbmVzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUXVldWUgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGQzLnNlbGVjdChjb250YWluZXIpO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyX0RPTSA9IHRoaXMuY29udGFpbmVyLm5vZGUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuc2VsZWN0QWxsKCkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIHRoaXMueFNjYWxlSW5pdCA9IGQzLnNjYWxlTGluZWFyKCk7XHJcbiAgICAgICAgdGhpcy55U2NhbGVJbml0ID0gZDMuc2NhbGVMaW5lYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnBhZGRpbmcgPSBcIjBweFwiO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9IFwiMFwiO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSBcIjBcIjtcclxuXHJcbiAgICAgICAgdGhpcy5jb250YWluZXJfRE9NLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZUJhdGNoID0gdGhpcy51cGRhdGVCYXRjaC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMubmV4dFBhZ2UgPSB0aGlzLm5leHRQYWdlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c1BhZ2UgPSB0aGlzLnByZXZpb3VzUGFnZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX29uTW91c2Vtb3ZlID0gdGhpcy5fb25Nb3VzZW1vdmUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9vbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLnpvb20gPSBkMy56b29tKCkuc2NhbGVFeHRlbnQoWzAsIDRdKTtcclxuICAgICAgICB0aGlzLnpvb20ub24oXCJ6b29tXCIsIHRoaXMudXBkYXRlQmF0Y2gpO1xyXG4gICAgICAgIHRoaXMuem9vbUQzRWxlbWVudCA9IGQzLnNlbGVjdCh0aGlzLmNhbnZhcyk7XHJcbiAgICAgICAgdGhpcy56b29tRDNFbGVtZW50LmNhbGwodGhpcy56b29tKS5vbihcImRibGNsaWNrLnpvb21cIiwgbnVsbCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZW1vdmUpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9vbkNsaWNrKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogaW1wcm92ZSB3aW5kb3cgcmVzaXplIGhhbmRsaW5nLiBDdXJyZW50bHkgdGhlIHdheSB0aGF0IHRoZSBkb21haW4gY2hhbmdlcyBpcyBzdWJvcHRpbWFsLlxyXG4gICAgICAgIC8vIEkgdGhpbmsgdGhlIGJlc3Qgd291bGQgYmUgdG8gbWFpbnRhaW4gdGhlIHggYW5kIHkgcmFuZ2UgYnkgc2NhbGluZy5cclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAgKCkgPT4gdGhpcy5yZXNpemUoKSk7XHJcblxyXG4gICAgICAgIGlmKHNzZXEpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTc2VxKHNzZXEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3IpIHtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRfY29sb3IgPSBjb2xvcjtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lcl9ET00uc3R5bGVbXCJiYWNrZ3JvdW5kXCJdID0gY29sb3I7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggT3B0aW9uYWwgd2lkdGguIERlZmF1bHQgdG8gOTclIG9mIHdpZHRoIG9mIGJvdW5kaW5nIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IE9wdGlvbmFsIGhlaWdodC4gRGVmYXVsdCB0byA5NyUgb2YgaGVpZ2h0IG9mIGJvdW5kaW5nIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KXtcclxuICAgICAgICBpZighdGhpcy5zc2VxKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBvbGR4bWluID0gdGhpcy54bWluRmxvYXQ7XHJcbiAgICAgICAgbGV0IG9sZHltaW4gPSB0aGlzLnltaW5GbG9hdDtcclxuICAgICAgICAvLyBUaGlzIGZpeGVzIHRoZSBzY2FsZSwgYnV0IGxlYXZlcyBhXHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl91cGRhdGVTY2FsZSgpO1xyXG4gICAgICAgIGxldCBkeCA9IHRoaXMueG1pbkZsb2F0IC0gb2xkeG1pbjtcclxuICAgICAgICBsZXQgZHkgPSB0aGlzLnltaW5GbG9hdCAtIG9sZHltaW47XHJcbiAgICAgICAgdGhpcy56b29tLm9uKFwiem9vbVwiLCBudWxsKTtcclxuICAgICAgICB0aGlzLnpvb20udHJhbnNsYXRlQnkodGhpcy56b29tRDNFbGVtZW50LCB0aGlzLmR4U2NhbGUoZHgpLCB0aGlzLmR5U2NhbGUoZHkpKTtcclxuICAgICAgICB0aGlzLnpvb20ub24oXCJ6b29tXCIsIHRoaXMudXBkYXRlQmF0Y2gpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQmF0Y2goKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemF0aW9uIG1ldGhvZCBjYWxsZWQgaW4gY29uc3RydWN0b3IuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfaW5pdGlhbGl6ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KXtcclxuICAgICAgICBjb25zdCBib3VuZGluZ1JlY3RhbmdsZSA9IHRoaXMuY29udGFpbmVyX0RPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBjb25zdCBjYW52YXNXaWR0aCA9IHdpZHRoIHx8IDAuOTkqYm91bmRpbmdSZWN0YW5nbGUud2lkdGg7XHJcbiAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0IHx8IDAuOTcqYm91bmRpbmdSZWN0YW5nbGUuaGVpZ2h0O1xyXG5cclxuICAgICAgICB0aGlzLmNhbnZhc1dpZHRoID0gY2FudmFzV2lkdGg7XHJcbiAgICAgICAgdGhpcy5jYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XHJcblxyXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xyXG5cclxuICAgICAgICB0aGlzLmNsaXBXaWR0aCA9IHRoaXMuY2FudmFzV2lkdGggLSB0aGlzLnJpZ2h0TWFyZ2luO1xyXG4gICAgICAgIHRoaXMuY2xpcEhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0IC0gdGhpcy5ib3R0b21NYXJnaW47XHJcblxyXG4gICAgICAgIHRoaXMucGxvdFdpZHRoID0gdGhpcy5jYW52YXNXaWR0aCAtIHRoaXMubGVmdE1hcmdpbiAtIHRoaXMucmlnaHRNYXJnaW47XHJcbiAgICAgICAgdGhpcy5wbG90SGVpZ2h0ID0gdGhpcy5jYW52YXNIZWlnaHQgLSB0aGlzLmJvdHRvbU1hcmdpbiAtIHRoaXMudG9wTWFyZ2luO1xyXG5cclxuICAgICAgICB0aGlzLnhTY2FsZUluaXQgPSB0aGlzLnhTY2FsZUluaXQucmFuZ2UoW3RoaXMubGVmdE1hcmdpbiwgdGhpcy5jbGlwV2lkdGhdKTtcclxuICAgICAgICB0aGlzLnlTY2FsZUluaXQgPSB0aGlzLnlTY2FsZUluaXQucmFuZ2UoW3RoaXMuY2xpcEhlaWdodCwgdGhpcy50b3BNYXJnaW5dKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHNwZWN0cmFsIHNlcXVlbmNlIHRvIGRpc3BsYXkuXHJcbiAgICAgKiBAcGFyYW0gc3NcclxuICAgICAqL1xyXG4gICAgc2V0U3NlcShzc2VxKXtcclxuICAgICAgICBpZih0aGlzLnNzZXEpIHtcclxuICAgICAgICAgICAgdGhpcy5zc2VxLnJlbW92ZUxpc3RlbmVyKFwidXBkYXRlXCIsIHRoaXMudXBkYXRlQmF0Y2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNzZXEgPSBzc2VxO1xyXG4gICAgICAgIC8vIFRoZSBzc2VxIG9iamVjdCBjb250YWlucyB0aGUgbGlzdCBvZiB2YWxpZCBwYWdlcy4gQWx3YXlzIGluY2x1ZGVzIGF0IGxlYXN0IDAgYW5kIGluZmluaXR5LlxyXG4gICAgICAgIGlmKHRoaXMuc3NlcS5pbml0aWFsX3BhZ2VfaWR4KXtcclxuICAgICAgICAgICAgdGhpcy5wYWdlX2lkeCA9IHRoaXMuc3NlcS5pbml0aWFsX3BhZ2VfaWR4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFnZV9pZHggPSB0aGlzLnNzZXEubWluX3BhZ2VfaWR4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLnBhZ2VfaWR4ID49IHRoaXMuc3NlcS5wYWdlX2xpc3QubGVuZ3RoKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFdhcm5pbmc6IG1pbl9wYWdlX2lkeCAke3RoaXMuc3NlcS5taW5fcGFnZV9pZHh9IGdyZWF0ZXIgdGhhbiBwYWdlIGxpc3QgbGVuZ3RoICR7dGhpcy5zc2VxLnBhZ2VfbGlzdC5sZW5ndGh9LiBVc2luZyAwIGZvciBtaW5fcGFnZV9pZHggaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgdGhpcy5wYWdlX2lkeCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubWluX3BhZ2VfaWR4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQYWdlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVDYW52YXMoKTtcclxuXHJcbiAgICAgICAgaWYoc3NlcS5ncmlkU3R5bGUpe1xyXG4gICAgICAgICAgICB0aGlzLmdyaWRTdHlsZSA9IHNzZXEuZ3JpZFN0eWxlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zc2VxLm9uKCd1cGRhdGUnLHRoaXMudXBkYXRlQmF0Y2gpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2luaXRpYWxpemVTY2FsZSgpe1xyXG4gICAgICAgIHRoaXMueFNjYWxlSW5pdC5kb21haW4oW3RoaXMuc3NlcS5pbml0aWFsX3hfcmFuZ2VbMF0gLSB0aGlzLmRvbWFpbk9mZnNldCwgdGhpcy5zc2VxLmluaXRpYWxfeF9yYW5nZVsxXSArIHRoaXMuZG9tYWluT2Zmc2V0XSk7XHJcbiAgICAgICAgdGhpcy55U2NhbGVJbml0LmRvbWFpbihbdGhpcy5zc2VxLmluaXRpYWxfeV9yYW5nZVswXSAtIHRoaXMuZG9tYWluT2Zmc2V0LCB0aGlzLnNzZXEuaW5pdGlhbF95X3JhbmdlWzFdICsgdGhpcy5kb21haW5PZmZzZXRdKTtcclxuICAgIH1cclxuXHJcbiAgICBuZXh0UGFnZSgpe1xyXG4gICAgICAgIGlmICh0aGlzLnBhZ2VfaWR4IDwgdGhpcy5zc2VxLnBhZ2VfbGlzdC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGFnZSh0aGlzLnBhZ2VfaWR4ICsgMSk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByZXZpb3VzUGFnZSgpe1xyXG4gICAgICAgIGlmICh0aGlzLnBhZ2VfaWR4ID4gdGhpcy5zc2VxLm1pbl9wYWdlX2lkeCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFBhZ2UodGhpcy5wYWdlX2lkeCAtIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGlzLnBhZ2UgYW5kIHRoaXMucGFnZVJhbmdlIHRvIHJlZmxlY3QgdGhlIHZhbHVlIG9mIHBhZ2VfaWR4LlxyXG4gICAgICogRXZlbnR1YWxseSBJIHNob3VsZCBtYWtlIGEgZGlzcGxheSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBwYWdlIGFnYWluLCB0aGVuIHRoaXMgY2FuIGFsc28gc2F5IHdoYXQgdGhhdCBpcy5cclxuICAgICAqL1xyXG4gICAgc2V0UGFnZShpZHgpe1xyXG4gICAgICAgIGlmICghdGhpcy5zc2VxKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmKGlkeCAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhpcy5wYWdlX2lkeCA9IGlkeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYWdlUmFuZ2UgPSB0aGlzLnNzZXEucGFnZV9saXN0W3RoaXMucGFnZV9pZHhdO1xyXG5cclxuICAgICAgICBpZihBcnJheS5pc0FycmF5KHRoaXMucGFnZVJhbmdlKSl7XHJcbiAgICAgICAgICAgIHRoaXMucGFnZSA9IHRoaXMucGFnZVJhbmdlWzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFnZSA9IHRoaXMucGFnZVJhbmdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVtaXQoXCJwYWdlLWNoYW5nZVwiLCB0aGlzLnBhZ2VSYW5nZSwgdGhpcy5wYWdlX2lkeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWFpbiB1cGRhdGVBbGwgcm91dGluZS5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlQmF0Y2goKXtcclxuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoYmF0Y2ggPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5zc2VxKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlUXVldWUgKys7XHJcblxyXG4gICAgICAgIGxldCBkcmF3RnVuYyA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVRdWV1ZSAtLTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlUXVldWUgIT0gMCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fZHJhd1NzZXEodGhpcy5jb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGQzLmV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkMyB6b29tIGRvZXNuJ3QgYWxsb3cgdGhlIGV2ZW50cyBpdCBoYW5kbGVzIHRvIGJ1YmJsZSwgc28gd2VcclxuICAgICAgICAgICAgICAgIC8vIGZhaWxzIHRvIHRyYWNrIHBvaW50ZXIgcG9zaXRpb24uXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vbk1vdXNlbW92ZShkMy5ldmVudCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vbk1vdXNlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZihiYXRjaCl7XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3RnVuYyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZHJhd0Z1bmMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xpcENvbnRleHQoY3R4KSB7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGxldCB5X2NsaXBfb2Zmc2V0ID0gdGhpcy55X2NsaXBfb2Zmc2V0IHx8IDA7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJ5X2NsaXBfb2Zmc2V0OlwiLCB5X2NsaXBfb2Zmc2V0KTtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwOyAvLyBDMlMgZG9lcyBub3QgY29ycmVjdGx5IGNsaXAgdW5sZXNzIHRoZSBjbGlwIGlzIHN0cm9rZWQuXHJcbiAgICAgICAgY3R4LnJlY3QodGhpcy5sZWZ0TWFyZ2luLCB0aGlzLnRvcE1hcmdpbiArIHlfY2xpcF9vZmZzZXQsIHRoaXMucGxvdFdpZHRoLCB0aGlzLnBsb3RIZWlnaHQgLSB5X2NsaXBfb2Zmc2V0KTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgY3R4LmNsaXAoKTtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIF9kcmF3U3NlcShjdHggPSB0aGlzLmNvbnRleHQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc3NlcSkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLl91cGRhdGVTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUdyaWRBbmRUaWNrU3RlcCgpO1xyXG5cclxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzV2lkdGgsIHRoaXMuY2FudmFzSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5fZHJhd1RpY2tzKGN0eCk7XHJcbiAgICAgICAgdGhpcy5fZHJhd0F4ZXMoY3R4KTtcclxuXHJcbiAgICAgICAgY3R4LnNhdmUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jbGlwQ29udGV4dChjdHgpO1xyXG5cclxuICAgICAgICBsZXQgW25vZGVzLCBlZGdlc10gPSB0aGlzLnNzZXEuZ2V0RWxlbWVudHNUb0RyYXcoXHJcbiAgICAgICAgICAgIHRoaXMucGFnZVJhbmdlLCBcclxuICAgICAgICAgICAgdGhpcy54bWluIC0gMSwgdGhpcy54bWF4ICsgMSwgdGhpcy55bWluIC0gMSwgdGhpcy55bWF4ICsgMVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuX2RyYXdHcmlkKGN0eCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwiZHJhd19iYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU5vZGVzKG5vZGVzKTtcclxuICAgICAgICB0aGlzLl9kcmF3RWRnZXMoY3R4LCBlZGdlcyk7XHJcbiAgICAgICAgdGhpcy5fZHJhd05vZGVzKGN0eCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNzZXEuZWRnZUxheWVyU1ZHKVxyXG4gICAgICAgICAgICB0aGlzLmRyYXdTVkcoY3R4LCB0aGlzLnNzZXEuZWRnZUxheWVyU1ZHKTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5zdmcpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5zdmdfdW5jbGlwcGVkKXtcclxuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB4X3NjYWxlID0gdGhpcy5zdmdfeF9zY2FsZSB8fCB0aGlzLnN2Z19zY2FsZSB8fCAxO1xyXG4gICAgICAgICAgICBsZXQgeV9zY2FsZSA9IHRoaXMuc3ZnX3lfc2NhbGUgfHwgdGhpcy5zdmdfc2NhbGUgfHwgMTtcclxuICAgICAgICAgICAgbGV0IHhfb2Zmc2V0ID0gdGhpcy5zdmdfeF9vZmZzZXQgfHwgMDtcclxuICAgICAgICAgICAgbGV0IHlfb2Zmc2V0ID0gdGhpcy5zdmdfeV9vZmZzZXQgfHwgMDtcclxuICAgICAgICAgICAgbGV0IGRlZmF1bHRfd2lkdGggPSBcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzV2lkdGggLyAodGhpcy54bWF4RmxvYXQgLSB0aGlzLnhtaW5GbG9hdCkgKiAodGhpcy5zc2VxLnhfcmFuZ2VbMV0gLSB0aGlzLnNzZXEueF9yYW5nZVswXSArIDEpO1xyXG4gICAgICAgICAgICBsZXQgZGVmYXVsdF9oZWlnaHQgPSBcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzSGVpZ2h0IC8gKHRoaXMueW1heEZsb2F0IC0gdGhpcy55bWluRmxvYXQpICogKHRoaXMuc3NlcS55X3JhbmdlWzFdIC0gdGhpcy5zc2VxLnlfcmFuZ2VbMF0gKyAxKTtcclxuICAgICAgICAgICAgbGV0IHdpZHRoID0gZGVmYXVsdF93aWR0aCAqIHhfc2NhbGU7XHJcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBkZWZhdWx0X2hlaWdodCAqIHlfc2NhbGU7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwid2lkdGg6XCIsd2lkdGgsIFwiaGVpZ2h0OlwiLCAgaGVpZ2h0KVxyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZHJhd0ltYWdlKHRoaXMuc3ZnLFxyXG4gICAgICAgICAgICAgICAgdGhpcy54U2NhbGUodGhpcy5zc2VxLnhfcmFuZ2VbMF0gKyB4X29mZnNldCksIC8vLSBkaXNwbGF5LnhNaW5PZmZzZXQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnlTY2FsZSh0aGlzLnNzZXEueV9yYW5nZVsxXSArIDEgKyB5X29mZnNldCkgLFxyXG4gICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5lbWl0KFwiZHJhd1wiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGVTY2FsZSgpe1xyXG4gICAgICAgIGxldCB6b29tRDNFbGVtZW50ID0gdGhpcy56b29tRDNFbGVtZW50O1xyXG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSBkMy56b29tVHJhbnNmb3JtKHpvb21EM0VsZW1lbnQubm9kZSgpKTtcclxuICAgICAgICBsZXQgc2NhbGUgPSB0cmFuc2Zvcm0uaztcclxuICAgICAgICBsZXQgeFNjYWxlID0gdHJhbnNmb3JtLnJlc2NhbGVYKHRoaXMueFNjYWxlSW5pdCk7XHJcbiAgICAgICAgbGV0IHlTY2FsZSA9IHRyYW5zZm9ybS5yZXNjYWxlWSh0aGlzLnlTY2FsZUluaXQpO1xyXG5cclxuICAgICAgICAvLyBXZSBoYXZlIHRvIGNhbGwgem9vbS50cmFuc2xhdGVCeSB3aGVuIHRoZSB1c2VyIGhpdHMgdGhlIGJvdW5kYXJ5IG9mIHRoZSBwYW4gcmVnaW9uXHJcbiAgICAgICAgLy8gdG8gYWRqdXN0IHRoZSB6b29tIHRyYW5zZm9ybS4gSG93ZXZlciwgdGhpcyBjYXVzZXMgdGhlIHpvb20gaGFuZGxlciAodGhpcyBmdW5jdGlvbikgdG8gYmUgY2FsbGVkIGEgc2Vjb25kIHRpbWUsXHJcbiAgICAgICAgLy8gd2hpY2ggaXMgbGVzcyBpbnR1aXRpdmUgcHJvZ3JhbSBmbG93IHRoYW4ganVzdCBjb250aW51aW5nIG9uIGluIHRoZSBjdXJyZW50IGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vIEluIG9yZGVyIHRvIHByZXZlbnQgdGhpcywgdGVtcG9yYXJpbHkgdW5zZXQgdGhlIHpvb20gaGFuZGxlci5cclxuICAgICAgICAvLyBUT0RPOiBTZWUgaWYgd2UgY2FuIG1ha2UgdGhlIGJlaGF2aW91ciBoZXJlIGxlc3MgamFuay5cclxuICAgICAgICB0aGlzLnpvb20ub24oXCJ6b29tXCIsIG51bGwpO1xyXG5cclxuICAgICAgICBsZXQgeFNjYWxlTWF4ZWQgPSBmYWxzZSwgeVNjYWxlTWF4ZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBQcmV2ZW50IHVzZXIgZnJvbSBwYW5uaW5nIG9mZiB0aGUgc2lkZS5cclxuICAgICAgICBpZiAodGhpcy5zc2VxLnhfcmFuZ2UpIHtcclxuICAgICAgICAgICAgaWYgKHhTY2FsZSh0aGlzLnNzZXEueF9yYW5nZVsxXSAtIHRoaXMuc3NlcS54X3JhbmdlWzBdICsgMiAqIHRoaXMuZG9tYWluT2Zmc2V0KSAtIHhTY2FsZSgwKSA8IHRoaXMucGxvdFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzaW1wbHkgcmVjb3JkIHRoZSBzY2FsZSB3YXMgbWF4ZWQgYW5kIGhhbmRsZSB0aGlzIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAvLyBieSBtb2RpZnlpbmcgeFNjYWxlIGRpcmVjdGx5LlxyXG4gICAgICAgICAgICAgICAgeFNjYWxlTWF4ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhTY2FsZSh0aGlzLnNzZXEueF9yYW5nZVswXSAtIHRoaXMuZG9tYWluT2Zmc2V0KSA+IHRoaXMubGVmdE1hcmdpbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29tLnRyYW5zbGF0ZUJ5KHpvb21EM0VsZW1lbnQsICh0aGlzLmxlZnRNYXJnaW4gLSB4U2NhbGUodGhpcy5zc2VxLnhfcmFuZ2VbMF0gLSB0aGlzLmRvbWFpbk9mZnNldCkpIC8gc2NhbGUsIDApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhTY2FsZSh0aGlzLnNzZXEueF9yYW5nZVsxXSArIHRoaXMuZG9tYWluT2Zmc2V0KSA8IHRoaXMuY2xpcFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20udHJhbnNsYXRlQnkoem9vbUQzRWxlbWVudCwgKHRoaXMuY2xpcFdpZHRoIC0geFNjYWxlKHRoaXMuc3NlcS54X3JhbmdlWzFdICsgdGhpcy5kb21haW5PZmZzZXQpKSAvIHNjYWxlLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc3NlcS55X3JhbmdlKSB7XHJcbiAgICAgICAgICAgIGlmICh5U2NhbGUoMCkgLXlTY2FsZSh0aGlzLnNzZXEueV9yYW5nZVsxXSAtIHRoaXMuc3NlcS55X3JhbmdlWzBdICsgMiAqIHRoaXMuZG9tYWluT2Zmc2V0KSA8IHRoaXMucGxvdEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgeVNjYWxlTWF4ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHlTY2FsZSh0aGlzLnNzZXEueV9yYW5nZVswXSAtIHRoaXMuZG9tYWluT2Zmc2V0KSA8IHRoaXMuY2xpcEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29tLnRyYW5zbGF0ZUJ5KHpvb21EM0VsZW1lbnQsIDAsICh0aGlzLmNsaXBIZWlnaHQgLSB5U2NhbGUodGhpcy5zc2VxLnlfcmFuZ2VbMF0gLSB0aGlzLmRvbWFpbk9mZnNldCkpIC8gc2NhbGUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHlTY2FsZSh0aGlzLnNzZXEueV9yYW5nZVsxXSArIHRoaXMuZG9tYWluT2Zmc2V0KSA+IHRoaXMudG9wTWFyZ2luKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20udHJhbnNsYXRlQnkoem9vbUQzRWxlbWVudCwgMCwgdGhpcy50b3BNYXJnaW4gLSB5U2NhbGUodGhpcy5zc2VxLnlfcmFuZ2VbMV0gKyB0aGlzLmRvbWFpbk9mZnNldCkgLyBzY2FsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIGJvdGggc2NhbGVzIGFyZSBtYXhlZCwgYW5kIHRoZSB1c2VyIGF0dGVtcHRzIHRvIHpvb20gb3V0IGZ1cnRoZXIsXHJcbiAgICAgICAgLy8gZDMgcmVnaXN0ZXJzIGEgem9vbSwgYnV0IG5vdGhpbmcgaW4gdGhlIGludGVyZmFjZSBjaGFuZ2VzIHNpbmNlIHdlXHJcbiAgICAgICAgLy8gbWFudWFsbHkgb3ZlcnJpZGUgeFNjYWxlIGFuZCB5U2NhbGUgaW5zdGVhZCBvZiBkb2luZyBzb21ldGhpbmcgYXRcclxuICAgICAgICAvLyB0aGUgbGV2ZWwgb2YgdGhlIHRyYW5zZm9ybSAoc2VlIGJlbG93KS4gV2UgZG8gKm5vdCogd2FudCB0byBrZWVwXHJcbiAgICAgICAgLy8gem9vbWluZyBvdXQsIG9yIGVsc2Ugd2hlbiB0aGUgdXNlciB3YW50cyB0byB6b29tIGJhY2sgaW4sIHRoZXkgd2lsbFxyXG4gICAgICAgIC8vIGhhdmUgdG8gem9vbSBpbiBmb3IgYSB3aGlsZSBiZWZvcmUgdGhlIGludGVyZmFjZSBhY3R1YWxseSB6b29tcyBpbi5cclxuICAgICAgICAvLyBUaHVzLCBXZSByZXN0b3JlIHRoZSBwcmV2aW91cyB6b29tIHN0YXRlLlxyXG4gICAgICAgIGlmICh4U2NhbGVNYXhlZCAmJiB5U2NhbGVNYXhlZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbGRTY2FsZXNNYXhlZCAmJiBzY2FsZSA8IHRoaXMuc2NhbGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuem9vbS50cmFuc2Zvcm0oem9vbUQzRWxlbWVudCwgdGhpcy50cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29tLm9uKFwiem9vbVwiLCB0aGlzLnVwZGF0ZUJhdGNoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2xkU2NhbGVzTWF4ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vbGRTY2FsZXNNYXhlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IG5ldyB0cmFuc2Zvcm0gYW5kIHNjYWxlIG9iamVjdHMgYWZ0ZXIgcG9zc2libGUgdHJhbnNsYXRpb24gYWJvdmVcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IGQzLnpvb21UcmFuc2Zvcm0oem9vbUQzRWxlbWVudC5ub2RlKCkpO1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSB0aGlzLnRyYW5zZm9ybS5rO1xyXG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy50cmFuc2Zvcm0ucmVzY2FsZVgodGhpcy54U2NhbGVJbml0KTtcclxuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMudHJhbnNmb3JtLnJlc2NhbGVZKHRoaXMueVNjYWxlSW5pdCk7XHJcblxyXG4gICAgICAgIC8vIElmIHggb3IgeSBzY2FsZSBpcyBtYXhlZCwgd2UgZGlyZWN0bHkgb3ZlcnJpZGUgeFNjYWxlL3lTY2FsZSBpbnN0ZWFkXHJcbiAgICAgICAgLy8gb2YgbWVzc2luZyB3aXRoIHpvb20sIHNpbmNlIHdlIHdhbnQgdG8gY29udGludWUgYWxsb3cgem9vbWluZyBpbiB0aGVcclxuICAgICAgICAvLyBvdGhlciBkaXJlY3Rpb25cclxuICAgICAgICBpZiAoeFNjYWxlTWF4ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy54U2NhbGUuZG9tYWluKFtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3NlcS54X3JhbmdlWzBdIC0gdGhpcy5kb21haW5PZmZzZXQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNzZXEueF9yYW5nZVsxXSArIHRoaXMuZG9tYWluT2Zmc2V0XHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeVNjYWxlTWF4ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy55U2NhbGUuZG9tYWluKFtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3NlcS55X3JhbmdlWzBdIC0gdGhpcy5kb21haW5PZmZzZXQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNzZXEueV9yYW5nZVsxXSArIHRoaXMuZG9tYWluT2Zmc2V0XHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy54bWluRmxvYXQgPSB0aGlzLnhTY2FsZS5pbnZlcnQodGhpcy5sZWZ0TWFyZ2luKTtcclxuICAgICAgICB0aGlzLnhtYXhGbG9hdCA9IHRoaXMueFNjYWxlLmludmVydCh0aGlzLmNsaXBXaWR0aCk7XHJcbiAgICAgICAgdGhpcy55bWluRmxvYXQgPSB0aGlzLnlTY2FsZS5pbnZlcnQodGhpcy5jbGlwSGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnltYXhGbG9hdCA9IHRoaXMueVNjYWxlLmludmVydCh0aGlzLnRvcE1hcmdpbik7XHJcbiAgICAgICAgdGhpcy54bWluID0gTWF0aC5jZWlsKHRoaXMueG1pbkZsb2F0KTtcclxuICAgICAgICB0aGlzLnhtYXggPSBNYXRoLmZsb29yKHRoaXMueG1heEZsb2F0KTtcclxuICAgICAgICB0aGlzLnltaW4gPSBNYXRoLmNlaWwodGhpcy55bWluRmxvYXQpO1xyXG4gICAgICAgIHRoaXMueW1heCA9IE1hdGguZmxvb3IodGhpcy55bWF4RmxvYXQpO1xyXG5cclxuICAgICAgICB0aGlzLnpvb20ub24oXCJ6b29tXCIsIHRoaXMudXBkYXRlQmF0Y2gpO1xyXG4gICAgfVxyXG5cclxuICAgIGR4U2NhbGUoeCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueFNjYWxlKHgpIC0gdGhpcy54U2NhbGUoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZHlTY2FsZSh4KXtcclxuICAgICAgICByZXR1cm4gdGhpcy55U2NhbGUoeCkgLSB0aGlzLnlTY2FsZSgwKTtcclxuICAgIH1cclxuXHJcbiAgICBfdXBkYXRlR3JpZEFuZFRpY2tTdGVwKCl7XHJcbiAgICAgICAgLy8gVE9ETzogVGhpcyA3MCBpcyBhIG1hZ2ljIG51bWJlci4gTWF5YmUgSSBzaG91bGQgZ2l2ZSBpdCBhIG5hbWU/XHJcbiAgICAgICAgdGhpcy54VGlja3MgPSB0aGlzLnhTY2FsZS50aWNrcyh0aGlzLmNhbnZhc1dpZHRoIC8gNzApO1xyXG4gICAgICAgIHRoaXMueVRpY2tzID0gdGhpcy55U2NhbGUudGlja3ModGhpcy5jYW52YXNIZWlnaHQgLyA3MCk7XHJcblxyXG4gICAgICAgIHRoaXMueFRpY2tTdGVwID0gTWF0aC5jZWlsKHRoaXMueFRpY2tzWzFdIC0gdGhpcy54VGlja3NbMF0pO1xyXG4gICAgICAgIHRoaXMueVRpY2tTdGVwID0gTWF0aC5jZWlsKHRoaXMueVRpY2tzWzFdIC0gdGhpcy55VGlja3NbMF0pO1xyXG4gICAgICAgIHRoaXMueFRpY2tzWzBdIC09IHRoaXMueFRpY2tTdGVwO1xyXG4gICAgICAgIHRoaXMueVRpY2tzWzBdIC09IHRoaXMueVRpY2tTdGVwO1xyXG4gICAgICAgIHRoaXMueFRpY2tzLnB1c2godGhpcy54VGlja3NbdGhpcy54VGlja3MubGVuZ3RoIC0gMV0gKyB0aGlzLnhUaWNrU3RlcCk7XHJcbiAgICAgICAgdGhpcy55VGlja3MucHVzaCh0aGlzLnlUaWNrc1t0aGlzLnlUaWNrcy5sZW5ndGggLSAxXSArIHRoaXMueVRpY2tTdGVwKTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5tYW51YWx4R3JpZFN0ZXApe1xyXG4gICAgICAgICAgICB0aGlzLnhHcmlkU3RlcCA9IHRoaXMubWFudWFseEdyaWRTdGVwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMueEdyaWRTdGVwID0gKE1hdGguZmxvb3IodGhpcy54VGlja1N0ZXAgLyA1KSA9PT0gMCkgPyAxIDogTWF0aC5mbG9vcih0aGlzLnhUaWNrU3RlcCAvIDUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLm1hbnVhbHlHcmlkU3RlcCl7XHJcbiAgICAgICAgICAgIHRoaXMueUdyaWRTdGVwID0gdGhpcy5tYW51YWx4R3JpZFN0ZXA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy55R3JpZFN0ZXAgPSAoTWF0aC5mbG9vcih0aGlzLnlUaWNrU3RlcCAvIDUpID09PSAwKSA/IDEgOiBNYXRoLmZsb29yKHRoaXMueVRpY2tTdGVwIC8gNSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYW4gYWQtaG9jIG1vZGlmaWNhdGlvbiByZXF1ZXN0ZWQgYnkgRGFubnkgdG8gZW5zdXJlIHRoYXQgdGhlIGdyaWQgYm94ZXMgYXJlIHNxdWFyZS5cclxuICAgICAgICAvLyBQcm9iYWJseSBpdCdzIGEgdXNlZnVsIHRoaW5nIHRvIGJlIGFibGUgdG8gaGF2ZSBzcXVhcmUgZ3JpZCBib3hlcywgaG93IGRvIHdlIHdhbnQgdG8gZGVhbCB3aXRoIHRoaXM/XHJcbiAgICAgICAgaWYodGhpcy5zc2VxLnNxdWFyZUFzcGVjdFJhdGlvKXtcclxuICAgICAgICAgICAgdGhpcy54R3JpZFN0ZXAgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLnlHcmlkU3RlcCA9IHRoaXMueEdyaWRTdGVwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfZHJhd1RpY2tzKGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuXHJcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG4gICAgICAgIGNvbnRleHQuZm9udCA9IFwiMTVweCBBcmlhbFwiO1xyXG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICBmb3IgKGxldCBpID0gTWF0aC5mbG9vcih0aGlzLnhUaWNrc1swXSk7IGkgPD0gdGhpcy54VGlja3NbdGhpcy54VGlja3MubGVuZ3RoIC0gMV07IGkgKz0gdGhpcy54VGlja1N0ZXApIHtcclxuICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dChpLCB0aGlzLnhTY2FsZShpKSwgdGhpcy5jbGlwSGVpZ2h0ICsgMjApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGguZmxvb3IodGhpcy55VGlja3NbMF0pOyBpIDw9IHRoaXMueVRpY2tzW3RoaXMueVRpY2tzLmxlbmd0aCAtIDFdOyBpICs9IHRoaXMueVRpY2tTdGVwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQoaSwgdGhpcy5sZWZ0TWFyZ2luIC0gMTAsIHRoaXMueVNjYWxlKGkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2RyYXdHcmlkKGNvbnRleHQpe1xyXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG5cclxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5ncmlkQ29sb3I7XHJcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0aGlzLmdyaWRTdHJva2VXaWR0aDtcclxuXHJcbiAgICAgICAgc3dpdGNoKHRoaXMuZ3JpZFN0eWxlKXtcclxuICAgICAgICAgICAgY2FzZSBncmlkR286XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3R29HcmlkKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgZ3JpZENoZXNzOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NoZXNzR3JpZChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYW4gZXJyb3IgaGVyZT9cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2RyYXdHb0dyaWQoY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuX2RyYXdHcmlkV2l0aE9mZnNldChjb250ZXh0LCAwLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBfZHJhd0NoZXNzR3JpZChjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fZHJhd0dyaWRXaXRoT2Zmc2V0KGNvbnRleHQsIDAuNSwgMC41KTtcclxuICAgIH1cclxuXHJcbiAgICBfZHJhd0dyaWRXaXRoT2Zmc2V0KGNvbnRleHQsIHhvZmZzZXQsIHlvZmZzZXQpe1xyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgZm9yIChsZXQgY29sID0gTWF0aC5mbG9vcih0aGlzLnhtaW4gLyB0aGlzLnhHcmlkU3RlcCkgKiB0aGlzLnhHcmlkU3RlcCAtIHhvZmZzZXQ7IGNvbCA8PSB0aGlzLnhtYXg7IGNvbCArPSB0aGlzLnhHcmlkU3RlcCkge1xyXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh0aGlzLnhTY2FsZShjb2wpLCAwKTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odGhpcy54U2NhbGUoY29sKSwgdGhpcy5jbGlwSGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuXHJcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICBmb3IgKGxldCByb3cgPSBNYXRoLmZsb29yKHRoaXMueW1pbiAvIHRoaXMueUdyaWRTdGVwKSAqIHRoaXMueUdyaWRTdGVwIC0geW9mZnNldDsgcm93IDw9IHRoaXMueW1heDsgcm93ICs9IHRoaXMueUdyaWRTdGVwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHRoaXMubGVmdE1hcmdpbiwgdGhpcy55U2NhbGUocm93KSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHRoaXMuY2FudmFzV2lkdGggLSB0aGlzLnJpZ2h0TWFyZ2luLCB0aGlzLnlTY2FsZShyb3cpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBfZHJhd0F4ZXMoY29udGV4dCl7XHJcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgbWFrZXMgdGhlIHdoaXRlIHNxdWFyZSBpbiB0aGUgYm90dG9tIGxlZnQgYW5kIHRvcCByaWdodCBjb3JuZXJzIHdoaWNoIHByZXZlbnRzIGF4ZXMgbGFiZWxzIGZyb20gYXBwZWFyaW5nIHRvIHRoZSBsZWZ0XHJcbiAgICAgICAgLy8gb3IgYmVsb3cgdGhlIGF4ZXMgaW50ZXJjZXB0LlxyXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kX2NvbG9yO1xyXG4gICAgICAgIGNvbnRleHQucmVjdCgwLCB0aGlzLmNsaXBIZWlnaHQsIHRoaXMubGVmdE1hcmdpbiwgdGhpcy5ib3R0b21NYXJnaW4pO1xyXG4gICAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB0aGlzLmxlZnRNYXJnaW4sIHRoaXMudG9wTWFyZ2luKTtcclxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiIzAwMFwiO1xyXG5cclxuICAgICAgICAvLyBEcmF3IHRoZSBheGVzLlxyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5tb3ZlVG8odGhpcy5sZWZ0TWFyZ2luLCB0aGlzLnRvcE1hcmdpbik7XHJcbiAgICAgICAgY29udGV4dC5saW5lVG8odGhpcy5sZWZ0TWFyZ2luLCB0aGlzLmNsaXBIZWlnaHQpO1xyXG4gICAgICAgIGNvbnRleHQubGluZVRvKHRoaXMuY2FudmFzV2lkdGggLSB0aGlzLnJpZ2h0TWFyZ2luLCB0aGlzLmNsaXBIZWlnaHQpO1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcblxyXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIF91cGRhdGVOb2RlcyhjbGFzc2VzKXtcclxuICAgICAgICBsZXQgc2l6ZSA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuZHhTY2FsZSgxKSwgLXRoaXMuZHlTY2FsZSgxKSwgdGhpcy5zc2VxLm1heF9jbGFzc19zaXplKSwgdGhpcy5zc2VxLm1pbl9jbGFzc19zaXplKSAqIHRoaXMuc3NlcS5jbGFzc19zY2FsZTtcclxuICAgICAgICB0aGlzLmNsYXNzZXNfdG9fZHJhdyA9IGNsYXNzZXM7XHJcbiAgICAgICAgZm9yKGxldCBjIG9mIGNsYXNzZXMpIHtcclxuICAgICAgICAgICAgYy5zZXRQb3NpdGlvbiggXHJcbiAgICAgICAgICAgICAgICB0aGlzLnhTY2FsZShjLngpICsgYy5nZXRYT2Zmc2V0KCksIFxyXG4gICAgICAgICAgICAgICAgdGhpcy55U2NhbGUoYy55KSArIGMuZ2V0WU9mZnNldCgpLCBcclxuICAgICAgICAgICAgICAgIHNpemVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX2RyYXdOb2Rlcyhjb250ZXh0KSB7XHJcbiAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLmNsYXNzZXNfdG9fZHJhdykge1xyXG4gICAgICAgICAgICBjLmRyYXcoY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9kcmF3RWRnZXMoY29udGV4dCwgZWRnZXMpeyAgICAgICAgXHJcbiAgICAgICAgZm9yIChsZXQgZSBvZiBlZGdlcykge1xyXG4gICAgICAgICAgICBpZighZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgVmFsdWVFcnJvcihcIlVuZGVmaW5lZCBlZGdlLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihlLmludmFsaWQgfHwgIWUudmlzaWJsZSl7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSBcIlN0cnVjdGxpbmVcIiAmJiB0aGlzLmhpZGRlblN0cnVjdGxpbmVzLmhhcyhlLm11bHQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHNvdXJjZV9ub2RlID0gZS5fc291cmNlO1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0X25vZGUgPSBlLl90YXJnZXQ7XHJcbiAgICAgICAgICAgIGlmKCFzb3VyY2Vfbm9kZSB8fCAhIHRhcmdldF9ub2RlKXtcclxuICAgICAgICAgICAgICAgIHRocm93IFZhbHVlRXJyb3IoYEVkZ2UgJHtlfSBoYXMgdW5kZWZpbmVkIHNvdXJjZSBvciB0YXJnZXQgbm9kZWApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlLl9zb3VyY2VPZmZzZXQgPSBlLnNvdXJjZU9mZnNldCB8fCB7eDogMCwgeTogMH07XHJcbiAgICAgICAgICAgIGUuX3RhcmdldE9mZnNldCA9IGUudGFyZ2V0T2Zmc2V0IHx8IHt4OiAwLCB5OiAwfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZS5jb2xvcjtcclxuICAgICAgICAgICAgaWYoZS5saW5lV2lkdGgpe1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBlLmxpbmVXaWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihlLm9wYWNpdHkpe1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGUub3BhY2l0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihlLmRhc2gpe1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChlLmRhc2gpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgc291cmNlWCA9IHNvdXJjZV9ub2RlLl9jYW52YXNfeCArIGUuX3NvdXJjZU9mZnNldC54O1xyXG4gICAgICAgICAgICBsZXQgc291cmNlWSA9IHNvdXJjZV9ub2RlLl9jYW52YXNfeSArIGUuX3NvdXJjZU9mZnNldC55O1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0WCA9IHRhcmdldF9ub2RlLl9jYW52YXNfeCArIGUuX3RhcmdldE9mZnNldC54O1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0WSA9IHRhcmdldF9ub2RlLl9jYW52YXNfeSArIGUuX3RhcmdldE9mZnNldC55O1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgaWYoZS5iZW5kICl7Ly8mJiBlLmJlbmQgIT09IDBcclxuICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IE1hdGguc3FydCgodGFyZ2V0WCAtIHNvdXJjZVgpKih0YXJnZXRYIC0gc291cmNlWCkgKyAodGFyZ2V0WSAtIHNvdXJjZVkpKih0YXJnZXRZIC0gc291cmNlWSkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxvb3NlbmVzcyA9IDAuNDtcclxuICAgICAgICAgICAgICAgIGlmKGUubG9vc2VuZXNzKXtcclxuICAgICAgICAgICAgICAgICAgICBsb29zZW5lc3MgPSBlLmxvb3NlbmVzcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbigodGFyZ2V0WSAtIHNvdXJjZVkpLyh0YXJnZXRYIC0gc291cmNlWCkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJlbmRBbmdsZSA9IC0gZS5iZW5kICogTWF0aC5QSS8xODA7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29udHJvbDFYID0gc291cmNlWCArIE1hdGguY29zKGFuZ2xlICsgYmVuZEFuZ2xlKSAqIGxvb3NlbmVzcyAqIGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRyb2wxWSA9IHNvdXJjZVkgKyBNYXRoLnNpbihhbmdsZSArIGJlbmRBbmdsZSkgKiBsb29zZW5lc3MgKiBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCBjb250cm9sMlggPSB0YXJnZXRYIC0gTWF0aC5jb3MoYW5nbGUgLSBiZW5kQW5nbGUpICogbG9vc2VuZXNzICogZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29udHJvbDJZID0gdGFyZ2V0WSAtIE1hdGguc2luKGFuZ2xlIC0gYmVuZEFuZ2xlKSAqIGxvb3NlbmVzcyAqIGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oc291cmNlWCwgc291cmNlWSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY29udHJvbDFYLCBjb250cm9sMVksIGNvbnRyb2wyWCwgY29udHJvbDJZLCB0YXJnZXRYLCB0YXJnZXRZKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHNvdXJjZVgsIHNvdXJjZVkpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8odGFyZ2V0WCwgdGFyZ2V0WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9vbkNsaWNrKGUpIHtcclxuICAgICAgICBsZXQgeCA9IHRoaXMueFNjYWxlLmludmVydChlLmxheWVyWCk7XHJcbiAgICAgICAgbGV0IHkgPSB0aGlzLnlTY2FsZS5pbnZlcnQoZS5sYXllclkpO1xyXG4gICAgICAgIHRoaXMuZW1pdChcImNsaWNrXCIsIHRoaXMubW91c2VvdmVyX25vZGUsIHgsIHksIGUpO1xyXG4gICAgfVxyXG5cclxuICAgIF9vbk1vdXNlbW92ZShlKSB7XHJcbiAgICAgICAgLy8gSWYgbm90IHlldCBzZXQgdXAgXHJcbiAgICAgICAgaWYgKCF0aGlzLmNsYXNzZXNfdG9fZHJhdykgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgcmVkcmF3ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIFdlIGNhbm5vdCBxdWVyeSBmb3IgbW91c2UgcG9zaXRpb24uIFdlIG11c3QgcmVtZW1iZXIgaXQgZnJvbVxyXG4gICAgICAgIC8vIHByZXZpb3VzIGV2ZW50cy4gSWYgdXBkYXRlKCkgaXMgY2FsbGVkLCB3ZSBjYWxsIF9vbk1vdXNlbW92ZSB3aXRob3V0XHJcbiAgICAgICAgLy8gYW4gZXZlbnQuXHJcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSBlLmNsaWVudFggLSByZWN0Lng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGUuY2xpZW50WSAtIHJlY3QueTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm1vdXNlb3Zlcl9ub2RlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNsYXNzZXNfdG9fZHJhdy5pbmNsdWRlcyh0aGlzLm1vdXNlb3Zlcl9jbGFzcykgJiYgdGhpcy5jb250ZXh0LmlzUG9pbnRJblBhdGgodGhpcy5tb3VzZW92ZXJfY2xhc3MuX3BhdGgsIHRoaXMueCwgdGhpcy55KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZW92ZXJfbm9kZS5oaWdobGlnaHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubW91c2VvdmVyX25vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZW92ZXJfY2xhc3MgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmVkcmF3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm1vdXNlb3V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5jbGFzc2VzX3RvX2RyYXcuZmluZChuID0+IHRoaXMuY29udGV4dC5pc1BvaW50SW5QYXRoKG4uX3BhdGgsIHRoaXMueCwgdGhpcy55KSk7XHJcbiAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgcmVkcmF3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgbm9kZS5oaWdobGlnaHQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlb3Zlcl9ub2RlID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZW92ZXJfY2xhc3MgPSBub2RlLmM7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIm1vdXNlb3ZlclwiLCBub2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZWRyYXcpIHRoaXMuX2RyYXdTc2VxKHRoaXMuY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGFuIHN2ZyBvbnRvIHRoZSBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBodG1sNSBjYW52YXMgY29udGV4dFxyXG4gICAgICogQHBhcmFtIHhtbCBBbiBzdmcgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGRyYXdTVkcoY29udGV4dCwgeG1sKXtcclxuICAgICAgICAvLyBtYWtlIGl0IGJhc2U2NFxyXG4gICAgICAgIGxldCBzdmc2NCA9IGJ0b2EoeG1sKTtcclxuICAgICAgICBsZXQgYjY0U3RhcnQgPSAnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwnO1xyXG5cclxuICAgICAgICAvLyBwcmVwZW5kIGEgXCJoZWFkZXJcIlxyXG4gICAgICAgIGxldCBpbWFnZTY0ID0gYjY0U3RhcnQgKyBzdmc2NDtcclxuXHJcbiAgICAgICAgLy8gc2V0IGl0IGFzIHRoZSBzb3VyY2Ugb2YgdGhlIGltZyBlbGVtZW50XHJcbiAgICAgICAgbGV0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGltZy5zcmMgPSBpbWFnZTY0O1xyXG5cclxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsXHJcbiAgICAgICAgICAgIHRoaXMueFNjYWxlKHRoaXMuc3NlcS54X3JhbmdlWzBdKSwvLyAtIHRoaXMueE1pbk9mZnNldCxcclxuICAgICAgICAgICAgdGhpcy55U2NhbGUodGhpcy5zc2VxLnlfcmFuZ2VbMV0gKyAxKSxcclxuICAgICAgICAgICAgdGhpcy5jYW52YXNXaWR0aCAgLyAodGhpcy54bWF4RmxvYXQgLSB0aGlzLnhtaW5GbG9hdCkgKiAodGhpcy5zc2VxLnhfcmFuZ2VbMV0gLSB0aGlzLnNzZXEueF9yYW5nZVswXSArIDEpLFxyXG4gICAgICAgICAgICB0aGlzLmNhbnZhc0hlaWdodCAvICh0aGlzLnltYXhGbG9hdCAtIHRoaXMueW1pbkZsb2F0KSAqICh0aGlzLnNzZXEueV9yYW5nZVsxXSAtIHRoaXMuc3NlcS55X3JhbmdlWzBdICsgMSlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHRvU1ZHKCl7XHJcbiAgICAgICAgbGV0IGN0eCA9IG5ldyBDMlModGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX2RyYXdTc2VxKGN0eCk7XHJcblxyXG4gICAgICAgIHJldHVybiBjdHguZ2V0U2VyaWFsaXplZFN2Zyh0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBkb3dubG9hZFNWRyhmaWxlbmFtZSkge1xyXG4gICAgICAgIGlmKGZpbGVuYW1lID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBmaWxlbmFtZSA9IGAke3RoaXMuc3NlcS5uYW1lfV94LSR7dGhpcy54bWlufS0ke3RoaXMueG1heH1feS0ke3RoaXMueW1pbn0tJHt0aGlzLnltYXh9LnN2Z2BcclxuICAgICAgICB9XHJcbiAgICAgICAgSU8uZG93bmxvYWQoZmlsZW5hbWUsIHRoaXMudG9TVkcoKSwgXCJpbWFnZS9zdmcreG1sXCIpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlIHRoZSBjYW52YXMgdG8gY29udGFpbiAoeCx5KVxyXG4gICAgICogVE9ETzogY29udHJvbCBzcGVlZCwgY29udHJvbCBhY2NlcHRhYmxlIHJhbmdlIG9mIHRhcmdldCBwb3NpdGlvbnMsIG1heWJlIHpvb20gb3V0IGlmIGRpc3BsYXkgaXMgc3VwZXIgem9vbWVkIGluP1xyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKi9cclxuICAgIHNlZWsoeCwgeSl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkeCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBkeSA9IDA7XHJcbiAgICAgICAgICAgIGlmICh4ID4gdGhpcy54bWF4RmxvYXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBkeCA9IHRoaXMueG1heEZsb2F0IC0gMSAtIHg7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeCA8IHRoaXMueG1pbkZsb2F0ICsgMSkge1xyXG4gICAgICAgICAgICAgICAgZHggPSB0aGlzLnhtaW5GbG9hdCArIDEgLSB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh5ID4gdGhpcy55bWF4RmxvYXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBkeSA9IHRoaXMueW1heEZsb2F0IC0gMSAtIHk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeSA8IHRoaXMueG1pbkZsb2F0ICsgMSkge1xyXG4gICAgICAgICAgICAgICAgZHkgPSB0aGlzLnltaW5GbG9hdCArIDEgLSB5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgZHhBY3R1YWwgPSB0aGlzLmR4U2NhbGUoZHgpO1xyXG4gICAgICAgICAgICBsZXQgZHlBY3R1YWwgPSB0aGlzLmR5U2NhbGUoZHkpO1xyXG4gICAgICAgICAgICBsZXQgZGlzdCA9IE1hdGguc3FydChkeEFjdHVhbCAqIGR4QWN0dWFsICsgZHlBY3R1YWwgKiBkeUFjdHVhbCk7XHJcbiAgICAgICAgICAgIC8vIHN0ZXBzIGNvbnRyb2xzIHRoZSBzcGVlZCAtLSBkb3VibGluZyBzdGVwcyBoYWx2ZXMgdGhlIHNwZWVkLlxyXG4gICAgICAgICAgICAvLyBPZiBjb3Vyc2Ugd2UgY291bGQgbWF5YmUgc2V0IHVwIHNvbWUgZmFuY3kgYWxnb3JpdGhtIHRoYXQgem9vbXMgYW5kIHBhbnMuXHJcbiAgICAgICAgICAgIGxldCBzdGVwcyA9IE1hdGguY2VpbChkaXN0IC8gMTApO1xyXG4gICAgICAgICAgICBsZXQgeHN0ZXAgPSBkeEFjdHVhbCAvIHN0ZXBzO1xyXG4gICAgICAgICAgICBsZXQgeXN0ZXAgPSBkeUFjdHVhbCAvIHN0ZXBzO1xyXG5cclxuICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICBsZXQgdCA9IGQzLmludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlQnkoeHN0ZXAsIHlzdGVwKTtcclxuICAgICAgICAgICAgICAgIGlmIChpID49IHN0ZXBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCA1KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0cmFuc2xhdGVCeSh4c3RlcCwgeXN0ZXApe1xyXG4gICAgICAgIHRoaXMuem9vbS5vbihcInpvb21cIiwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy56b29tLnRyYW5zbGF0ZUJ5KHRoaXMuem9vbUQzRWxlbWVudCwgeHN0ZXAgLyB0aGlzLnNjYWxlLCB5c3RlcCAvIHRoaXMuc2NhbGUgKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuem9vbS5vbihcInpvb21cIiwgdGhpcy51cGRhdGVCYXRjaCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UGFnZURlc2NyaXB0b3IocGFnZVJhbmdlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNzZXEpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGJhc2VQYWdlID0gMjtcclxuICAgICAgICBpZih0aGlzLnNzZXEucGFnZV9saXN0LmluY2x1ZGVzKDEpKXtcclxuICAgICAgICAgICAgYmFzZVBhZ2UgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFnZVJhbmdlWzBdID09PSBJTkZJTklUWSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJQYWdlIOKInlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFnZVJhbmdlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgUGFnZSAke2Jhc2VQYWdlfSB3aXRoIGFsbCBkaWZmZXJlbnRpYWxzYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhZ2VSYW5nZSA9PT0gMSAmJiBiYXNlUGFnZSA9PT0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gYFBhZ2UgJHtiYXNlUGFnZX0gd2l0aCBubyBkaWZmZXJlbnRpYWxzYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhZ2VSYW5nZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYocGFnZVJhbmdlWzFdID09PSBJTkZJTklUWSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYFBhZ2UgJHtwYWdlUmFuZ2VbMF19IHdpdGggYWxsIGRpZmZlcmVudGlhbHNgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHBhZ2VSYW5nZVsxXSA9PT0gLTEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBQYWdlICR7cGFnZVJhbmdlWzBdfSB3aXRoIG5vIGRpZmZlcmVudGlhbHNgO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihwYWdlUmFuZ2VbMF0gPT09IHBhZ2VSYW5nZVsxXSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYFBhZ2UgJHtwYWdlUmFuZ2VbMF19YDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGBQYWdlcyAke3BhZ2VSYW5nZVswXX0g4oCTICR7cGFnZVJhbmdlWzFdfWAucmVwbGFjZShJTkZJTklUWSwgXCLiiJ5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBgUGFnZSAke3BhZ2VSYW5nZX1gO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IEZpeCB0aGUgc2VsZWN0aW9uXHJcbiAgICAvLyAgICAvKipcclxuICAgIC8vICAgICAqIFRoaXMgaXMgYSBjbGljayBldmVudCBoYW5kbGVyIHRvIHVwZGF0ZSB0aGUgc2VsZWN0ZWQgY2VsbCB3aGVuIHRoZSB1c2VyIGNsaWNrcy5cclxuICAgIC8vICAgICAqIEBwYXJhbSBldmVudCBBIGNsaWNrIGV2ZW50LlxyXG4gICAgLy8gICAgICovXHJcbiAgICAvLyAgICB1cGRhdGVTZWxlY3Rpb24oZXZlbnQpe1xyXG4gICAgLy8gICAgICAgIGV2ZW50Lm1vdXNlb3Zlcl9jbGFzcyA9IHRoaXMubW91c2VvdmVyX2NsYXNzO1xyXG4gICAgLy8gICAgICAgIHRoaXMuc2VsZWN0ZWRYID0gTWF0aC5mbG9vcihkaXNwbGF5LnhTY2FsZS5pbnZlcnQoZXZlbnQubGF5ZXJYKSArIDAuNSk7XHJcbiAgICAvLyAgICAgICAgdGhpcy5zZWxlY3RlZFkgPSBNYXRoLmZsb29yKGRpc3BsYXkueVNjYWxlLmludmVydChldmVudC5sYXllclkpICsgMC41KTtcclxuICAgIC8vICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgLy8gICAgfVxyXG4gICAgLy9cclxuICAgIC8vICAgIC8qKlxyXG4gICAgLy8gICAgICogRW5hYmxlIHNlbGVjdGlvbi4gVGhpcyBjaGFuZ2VzIHRoZSBncmlkIHN0eWxlIHRvIGEgY2hlc3MgZ3JpZCBhbmQgYXR0YWNoZXMgZXZlbnQgaGFuZGxlcnMgZm9yIGNsaWNraW5nXHJcbiAgICAvLyAgICAgKiBAcGFyYW0gYXJyb3dOYXZpZ2F0ZVxyXG4gICAgLy8gICAgICovXHJcbiAgICAvLyAgICBlbmFibGVTZWxlY3Rpb24oYXJyb3dOYXZpZ2F0ZSl7XHJcbiAgICAvLyAgICAgICAgdGhpcy5ncmlkU3R5bGUgPSBncmlkQ2hlc3M7XHJcbiAgICAvLyAgICAgICAgdGhpcy5hZGRFdmVudEhhbmRsZXIoXCJvbmNsaWNrXCIsdGhpcy51cGRhdGVTZWxlY3Rpb24uYmluZCh0aGlzKSk7XHJcbiAgICAvLyAgICAgICAgaWYoYXJyb3dOYXZpZ2F0ZSl7XHJcbiAgICAvLyAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRIYW5kbGVyKCdsZWZ0JywgICgpID0+IHtcclxuICAgIC8vICAgICAgICAgICAgICAgIGlmKHRoaXMuc2VsZWN0ZWRYICE9PSB1bmRlZmluZWQpe1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRYIC0tO1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAvLyAgICAgICAgICAgICAgICB9XHJcbiAgICAvLyAgICAgICAgICAgIH0pO1xyXG4gICAgLy8gICAgICAgICAgICB0aGlzLmFkZEV2ZW50SGFuZGxlcigncmlnaHQnLCAoKSA9PiB7XHJcbiAgICAvLyAgICAgICAgICAgICAgICBpZih0aGlzLnNlbGVjdGVkWCAhPT0gdW5kZWZpbmVkKXtcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkWCArKztcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgLy8gICAgICAgICAgICAgICAgfVxyXG4gICAgLy8gICAgICAgICAgICB9KTtcclxuICAgIC8vICAgICAgICAgICAgdGhpcy5hZGRFdmVudEhhbmRsZXIoJ2Rvd24nLCAgKCkgPT4ge1xyXG4gICAgLy8gICAgICAgICAgICAgICAgaWYodGhpcy5zZWxlY3RlZFkgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFkgLS07XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIC8vICAgICAgICAgICAgICAgIH1cclxuICAgIC8vICAgICAgICAgICAgfSk7XHJcbiAgICAvLyAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRIYW5kbGVyKCd1cCcsICgpID0+IHtcclxuICAgIC8vICAgICAgICAgICAgICAgIGlmKHRoaXMuc2VsZWN0ZWRZICE9PSB1bmRlZmluZWQpe1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRZICsrO1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAvLyAgICAgICAgICAgICAgICB9XHJcbiAgICAvLyAgICAgICAgICAgIH0pO1xyXG4gICAgLy8gICAgICAgIH1cclxuICAgIC8vICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgLy8gICAgfVxyXG4gICAgLy9cclxuICAgIC8vICAgIGRpc2FibGVTZWxlY3Rpb24oKXtcclxuICAgIC8vICAgICAgICB0aGlzLnNlbGVjdGVkWCA9IHVuZGVmaW5lZDtcclxuICAgIC8vICAgICAgICB0aGlzLmdyaWRTdHlsZSA9IGdyaWRHbztcclxuICAgIC8vICAgICAgICBNb3VzZXRyYXAuYmluZCgnbGVmdCcsICB0aGlzLnByZXZpb3VzUGFnZSk7XHJcbiAgICAvLyAgICAgICAgTW91c2V0cmFwLmJpbmQoJ3JpZ2h0JywgdGhpcy5uZXh0UGFnZSk7XHJcbiAgICAvLyAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJMYXllcltcIm9uY2xpY2tcIl0gPSAoZXZlbnQpID0+IHt9O1xyXG4gICAgLy8gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAvLyAgICB9XHJcbiAgICAvL1xyXG4gICAgLy8gICAgX2RyYXdTZWxlY3Rpb24oY29udGV4dCl7XHJcbiAgICAvLyAgICAgICAgbGV0IHggPSB0aGlzLnNlbGVjdGVkWDtcclxuICAgIC8vICAgICAgICBsZXQgeSA9IHRoaXMuc2VsZWN0ZWRZO1xyXG4gICAgLy8gICAgICAgIGlmKHggIT09IHVuZGVmaW5lZCAmJiB5ICE9PSB1bmRlZmluZWQpe1xyXG4gICAgLy8gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuZ3JpZENvbG9yO1xyXG4gICAgLy8gICAgICAgICAgICBjb250ZXh0LnJlY3QoXHJcbiAgICAvLyAgICAgICAgICAgICAgICBkaXNwbGF5LnhTY2FsZSh4IC0gMC41KSxcclxuICAgIC8vICAgICAgICAgICAgICAgIGRpc3BsYXkueVNjYWxlKHkgLSAwLjUpLFxyXG4gICAgLy8gICAgICAgICAgICAgICAgZGlzcGxheS5keFNjYWxlKDEpLFxyXG4gICAgLy8gICAgICAgICAgICAgICAgZGlzcGxheS5keVNjYWxlKDEpXHJcbiAgICAvLyAgICAgICAgICAgICk7XHJcbiAgICAvLyAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgLy8gICAgICAgIH1cclxuICAgIC8vICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydHMuRGlzcGxheSA9IERpc3BsYXk7XHJcbiIsIlwidXNlIHN0cmljdFwiXG5cbmxldCBTaWRlYmFyRGlzcGxheSA9IHJlcXVpcmUoXCIuL1NpZGViYXJEaXNwbGF5LmpzXCIpLlNpZGViYXJEaXNwbGF5O1xubGV0IFBhbmVsID0gcmVxdWlyZShcIi4vUGFuZWwuanNcIik7XG5sZXQgVG9vbHRpcCA9IHJlcXVpcmUoXCIuL1Rvb2x0aXAuanNcIikuVG9vbHRpcDtcbmxldCBJbnRlcmZhY2UgPSByZXF1aXJlKFwiLi9JbnRlcmZhY2UuanNcIik7XG5sZXQgTW91c2V0cmFwID0gcmVxdWlyZShcIm1vdXNldHJhcFwiKTtcblxuY29uc3QgU1RBVEVfQUREX0RJRkZFUkVOVElBTCA9IDE7XG5jb25zdCBTVEFURV9STV9ESUZGRVJFTlRJQUwgPSAyO1xuY29uc3QgU1RBVEVfQUREX1NUUlVDVExJTkUgPSAzO1xuY29uc3QgU1RBVEVfUk1fU1RSVUNUTElORSA9IDQ7XG5jb25zdCBTVEFURV9STV9FREdFID0gNTtcbmNvbnN0IFNUQVRFX0FERF9DTEFTUyA9IDY7XG5cbmNsYXNzIEVkaXRvckRpc3BsYXkgZXh0ZW5kcyBTaWRlYmFyRGlzcGxheSB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBzc2VxKSB7XG4gICAgICAgIHN1cGVyKGNvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5kaWZmZXJlbnRpYWxDb2xvcnMgPSB7fTtcblxuICAgICAgICAvLyBGb290ZXJcbiAgICAgICAgdGhpcy5zaWRlYmFyLmZvb3Rlci5uZXdHcm91cCgpO1xuICAgICAgICB0aGlzLnNpZGViYXIuZm9vdGVyLmFkZEJ1dHRvblJvdyhbXG4gICAgICAgICAgICBbXCJVbmRvXCIsICgpID0+IHRoaXMuc3NlcS51bmRvLnVuZG8oKV0sXG4gICAgICAgICAgICBbXCJSZWRvXCIsICgpID0+IHRoaXMuc3NlcS51bmRvLnJlZG8oKV1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgdGhpcy5zaWRlYmFyLmZvb3Rlci5hZGRCdXR0b24oXCJEb3dubG9hZCBTVkdcIiwgKCkgPT4gdGhpcy5kb3dubG9hZFNWRyhcInNzZXEuc3ZnXCIpKTtcbiAgICAgICAgdGhpcy5zaWRlYmFyLmZvb3Rlci5hZGRCdXR0b24oXCJTYXZlXCIsICgpID0+IHRoaXMuc3NlcS5kb3dubG9hZChcInNzZXEuanNvblwiKSk7XG5cbiAgICAgICAgLy8gR2VuZXJhbCBQYW5lbFxuICAgICAgICB0aGlzLmdlbmVyYWxQYW5lbCA9IG5ldyBQYW5lbC5QYW5lbCh0aGlzLnNpZGViYXIubWFpbl9kaXYsIHRoaXMpO1xuICAgICAgICB0aGlzLmdlbmVyYWxQYW5lbC5uZXdHcm91cCgpO1xuICAgICAgICB0aGlzLnBhZ2VMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB0aGlzLm9uKFwicGFnZS1jaGFuZ2VcIiwgKHIpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFnZUxhYmVsLmlubmVySFRNTCA9IHRoaXMuZ2V0UGFnZURlc2NyaXB0b3Iocik7XG4gICAgICAgICAgICB0aGlzLl91bnNlbGVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZW5lcmFsUGFuZWwuYWRkT2JqZWN0KHRoaXMucGFnZUxhYmVsKTtcblxuICAgICAgICB0aGlzLmdlbmVyYWxQYW5lbC5uZXdHcm91cCgpO1xuICAgICAgICB0aGlzLmdlbmVyYWxQYW5lbC5hZGRCdXR0b24oXCJBZGQgY2xhc3NcIiwgKCkgPT4gdGhpcy5zdGF0ZSA9IFNUQVRFX0FERF9DTEFTUywgeyBzaG9ydGN1dHM6IFtcIm5cIl0gfSk7XG5cbiAgICAgICAgdGhpcy5nZW5lcmFsUGFuZWwubmV3R3JvdXAoKTtcbiAgICAgICAgdGhpcy5nZW5lcmFsUGFuZWwuYWRkTGlua2VkSW5wdXQoXCJNaW4gWFwiLCBcInNzZXEubWluWFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5nZW5lcmFsUGFuZWwuYWRkTGlua2VkSW5wdXQoXCJNYXggWFwiLCBcInNzZXEubWF4WFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5nZW5lcmFsUGFuZWwuYWRkTGlua2VkSW5wdXQoXCJNaW4gWVwiLCBcInNzZXEubWluWVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5nZW5lcmFsUGFuZWwuYWRkTGlua2VkSW5wdXQoXCJNYXggWVwiLCBcInNzZXEubWF4WVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5zaWRlYmFyLmFkZFBhbmVsKHRoaXMuZ2VuZXJhbFBhbmVsKTtcblxuICAgICAgICAvLyBDbGFzcyBwYW5lbFxuICAgICAgICB0aGlzLmNsYXNzUGFuZWwgPSBuZXcgUGFuZWwuVGFiYmVkUGFuZWwodGhpcy5zaWRlYmFyLm1haW5fZGl2LCB0aGlzKTtcbiAgICAgICAgdGhpcy5zaWRlYmFyLmFkZFBhbmVsKHRoaXMuY2xhc3NQYW5lbCk7XG5cbiAgICAgICAgLy8gTm9kZSB0YWJcbiAgICAgICAgdGhpcy5ub2RlVGFiID0gbmV3IFBhbmVsLlBhbmVsKHRoaXMuY2xhc3NQYW5lbC5jb250YWluZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGVUYWIubmV3R3JvdXAoKTtcblxuICAgICAgICB0aGlzLnRpdGxlX3RleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgdGhpcy5ub2RlVGFiLmFkZE9iamVjdCh0aGlzLnRpdGxlX3RleHQpO1xuXG4gICAgICAgIHRoaXMudGl0bGVfZWRpdF9saW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIHRoaXMudGl0bGVfZWRpdF9saW5rLmNsYXNzTmFtZSA9IFwiY2FyZC1saW5rLWJvZHlcIjtcbiAgICAgICAgdGhpcy50aXRsZV9lZGl0X2xpbmsuaHJlZiA9IFwiI1wiO1xuICAgICAgICB0aGlzLnRpdGxlX2VkaXRfbGluay5zdHlsZS5mbG9hdCA9IFwicmlnaHRcIjtcbiAgICAgICAgdGhpcy50aXRsZV9lZGl0X2xpbmsuaW5uZXJIVE1MID0gXCJFZGl0XCI7XG4gICAgICAgIHRoaXMudGl0bGVfZWRpdF9saW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgYyA9IHRoaXMuc2VsZWN0ZWQuYztcbiAgICAgICAgICAgIGlmICh0aGlzLnRpdGxlX2VkaXRfbGluay5pbm5lckhUTUwgPT0gXCJPS1wiKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZF9uYW1lID0gYy5uYW1lO1xuICAgICAgICAgICAgICAgIGMubmFtZSA9IHRoaXMudGl0bGVfZWRpdF9pbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNzZXEudW5kby5hZGRWYWx1ZUNoYW5nZShjLCBcIm5hbWVcIiwgb2xkX25hbWUsIGMubmFtZSwgKCkgPT4gdGhpcy5zaWRlYmFyLnNob3dQYW5lbCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNzZXEuZW1pdChcInVwZGF0ZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVUYWIuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpdGxlX2VkaXRfbGluay5pbm5lckhUTUwgPSBcIk9LXCI7XG4gICAgICAgICAgICAgICAgaWYgKGMubmFtZSkgdGhpcy50aXRsZV9lZGl0X2lucHV0LnZhbHVlID0gYy5uYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMudGl0bGVfZWRpdF9pbnB1dC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5vZGVUYWIuYWRkT2JqZWN0KHRoaXMudGl0bGVfZWRpdF9saW5rKTtcblxuICAgICAgICB0aGlzLnRpdGxlX2VkaXRfaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIHRoaXMudGl0bGVfZWRpdF9pbnB1dC5jbGFzc05hbWUgPSBcImZvcm0tY29udHJvbCBtdC0yXCI7XG4gICAgICAgIHRoaXMudGl0bGVfZWRpdF9pbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgIHRoaXMudGl0bGVfZWRpdF9pbnB1dC5wbGFjZWhvbGRlciA9IFwiRW50ZXIgY2xhc3MgbmFtZVwiO1xuICAgICAgICB0aGlzLm5vZGVUYWIuYWRkT2JqZWN0KHRoaXMudGl0bGVfZWRpdF9pbnB1dCk7XG5cbiAgICAgICAgdGhpcy5ub2RlVGFiLm9uKFwic2hvd1wiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRpdGxlX2VkaXRfaW5wdXQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgdGhpcy50aXRsZV9lZGl0X2lucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMudGl0bGVfZWRpdF9saW5rLmlubmVySFRNTCA9IFwiRWRpdFwiO1xuICAgICAgICAgICAgbGV0IGMgPSB0aGlzLnNlbGVjdGVkLmM7XG4gICAgICAgICAgICBpZiAoYy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aXRsZV90ZXh0LmlubmVySFRNTCA9IEludGVyZmFjZS5yZW5kZXJMYVRlWChJbnRlcmZhY2UuZW5zdXJlTWF0aChjLm5hbWUpKSArIGAgLSAoJHtjLnh9LCAke2MueX0pYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aXRsZV90ZXh0LmlubmVySFRNTCA9IGA8c3BhbiBzdHlsZT0nY29sb3I6IGdyYXknPnVubmFtZWQ8L3NwYW4+IC0gKCR7Yy54fSwgJHtjLnl9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubm9kZVRhYi5uZXdHcm91cCgpO1xuICAgICAgICB0aGlzLm5vZGVUYWIuYWRkTGlua2VkSW5wdXQoXCJDb2xvclwiLCBcInNlbGVjdGVkLmNvbG9yXCIsIFwidGV4dFwiLCBcInNlbGVjdGVkLmNcIik7XG4gICAgICAgIHRoaXMubm9kZVRhYi5hZGRMaW5rZWRJbnB1dChcIlNpemVcIiwgXCJzZWxlY3RlZC5zaXplXCIsIFwibnVtYmVyXCIsIFwic2VsZWN0ZWQuY1wiKTtcbiAgICAgICAgdGhpcy5ub2RlVGFiLmFkZEJ1dHRvbihcIkRlbGV0ZSBjbGFzc1wiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNzZXEuc3RhcnRNdXRhdGlvblRyYWNraW5nKCk7XG4gICAgICAgICAgICB0aGlzLnNzZXEuZGVsZXRlQ2xhc3ModGhpcy5zZWxlY3RlZC5jKTtcbiAgICAgICAgICAgIHRoaXMuc3NlcS5hZGRNdXRhdGlvbnNUb1VuZG9TdGFjaygpO1xuICAgICAgICAgICAgdGhpcy5zaWRlYmFyLnNob3dQYW5lbCh0aGlzLmdlbmVyYWxQYW5lbClcbiAgICAgICAgfSwgeyBzdHlsZTogXCJkYW5nZXJcIiB9KTtcbiAgICAgICAgdGhpcy5jbGFzc1BhbmVsLmFkZFRhYihcIk5vZGVcIiwgdGhpcy5ub2RlVGFiKTtcblxuICAgICAgICAvLyBEaWZmZXJlbnRpYWxzIHRhYlxuICAgICAgICB0aGlzLmRpZmZlcmVudGlhbFRhYiA9IG5ldyBQYW5lbC5EaWZmZXJlbnRpYWxQYW5lbCh0aGlzLmNsYXNzUGFuZWwuY29udGFpbmVyLCB0aGlzKTtcbiAgICAgICAgTW91c2V0cmFwLmJpbmQoJ2QnLCAoKSA9PiB0aGlzLnN0YXRlID0gU1RBVEVfQUREX0RJRkZFUkVOVElBTCk7XG4gICAgICAgIE1vdXNldHJhcC5iaW5kKCdyJywgKCkgPT4gdGhpcy5zdGF0ZSA9IFNUQVRFX1JNX0VER0UpO1xuICAgICAgICB0aGlzLmNsYXNzUGFuZWwuYWRkVGFiKFwiRGlmZlwiLCB0aGlzLmRpZmZlcmVudGlhbFRhYik7XG5cbiAgICAgICAgLy8gU3RydWN0bGluZSB0YWJcbiAgICAgICAgdGhpcy5zdHJ1Y3RsaW5lVGFiID0gbmV3IFBhbmVsLlN0cnVjdGxpbmVQYW5lbCh0aGlzLmNsYXNzUGFuZWwuY29udGFpbmVyLCB0aGlzKTtcbiAgICAgICAgTW91c2V0cmFwLmJpbmQoJ3MnLCAoKSA9PiB0aGlzLnN0YXRlID0gU1RBVEVfQUREX1NUUlVDVExJTkUpO1xuICAgICAgICB0aGlzLmNsYXNzUGFuZWwuYWRkVGFiKFwiU3RydWN0XCIsIHRoaXMuc3RydWN0bGluZVRhYik7XG5cbiAgICAgICAgdGhpcy5zaWRlYmFyLnNob3dQYW5lbCh0aGlzLmdlbmVyYWxQYW5lbCk7XG5cbiAgICAgICAgdGhpcy50b29sdGlwID0gbmV3IFRvb2x0aXAodGhpcyk7XG4gICAgICAgIHRoaXMub24oXCJtb3VzZW92ZXJcIiwgKG5vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zZXRIVE1MKGAoJHtub2RlLmMueH0sICR7bm9kZS5jLnl9KWApO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwLnNob3cobm9kZS5jYW52YXNfeCwgbm9kZS5jYW52YXNfeSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKFwibW91c2VvdXRcIiwgdGhpcy5fb25Nb3VzZW91dC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vbihcImNsaWNrXCIsIHRoaXMuX19vbkNsaWNrLmJpbmQodGhpcykpOyAvLyBEaXNwbGF5IGFscmVhZHkgaGFzIGFuIF9vbkNsaWNrXG5cbiAgICAgICAgdGhpcy5fb25EaWZmZXJlbnRpYWxBZGRlZCA9IHRoaXMuX29uRGlmZmVyZW50aWFsQWRkZWQuYmluZCh0aGlzKTtcblxuICAgICAgICBNb3VzZXRyYXAuYmluZCgnbGVmdCcsICB0aGlzLnByZXZpb3VzUGFnZSk7XG4gICAgICAgIE1vdXNldHJhcC5iaW5kKCdyaWdodCcsIHRoaXMubmV4dFBhZ2UpO1xuICAgICAgICBNb3VzZXRyYXAuYmluZCgneCcsICgpID0+IHsgaWYodGhpcy5zZWxlY3RlZCl7IGNvbnNvbGUubG9nKHRoaXMuc2VsZWN0ZWQuYyk7IH0gfSk7XG5cbiAgICAgICAgaWYgKHNzZXEpIHRoaXMuc2V0U3NlcShzc2VxKTtcbiAgICB9XG5cbiAgICBzZXREaWZmZXJlbnRpYWxDb2xvcihwYWdlLCBjb2xvcikge1xuICAgICAgICB0aGlzLmRpZmZlcmVudGlhbENvbG9yc1twYWdlXSA9IGNvbG9yO1xuICAgIH1cblxuICAgIHNldFNzZXEoc3NlcSkge1xuICAgICAgICBpZiAodGhpcy5zc2VxKVxuICAgICAgICAgICAgdGhpcy5zc2VxLnJlbW92ZUxpc3RlbmVyKFwiZGlmZmVyZW50aWFsLWFkZGVkXCIsIHRoaXMuX29uRGlmZmVyZW50aWFsQWRkZWQpO1xuXG4gICAgICAgIHN1cGVyLnNldFNzZXEoc3NlcSlcblxuICAgICAgICB0aGlzLnNpZGViYXIuc2hvd1BhbmVsKHRoaXMuZ2VuZXJhbFBhbmVsKTtcblxuICAgICAgICB0aGlzLnNzZXEub24oXCJkaWZmZXJlbnRpYWwtYWRkZWRcIiwgdGhpcy5fb25EaWZmZXJlbnRpYWxBZGRlZCk7XG4gICAgfVxuXG4gICAgX29uTW91c2VvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB0aGlzLnNlbGVjdGVkLmhpZ2hsaWdodCA9IHRydWU7XG4gICAgICAgIHRoaXMudG9vbHRpcC5oaWRlKCk7XG4gICAgfVxuXG4gICAgX3Vuc2VsZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWQpIHJldHVybjtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkLmhpZ2hsaWdodCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5zaWRlYmFyLnNob3dQYW5lbCh0aGlzLmdlbmVyYWxQYW5lbCk7XG5cbiAgICAgICAgdGhpcy5fZHJhd1NzZXEodGhpcy5jb250ZXh0KTtcbiAgICB9XG5cbiAgICBfX29uQ2xpY2sobm9kZSwgZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9BRERfQ0xBU1MpIHtcbiAgICAgICAgICAgIGxldCB4ID0gTWF0aC5yb3VuZCh0aGlzLnhTY2FsZS5pbnZlcnQoZS5jbGllbnRYKSk7XG4gICAgICAgICAgICBsZXQgeSA9IE1hdGgucm91bmQodGhpcy55U2NhbGUuaW52ZXJ0KGUuY2xpZW50WSkpO1xuICAgICAgICAgICAgdGhpcy5zc2VxLnVuZG8uc3RhcnRNdXRhdGlvblRyYWNraW5nKCk7XG4gICAgICAgICAgICB0aGlzLnNzZXEuYWRkQ2xhc3MoeCwgeSk7XG4gICAgICAgICAgICB0aGlzLnNzZXEudW5kby5hZGRNdXRhdGlvbnNUb1VuZG9TdGFjaygpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc2VsZWN0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuc2lkZWJhci5zaG93UGFuZWwodGhpcy5jbGFzc1BhbmVsKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHMgPSB0aGlzLnNlbGVjdGVkLmM7XG4gICAgICAgIGxldCB0ID0gbm9kZS5jO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgU1RBVEVfQUREX0RJRkZFUkVOVElBTDpcbiAgICAgICAgICAgICAgICBpZihzLnggIT09IHQueCArIDEpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHQueSAtIHMueTtcbiAgICAgICAgICAgICAgICB0aGlzLnNzZXEudW5kby5zdGFydE11dGF0aW9uVHJhY2tpbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNzZXEuYWRkRGlmZmVyZW50aWFsKHMsIHQsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zc2VxLnVuZG8uYWRkTXV0YXRpb25zVG9VbmRvU3RhY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZGViYXIuc2hvd1BhbmVsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNUQVRFX1JNX0RJRkZFUkVOVElBTDpcbiAgICAgICAgICAgICAgICB0aGlzLnNzZXEudW5kby5zdGFydE11dGF0aW9uVHJhY2tpbmcoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlIG9mIHMuZWRnZXMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwiRGlmZmVyZW50aWFsXCIgJiYgZS50YXJnZXQgPT0gdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNzZXEuZGVsZXRlRWRnZShlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNzZXEudW5kby5hZGRNdXRhdGlvbnNUb1VuZG9TdGFjaygpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2lkZWJhci5zaG93UGFuZWwoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU1RBVEVfQUREX1NUUlVDVExJTkU6XG4gICAgICAgICAgICAgICAgdGhpcy5zc2VxLnVuZG8uc3RhcnRNdXRhdGlvblRyYWNraW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zc2VxLmFkZFN0cnVjdGxpbmUocywgdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zc2VxLnVuZG8uYWRkTXV0YXRpb25zVG9VbmRvU3RhY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZGViYXIuc2hvd1BhbmVsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNUQVRFX1JNX1NUUlVDVExJTkU6XG4gICAgICAgICAgICAgICAgdGhpcy5zc2VxLnVuZG8uc3RhcnRNdXRhdGlvblRyYWNraW5nKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSBvZiBzLmVkZ2VzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSBcIlN0cnVjdGxpbmVcIiAmJiBlLnRhcmdldCA9PSB0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc3NlcS5kZWxldGVFZGdlKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3NlcS51bmRvLmFkZE11dGF0aW9uc1RvVW5kb1N0YWNrKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWRlYmFyLnNob3dQYW5lbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTVEFURV9STV9FREdFOlxuICAgICAgICAgICAgICAgIHRoaXMuc3NlcS51bmRvLnN0YXJ0TXV0YXRpb25UcmFja2luZygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgb2Ygcy5lZGdlcylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09IHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzc2VxLmRlbGV0ZUVkZ2UoZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zc2VxLnVuZG8uYWRkTXV0YXRpb25zVG9VbmRvU3RhY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZGViYXIuc2hvd1BhbmVsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuX3Vuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWRlYmFyLnNob3dQYW5lbCh0aGlzLmNsYXNzUGFuZWwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIF9vbkRpZmZlcmVudGlhbEFkZGVkKGQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlmZmVyZW50aWFsQ29sb3JzW2QucGFnZV0pXG4gICAgICAgICAgICBkLmNvbG9yID0gdGhpcy5kaWZmZXJlbnRpYWxDb2xvcnNbZC5wYWdlXTtcbiAgICB9XG59XG5leHBvcnRzLkVkaXRvckRpc3BsYXkgPSBFZGl0b3JEaXNwbGF5O1xuIiwibGV0IGthdGV4ID0gcmVxdWlyZShcImthdGV4XCIpO1xyXG5cclxuYXBwbHlBdHRyaWJ1dGVzVG9FbGVtZW50ID0gZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVzVG9FbGVtZW50KGVsZW1lbnQsIGF0dHJpYnV0ZXMpe1xyXG4gICAgaWYoIWVsZW1lbnQgfHwgIWF0dHJpYnV0ZXMpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZvcihsZXQga3Ygb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpe1xyXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGt2WzBdLCBrdlsxXSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBlbnN1cmVNYXRoKHN0cil7XHJcbiAgICBpZihzdHIuc3RhcnRzV2l0aChcIlxcXFwoXCIpIHx8IHN0ci5zdGFydHNXaXRoKFwiJFwiKSl7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuICAgIGlmKCFzdHIpe1xyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiJFwiICsgc3RyICsgXCIkXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbmRlckxhdGV4KGh0bWwpIHtcclxuICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcbi9nLCBcIlxcbjxocj5cXG5cIilcclxuICAgIGxldCBodG1sX2xpc3QgPSBodG1sLnNwbGl0KC8oPzpcXFxcXFxbKXwoPzpcXFxcXFwoKXwoPzpcXFxcXFwpKXwoPzpcXFxcXFxdKXwoPzpcXCQpLyk7XHJcbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgaHRtbF9saXN0Lmxlbmd0aDsgaSs9Mil7XHJcbiAgICAgICAgaHRtbF9saXN0W2ldID0ga2F0ZXgucmVuZGVyVG9TdHJpbmcoaHRtbF9saXN0W2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBodG1sX2xpc3Quam9pbihcIlxcblwiKVxyXG59XHJcbmV4cG9ydHMucmVuZGVyTGF0ZXggPSByZW5kZXJMYXRleDtcclxuZXhwb3J0cy5yZW5kZXJMYVRlWCA9IHJlbmRlckxhdGV4O1xyXG5leHBvcnRzLmVuc3VyZU1hdGggPSBlbnN1cmVNYXRoO1xyXG5leHBvcnRzLnJlbmRlck1hdGggPSB4ID0+IHJlbmRlckxhdGV4KGVuc3VyZU1hdGgoeCkpO1xyXG5cclxuZml4Rm9ybUhUTUwgPSB7fTtcclxuZml4Rm9ybUhUTUwucmFkaW8gPSBmdW5jdGlvbihkb2MsIGZpZWxkKXtcclxuICAgIGxldCBlbHRzID0gZG9jLmdldEVsZW1lbnRzQnlOYW1lKGZpZWxkLm5hbWUpO1xyXG4gICAgbGV0IGl0ZW1zID0gZmllbGQub3B0aW9ucy5pdGVtcztcclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBlbHRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBhcHBseUF0dHJpYnV0ZXNUb0VsZW1lbnQoZWx0c1tpXSwgaXRlbXNbaV0uYXR0cmlidXRlcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5jbGFzcyBQb3B1cEZvcm0ge1xyXG4gICAgLy8gVGhpcyBjb3BpZXMgZm9ybS5yZWNvcmQgaW50byBmb3JtLnNhdmVfcmVjb3JkIHRvIGF2b2lkIGEgcmFjZSBjb25kaXRpb24gYmV0d2VlbjpcclxuICAgIC8vICAgIHRoZSBvbkNsb3NlIHdyaXRlcyBvdmVyIGZvcm0ucmVjb3JkIHdpdGggZm9ybS5vcmlnaW5hbFxyXG4gICAgLy8gICAgdGhlIHN1Y2Nlc3MgY29kZSB3cml0ZXMgb3ZlciBmb3JtLm9yaWdpbmFsIHdpdGggZm9ybS5yZWNvcmQuXHJcbiAgICBzdGF0aWMgYmFja3VwUmVjb3JkKGZvcm0pe1xyXG4gICAgICAgIGZvcm0uc2F2ZV9yZWNvcmQgPSB7fTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKGZvcm0uc2F2ZV9yZWNvcmQsZm9ybS5yZWNvcmQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdyaXRlIG92ZXIgZm9ybS5vcmlnaW5hbCBhbmQgZm9ybS5yZWNvcmQgd2l0aCBmb3JtLnNhdmVfcmVjb3JkLiBCZXR0ZXIgaGF2ZSBjYWxsZWQgYmFja3VwUmVjb3JkIGZpcnN0IVxyXG4gICAgc3RhdGljIHNhdmVSZWNvcmQoZm9ybSl7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihmb3JtLm9yaWdpbmFsLCBmb3JtLnNhdmVfcmVjb3JkKTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKGZvcm0ucmVjb3JkLCAgIGZvcm0uc2F2ZV9yZWNvcmQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdyaXRlIG92ZXIgZm9ybS5yZWNvcmQgd2l0aCBmb3JtLm9yaWdpbmFsLiBHb2VzIGluIHRoZSBvbkNsb3NlIGhhbmRsZXIuXHJcbiAgICBzdGF0aWMgcmVzdG9yZVJlY29yZChmb3JtKXtcclxuICAgICAgICBPYmplY3QuYXNzaWduKGZvcm0ucmVjb3JkLCBmb3JtLm9yaWdpbmFsKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihmb3JtX29wdGlvbnMsIHBvcHVwX29wdGlvbnMpe1xyXG4gICAgICAgIGxldCBmb3JtX29iaiA9IE9iamVjdC5hc3NpZ24oe30sIFBvcHVwRm9ybS5kZWZhdWx0X2Zvcm1fb2JqLCBmb3JtX29wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuZm9ybV9vYmogPSBmb3JtX29iajtcclxuICAgICAgICBsZXQgbmFtZSA9IGZvcm1fb2JqLm5hbWU7XHJcbiAgICAgICAgZm9ybV9vYmouYWN0aW9ucyA9IHt9O1xyXG4gICAgICAgIGZvcm1fb2JqLmFjdGlvbnNbdGhpcy5mb3JtX29iai5hY2NlcHRfYnV0dG9uX25hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgY2FsbCB0byBcIi5zYXZlKClcIiBwcm9kdWNlcyBhIGxvZ2dlZCBlcnJvciBidXQgc2VlbXMgdG8gaGF2ZSB0aGUgZGVzaXJlZCBlZmZlY3RcclxuICAgICAgICAgICAgLy8gb2YgbW92aW5nIHRoZSBjdXJyZW50IHNldCBvZiBmb3JtIGZpZWxkcyBpbnRvIFwiLnJlY29yZFwiLiBzYXZlIGlzIHN1cHBvc2VkIHRvIHNlbmQgdGhlIGZvcm0gZGF0YVxyXG4gICAgICAgICAgICAvLyB0byBhIHNlcnZlci4gVGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGFuIEFQSSBjYWxsIHRvIHNhdmUgY3VycmVudCBmaWVsZHMgaW50byAucmVjb3JkLCBhbmRcclxuICAgICAgICAgICAgLy8gSSBjb3VsZG4ndCBmaWd1cmUgb3V0IGFub3RoZXIgd2F5IHRvIGFjY2VzcyB0aGVtLlxyXG4gICAgICAgICAgICB3MnVpW25hbWVdLnNhdmUoKTtcclxuICAgICAgICAgICAgUG9wdXBGb3JtLmJhY2t1cFJlY29yZCh3MnVpW25hbWVdKTtcclxuICAgICAgICAgICAgbGV0IGVycnMgPSB3MnVpW25hbWVdLnZhbGlkYXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChlcnJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQb3B1cEZvcm0uc2F2ZVJlY29yZCh3MnVpW25hbWVdKTtcclxuICAgICAgICAgICAgdzJ1aVtuYW1lXS5vblN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgdzJwb3B1cC5jbG9zZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9ybV9vYmouYWN0aW9uc1tcIkNhbmNlbFwiXSA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcclxuICAgICAgICAgICAgLy8gTm8gc3BlY2lhbCBoYW5kbGluZyBpZiB0aGUgdXNlciBjbGlja3MgdGhlIGNhbmNlbCBidXR0b24gYXMgb3Bwb3NlZCB0byBlc2NhcGUgb3IgY2xvc2Ugb3IgY2xpY2sgb3V0c2lkZSB0aGUgYm94LlxyXG4gICAgICAgICAgICB3MnBvcHVwLmNsb3NlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgJCgpLncyZm9ybSh0aGlzLmZvcm1fb2JqKTtcclxuICAgICAgICBsZXQgZm9ybSA9IHcydWlbbmFtZV07XHJcbiAgICAgICAgdGhpcy5mb3JtID0gZm9ybTtcclxuICAgICAgICB0aGlzLmZpeEZvcm1IVE1MKGZvcm0pO1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZm9ybS5vcmlnaW5hbCwgZm9ybV9vYmoucmVjb3JkKTtcclxuXHJcbiAgICAgICAgdGhpcy5wb3B1cF9vYmogPSBPYmplY3QuYXNzaWduKHt9LCBQb3B1cEZvcm0uZGVmYXVsdF9wb3B1cF9vYmosIHBvcHVwX29wdGlvbnMpO1xyXG4gICAgICAgIC8vIE5vIGlkZWEgd2hhdCB0aGlzIGlzIGZvciBJIGp1c3QgY29waWVkIGl0IGZyb20gaHR0cDovL3cydWkuY29tL3dlYi9kZW1vcy8jIWZvcm1zL2Zvcm1zLThcclxuICAgICAgICB0aGlzLnBvcHVwX29iai5vblRvZ2dsZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAkKGZvcm0uYm94KS5oaWRlKCk7XHJcbiAgICAgICAgICAgIGV2ZW50Lm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAkKGZvcm0uYm94KS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICBmb3JtLnJlc2l6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBQcmVzc2luZyBcIkVudGVyXCIgaXMgdGhlIHNhbWUgYXMgY2xpY2tpbmcgXCJvcGVuXCJcclxuICAgICAgICB0aGlzLnBvcHVwX29iai5vbktleWRvd24gPSBmdW5jdGlvbihldmVudCl7XHJcbiAgICAgICAgICAgIGlmKGV2ZW50Lm9yaWdpbmFsRXZlbnQua2V5ID09PSBcIkVudGVyXCIpe1xyXG4gICAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIncydWktZXJyb3JcIikubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9ybS5hY3Rpb25zW2Zvcm1fb2JqLmFjY2VwdF9idXR0b25fbmFtZV0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMucG9wdXBfb2JqLm9uQ2xvc2UgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgICAgICAgICAgIFBvcHVwRm9ybS5yZXN0b3JlUmVjb3JkKGZvcm0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMudXNlck9uT3BlbiA9IHRoaXMucG9wdXBfb2JqLm9uT3BlbjtcclxuICAgICAgICB0aGlzLnBvcHVwX29iai5vbk9wZW4gPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgLy8gVGhlcmUncyBhIGRlbGF5IGJldHdlZW4gd2hlbiB0aGUgcG9wdXAgb3BlbnMgYW5kIHdoZW4gdGhlIGZvcm0gaXMgcmVuZGVyZWQgaW50byB0aGUgcG9wdXAuXHJcbiAgICAgICAgICAgIC8vIEl0IGxvb2tzIHVnbHkgaWYgd2UgbGV0IHRoZXNlIHR3byBldmVudHMgaGFwcGVuIHNlcXVlbnRpYWxseSwgc28gd2UgdGVtcG9yYXJpbHkgYWRkIGEgc3R5bGVcclxuICAgICAgICAgICAgLy8gZWxlbWVudCB0byBvdmVycmlkZSB0aGUgb3BhY2l0eSB3aXRoIDAuIE9uY2UgdGhlIGRvY3VtZW50IGlzIHJlbmRlcmVkLCB3ZSByZW1vdmUgdGhpcyBzdHlsZSBlbGVtZW50XHJcbiAgICAgICAgICAgIC8vIHRvIGFsbG93IHRoZSBmb3JtIHRvIGRpc3BsYXkuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRoaXMgYSBiaXQuXHJcbiAgICAgICAgICAgIGxldCBoaWRlX3BvcHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG4gICAgICAgICAgICBoaWRlX3BvcHVwLmlubmVyVGV4dCA9ICcjdzJ1aS1wb3B1cCwgI3cydWktbG9jayB7IG9wYWNpdHkgOiAgMCAhaW1wb3J0YW50IH0nO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGhpZGVfcG9wdXApO1xyXG4gICAgICAgICAgICBldmVudC5vbkNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgJCgnI3cydWktcG9wdXAgI2Zvcm0nKS53MnJlbmRlcihmb3JtKTsgLy8gUmVuZGVyIHRoZSBmb3JtXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLnVzZXJPbk9wZW4pe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlck9uT3BlbihldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGhpZGVfcG9wdXApOyAvLyBPbmNlIGV2ZXJ5dGhpbmcgaXMgZG9uZSwgcmVtb3ZlIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5vcGVuID0gdGhpcy5vcGVuLmJpbmQodGhpcyk7XHJcbi8vICAgICAgICB3MnVpLm9wZW5fc3NlcV9mb3JtLnJlY29yZFsnc3NlcS1maWxlLW5hbWUnXSA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIG9wZW4oKXtcclxuICAgICAgICBpZigkKCcjdzJ1aS1wb3B1cCcpLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgICQoKS53MnBvcHVwKHRoaXMucG9wdXBfb2JqKTtcclxuICAgIH1cclxuXHJcbiAgICBmaXhGb3JtSFRNTCgpe1xyXG4gICAgICAgIGxldCBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHRoaXMuZm9ybS5mb3JtSFRNTCwgXCJ0ZXh0L2h0bWxcIik7XHJcbiAgICAgICAgZm9yKGxldCBmIG9mIHRoaXMuZm9ybS5maWVsZHMpe1xyXG4gICAgICAgICAgICBpZihmLmF0dHJpYnV0ZXMpe1xyXG4gICAgICAgICAgICAgICAgYXBwbHlBdHRyaWJ1dGVzVG9FbGVtZW50KGRvYy5nZXRFbGVtZW50c0J5TmFtZShmLm5hbWUpWzBdLCBmLmF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGZpeEZvcm1IVE1MW2YudHlwZV0pe1xyXG4gICAgICAgICAgICAgICAgZml4Rm9ybUhUTUxbZi50eXBlXShkb2MsIGYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZm9ybS5mb3JtSFRNTCA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoZG9jKTtcclxuICAgIH07XHJcblxyXG5cclxufVxyXG5cclxuUG9wdXBGb3JtLmRlZmF1bHRfZm9ybV9vYmogPSB7c3R5bGU6ICdib3JkZXI6IDBweDsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7J307XHJcblBvcHVwRm9ybS5kZWZhdWx0X3BvcHVwX29iaiA9IHtcclxuICAgIGJvZHkgICAgOiAnPGRpdiBpZD1cImZvcm1cIiBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XCI+PC9kaXY+JyxcclxuICAgIHN0eWxlICAgOiAncGFkZGluZzogMTVweCAwcHggMHB4IDBweCBvcGFjaXR5OiAwJyxcclxuICAgIHdpZHRoICAgOiA1MDAsXHJcbiAgICBoZWlnaHQgIDogMjIwXHJcbn07XHJcblxyXG5leHBvcnRzLlBvcHVwRm9ybSA9IFBvcHVwRm9ybTtcclxuXHJcblxyXG5jbGFzcyBVbmRvIHtcclxuICAgIGNvbnN0cnVjdG9yKHNzZXEpe1xyXG4gICAgICAgIHRoaXMuc3NlcSA9IHNzZXE7XHJcbiAgICAgICAgdGhpcy51bmRvU3RhY2sgPSBbXTtcclxuICAgICAgICB0aGlzLnVuZG9PYmpTdGFjayA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVkb1N0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5yZWRvT2JqU3RhY2sgPSBbXTtcclxuICAgICAgICB0aGlzLnVuZG8gPSB0aGlzLnVuZG8uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZG8gPSB0aGlzLnJlZG8uYmluZCh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgc3RhcnRNdXRhdGlvblRyYWNraW5nKCl7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbk1hcCA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRNdXRhdGlvbnNUb1VuZG9TdGFjayhldmVudF9vYmope1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMubXV0YXRpb25NYXAsIGV2ZW50X29iaik7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbk1hcCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBhZGRNdXRhdGlvbihvYmosIHByZSwgcG9zdCl7XHJcbiAgICAgICAgaWYoIXRoaXMubXV0YXRpb25NYXApe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMubXV0YXRpb25NYXAuZ2V0KG9iaikpe1xyXG4gICAgICAgICAgICBwcmUgPSB0aGlzLm11dGF0aW9uTWFwLmdldChvYmopLmJlZm9yZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbk1hcC5zZXQob2JqLCB7b2JqOiBvYmosIGJlZm9yZTogcHJlLCBhZnRlciA6IHBvc3R9KTtcclxuICAgIH1cclxuXHJcbiAgICBhZGQobXV0YXRpb25zLCBldmVudF9vYmopIHtcclxuICAgICAgICB0aGlzLnVuZG9TdGFjay5wdXNoKHt0eXBlOlwibm9ybWFsXCIsICBtdXRhdGlvbnM6IG11dGF0aW9uc30pO1xyXG4gICAgICAgIHRoaXMudW5kb09ialN0YWNrLnB1c2goZXZlbnRfb2JqKTtcclxuICAgICAgICB0aGlzLnJlZG9TdGFjayA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVkb09ialN0YWNrID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgYWRkVmFsdWVDaGFuZ2UodGFyZ2V0LCBwcm9wLCBiZWZvcmUsIGFmdGVyLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGxldCBlID0ge3R5cGU6XCJ2YWx1ZVwiLCB0YXJnZXQ6IHRhcmdldCwgcHJvcDogcHJvcCwgYmVmb3JlOiBiZWZvcmUsIGFmdGVyOiBhZnRlciwgY2FsbGJhY2s6IGNhbGxiYWNrfTtcclxuICAgICAgICB0aGlzLnVuZG9TdGFjay5wdXNoKGUpO1xyXG4gICAgICAgIHRoaXMudW5kb09ialN0YWNrLnB1c2goZSk7XHJcbiAgICAgICAgdGhpcy5yZWRvU3RhY2sgPSBbXTtcclxuICAgICAgICB0aGlzLnJlZG9PYmpTdGFjayA9IFtdO1xyXG4gICAgfVxyXG4gICAgYWRkTWFudWFsKGUsIGVfb2JqKSB7XHJcbiAgICAgICAgdGhpcy51bmRvU3RhY2sucHVzaChlKTtcclxuICAgICAgICB0aGlzLnVuZG9PYmpTdGFjay5wdXNoKGVfb2JqKTtcclxuICAgICAgICB0aGlzLnJlZG9TdGFjayA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVkb09ialN0YWNrID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXIoKXtcclxuICAgICAgICB0aGlzLnVuZG9TdGFjayA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVkb1N0YWNrID0gW107XHJcbiAgICB9O1xyXG5cclxuICAgIHVuZG8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudW5kb1N0YWNrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlID0gdGhpcy51bmRvU3RhY2sucG9wKCk7XHJcbiAgICAgICAgdGhpcy5yZWRvU3RhY2sucHVzaChlKTtcclxuICAgICAgICBsZXQgb2JqID0gdGhpcy51bmRvT2JqU3RhY2sucG9wKCk7XHJcbiAgICAgICAgdGhpcy5yZWRvT2JqU3RhY2sucHVzaChvYmopO1xyXG4gICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJub3JtYWxcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMudW5kb05vcm1hbChlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcclxuICAgICAgICAgICAgICAgIGUudGFyZ2V0W2UucHJvcF0gPSBlLmJlZm9yZTtcclxuICAgICAgICAgICAgICAgIGlmIChlLmNhbGxiYWNrKSBlLmNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zc2VxLmVtaXQoXCJ1cGRhdGVcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIHVuZG9Ob3JtYWwob2JqKXtcclxuICAgICAgICBsZXQgbXV0YXRpb25zID0gb2JqLm11dGF0aW9ucztcclxuICAgICAgICBmb3IobGV0IG0gb2YgbXV0YXRpb25zLnZhbHVlcygpKXtcclxuICAgICAgICAgICAgaWYobS5vYmoudW5kb0Zyb21NZW1lbnRvKXtcclxuICAgICAgICAgICAgICAgIG0ub2JqLnVuZG9Gcm9tTWVtZW50byhtLmJlZm9yZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtLm9iai5yZXN0b3JlRnJvbU1lbWVudG8obS5iZWZvcmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlZG8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVkb1N0YWNrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlID0gdGhpcy5yZWRvU3RhY2sucG9wKCk7XHJcbiAgICAgICAgdGhpcy51bmRvU3RhY2sucHVzaChlKTtcclxuICAgICAgICBsZXQgb2JqID0gdGhpcy5yZWRvT2JqU3RhY2sucG9wKCk7XHJcbiAgICAgICAgdGhpcy51bmRvT2JqU3RhY2sucHVzaChvYmopO1xyXG4gICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJub3JtYWxcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMucmVkb05vcm1hbChlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcclxuICAgICAgICAgICAgICAgIGUudGFyZ2V0W2UucHJvcF0gPSBlLmFmdGVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuY2FsbGJhY2spIGUuY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNzZXEuZW1pdChcInVwZGF0ZVwiKTtcclxuICAgIH07XHJcblxyXG4gICAgcmVkb05vcm1hbChvYmope1xyXG4gICAgICAgIGxldCBtdXRhdGlvbnMgPSBvYmoubXV0YXRpb25zO1xyXG4gICAgICAgIGZvcihsZXQgbSBvZiBtdXRhdGlvbnMudmFsdWVzKCkpe1xyXG4gICAgICAgICAgICBpZihtLm9iai5yZWRvRnJvbU1lbWVudG8pe1xyXG4gICAgICAgICAgICAgICAgbS5vYmoucmVkb0Zyb21NZW1lbnRvKG0uYWZ0ZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbS5vYmoucmVzdG9yZUZyb21NZW1lbnRvKG0uYWZ0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZExvY2sobXNnKXtcclxuICAgICAgICBsZXQgZCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgaWYobXNnID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBtc2cgPSBgVW5kbyBldmVudHMgYmVmb3JlIHNhdmUgYXQgJHtkLmdldEZ1bGxZZWFyKCl9LSR7ZC5nZXRNb250aCgpfS0ke2QuZ2V0RGF5KCl9ICR7ZC5nZXRIb3VycygpfToke2QuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMixcIjBcIil9P2A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudW5kb1N0YWNrLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlIDogXCJsb2NrXCIsXHJcbiAgICAgICAgICAgIG1zZyA6IG1zZyxcclxuICAgICAgICAgICAgZGF0ZSA6IGQsXHJcbiAgICAgICAgICAgIHVuZG9GdW5jdGlvbiA6IGxvY2tGdW5jdGlvbi5iaW5kKHRoaXMpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBnZXRFdmVudE9iamVjdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5kb09ialN0YWNrO1xyXG4gICAgfVxyXG5cclxuICAgIHRvSlNPTigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVuZG9TdGFjay5tYXAoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBpZihlLnR5cGUgPT09IFwibm9ybWFsXCIpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIiA6IFwibm9ybWFsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJtdXRhdGlvbnNcIiA6IEFycmF5LmZyb20oZS5tdXRhdGlvbnMuZW50cmllcygpKS5tYXAoKFtrLHZdKSA9PiBbay5yZWNpZCwgdi5iZWZvcmVdKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblVuZG8udW5kb0Z1bmN0aW9ucyA9IHt9O1xyXG5VbmRvLnJlZG9GdW5jdGlvbnMgPSB7fTtcclxuVW5kby51bmRvRnVuY3Rpb25zW1wibG9ja1wiXSA9IGxvY2tGdW5jdGlvbjtcclxuVW5kby5yZWRvRnVuY3Rpb25zW1wibG9ja1wiXSA9IGZ1bmN0aW9uKCkge307XHJcblxyXG5cclxuZnVuY3Rpb24gbG9ja0Z1bmN0aW9uKG9iail7XHJcbiAgICB3MmNvbmZpcm0ob2JqLm1zZylcclxuICAgICAgICAueWVzKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZWRvU3RhY2sucG9wKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAubm8oKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZSA9IHRoaXMucmVkb1N0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnVuZG9TdGFjay5wdXNoKGUpO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5VbmRvLmRlZmF1bHRMb2NrTWVzc2FnZSA9IFwiVW5kbyBldmVudHMgYmVmb3JlIGxvYWRlZCBwYWdlP1wiO1xyXG5cclxuZXhwb3J0cy5VbmRvID0gVW5kbztcclxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubGV0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5sZXQgTW91c2V0cmFwID0gcmVxdWlyZShcIm1vdXNldHJhcFwiKTtcbmxldCBJbnRlcmZhY2UgPSByZXF1aXJlKFwiLi9JbnRlcmZhY2UuanNcIik7XG5cbmNvbnN0IFNUQVRFX0FERF9ESUZGRVJFTlRJQUwgPSAxO1xuY29uc3QgU1RBVEVfUk1fRElGRkVSRU5USUFMID0gMjtcbmNvbnN0IFNUQVRFX0FERF9TVFJVQ1RMSU5FID0gMztcbmNvbnN0IFNUQVRFX1JNX1NUUlVDVExJTkUgPSA0O1xuY29uc3QgU1RBVEVfUk1fRURHRSA9IDU7XG5cbi8qKlxuICogQSBwYW5lbCBpcyBhIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyAoYnV0dG9uIGV0Yy4pIHRvIGJlIGRpc3BsYXllZCBpbiBhXG4gKiBzaWRlcGFuZWwuIFRoZSBtYWluIGZ1bmN0aW9uIHRvIGltcGxlbWVudCBpcyBzaG93KCksIHdoaWNoIGlzIGNhbGxlZFxuICogd2hlbmV2ZXIgdGhlIHBhbmVsIGlzIHRvIGJlIGRpc3BsYXllZC5cbiAqXG4gKiBUaGUgc3RhbmRhcmQgd2F5IHRvIGRlYWwgd2l0aCBwYW5lbHMgaXMgdGhhdCBhbGwgY2hpbGRyZW4gb2YgdGhlIHBhbmVsIGFyZVxuICogY3JlYXRlZCB3aGVuIHRoZSBwYW5lbCBpcyBpbml0aWFsaXplZCwgYW5kIGFsbCBjYWxsYmFja3MgYXJlIGFwcHJvcHJpYXRlbHlcbiAqIHNldCB1cC4gV2hlbiBzaG93KCkgaXMgY2FsbGVkLCB3ZSBkZWNpZGUgd2hpY2ggZWxlbWVudHMgdG8gZGlzcGxheSBieVxuICogc2V0dGluZyB0aGUgZGlzcGxheSBwcm9wZXJ0eSwgYW5kIHRoZW4gaW5pdGlhbGl6ZSB0aGUgdmFsdWVzIG9mIHRoZSBlbGVtZW50c1xuICogYWNjb3JkaW5nbHkuXG4gKlxuICogUGFuZWxzIGFuZCBpdHMgY2hpbGRyZW4gYXJlIGV4cGVjdGVkIHRvIHByb3Blcmx5IHRyYWNrIG11dGF0aW9ucyBhbmQgd3JpdGVcbiAqIHRoZW0gdG8gdGhpcy5kaXNwbGF5LnNzZXEudW5kbyB1cG9uIGVhY2ggY2hhbmdlLlxuICpcbiAqIFRoZXJlIGFyZSBhIGZldyBoZWxwZXIgZnVuY3Rpb25zIHRoYXQgYWRkIGVsZW1lbnRzIHRvIHRoZSBwYW5lbCwgc3VjaCBhc1xuICogYWRkQnV0dG9uLlxuICpcbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gY29udGFpbmVyIC0gVG9wIG5vZGUgb2YgdGhlIHBhbmVsLCB0byB3aGljaCB3ZSBhZGQgYWxsXG4gKiBjaGlsZHJlbi4gVGhpcyBpcyBhIHBsYWluIGRpdiBlbGVtZW50IHRoYXQgaXMgbm90IHN0eWxlZC4gQWxsIHN0eWxpbmcgc2hvdWxkXG4gKiBiZSBhcHBsaWVkIHRvIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyLlxuICogQHByb3BlcnR5IHtOb2RlfSBjdXJyZW50R3JvdXAgLSBUaGlzIGlzIHRoZSBET00gZWxlbWVudCB0aGF0IHRoZSBoZWxwZXJcbiAqIGZ1bmN0aW9ucyB3aWxsIGFkZCB0aGUgYnV0dG9ucy9maWVsZHMgdG8uIFRoaXMgZGVmYXVsdHMgdG8gdGhpcy5jb250YWluZXJcbiAqIGJ1dCBpcyBtb2RpZmllZCBieSBuZXdHcm91cCgpIGFuZCBlbmRHcm91cCgpLiBJdCBjYW4gYWxzbyBiZSBtYW51YWxseVxuICogbW9kaWZpZWQgYXMgZGVzaXJlZC5cbiAqXG4gKiBAZmlyZXMgUGFuZWwjc2hvd1xuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFBhbmVsIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgcGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IHBhcmVudENvbnRhaW5lciAtIFRoZSBub2RlIHRvIGFkZCB0aGUgcGFuZWwgdG9cbiAgICAgKiBAcGFyYW0ge0Rpc3BsYXk6RGlzcGxheX0gLSBUaGUgRGlzcGxheSBvYmplY3QgdGhlIHBhbmVsIGlzIGFib3V0LlxuICAgICAqIFRoaXMgaXMgdXNlZCBieSB0aGUgaGVscGVyIGZ1bmN0aW9ucyB0byBrbm93IHdoZXJlIHRvIHRyYWNrIG11dGF0aW9ucyxcbiAgICAgKiB1cGRhdGUgdGhlIGRpc3BsYXkgd2hlbiBwcm9wZXJ0aWVzIGNoYW5nZSwgZXRjLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChwYXJlbnRDb250YWluZXIsIGRpc3BsYXkpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLmRpc3BsYXkgPSBkaXNwbGF5O1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHBhcmVudENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMubGlua3MgPSBbXTtcblxuICAgICAgICB0aGlzLmN1cnJlbnRHcm91cCA9IHRoaXMuY29udGFpbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaGlkZXMgdGhlIHBhbmVsLiBJdCBkb2VzIG5vdGhpbmcgYnV0IHNldCB0aGUgZGlzcGxheSBwcm9wZXJ0eSB0b1xuICAgICAqIG5vbmUuXG4gICAgICovXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2xlYXJzIGV2ZXJ5dGhpbmcgaW4gdGhlIHBhbmVsLiBUaGlzIGN1cnJlbnRseSBkb2VzIG5vdCB1bmJpbmQgdGhlXG4gICAgICogc2hvcnRjdXRzLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5jb250YWluZXIuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXG4gICAgICAgIHRoaXMubGlua3MgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3dzIHRoZSBwYW5lbCwgYW5kIHBvcHVsYXRlcyB0aGUgdmFsdWVzIG9mIHRoZSBjaGlsZHJlbi4gIFRoaXNcbiAgICAgKiBjb3JyZWN0bHkgcG9wdWxhdGVzIHRoZSBjaGlsZHJlbiBhZGRlZCBieSB0aGUgaGVscGVyIGZ1bmN0aW9ucywgYW5kIG5vXG4gICAgICogZXh0cmEgd29yayBoYXMgdG8gYmUgZG9uZSBmb3IgdGhlbS4gSWYgY3VzdG9tIGNoaWxkcmVuIGFyZSBhZGRlZCwgb25lXG4gICAgICogd2lsbCB3YW50IHRvIGN1c3RvbWl6ZSB0aGUgc2hvdygpIGZ1bmN0aW9uIHRvIGVuc3VyZSB0aGUgY2hpbGRyZW4gYXJlXG4gICAgICogY29ycmVjdGx5IGRpc3BsYXllZC4gVGhpcyBjYW4gYmUgZG9uZSBieSBvdmVyd3JpdGluZyB0aGUgc2hvdygpIGZ1bmN0aW9uXG4gICAgICogb3IgYnkgbGlzdGVuaW5nIHRvIHRoZSBQYW5lbCNzaG93IGV2ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIHdoZW4gdGhlIHBhbmVsIGlzIGFscmVhZHkgc2hvd24uIEluIHRoaXNcbiAgICAgKiBjYXNlLCB0aGUgY29ycmVjdCBiZWhhdmlvdXIgaXMgdG8gcmVmcmVzaCB0aGUgZGlzcGxheSAoZS5nLiB1cGRhdGUgdGhlXG4gICAgICogdmFsdWVzIG9mIHRoZSBmaWVsZHMpXG4gICAgICovXG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xuXG4gICAgICAgIGZvciAobGV0IGxpbmsgb2YgdGhpcy5saW5rcykge1xuICAgICAgICAgICAgbGV0IHQgPSB0aGlzLmRpc3BsYXk7XG4gICAgICAgICAgICBmb3IgKGxldCBhdHRyIG9mIGxpbmtbMF0uc3BsaXQoXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgdCA9IHRbYXR0cl07XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZCB8fCB0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rWzFdLnZhbHVlID0gdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyBldmVudC4gVGhpcyBpcyBlbWl0dGVkIHdoZW4gc2hvdygpIGlzIGNhbGxlZC4gT25lIG1heSBvcHQgdG9cbiAgICAgICAgICogbGlzdGVuIGFuZCByZXNwb25kIHRvIHRoZSBzaG93IGV2ZW50IGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgc2hvdygpXG4gICAgICAgICAqIHdoZW4gZGVzaWduaW5nIGN1c3RvbSBwYW5lbHMsIGMuZi4gRGlmZmVyZW50aWFsUGFuZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQYW5lbCNzaG93XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoXCJzaG93XCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgY3JlYXRlcyBhIG5ldyBkaXYgYW5kIGFkZHMgaXQgdG8gdGhlIGNvbnRhaW5lci4gVGhpcyBuZXcgZGl2IGlzXG4gICAgICogdGhlbiBzZXQgYXMgY3VycmVudEdyb3VwIGFuZCBoYXMgY2xhc3MgY2FyZC1ib2R5LlxuICAgICAqXG4gICAgICogVGhpcyBzaG91bGQgYmUgdXNlZCBpZiBvbmUgd2lzaGVzIHRvIGFkZCBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gdGhhdFxuICAgICAqIGFyZSB0byBiZSBncm91cGVkIHRvZ2V0aGVyLiBUaGUgcHJvY2VkdXJlIGZvciB1c2luZyB0aGlzIGlzIGFzIGZvbGxvd3M6XG4gICAgICogKDEpIFJ1biBQYW5lbCNhZGRHcm91cFxuICAgICAqICgyKSBBZGQgdGhlIGNoaWxkcmVuIHVzaW5nIHRoZSBoZWxwZXIgZnVuY3Rpb25zIChhZGRCdXR0b24sIGFkZE9iamVjdCwgZXRjLilcbiAgICAgKiAoMykgUnVuIFBhbmVsI2VuZEdyb3VwIHRvIHNldCBjdXJyZW50R3JvdXAgYmFjayB0byB0aGlzLmNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBuZXdHcm91cCgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50R3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmN1cnJlbnRHcm91cC5jbGFzc05hbWUgPSBcImNhcmQtYm9keVwiO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRHcm91cCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlZSBuZXdHcm91cCgpLlxuICAgICAqL1xuICAgIGVuZEdyb3VwKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRHcm91cCA9IHRoaXMuY29udGFpbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgbm90aGluZyBidXQgdGhpcy5jdXJyZW50R3JvdXAuYXBwZW5kQ2hpbGQob2JqKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gb2JqIC0gVGhlIG9iamVjdCB0byBiZSBhZGRlZC5cbiAgICAgKi9cbiAgICBhZGRPYmplY3Qob2JqKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEdyb3VwLmFwcGVuZENoaWxkKG9iaik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBhZGRzIGEgYnV0dG9uIHRvIGN1cnJlbnRHcm91cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGV4dCB0byBhcHBlYXIgb24gdGhlIGJ1dHRvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBidXR0b24gaXMgY2xpY2tlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmEgLSBFeHRyYSAob3B0aW9uYWwpIHByb3BlcnRpZXMgdG8gc3VwcGx5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRyYS50b29sdGlwIC0gVG9vbHRpcCB0ZXh0IHRvIGRpc3BsYXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBzaG9ydGN1dHMgLSBBIGxpc3Qgb2Ygc2hvcnRjdXRzIHRoYXQgd2lsbCBiZSBib3VuZCB0byBjYWxsYmFja1xuICAgICAqL1xuICAgIGFkZEJ1dHRvbih0ZXh0LCBjYWxsYmFjaywgZXh0cmEgPSB7fSkge1xuICAgICAgICBsZXQgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIGlmIChleHRyYS5zdHlsZSlcbiAgICAgICAgICAgIG8uY2xhc3NOYW1lID0gYGJ0biBidG4tJHtleHRyYS5zdHlsZX0gbWItMmA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG8uY2xhc3NOYW1lID0gXCJidG4gYnRuLXByaW1hcnkgbWItMlwiO1xuXG4gICAgICAgIG8uc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgby5pbm5lckhUTUwgPSB0ZXh0O1xuICAgICAgICBvLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjYWxsYmFjayk7XG5cbiAgICAgICAgaWYgKGV4dHJhLnRvb2x0aXApXG4gICAgICAgICAgICBvLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIGV4dHJhLnRvb2x0aXApO1xuICAgICAgICBpZiAoZXh0cmEuc2hvcnRjdXRzKVxuICAgICAgICAgICAgZm9yIChsZXQgayBvZiBleHRyYS5zaG9ydGN1dHMpXG4gICAgICAgICAgICAgICAgTW91c2V0cmFwLmJpbmQoaywgY2FsbGJhY2spO1xuXG4gICAgICAgIHRoaXMuY3VycmVudEdyb3VwLmFwcGVuZENoaWxkKG8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYWRkcyBzZXZlcmFsIGJ1dHRvbnMgcGxhY2VkIHNpZGUtYnktc2lkZSBvbiBhIHJvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXlbXX0gYnV0dG9ucyAtIEFuIGFycmF5IG9mIGFyZ3VtZW50cyBzcGVjaWZ5aW5nIHRoZSBidXR0b25zXG4gICAgICogdG8gYmUgYWRkZWQuIEVhY2ggZW50cnkgaW4gdGhlIGFycmF5IHNob3VsZCBpdHNlbGYgYmUgYW4gYXJyYXksIHdoaWNoXG4gICAgICogY29uc2lzdHMgb2YgdGhlIGFyZ3VtZW50cyB0byBQYW5lbCNhZGRCdXR0b24gZm9yIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogYnV0dG9uLlxuICAgICAqL1xuICAgIGFkZEJ1dHRvblJvdyhidXR0b25zKXtcbiAgICAgICAgbGV0IGdyb3VwID0gdGhpcy5jdXJyZW50R3JvdXA7XG4gICAgICAgIGxldCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgby5jbGFzc05hbWUgPSBcImZvcm0tcm93XCI7XG4gICAgICAgIGZvciAobGV0IGJ1dHRvbiBvZiBidXR0b25zKSB7XG4gICAgICAgICAgICBsZXQgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBjLmNsYXNzTmFtZSA9IFwiY29sXCI7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRHcm91cCA9IGM7XG4gICAgICAgICAgICB0aGlzLmFkZEJ1dHRvbiguLi5idXR0b24pO1xuICAgICAgICAgICAgby5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRHcm91cCA9IGdyb3VwO1xuICAgICAgICB0aGlzLmN1cnJlbnRHcm91cC5hcHBlbmRDaGlsZChvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGFkZHMgYSBoZWFkZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciAtIFRoZSBoZWFkZXIgdGV4dC5cbiAgICAgKi9cbiAgICBhZGRIZWFkZXIoaGVhZGVyKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImg1XCIpO1xuICAgICAgICBub2RlLmNsYXNzTmFtZSA9IFwiY2FyZC10aXRsZVwiO1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGhlYWRlcjtcbiAgICAgICAgdGhpcy5hZGRPYmplY3Qobm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBhZGRzIGEgbGlua2VkIGlucHV0LiBBIGxpbmtlZCBpbnB1dCBpcyBhbiBlbnRyeSB0aGF0IGxvb2tzIGxpa2VcbiAgICAgKlxuICAgICAqICAgICAgICstLS0tLStcbiAgICAgKiBMYWJlbCB8ICAgICB8XG4gICAgICogICAgICAgKy0tLS0tK1xuICAgICAqXG4gICAgICogVGhlIGlucHV0IGZpZWxkIGlzIGxpbmtlZCB0byBhIGNlcnRhaW4gcHJvcGVydHkgb2YgZGlzcGxheS4gV2hlbiB0aGVcbiAgICAgKiBwYW5lbCBpcyBzaG93biwgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGlucHV0IGZpZWxkIGlzIHNldCB0byB0aGUgdmFsdWVcbiAgICAgKiBvZiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSwgYW5kIHdoZW4gdGhlIGlucHV0IGZpZWxkIGlzIGNoYW5nZWQsIHRoZVxuICAgICAqIHByb3BlcnR5IGlzIGNoYW5nZWQgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgLSBUaGUgbGFiZWwgZGlzcGxheWVkIG5leHQgdG8gdGhlIGlucHV0IGZpZWxkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCAtIFRoZSBwcm9wZXJ0eSB0aGUgaW5wdXQgZmllbGQgaXMgbGlua2VkIHRvLlxuICAgICAqIFRoaXMgaXMgc3BlY2lmaWVkIGJ5IGEgc3RyaW5nIG9mIHRoZSBmcm9tIFwiZm9vLmJhci54eXpcIiwgd2hpY2ggc2F5cyB0aGVcbiAgICAgKiBmaWVsZCBpcyBsaW5rZWQgdG8gdGhpcy5kaXNwbGF5LmZvby5iYXIueHl6LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGlucHV0IGZpZWxkLiBUaGlzIGlzIFwidGV4dFwiIG9yXG4gICAgICogXCJudW1iZXJcIiB3b3VsZCB1c3VhbGx5IGJlIHNlbnNpYmxlIGNob2ljZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBtZW1lbnRvT2JqZWN0IC0gQnkgZGVmYXVsdCwgdGhlIHVuZG8vcmVkbyBmdW5jdGlvbnNcbiAgICAgKiB3aWxsIHNpbXBseSBzZXQgdGhlIHZhbHVlIG9mIHRhcmdldCB0byB3aGF0IGl0IHdhcy4gSGVyZSB0aGUgdGFyZ2V0XG4gICAgICogaXMgcmVtZW1iZXJlZCBhcyBhbiAqb2JqZWN0Kiwgbm90IGFzIGEgcHJvcGVydHkgb2YgdGhpcy5kaXNwbGF5IHZpYVxuICAgICAqIHRhcmdldCAoZm9yIGV4YW1wbGUsIGlmIHRoZSBpbnB1dCBpcyBhYm91dCB0aGUgY3VycmVudGx5IGFjdGl2ZSBub2RlXG4gICAgICogKHRoaXMuZGlzcGxheS5zZWxlY3RlZCksIHRoZSB1bmRvIGZ1bmN0aW9uIHNob3VsZCB1bmRvIHRoZSBjaGFuZ2Ugb24gdGhlXG4gICAgICogbm9kZSB0aGF0IHdhcyBhZmZlY3RlZCwgbm90IHRoZSBub2RlIHRoYXQgaXMgYWN0aXZlIHdoZW4gdGhlIHVuZG8gYnV0dG9uXG4gICAgICogaXMgcHJlc3NlZCkuIEl0IHR1cm5zIG91dCB0aGlzIGlzIHByb2JsZW1hdGljIHdoZW4gZGVhbGluZyB3aXRoIG5vZGVzIG9mXG4gICAgICogY2xhc3Nlcywgc2luY2Ugd2hlbiBjbGFzc2VzIGFyZSByZXN0b3JlZCB2aWEgdW5kby9yZWRvLCB0aGUgc2V0IG9mIG5vZGVzXG4gICAgICogaXMgY29waWVkIGFuZCBhbGwgcmVmZXJlbmNlcyBhcmUgbG9zdC5cbiAgICAgKlxuICAgICAqIElmIG1lbWVudG9PYmplY3QgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIG9mIHRyYWNraW5nIGluZGl2aWR1YWwgY2hhbmdlc1xuICAgICAqIG9mIHRoZSBwcm9wZXJ0aWVzLCB0aGUgbXV0YXRpb24gdHJhY2tlciByZW1lbWJlcnMgdGhlIHByZXZpb3VzIGFuZCBhZnRlclxuICAgICAqIHN0YXRlcyBvZiBtZW1lbnRvT2JqZWN0IGFuZCB3cml0ZXMgdGhhdCBpbnRvIHRoZSB1bmRvIHN0YWNrIGluc3RlYWQuXG4gICAgICogYy5mLiB0aGUgbm9kZSBjb2xvci9zaXplIGlucHV0cyBpbiBFZGl0b3JEaXNwbGF5LlxuICAgICAqL1xuICAgIGFkZExpbmtlZElucHV0KGxhYmVsLCB0YXJnZXQsIHR5cGUsIG1lbWVudG9PYmplY3QpIHtcbiAgICAgICAgbGV0IG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBvLmNsYXNzTmFtZSA9IFwiZm9ybS1yb3cgbWItMlwiO1xuICAgICAgICBvLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgIHRoaXMuY3VycmVudEdyb3VwLmFwcGVuZENoaWxkKG8pO1xuXG4gICAgICAgIGxldCBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xuICAgICAgICBsLmNsYXNzTmFtZSA9IFwiY29sLWZvcm0tbGFiZWwgbXItc20tMlwiO1xuICAgICAgICBsLmlubmVySFRNTCA9IGxhYmVsO1xuICAgICAgICBvLmFwcGVuZENoaWxkKGwpO1xuXG4gICAgICAgIGxldCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBpLnN0eWxlW1wiZmxleC1ncm93XCJdID0gMTtcbiAgICAgICAgaS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICBvLmFwcGVuZENoaWxkKGkpO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgICAgICBpLnNldEF0dHJpYnV0ZShcInNpemVcIiwgXCIxXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpLnN0eWxlLndpZHRoID0gXCIxcHhcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGlua3MucHVzaChbdGFyZ2V0LCBpXSk7XG5cbiAgICAgICAgaS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0X3ByZTtcbiAgICAgICAgICAgIGlmIChtZW1lbnRvT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgbWVtZW50b09iamVjdCA9IFBhbmVsLnVud3JhcFByb3BlcnR5KHRoaXMuZGlzcGxheSwgbWVtZW50b09iamVjdC5zcGxpdChcIi5cIikpXG4gICAgICAgICAgICAgICAgdGFyZ2V0X3ByZSA9IG1lbWVudG9PYmplY3QuZ2V0TWVtZW50bygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbCA9IHRhcmdldC5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IGwucG9wKCk7XG4gICAgICAgICAgICBsZXQgdCA9IFBhbmVsLnVud3JhcFByb3BlcnR5KHRoaXMuZGlzcGxheSwgbCk7XG5cbiAgICAgICAgICAgIGxldCBvbGRfdmFsID0gdFtwcm9wXTtcbiAgICAgICAgICAgIGxldCBuZXdfdmFsID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICB0W3Byb3BdID0gbmV3X3ZhbDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheS5zc2VxLnVuZG8pIHtcbiAgICAgICAgICAgICAgICBpZiAobWVtZW50b09iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkuc3NlcS51bmRvLnN0YXJ0TXV0YXRpb25UcmFja2luZygpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheS5zc2VxLnVuZG8uYWRkTXV0YXRpb24obWVtZW50b09iamVjdCwgdGFyZ2V0X3ByZSwgbWVtZW50b09iamVjdC5nZXRNZW1lbnRvKCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheS5zc2VxLnVuZG8uYWRkTXV0YXRpb25zVG9VbmRvU3RhY2soKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkuc3NlcS51bmRvLmFkZFZhbHVlQ2hhbmdlKHQsIHByb3AsIG9sZF92YWwsIG5ld192YWwsICgpID0+IHRoaXMuZGlzcGxheS5zaWRlYmFyLnNob3dQYW5lbCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGxheS5zc2VxLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB1bndyYXBQcm9wZXJ0eShzdGFydCwgbGlzdCkge1xuICAgICAgICBsZXQgdCA9IHN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBpIG9mIGxpc3QpXG4gICAgICAgICAgICB0ID0gdFtpXTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBwYW5lbCB3aG9zZSBzb21lIHB1cnBvc2UgaXMgdG8gY29udGFpbiBmdXJ0aGVyIHBhbmVscyBhcnJhbmdlZCBpblxuICogdGFicy4gVGhpcyBpcyB1c2VkLCBmb3IgZXhhbXBsZSwgaW4gRWRpdG9yRGlzcGxheSBmb3IgY29uZmlndXJpbmcgZGlmZmVyZW50XG4gKiBwcm9wZXJ0aWVzIG9mIGEgY2xhc3MuXG4gKlxuICogQHByb3BlcnR5IHtQYW5lbH0gY3VycmVudFRhYiAtIFRoZSBjdXJyZW50IHRhYiB0aGF0IGlzIGRpc3BsYXllZC5cbiAqL1xuY2xhc3MgVGFiYmVkUGFuZWwgZXh0ZW5kcyBQYW5lbCB7XG4gICAgY29uc3RydWN0b3IgKHBhcmVudENvbnRhaW5lciwgZGlzcGxheSkge1xuICAgICAgICBzdXBlcihwYXJlbnRDb250YWluZXIsIGRpc3BsYXkpO1xuXG4gICAgICAgIGxldCBoZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaGVhZC5jbGFzc05hbWUgPSBcImNhcmQtaGVhZGVyXCI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGhlYWQpO1xuXG4gICAgICAgIHRoaXMuaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgICAgICB0aGlzLmhlYWRlci5jbGFzc05hbWUgPSBcIm5hdiBuYXYtdGFicyBjYXJkLWhlYWRlci10YWJzXCI7XG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQodGhpcy5oZWFkZXIpO1xuXG4gICAgICAgIHRoaXMudGFicyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRUYWIgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYWRkcyBhIHRhYiB0byBUYWJiZWRQYW5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHRhYiwgdG8gYmUgZGlzcGxheWVkIGluIHRoZVxuICAgICAqIGhlYWRlci4gQXZvaWQgbWFraW5nIHRoaXMgdG9vIGxvbmcuXG4gICAgICogQHBhcmFtIHtQYW5lbH0gdGFiIC0gVGhlIHRhYiB0byBiZSBhZGRlZC5cbiAgICAgKi9cbiAgICBhZGRUYWIobmFtZSwgdGFiKSB7XG4gICAgICAgIGxldCBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgICAgbGkuY2xhc3NOYW1lID0gXCJuYXYtaXRlbVwiO1xuICAgICAgICB0aGlzLmhlYWRlci5hcHBlbmRDaGlsZChsaSk7XG5cbiAgICAgICAgbGV0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgYS5jbGFzc05hbWUgPSBcIm5hdi1saW5rXCI7XG4gICAgICAgIGEuaHJlZiA9IFwiI1wiO1xuICAgICAgICBhLmlubmVySFRNTCA9IG5hbWU7XG4gICAgICAgIGxpLmFwcGVuZENoaWxkKGEpO1xuXG4gICAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuc2hvd1RhYih0YWIpKTtcbiAgICAgICAgdGhpcy50YWJzW3RoaXMudGFicy5sZW5ndGhdID0gW3RhYiwgYV07XG5cbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRUYWIpIHRoaXMuY3VycmVudFRhYiA9IHRhYjtcbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgICBzdXBlci5zaG93KCk7XG4gICAgICAgIHRoaXMuc2hvd1RhYih0aGlzLmN1cnJlbnRUYWIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvcnJlc3BvbmRpbmcgdGFiIHRvIGJlIHRoZSBhY3RpdmUgdGFiIGFuZCBzaG93cyBpdCAob2YgY291cnNlLFxuICAgICAqIHRoZSB0YWIgd2lsbCBub3QgYmUgYWN0dWFsbHkgc2hvd24gaWYgdGhlIHBhbmVsIGl0c2VsZiBpcyBoaWRkZW4pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYW5lbH0gdGFiIC0gVGFiIHRvIGJlIHNob3duLlxuICAgICAqL1xuICAgIHNob3dUYWIodGFiKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRhYiA9IHRhYjtcbiAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRhYnMpIHtcbiAgICAgICAgICAgIGlmICh0WzBdID09IHRhYikge1xuICAgICAgICAgICAgICAgIHRbMV0uY2xhc3NOYW1lID0gXCJuYXYtbGluayBhY3RpdmVcIjtcbiAgICAgICAgICAgICAgICB0WzBdLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdFsxXS5jbGFzc05hbWUgPSBcIm5hdi1saW5rXCI7XG4gICAgICAgICAgICAgICAgdFswXS5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIERpZmZlcmVudGlhbFBhbmVsIGV4dGVuZHMgUGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudENvbnRhaW5lciwgZGlzcGxheSkge1xuICAgICAgICBzdXBlcihwYXJlbnRDb250YWluZXIsIGRpc3BsYXkpO1xuXG4gICAgICAgIHRoaXMuZGlmZmVyZW50aWFsX2xpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICAgIHRoaXMuZGlmZmVyZW50aWFsX2xpc3QuY2xhc3NOYW1lID0gXCJsaXN0LWdyb3VwIGxpc3QtZ3JvdXAtZmx1c2hcIjtcbiAgICAgICAgdGhpcy5kaWZmZXJlbnRpYWxfbGlzdC5zdHlsZVtcInRleHQtYWxpZ25cIl0gPSBcImNlbnRlclwiO1xuICAgICAgICB0aGlzLmFkZE9iamVjdCh0aGlzLmRpZmZlcmVudGlhbF9saXN0KTtcblxuICAgICAgICB0aGlzLm9uKFwic2hvd1wiLCAoKSA9PiB7XG4gICAgICAgICAgICB3aGlsZSh0aGlzLmRpZmZlcmVudGlhbF9saXN0LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgdGhpcy5kaWZmZXJlbnRpYWxfbGlzdC5yZW1vdmVDaGlsZCh0aGlzLmRpZmZlcmVudGlhbF9saXN0LmZpcnN0Q2hpbGQpO1xuXG4gICAgICAgICAgICBsZXQgZWRnZXMgPSB0aGlzLmRpc3BsYXkuc2VsZWN0ZWQuYy5lZGdlcy5maWx0ZXIoZSA9PiBlLnR5cGUgPT09IFwiRGlmZmVyZW50aWFsXCIpLnNvcnQoKGEsIGIpID0+IGEucGFnZSAtIGIucGFnZSk7XG5cbiAgICAgICAgICAgIGxldCBzbmFtZSwgdG5hbWU7XG4gICAgICAgICAgICBmb3IgKGxldCBlIG9mIGVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgc25hbWUgPSBlLnNvdXJjZS5uYW1lID8gZS5zb3VyY2UubmFtZSA6IFwiP1wiXG4gICAgICAgICAgICAgICAgdG5hbWUgPSBlLnRhcmdldC5uYW1lID8gZS50YXJnZXQubmFtZSA6IFwiP1wiXG4gICAgICAgICAgICAgICAgaWYgKGUuc291cmNlID09IHRoaXMuZGlzcGxheS5zZWxlY3RlZC5jKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZExJKEludGVyZmFjZS5yZW5kZXJNYXRoKGBkXyR7ZS5wYWdlfSh7XFxcXGNvbG9ye2JsdWV9JHtzbmFtZX19KSA9ICR7dG5hbWV9YCkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRMSShJbnRlcmZhY2UucmVuZGVyTWF0aChgZF8ke2UucGFnZX0oJHtzbmFtZX0pID0ge1xcXFxjb2xvcntibHVlfSR7dG5hbWV9fWApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hZGRMSShcIjxhIGhyZWY9JyMnPkFkZCBkaWZmZXJlbnRpYWw8L2E+XCIsICgpID0+IHRoaXMuZGlzcGxheS5zdGF0ZSA9IFNUQVRFX0FERF9ESUZGRVJFTlRJQUwgKTtcbiAgICAgICAgICAgIHRoaXMuYWRkTEkoXCI8YSBocmVmPScjJz5SZW1vdmUgZGlmZmVyZW50aWFsPC9hPlwiLCAoKSA9PiB0aGlzLmRpc3BsYXkuc3RhdGUgPSBTVEFURV9STV9ESUZGRVJFTlRJQUwgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWRkTEkoaHRtbCwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG4gICAgICAgIG5vZGUuY2xhc3NOYW1lID0gXCJsaXN0LWdyb3VwLWl0ZW1cIjtcbiAgICAgICAgbm9kZS5zdHlsZSA9IFwicGFkZGluZzogMC43NXJlbSAwXCI7XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY2FsbGJhY2spO1xuICAgICAgICB0aGlzLmRpZmZlcmVudGlhbF9saXN0LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbn1cblxuY2xhc3MgU3RydWN0bGluZVBhbmVsIGV4dGVuZHMgUGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudENvbnRhaW5lciwgZGlzcGxheSkge1xuICAgICAgICBzdXBlcihwYXJlbnRDb250YWluZXIsIGRpc3BsYXkpO1xuXG4gICAgICAgIHRoaXMuc3RydWN0bGluZV9saXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgICAgICB0aGlzLnN0cnVjdGxpbmVfbGlzdC5jbGFzc05hbWUgPSBcImxpc3QtZ3JvdXAgbGlzdC1ncm91cC1mbHVzaFwiO1xuICAgICAgICB0aGlzLnN0cnVjdGxpbmVfbGlzdC5zdHlsZVtcInRleHQtYWxpZ25cIl0gPSBcImNlbnRlclwiO1xuICAgICAgICB0aGlzLmFkZE9iamVjdCh0aGlzLnN0cnVjdGxpbmVfbGlzdCk7XG5cbiAgICAgICAgdGhpcy5vbihcInNob3dcIiwgKCkgPT4ge1xuICAgICAgICAgICAgd2hpbGUodGhpcy5zdHJ1Y3RsaW5lX2xpc3QuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICB0aGlzLnN0cnVjdGxpbmVfbGlzdC5yZW1vdmVDaGlsZCh0aGlzLnN0cnVjdGxpbmVfbGlzdC5maXJzdENoaWxkKTtcblxuICAgICAgICAgICAgbGV0IGVkZ2VzID0gdGhpcy5kaXNwbGF5LnNlbGVjdGVkLmMuZWRnZXMuZmlsdGVyKGUgPT4gZS50eXBlID09PSBcIlN0cnVjdGxpbmVcIikuc29ydCgoYSwgYikgPT4gYS5wYWdlIC0gYi5wYWdlKTtcblxuICAgICAgICAgICAgbGV0IHNuYW1lLCB0bmFtZTtcbiAgICAgICAgICAgIGZvciAobGV0IGUgb2YgZWRnZXMpIHtcbiAgICAgICAgICAgICAgICBzbmFtZSA9IGUuc291cmNlLm5hbWUgPyBlLnNvdXJjZS5uYW1lIDogXCI/XCJcbiAgICAgICAgICAgICAgICB0bmFtZSA9IGUudGFyZ2V0Lm5hbWUgPyBlLnRhcmdldC5uYW1lIDogXCI/XCJcbiAgICAgICAgICAgICAgICBpZiAoZS5zb3VyY2UgPT0gdGhpcy5kaXNwbGF5LnNlbGVjdGVkLmMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTEkoSW50ZXJmYWNlLnJlbmRlck1hdGgoYHtcXFxcY29sb3J7Ymx1ZX0ke3NuYW1lfX0gXFxcXHRleHR7LS0tfSAke3RuYW1lfWApKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTEkoSW50ZXJmYWNlLnJlbmRlck1hdGgoYCR7c25hbWV9IFxcXFx0ZXh0ey0tLX0ge1xcXFxjb2xvcntibHVlfSR7dG5hbWV9fWApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hZGRMSShcIjxhIGhyZWY9JyMnPkFkZCBzdHJ1Y3RsaW5lPC9hPlwiLCAoKSA9PiB0aGlzLmRpc3BsYXkuc3RhdGUgPSBTVEFURV9BRERfU1RSVUNUTElORSApO1xuICAgICAgICAgICAgdGhpcy5hZGRMSShcIjxhIGhyZWY9JyMnPlJlbW92ZSBzdHJ1Y3RsaW5lPC9hPlwiLCAoKSA9PiB0aGlzLmRpc3BsYXkuc3RhdGUgPSBTVEFURV9STV9TVFJVQ1RMSU5FICk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgYWRkTEkoaHRtbCwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG4gICAgICAgIG5vZGUuY2xhc3NOYW1lID0gXCJsaXN0LWdyb3VwLWl0ZW1cIjtcbiAgICAgICAgbm9kZS5zdHlsZSA9IFwicGFkZGluZzogMC43NXJlbSAwXCI7XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY2FsbGJhY2spO1xuICAgICAgICB0aGlzLnN0cnVjdGxpbmVfbGlzdC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG59XG5cbmV4cG9ydHMuUGFuZWwgPSBQYW5lbDtcbmV4cG9ydHMuVGFiYmVkUGFuZWwgPSBUYWJiZWRQYW5lbDtcbmV4cG9ydHMuRGlmZmVyZW50aWFsUGFuZWwgPSBEaWZmZXJlbnRpYWxQYW5lbDtcbmV4cG9ydHMuU3RydWN0bGluZVBhbmVsID0gU3RydWN0bGluZVBhbmVsO1xuIiwiZXhwb3J0cy5kb3dubG9hZCA9IGZ1bmN0aW9uKGZpbGVuYW1lLCB0ZXh0LCBtaW1lPVwidGV4dC9wbGFpblwiKSB7XHJcbiAgICBpZih0ZXh0LmNvbnN0cnVjdG9yICE9PSBTdHJpbmcpe1xyXG4gICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeSh0ZXh0KTtcclxuICAgIH1cclxuICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG5cclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdocmVmJywgYGRhdGE6JHttaW1lfTtjaGFyc2V0PXV0Zi04LGAgKyBlbmNvZGVVUklDb21wb25lbnQodGV4dCkpO1xyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2Rvd25sb2FkJywgZmlsZW5hbWUpO1xyXG5cclxuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcbiAgICBlbGVtZW50LmNsaWNrKCk7XHJcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xyXG59O1xyXG5cclxuXHJcbi8vZnVuY3Rpb25cclxuXHJcbmV4cG9ydHMudXBsb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KSA9PiB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ZpbGUnKTtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnJyk7XHJcblxyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgbGV0IGZpbGVMaXN0ID0gW107XHJcbiAgICAgICAgZWxlbWVudC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yKGxldCBmIG9mIGVsZW1lbnQuZmlsZXMpe1xyXG4gICAgICAgICAgICAgICAgZmlsZUxpc3QucHVzaCh7IG5hbWUgOiBmLm5hbWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZWxlbWVudC5maWxlc1swXSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGZpbGVMaXN0W2ldLmNvbnRlbnQgPSByZWFkZXIucmVzdWx0O1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGlmKGkgPCBlbGVtZW50LmZpbGVzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChlbGVtZW50LmZpbGVzW2ldKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZmlsZUxpc3QpO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KTtcclxuICAgICAgICBlbGVtZW50LmNsaWNrKCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblxyXG5cclxuZXhwb3J0cy5zYXZlVG9Mb2NhbFN0b3JlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgY29sbGVjdGlvbil7XHJcbiAgICBpZih2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nKXtcclxuICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzc2VxRGF0YWJhc2Uub3BlbigpLmNhdGNoKChlcnIpID0+IGNvbnNvbGUubG9nKGVycikpXHJcbiAgICAgICAgLnRoZW4oKCkgPT4gc3NlcURhdGFiYXNlLmNyZWF0ZUtleShrZXksIHZhbHVlLCBjb2xsZWN0aW9uKSlcclxuICAgICAgICAudGhlbigoKSA9PiBjb25zb2xlLmxvZyhcIlN1Y2Nlc3NmdWxseSBzYXZlZC5cIikpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gbmV4dFN0cmluZyhzdHIpe1xyXG4gICAgaWYoc3RyLmxlbmd0aCA9PT0gMCApe1xyXG4gICAgICAgIHJldHVybiBcIsKmXCI7IC8vIExhc3QgcHJpbnRhYmxlIGFzY2lpIGNoYXJhY3RlciAtLSBpdCdzIGluIGNvZGUgcG9pbnQgMjU0LlxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCxzdHIubGVuZ3RoLTEpK1N0cmluZy5mcm9tQ2hhckNvZGUoc3RyLmNoYXJDb2RlQXQoc3RyLmxlbmd0aC0xKSsxKTtcclxufVxyXG5cclxuZXhwb3J0cy5sb2FkS2V5c0Zyb21Mb2NhbFN0b3JlV2l0aFByZWZpeCA9IGFzeW5jIGZ1bmN0aW9uKHByZWZpeCl7XHJcbiAgICBsZXQgZW5kU3RyID0gbmV4dFN0cmluZyhwcmVmaXgpO1xyXG4gICAgYXdhaXQgc3NlcURhdGFiYXNlLm9wZW4oKTtcclxuICAgIHJldHVybiBhd2FpdCBzc2VxRGF0YWJhc2UuZmV0Y2hLZXlSYW5nZShwcmVmaXgsIGVuZFN0cik7XHJcbn07XHJcblxyXG5leHBvcnRzLmxvYWRGcm9tTG9jYWxTdG9yZSA9IGFzeW5jIGZ1bmN0aW9uKGtleSl7XHJcbiAgICBhd2FpdCBzc2VxRGF0YWJhc2Uub3BlbigpO1xyXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgc3NlcURhdGFiYXNlLmZldGNoS2V5KGtleSk7XHJcbiAgICBpZighcmVzcG9uc2UgfHwgIXJlc3BvbnNlLnZhbHVlKXtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgbGV0IG9iaiA9IEpTT04ucGFyc2UocmVzcG9uc2UudmFsdWUpO1xyXG4gICAgb2JqLm5hbWUgPSByZXNwb25zZS5rZXk7XHJcbiAgICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuZXhwb3J0cy5kZWxldGVGcm9tTG9jYWxTdG9yZSA9IGFzeW5jIGZ1bmN0aW9uKGtleSl7XHJcbiAgICBhd2FpdCBzc2VxRGF0YWJhc2Uub3BlbigpO1xyXG4gICAgYXdhaXQgc3NlcURhdGFiYXNlLmRlbGV0ZUtleShrZXkpO1xyXG4gICAgcmV0dXJuO1xyXG59O1xyXG5cclxuZXhwb3J0cy5sb2FkRnJvbVNlcnZlciA9IGFzeW5jIGZ1bmN0aW9uKHBhdGgpe1xyXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocGF0aCk7XHJcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG59O1xyXG5cclxuXHJcbmNvbnN0IHNzZXFEYXRhYmFzZSA9IHt9O1xyXG5sZXQgZGF0YXN0b3JlID0gbnVsbDtcclxuXHJcbnNzZXFEYXRhYmFzZS5vcGVuID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3QpIHtcclxuICAgICAgICBpZihkYXRhc3RvcmUpe1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGF0YWJhc2UgdmVyc2lvbi5cclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gNjtcclxuXHJcbiAgICAgICAgLy8gT3BlbiBhIGNvbm5lY3Rpb24gdG8gdGhlIGRhdGFzdG9yZS5cclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oJ3NzZXEnLCB2ZXJzaW9uKTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGRhdGFzdG9yZSB1cGdyYWRlcy5cclxuICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRiID0gZS50YXJnZXQucmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgZS50YXJnZXQudHJhbnNhY3Rpb24ub25lcnJvciA9IHNzZXFEYXRhYmFzZS5vbmVycm9yO1xyXG5cclxuICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBvbGQgZGF0YXN0b3JlLlxyXG4gICAgICAgICAgICBpZiAoZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnc3NlcScpKSB7XHJcbiAgICAgICAgICAgICAgICBkYi5kZWxldGVPYmplY3RTdG9yZSgnc3NlcScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZGF0YXN0b3JlLlxyXG4gICAgICAgICAgICBjb25zdCBzdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdzc2VxJywge1xyXG4gICAgICAgICAgICAgICAga2V5UGF0aDogJ2tleSdcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBzdG9yZS5jcmVhdGVJbmRleChcImtleVwiLCBcImtleVwiLCAgeyB1bmlxdWU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIHN0b3JlLmNyZWF0ZUluZGV4KFwiY29sbGVjdGlvblwiLCBcImNvbGxlY3Rpb25cIiwgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBzdWNjZXNzZnVsIGRhdGFzdG9yZSBhY2Nlc3MuXHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIERCLlxyXG4gICAgICAgICAgICBkYXRhc3RvcmUgPSBlLnRhcmdldC5yZXN1bHQ7XHJcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGVycm9ycyB3aGVuIG9wZW5pbmcgdGhlIGRhdGFzdG9yZS5cclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSByZWplY3Q7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblxyXG5zc2VxRGF0YWJhc2UuZmV0Y2hBbGxLZXlzID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYXRhc3RvcmUudHJhbnNhY3Rpb24oWydzc2VxJ10sICdyZWFkd3JpdGUnKTtcclxuICAgICAgICBjb25zdCBvYmpTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdzc2VxJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGtleVJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZCgwKTtcclxuICAgICAgICBjb25zdCBjdXJzb3JSZXF1ZXN0ID0gb2JqU3RvcmUub3BlbkN1cnNvcihrZXlSYW5nZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvZG9zID0gW107XHJcblxyXG4gICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAgICAgICAgcmVzb2x2ZSh0b2Rvcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZS50YXJnZXQucmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgaWYgKCEhcmVzdWx0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0b2Rvcy5wdXNoKHJlc3VsdC52YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICByZXN1bHQuY29udGludWUoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSByZWplY3Q7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnNzZXFEYXRhYmFzZS5mZXRjaEtleSA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGF0YXN0b3JlLnRyYW5zYWN0aW9uKFsnc3NlcSddLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgICAgY29uc3Qgb2JqU3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnc3NlcScpO1xyXG5cclxuICAgICAgICBjb25zdCBrZXlSYW5nZSA9IElEQktleVJhbmdlLmxvd2VyQm91bmQoMCk7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmVSZXF1ZXN0ID0gb2JqU3RvcmUuaW5kZXgoXCJrZXlcIikuZ2V0KGtleSk7XHJcblxyXG4gICAgICAgIG9iamVjdFN0b3JlUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICByZXNvbHZlKG9iamVjdFN0b3JlUmVxdWVzdC5yZXN1bHQpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG9iamVjdFN0b3JlUmVxdWVzdC5vbmVycm9yID0gcmVqZWN0O1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5cclxuc3NlcURhdGFiYXNlLmZldGNoS2V5UmFuZ2UgPSBmdW5jdGlvbihtaW4sbWF4KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYXRhc3RvcmUudHJhbnNhY3Rpb24oWydzc2VxJ10sICdyZWFkd3JpdGUnKTtcclxuICAgICAgICBjb25zdCBvYmpTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdzc2VxJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGtleVJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQobWluLCBtYXgsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBjdXJzb3JSZXF1ZXN0ID0gb2JqU3RvcmUub3BlbkN1cnNvcihrZXlSYW5nZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvZG9zID0gW107XHJcblxyXG4gICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAgICAgICAgcmVzb2x2ZSh0b2Rvcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZS50YXJnZXQucmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgaWYgKCEhcmVzdWx0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0b2Rvcy5wdXNoKHJlc3VsdC52YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICByZXN1bHQuY29udGludWUoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSByZWplY3Q7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnNzZXFEYXRhYmFzZS5mZXRjaENvbGxlY3Rpb24gPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYXRhc3RvcmUudHJhbnNhY3Rpb24oWydzc2VxJ10sICdyZWFkd3JpdGUnKTtcclxuICAgICAgICBjb25zdCBvYmpTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdzc2VxJyk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGNvbGxlY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IGN1cnNvclJlcXVlc3QgPSBvYmpTdG9yZS5pbmRleChcImNvbGxlY3Rpb25cIikub3BlbkN1cnNvcihjb2xsZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdG9kb3MgPSBbXTtcclxuXHJcbiAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICByZXNvbHZlKHRvZG9zKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBlLnRhcmdldC5yZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoISFyZXN1bHQgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdG9kb3MucHVzaChyZXN1bHQudmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0LmNvbnRpbnVlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY3Vyc29yUmVxdWVzdC5vbmVycm9yID0gcmVqZWN0O1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5zc2VxRGF0YWJhc2UuY3JlYXRlS2V5ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgY29sbGVjdGlvbikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIC8vIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgZGIuXHJcbiAgICAgICAgY29uc3QgZGIgPSBkYXRhc3RvcmU7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYXRlIGEgbmV3IHRyYW5zYWN0aW9uLlxyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oWydzc2VxJ10sICdyZWFkd3JpdGUnKTtcclxuICAgICAgICAvLyBHZXQgdGhlIGRhdGFzdG9yZS5cclxuICAgICAgICBjb25zdCBvYmpTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdzc2VxJyk7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGZvciB0aGUgaXRlbS5cclxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAvLyBDcmVhdGUgYW4gb2JqZWN0IGZvciB0aGUgaXRlbS5cclxuICAgICAgICBjb25zdCBpdGVtID0ge1xyXG4gICAgICAgICAgICAna2V5JyA6IGtleSxcclxuICAgICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXHJcbiAgICAgICAgICAgICdjb2xsZWN0aW9uJyA6IGNvbGxlY3Rpb24sXHJcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXBcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZGF0YXN0b3JlIHJlcXVlc3QuXHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG9ialN0b3JlLnB1dChpdGVtKTtcclxuICAgICAgICAvLyBIYW5kbGUgYSBzdWNjZXNzZnVsIGRhdGFzdG9yZSBwdXQuXHJcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAgICAgICAgcmVzb2x2ZShpdGVtKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBIYW5kbGUgZXJyb3JzLlxyXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHJlamVjdDtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuXHJcbnNzZXFEYXRhYmFzZS5kZWxldGVLZXkgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gZGF0YXN0b3JlO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oWydzc2VxJ10sICdyZWFkd3JpdGUnKTtcclxuICAgICAgICBjb25zdCBvYmpTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdzc2VxJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBvYmpTdG9yZS5kZWxldGUoaWQpO1xyXG5cclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSByZWplY3Q7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbmV4cG9ydHMuc3NlcURhdGFiYXNlID0gc3NlcURhdGFiYXNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5sZXQgRGlzcGxheSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXkuanNcIikuRGlzcGxheTtcbmxldCBQYW5lbCA9IHJlcXVpcmUoXCIuL1BhbmVsLmpzXCIpO1xuXG5jbGFzcyBTaWRlYmFyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5hZGp1c3RlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuYWRqdXN0ZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKDAsMCwwLDAuMTI1KVwiO1xuICAgICAgICB0aGlzLmFkanVzdGVyLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgICB0aGlzLmFkanVzdGVyLnN0eWxlLmN1cnNvciA9IFwiZXctcmVzaXplXCI7XG4gICAgICAgIHRoaXMuYWRqdXN0ZXIuc3R5bGUud2lkdGggPSBcIjJweFwiO1xuXG4gICAgICAgIHBhcmVudENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmFkanVzdGVyKTtcblxuICAgICAgICB0aGlzLnJlc2l6ZSA9IHRoaXMucmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3RvcFJlc2l6ZSA9IHRoaXMuc3RvcFJlc2l6ZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuYWRqdXN0ZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMucmVzaXplKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5zdG9wUmVzaXplKTtcbiAgICAgICAgfSkuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5zaWRlYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zaWRlYmFyLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgICB0aGlzLnNpZGViYXIuc3R5bGUud2lkdGggPSBcIjI0MHB4XCI7XG4gICAgICAgIHRoaXMuc2lkZWJhci5zdHlsZS5ib3JkZXIgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5zaWRlYmFyLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICAgICAgdGhpcy5zaWRlYmFyLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSBcImNvbHVtblwiO1xuICAgICAgICB0aGlzLnNpZGViYXIuY2xhc3NOYW1lID0gXCJjYXJkXCI7XG5cbiAgICAgICAgcGFyZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc2lkZWJhcik7XG5cbiAgICAgICAgdGhpcy5tYWluX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMubWFpbl9kaXYuc3R5bGUub3ZlcmZsb3cgPSBcImF1dG9cIjtcbiAgICAgICAgdGhpcy5zaWRlYmFyLmFwcGVuZENoaWxkKHRoaXMubWFpbl9kaXYpO1xuXG4gICAgICAgIGxldCBmaWxsZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBmaWxsZXIuc3R5bGUuZmxleEdyb3cgPSBcIjFcIjtcbiAgICAgICAgdGhpcy5zaWRlYmFyLmFwcGVuZENoaWxkKGZpbGxlcik7XG5cbiAgICAgICAgdGhpcy5mb290ZXJfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zaWRlYmFyLmFwcGVuZENoaWxkKHRoaXMuZm9vdGVyX2Rpdik7XG5cbiAgICAgICAgdGhpcy5wYW5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGFuZWwgPSBudWxsO1xuICAgIH1cblxuICAgIGFkZFBhbmVsKHBhbmVsKSB7XG4gICAgICAgIHRoaXMucGFuZWxzLnB1c2gocGFuZWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYW5lbHMubGVuZ3RoO1xuICAgIH1cblxuICAgIGluaXQoZGlzcGxheSkge1xuICAgICAgICB0aGlzLmRpc3BsYXkgPSBkaXNwbGF5O1xuICAgICAgICB0aGlzLmZvb3RlciA9IG5ldyBQYW5lbC5QYW5lbCh0aGlzLmZvb3Rlcl9kaXYsIGRpc3BsYXkpO1xuICAgIH1cblxuICAgIHJlc2l6ZShlKSB7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMuc2lkZWJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCAtIGUucGFnZVg7XG4gICAgICAgIHRoaXMuc2lkZWJhci5zdHlsZS53aWR0aCA9IGAke3dpZHRofXB4YDtcbiAgICB9XG5cbiAgICBzdG9wUmVzaXplKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5yZXNpemUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuc3RvcFJlc2l6ZSk7XG4gICAgICAgIHRoaXMuZGlzcGxheS5yZXNpemUoKTtcbiAgICB9XG5cbiAgICBzaG93UGFuZWwocGFuZWwpIHtcbiAgICAgICAgaWYgKCFwYW5lbCkgcGFuZWwgPSB0aGlzLmN1cnJlbnRQYW5lbDtcbiAgICAgICAgdGhpcy5jdXJyZW50UGFuZWwgPSBwYW5lbDtcblxuICAgICAgICBmb3IgKGxldCB4IG9mIHRoaXMucGFuZWxzKSB7XG4gICAgICAgICAgICBpZiAoeCA9PSBwYW5lbClcbiAgICAgICAgICAgICAgICB4LnNob3coKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB4LmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgU2lkZWJhckRpc3BsYXkgZXh0ZW5kcyBEaXNwbGF5IHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHNzZXEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250YWluZXIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcblxuICAgICAgICBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuZGlzcGxheURpcmVjdGlvbiA9IFwicm93XCI7XG5cbiAgICAgICAgbGV0IGNoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgY2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgICAgIGNoaWxkLnN0eWxlLm1pbkhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgICBjaGlsZC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgIGNoaWxkLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICBjaGlsZC5zdHlsZS5mbGV4R3JvdyA9IFwiMVwiO1xuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG5cbiAgICAgICAgbGV0IHNpZGViYXIgPSBuZXcgU2lkZWJhcihjb250YWluZXIpXG5cbiAgICAgICAgc3VwZXIoY2hpbGQsIHNzZXEpO1xuXG4gICAgICAgIHRoaXMuc2lkZWJhciA9IHNpZGViYXI7XG4gICAgICAgIHRoaXMuc2lkZWJhci5pbml0KHRoaXMpO1xuICAgIH1cbn1cblxuZXhwb3J0cy5TaWRlYmFyRGlzcGxheSA9IFNpZGViYXJEaXNwbGF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuY29uc3QgTUFSR0lOID0gMTA7XG5cbmNsYXNzIFRvb2x0aXAge1xuICAgIGNvbnN0cnVjdG9yKGRpc3BsYXkpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5ID0gZGlzcGxheTtcblxuICAgICAgICB0aGlzLmRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZGl2LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB0aGlzLmRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgdGhpcy5kaXYuc3R5bGVbXCJ6LWluZGV4XCJdID0gOTk5OTk5O1xuICAgICAgICB0aGlzLmRpdi5jbGFzc05hbWUgPSBcInRvb2x0aXBcIjtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZGl2KTtcbiAgICB9XG5cbiAgICBzZXRIVE1MKGh0bWwpIHtcbiAgICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9XG5cbiAgICBzaG93KHgsIHkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0IHRoZSB0b29sdGlwIHBvc2l0aW9uLiBUaGlzIHByZXZlbnRzIGEgYnVnIHRoYXQgb2NjdXJzIHdoZW4gdGhlXG4gICAgICAgICAqIHByZXZpb3VzbHkgZGlzcGxheWVkIHRvb2x0aXAgaXMgcG9zaXRpb25lZCBuZWFyIHRoZSBlZGdlIChidXQgc3RpbGxcbiAgICAgICAgICogcG9zaXRpb25lZCB0byB0aGUgcmlnaHQgb2YgdGhlIG5vZGUpLCBhbmQgdGhlIG5ldyB0b29sdGlwIHRleHQgaXNcbiAgICAgICAgICogbG9uZ2VyIHRoYW4gdGhlIHByZXZpb3VzIHRvb2x0aXAgdGV4dC4gVGhpcyBtYXkgY2F1c2UgdGhlIG5ld1xuICAgICAgICAgKiAodW5kaXNwbGF5ZWQpIHRvb2x0aXAgdGV4dCB0byB3cmFwLCB3aGljaCBnaXZlcyBhbiBpbmNvcnJlY3QgdmFsdWVcbiAgICAgICAgICogb2YgcmVjdC53aWR0aCBhbmQgcmVjdC5oZWlnaHQuIFRoZSBidWcgYWxzbyBvY2N1cnMgYWZ0ZXIgcmVzaXppbmcsXG4gICAgICAgICAqIHdoZXJlIHRoZSBsb2NhdGlvbiBvZiB0aGUgcHJldmlvdXMgdG9vbHRpcCBpcyBub3cgb3V0c2lkZSBvZiB0aGVcbiAgICAgICAgICogd2luZG93LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXYuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIHRoaXMuZGl2LnN0eWxlLnRvcCA9IFwiMHB4XCI7XG5cbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGNhbnZhc1JlY3QgPSB0aGlzLmRpc3BsYXkuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHggPSB4ICsgY2FudmFzUmVjdC54O1xuICAgICAgICB5ID0geSArIGNhbnZhc1JlY3QueTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQnkgZGVmYXVsdCwgc2hvdyB0aGUgdG9vbHRpcCB0byB0aGUgdG9wIGFuZCByaWdodCBvZiAoeCwgeSksIG9mZnNldFxuICAgICAgICAgKiBieSBNQVJHSU4uIElmIHRoaXMgY3Vhc2VzIHRoZSB0b29sdGlwIHRvIGxlYXZlIHRoZSB3aW5kb3csIHBvc2l0aW9uXG4gICAgICAgICAqIGl0IHRvIHRoZSBib3R0b20vbGVmdCBhY2NvcmRpbmdseS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh4ICsgTUFSR0lOICsgcmVjdC53aWR0aCA8IHdpbmRvdy5pbm5lcldpZHRoKVxuICAgICAgICAgICAgeCA9IHggKyBNQVJHSU47XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHggPSB4IC0gcmVjdC53aWR0aCAtIE1BUkdJTjtcblxuICAgICAgICBpZiAoeSAtIHJlY3QuaGVpZ2h0IC0gTUFSR0lOID4gMClcbiAgICAgICAgICAgIHkgPSB5IC0gcmVjdC5oZWlnaHQgLSBNQVJHSU47XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHkgPSB5ICsgTUFSR0lOO1xuXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlLmxlZnQgPSBgJHt4fXB4YDtcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUudG9wID0gYCR7eX1weGA7XG5cbiAgICAgICAgdGhpcy5kaXYuc3R5bGUudHJhbnNpdGlvbiA9IFwib3BhY2l0eSAyMDBtc1wiO1xuICAgICAgICB0aGlzLmRpdi5zdHlsZS5vcGFjaXR5ID0gMC45O1xuICAgIH1cblxuICAgIGhpZGUgKCkge1xuICAgICAgICB0aGlzLmRpdi5zdHlsZS50cmFuc2l0aW9uID0gXCJvcGFjaXR5IDUwMG1zXCI7XG4gICAgICAgIHRoaXMuZGl2LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIH1cbn1cblxuZXhwb3J0cy5Ub29sdGlwID0gVG9vbHRpcDtcbiIsImV4cG9ydHMuQmFzaWNEaXNwbGF5ID0gcmVxdWlyZShcIi4vQmFzaWNEaXNwbGF5LmpzXCIpLkJhc2ljRGlzcGxheTtcclxuZXhwb3J0cy5EaXNwbGF5ID0gcmVxdWlyZShcIi4vRGlzcGxheS5qc1wiKS5EaXNwbGF5O1xyXG5leHBvcnRzLkVkaXRvckRpc3BsYXkgPSByZXF1aXJlKFwiLi9FZGl0b3JEaXNwbGF5LmpzXCIpLkVkaXRvckRpc3BsYXk7XHJcbmV4cG9ydHMuSW50ZXJmYWNlID0gcmVxdWlyZShcIi4vSW50ZXJmYWNlXCIpO1xyXG5leHBvcnRzLklPID0gcmVxdWlyZShcIi4vU2F2ZUxvYWRcIik7XHJcbiAgICBleHBvcnRzLnNzZXFEYXRhYmFzZSA9IGV4cG9ydHMuSU8uc3NlcURhdGFiYXNlO1xyXG5leHBvcnRzLlNpZGViYXJEaXNwbGF5ID0gcmVxdWlyZShcIi4vU2lkZWJhckRpc3BsYXkuanNcIikuU2lkZWJhckRpc3BsYXk7XHJcbmV4cG9ydHMuVG9vbHRpcCA9IHJlcXVpcmUoXCIuL1Rvb2x0aXAuanNcIikuVG9vbHRpcDtcclxuZXhwb3J0cy5QYW5lbCA9IHJlcXVpcmUoXCIuL1BhbmVsLmpzXCIpO1xyXG4vLyBleHBvcnRzLkVkaXRNb2RlID0gcmVxdWlyZShcIi4vRWRpdE1vZGUuanNcIikuRWRpdE1vZGU7IiwiZXhwb3J0cy5JTkZJTklUWSA9IHJlcXVpcmUoXCIuL2luZmluaXR5LmpzXCIpLklORklOSVRZO1xyXG5cclxuZXhwb3J0cy5tb2QgPSBmdW5jdGlvbihuLGQpe1xyXG4gICAgcmV0dXJuIChuICUgZCArIGQpJWQ7XHJcbn07XHJcblxyXG4vLyB3aW5kb3cuVXRpbCA9IHJlcXVpcmUoXCIuL3NzZXEvVXRpbC5qc1wiKTtcclxuXHJcbmV4cG9ydHMuQzJTID0gcmVxdWlyZShcImNhbnZhczJzdmdcIik7XHJcbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKTtcclxuXHJcblxyXG5leHBvcnRzLmludGVyZmFjZSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZS9tb2QuanNcIik7XHJcbmV4cG9ydHMuc3BlY3RyYWxzZXF1ZW5jZXMgPSByZXF1aXJlKFwiLi9zc2VxL21vZC5qc1wiKTtcclxuZXhwb3J0cy5TcGVjdHJhbFNlcXVlbmNlU29ja2V0TGlzdGVuZXIgPSByZXF1aXJlKFwiLi9zcGVjdHJhbHNlcXVlbmNlX3NvY2tldF9saXN0ZW5lci5qc1wiKS5TcGVjdHJhbFNlcXVlbmNlU29ja2V0TGlzdGVuZXI7XHJcblxyXG5cclxuZXhwb3J0cy5kMyA9IHJlcXVpcmUoXCJkMy1zZWxlY3Rpb25cIik7XHJcbmV4cG9ydHMuTW91c2V0cmFwID0gcmVxdWlyZShcIm1vdXNldHJhcFwiKTtcclxuIiwibGV0IHdlYmNsaWVudCA9IHJlcXVpcmUoXCIuL2xpYi5qc1wiKVxyXG5cclxud2luZG93LmluZmluaXR5ID0gd2ViY2xpZW50LmluZmluaXR5O1xyXG53aW5kb3cubW9kID0gZnVuY3Rpb24obixkKXtcclxuICAgIHJldHVybiAobiAlIGQgKyBkKSVkO1xyXG59O1xyXG5cclxuLy8gd2luZG93LlV0aWwgPSByZXF1aXJlKFwiLi9zc2VxL1V0aWwuanNcIik7XHJcblxyXG53aW5kb3cuQzJTID0gcmVxdWlyZShcImNhbnZhczJzdmdcIik7XHJcbndpbmRvdy5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xyXG5cclxuXHJcbndpbmRvdy5JbnRlcmZhY2UgPSB3ZWJjbGllbnQuaW50ZXJmYWNlO1xyXG53aW5kb3cuSU8gPSB3ZWJjbGllbnQuaW50ZXJmYWNlLklPO1xyXG53aW5kb3cuQmFzaWNEaXNwbGF5ID0gd2ViY2xpZW50LmludGVyZmFjZS5CYXNpY0Rpc3BsYXk7XHJcblxyXG53aW5kb3cuc3BlY3RyYWxzZXF1ZW5jZXMgPSB3ZWJjbGllbnQuc3BlY3RyYWxzZXF1ZW5jZXM7XHJcbndpbmRvdy5TcGVjdHJhbFNlcXVlbmNlQ2hhcnQgPSB3ZWJjbGllbnQuc3BlY3RyYWxzZXF1ZW5jZXMuU3BlY3RyYWxTZXF1ZW5jZUNoYXJ0O1xyXG53aW5kb3cuQ2hhcnRTaGFwZSA9IHdlYmNsaWVudC5zcGVjdHJhbHNlcXVlbmNlcy5DaGFydFNoYXBlO1xyXG53aW5kb3cuQ2hhcnROb2RlID0gd2ViY2xpZW50LnNwZWN0cmFsc2VxdWVuY2VzLkNoYXJ0Tm9kZTtcclxud2luZG93LkNoYXJ0Q2xhc3MgPSB3ZWJjbGllbnQuc3BlY3RyYWxzZXF1ZW5jZXMuQ2hhcnRDbGFzcztcclxud2luZG93LkNoYXJ0RWRnZSA9IHdlYmNsaWVudC5zcGVjdHJhbHNlcXVlbmNlcy5DaGFydEVkZ2U7XHJcbndpbmRvdy5DaGFydFN0cnVjdGxpbmUgPSB3ZWJjbGllbnQuc3BlY3RyYWxzZXF1ZW5jZXMuQ2hhcnRTdHJ1Y3RsaW5lO1xyXG53aW5kb3cuQ2hhcnREaWZmZXJlbnRpYWwgPSB3ZWJjbGllbnQuc3BlY3RyYWxzZXF1ZW5jZXMuQ2hhcnREaWZmZXJlbnRpYWw7XHJcbndpbmRvdy5DaGFydEV4dGVuc2lvbiA9IHdlYmNsaWVudC5zcGVjdHJhbHNlcXVlbmNlcy5DaGFydEV4dGVuc2lvbjtcclxuXHJcbndpbmRvdy5TcGVjdHJhbFNlcXVlbmNlU29ja2V0TGlzdGVuZXIgPSB3ZWJjbGllbnQuU3BlY3RyYWxTZXF1ZW5jZVNvY2tldExpc3RlbmVyO1xyXG5cclxuXHJcbndpbmRvdy5kMyA9IHdlYmNsaWVudC5kMztcclxud2luZG93Lk1vdXNldHJhcCA9IHdlYmNsaWVudC5Nb3VzZXRyYXA7XHJcbiIsImNsYXNzIEJhZE1lc3NhZ2VFcnJvciBleHRlbmRzIFR5cGVFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJncylcclxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMuc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSkuam9pbihcIlxcblwiKVxyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBVbmtub3duQ29tbWFuZEVycm9yIGV4dGVuZHMgQmFkTWVzc2FnZUVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcclxuICAgICAgICBzdXBlciguLi5hcmdzKVxyXG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgxKS5qb2luKFwiXFxuXCIpXHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIEludmFsaWRDb21tYW5kRXJyb3IgZXh0ZW5kcyBCYWRNZXNzYWdlRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpXHJcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEpLmpvaW4oXCJcXG5cIilcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmNsYXNzIFVua25vd25EaXNwbGF5Q29tbWFuZEVycm9yIGV4dGVuZHMgVW5rbm93bkNvbW1hbmRFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJncylcclxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMuc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSkuam9pbihcIlxcblwiKVxyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBTcGVjdHJhbFNlcXVlbmNlU29ja2V0TGlzdGVuZXIge1xyXG4gICAgY29uc3RydWN0b3Iod2Vic29ja2V0LCBtYWtlX2Rpc3BsYXkpIHtcclxuICAgICAgICB0aGlzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcclxuICAgICAgICB0aGlzLndlYnNvY2tldC5vbm1lc3NhZ2UgPSB0aGlzLm9ubWVzc2FnZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMud2Vic29ja2V0Lm9ub3BlbiA9IHRoaXMub25vcGVuLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5tYWtlX2Rpc3BsYXkgPSBtYWtlX2Rpc3BsYXk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3NlcSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VfZGlzcGF0Y2ggPSB7fTtcclxuICAgICAgICB0aGlzLmFkZF9tZXNzYWdlX2hhbmRsZXJzX2Zyb21fb2JqZWN0KGRlZmF1bHRfbWVzc2FnZV9oYW5kbGVycyk7XHJcbiAgICAgICAgdGhpcy5kZWJ1Z19tb2RlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkX21lc3NhZ2VfaGFuZGxlcnNfZnJvbV9vYmplY3QoaGFuZGxlcnMpIHtcclxuICAgICAgICBmb3IobGV0IFtjbWRfZmlsdGVyLCBoYW5kbGVyXSBvZiBPYmplY3QuZW50cmllcyhoYW5kbGVycykpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRfbWVzc2FnZV9oYW5kbGVyKGNtZF9maWx0ZXIsIGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRfbWVzc2FnZV9oYW5kbGVyKGNtZF9maWx0ZXIsIGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VfZGlzcGF0Y2hbY21kX2ZpbHRlcl0gPSBoYW5kbGVyLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJjbGllbnQgcmVhZHlcIik7XHJcbiAgICAgICAgdGhpcy5jbGllbnRfcmVhZHkgPSB0cnVlO1xyXG4gICAgICAgIGlmKHRoaXMuc29ja2V0X3JlYWR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZF9pbnRyb2R1Y3Rpb25fbWVzc2FnZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbm9wZW4oZXZlbnQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInNvY2tldCBvcGVuZWRcIik7XHJcbiAgICAgICAgdGhpcy5zb2NrZXRfcmVhZHkgPSB0cnVlO1xyXG4gICAgICAgIGlmKHRoaXMuY2xpZW50X3JlYWR5KXtcclxuICAgICAgICAgICAgdGhpcy5zZW5kX2ludHJvZHVjdGlvbl9tZXNzYWdlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbmRfaW50cm9kdWN0aW9uX21lc3NhZ2UoKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInNlbmRfaW50cm9kdWN0aW9uX21lc3NhZ2VcIik7XHJcbiAgICAgICAgdGhpcy5zZW5kKFwibmV3X3VzZXJcIiwge30pO1xyXG4gICAgfVxyXG5cclxuICAgIG9ubWVzc2FnZShldmVudCkge1xyXG4gICAgICAgIGxldCBtc2cgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlX21lc3NhZ2VfZGlzcGF0Y2gobXNnKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZGlzcGxheV9jbGlja19oYW5kbGVyKGNscywgeCwgeSkgeyBcclxuICAgICAgICB0aGlzLnNlbmQoXCJjbGlja1wiLCB7IFwiY2hhcnRfY2xhc3NcIiA6IGNscywgXCJ4XCIgOiB4LCBcInlcIiA6IHkgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuXHJcbiAgICBzZW5kKGNtZCwga3dhcmdzKSB7IC8vIGFyZ3MgcGFyYW1ldGVyP1xyXG4gICAgICAgIGxldCBhcmdzID0gW11cclxuICAgICAgICBjb25zb2xlLmxvZyhcInNlbmQgbWVzc2FnZVwiLCBjbWQsIGt3YXJncyk7XHJcbiAgICAgICAgLy8gaWYoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGt3YXJncyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gICAgIHRocm93IFR5cGVFcnJvcihgU2VuZCB3aXRoIG1pc3NpbmcgYXJndW1lbnRzLmApO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBpZihhcmdzLmNvbnN0cnVjdG9yICE9PSBBcnJheSl7XHJcbiAgICAgICAgLy8gICAgIHRocm93IFR5cGVFcnJvcihgQXJndW1lbnQgXCJhcmdzXCIgZXhwZWN0ZWQgdG8gaGF2ZSB0eXBlIFwiQXJyYXlcIiBub3QgXCIke2FyZ3MuY29uc3RydWN0b3IubmFtZX1cImApO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBpZihrd2FyZ3MuY29uc3RydWN0b3IgIT09IE9iamVjdCl7XHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihgQXJndW1lbnQgXCJrd2FyZ3NcIiBleHBlY3RlZCB0byBoYXZlIHR5cGUgXCJBcnJheVwiIG5vdCBcIiR7a3dhcmdzLmNvbnN0cnVjdG9yLm5hbWV9XCJgKTtcclxuICAgICAgICB9ICAgICAgICAgICAgXHJcbiAgICAgICAgaWYoXCJjbWRcIiBpbiBrd2FyZ3MpIHtcclxuICAgICAgICAgICAgdGhyb3cgVmFsdWVFcnJvcihgVHJpZWQgdG8gc2VuZCBtZXNzYWdlIHdpdGggdG9wIGxldmVsIFwiY21kXCIga2V5YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBvYmogPSB7IFwiY21kXCIgOiBjbWQsIFwiYXJnc1wiIDogYXJncywgXCJrd2FyZ3NcIiA6IGt3YXJncyB9O1xyXG4gICAgICAgIGxldCBqc29uX3N0ciA9IEpTT04uc3RyaW5naWZ5KG9iaik7XHJcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuc2VuZChqc29uX3N0cik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZV9sb2dfaWZfZGVidWcobXNnKSB7XHJcbiAgICAgICAgaWYodGhpcy5kZWJ1Z19tb2RlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBkZWJ1Zyh0eXBlLCB0ZXh0LCBvcmlnX21zZykge1xyXG4gICAgICAgIGxldCBjbWQgPSBcImRlYnVnXCI7XHJcbiAgICAgICAgaWYodHlwZSAhPT0gXCJcIil7XHJcbiAgICAgICAgICAgIGNtZCArPSBgLiR7dHlwZX1gXHJcbiAgICAgICAgfSAgICAgICAgICAgIFxyXG4gICAgICAgIHRoaXMuc2VuZChcImRlYnVnXCIsIHtcclxuICAgICAgICAgICAgXCJ0eXBlXCIgOiB0eXBlLFxyXG4gICAgICAgICAgICBcInRleHRcIiA6IHRleHQsIFxyXG4gICAgICAgICAgICBcIm9yaWdfbXNnXCIgOiBvcmlnX21zZ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGluZm8odHlwZSwgdGV4dCwgb3JpZ19tc2cpIHtcclxuICAgICAgICBsZXQgY21kID0gXCJpbmZvXCI7XHJcbiAgICAgICAgaWYodHlwZSAhPT0gXCJcIil7XHJcbiAgICAgICAgICAgIGNtZCArPSBgLiR7dHlwZX1gXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VuZChjbWQsIHtcclxuICAgICAgICAgICAgXCJ0eXBlXCIgOiB0eXBlLFxyXG4gICAgICAgICAgICBcInRleHRcIiA6IHRleHQsIFxyXG4gICAgICAgICAgICBcIm9yaWdfbXNnXCIgOiBvcmlnX21zZ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHdhcm5pbmcodHlwZSwgdGV4dCwgb3JpZ19tc2csIHN0YWNrX3RyYWNlKSB7XHJcbiAgICAgICAgbGV0IGNtZCA9IFwid2FybmluZ1wiO1xyXG4gICAgICAgIGlmKHR5cGUgIT09IFwiXCIpe1xyXG4gICAgICAgICAgICBjbWQgKz0gYC4ke3R5cGV9YFxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbmQoY21kLCB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiIDogdHlwZSxcclxuICAgICAgICAgICAgXCJ0ZXh0XCIgOiB0ZXh0LCBcclxuICAgICAgICAgICAgXCJvcmlnX21zZ1wiIDogb3JpZ19tc2csXHJcbiAgICAgICAgICAgIFwic3RhY2tfdHJhY2VcIiA6IHN0YWNrX3RyYWNlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZXJyb3IodHlwZSwgbXNnKSB7XHJcbiAgICAgICAgbGV0IGNtZCA9IFwiZXJyb3IuY2xpZW50XCI7XHJcbiAgICAgICAgaWYodHlwZSAhPT0gXCJcIil7XHJcbiAgICAgICAgICAgIGNtZCArPSBgLiR7dHlwZX1gXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VuZChjbWQsIG1zZyk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9nX2V4Y2VwdGlvbihlcnJvciwgb3JpZ19tc2cpIHtcclxuICAgICAgICAvLyBGb3Igc29tZSByZWFzb24gSlNPTi5zdHJpbmdpZnkoZXJyb3IpIGRyb3BzIHRoZSBcIm1lc3NhZ2VcIiBmaWVsZCBieSBkZWZhdWx0LlxyXG4gICAgICAgIC8vIFdlIG1vdmUgaXQgdG8gXCJtc2dcIiB0byBhdm9pZCB0aGF0LlxyXG4gICAgICAgIGVycm9yLm1zZyA9IGVycm9yLm1lc3NhZ2U7IFxyXG4gICAgICAgIHRoaXMuZXJyb3IoZXJyb3IubmFtZSwgXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiZXhjZXB0aW9uXCIgOiBlcnJvcixcclxuICAgICAgICAgICAgICAgIFwib3JpZ19tc2dcIiA6IG9yaWdfbXNnLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc2V0X2Rpc3BsYXlfc3RhdGUoa3dhcmdzKSB7XHJcbiAgICAgICAgaWYoXCJiYWNrZ3JvdW5kX2NvbG9yXCIgaW4ga3dhcmdzKXtcclxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5LnNldEJhY2tncm91bmRDb2xvcihrd2FyZ3MuYmFja2dyb3VuZF9jb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZV9tZXNzYWdlX2Rpc3BhdGNoKG1zZykge1xyXG4gICAgICAgIHRoaXMuY29uc29sZV9sb2dfaWZfZGVidWcobXNnKTtcclxuICAgICAgICBsZXQgc3VjY2VlZGVkID0gdHJ1ZTtcclxuICAgICAgICBsZXQgZXJyb3I7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYobXNnLmNtZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5rbm93bkNvbW1hbmRFcnJvcihgQ29uc29sZSBzZW50IG1lc3NhZ2UgbWlzc2luZyBcImNtZFwiIGZpZWxkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgaWYobXNnLmNtZC5jb25zdHJ1Y3RvciAhPSBBcnJheSl7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvbW1hbmRFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICBgXCJtc2cuY21kXCIgc2hvdWxkIGhhdmUgdHlwZSBcIkFycmF5XCIgbm90IFwiJHttc2cuY21kLmNvbnN0cnVjdG9yLm5hbWV9LlwiYFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIGlmKG1zZy5hcmdzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ29tbWFuZEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgIGBNZXNzYWdlIGlzIG1pc3NpbmcgdGhlIFwiYXJnc1wiIGZpZWxkLmBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKG1zZy5rd2FyZ3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDb21tYW5kRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgYE1lc3NhZ2UgaXMgbWlzc2luZyB0aGUgXCJrd2FyZ3NcIiBmaWVsZC5gXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgbGV0IGtleSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgZm9yKGxldCBwYXJ0aWFsX2NtZCBvZiBtc2cuY21kKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLm1lc3NhZ2VfZGlzcGF0Y2hbcGFydGlhbF9jbWRdICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnRpYWxfY21kOyBcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbnNvbGVfbG9nX2lmX2RlYnVnKFwiY21kXCIsIG1zZy5jbWQsIFwia2V5XCIsIGtleSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc29sZV9sb2dfaWZfZGVidWcoXCJyZWNlaXZlZCBtZXNzYWdlXCIsXCJjbWRcIiwgbXNnLmNtZCwgXCJrZXlcIiwga2V5KTtcclxuICAgICAgICAgICAgaWYoa2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmtub3duQ29tbWFuZEVycm9yKGBDb25zb2xlIHNlbnQgdW5rbm93biBjb21tYW5kIFwiJHttc2cuY21kWzBdfVwiLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZV9kaXNwYXRjaFtrZXldKG1zZy5jbWQsIG1zZy5hcmdzLCBtc2cua3dhcmdzKTtcclxuICAgICAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICAgICAgICBzdWNjZWVkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgaWYoIXN1Y2NlZWRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnNvbGVfbG9nX2lmX2RlYnVnKGVycm9yKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dfZXhjZXB0aW9uKGVycm9yLCBtc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH0gICAgXHJcbn1cclxuXHJcblxyXG5sZXQgZGVmYXVsdF9tZXNzYWdlX2hhbmRsZXJzID0ge1xyXG4gICAgXCJpbml0aWFsaXplLmNoYXJ0LnN0YXRlXCIgOiBmdW5jdGlvbihjbWQsIGFyZ3MsIGt3YXJncykge1xyXG4gICAgICAgIHRoaXMuY29uc29sZV9sb2dfaWZfZGVidWcoXCJhY2NlcHRlZCB1c2VyOlwiLCBrd2FyZ3Muc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuc3NlcSA9IFNwZWN0cmFsU2VxdWVuY2VDaGFydC5mcm9tX0pTT04oa3dhcmdzLnN0YXRlKTtcclxuICAgICAgICB0aGlzLmRpc3BsYXkgPSB0aGlzLm1ha2VfZGlzcGxheSh0aGlzLnNzZXEpO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheS55X2NsaXBfb2Zmc2V0ID0gdGhpcy5zc2VxLnlfY2xpcF9vZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5zZXRfZGlzcGxheV9zdGF0ZShrd2FyZ3MuZGlzcGxheV9zdGF0ZSlcclxuICAgICAgICB0aGlzLmRpc3BsYXkub24oXCJjbGlja1wiLCB0aGlzLmRpc3BsYXlfY2xpY2tfaGFuZGxlci5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnNlbmQoXCJpbml0aWFsaXplLmNvbXBsZXRlXCIsIHt9KTtcclxuICAgICAgICAvLyBpZihrd2FyZ3MuZGlzcGxheV9zdGF0ZSkge1xyXG4gICAgICAgIC8vICAgICBzZXRfZGlzcGxheV9zZXR0aW5ncyhrd2FyZ3MuZGlzcGxheV9zdGF0ZSk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIGxldCBzc2VxID0gbmV3IFNwZWN0cmFsU2VxdWVuY2VDaGFydCgpO1xyXG4gICAgICAgIC8vIE9iamVjdC5hc3NpZ24oc3NlcSwgbXNnLnN0YXRlKVxyXG4gICAgfSxcclxuXHJcbiAgICBcImNoYXJ0LmJhdGNoZWRcIiA6IGZ1bmN0aW9uKGNtZCwgYXJncywga3dhcmdzKSB7XHJcbiAgICAgICAgZm9yKG1zZyBvZiBrd2FyZ3MubWVzc2FnZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVfbWVzc2FnZV9kaXNwYXRjaChtc2cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRpc3BsYXkudXBkYXRlKClcclxuICAgIH0sXHJcbiAgICBcclxuICAgIFwiY2hhcnQuc3RhdGUucmVzZXRcIiA6IGZ1bmN0aW9uKGNtZCwgYXJncywga3dhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5jb25zb2xlX2xvZ19pZl9kZWJ1ZyhcImFjY2VwdGVkIHVzZXI6XCIsIGt3YXJncy5zdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5zc2VxID0gU3BlY3RyYWxTZXF1ZW5jZUNoYXJ0LmZyb21fSlNPTihrd2FyZ3Muc3RhdGUpO1xyXG4gICAgICAgIGlmKGt3YXJncy5kaXNwbGF5X3N0YXRlICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLnNldF9kaXNwbGF5X3N0YXRlKGt3YXJncy5kaXNwbGF5X3N0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5LnlfY2xpcF9vZmZzZXQgPSB0aGlzLnNzZXEueV9jbGlwX29mZnNldDtcclxuICAgICAgICB0aGlzLmRpc3BsYXkuc2V0U3NlcSh0aGlzLnNzZXEpO1xyXG4gICAgICAgIC8vIHRoaXMuZGlzcGxheS5vbihcImNsaWNrXCIsIHRoaXMuZGlzcGxheV9jbGlja19oYW5kbGVyLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIHRoaXMuc2VuZChcImluaXRpYWxpemUuY29tcGxldGVcIiwge30pO1xyXG4gICAgICAgIC8vIGlmKGt3YXJncy5kaXNwbGF5X3N0YXRlKSB7XHJcbiAgICAgICAgLy8gICAgIHNldF9kaXNwbGF5X3NldHRpbmdzKGt3YXJncy5kaXNwbGF5X3N0YXRlKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gbGV0IHNzZXEgPSBuZXcgU3BlY3RyYWxTZXF1ZW5jZUNoYXJ0KCk7XHJcbiAgICAgICAgLy8gT2JqZWN0LmFzc2lnbihzc2VxLCBtc2cuc3RhdGUpXHJcbiAgICB9LFxyXG5cclxuICAgIFwiY2hhcnQuc2V0X3hfcmFuZ2VcIiA6IGZ1bmN0aW9uKGNtZCwgYXJncywga3dhcmdzKXtcclxuICAgICAgICB0aGlzLnNzZXEueF9yYW5nZSA9IFtrd2FyZ3MueF9taW4sIGt3YXJncy54X21heF07XHJcbiAgICB9LFxyXG4gICAgXCJjaGFydC5zZXRfeV9yYW5nZVwiIDogZnVuY3Rpb24oY21kLCBhcmdzLCBrd2FyZ3Mpe1xyXG4gICAgICAgIHRoaXMuc3NlcS55X3JhbmdlID0gW2t3YXJncy55X21pbiwga3dhcmdzLnlfbWF4XTtcclxuICAgIH0sXHJcbiAgICBcImNoYXJ0LnNldF9pbml0aWFsX3hfcmFuZ2VcIiA6IGZ1bmN0aW9uKGNtZCwgYXJncywga3dhcmdzKXtcclxuICAgICAgICB0aGlzLnNzZXEuaW5pdGlhbF94X3JhbmdlID0gW2t3YXJncy54X21pbiwga3dhcmdzLnhfbWF4XTtcclxuICAgIH0sXHJcbiAgICBcImNoYXJ0LnNldF9pbml0aWFsX3lfcmFuZ2VcIiA6IGZ1bmN0aW9uKGNtZCwgYXJncywga3dhcmdzKXtcclxuICAgICAgICB0aGlzLnNzZXEuaW5pdGlhbF95X3JhbmdlID0gW2t3YXJncy55X21pbiwga3dhcmdzLnlfbWF4XTtcclxuICAgIH0sICAgIFxyXG4gICAgXCJjaGFydC5pbnNlcnRfcGFnZV9yYW5nZVwiIDogZnVuY3Rpb24oY21kLCBhcmdzLCBrd2FyZ3MpIHtcclxuICAgICAgICB0aGlzLnNzZXEucGFnZV9saXN0LnNwbGljZShrd2FyZ3MuaWR4LCAwLCBrd2FyZ3MucGFnZV9yYW5nZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIFwiY2hhcnQubm9kZS5hZGRcIiA6IGZ1bmN0aW9uKGNtZCwgYXJncywga3dhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5jb25zb2xlX2xvZ19pZl9kZWJ1ZyhcImFkZCBub2RlXCIsIGNtZCwga3dhcmdzKVxyXG4gICAgICAgIC8vIHRoaXMuaW5mbyhtc2cpO1xyXG4gICAgfSxcclxuXHJcbiAgICBcImNoYXJ0LmNsYXNzLmFkZFwiIDogZnVuY3Rpb24oY21kLCBhcmdzLCBrd2FyZ3MpIHtcclxuICAgICAgICBsZXQgYyA9IHRoaXMuc3NlcS5hZGRfY2xhc3Moa3dhcmdzLm5ld19jbGFzcyk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5LnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBcImNoYXJ0LmNsYXNzLnVwZGF0ZVwiIDogZnVuY3Rpb24oY21kLCBhcmdzLCBrd2FyZ3MpIHtcclxuICAgICAgICBsZXQgYyA9IGt3YXJncy5jbGFzc190b191cGRhdGU7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnNzZXEuY2xhc3Nlc1tjLnV1aWRdLCBjKTtcclxuICAgICAgICAvLyB0aGlzLmRpc3BsYXkudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIFwiY2hhcnQuY2xhc3Muc2V0X25hbWVcIiA6IGZ1bmN0aW9uKGNtZCwgYXJncywga3dhcmdzKSB7XHJcbiAgICAgICAgbGV0IFt4LHksaWR4XSA9IGxvYWRfYXJncyh7XHJcbiAgICAgICAgICAgIFwieFwiIDogTnVtYmVyLmlzSW50ZWdlciwgXHJcbiAgICAgICAgICAgIFwieVwiIDogTnVtYmVyLmlzSW50ZWdlciwgXHJcbiAgICAgICAgICAgIFwiaWR4XCIgOiBOdW1iZXIuaXNJbnRlZ2VyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zc2VxLmNsYXNzZXNfYnlfZGVncmVlLmdldChba3dhcmdzLngsIG1zZy5hcmd1bWVudHMueV0pW21zZy5hcmd1bWVudHMuaWR4XS5uYW1lID0gbXNnLmFyZ3VtZW50cy5uYW1lO1xyXG4gICAgfSxcclxuXHJcbiAgICBcImNoYXJ0LmVkZ2UuYWRkXCIgOiBmdW5jdGlvbihjbWQsIGFyZ3MsIGt3YXJncykge1xyXG4gICAgICAgIHRoaXMuY29uc29sZV9sb2dfaWZfZGVidWcoa3dhcmdzKTtcclxuICAgICAgICB0aGlzLnNzZXEuYWRkX2VkZ2Uoa3dhcmdzKTtcclxuICAgICAgICAvLyB0aGlzLmRpc3BsYXkudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIFwiY2hhcnQuZWRnZS51cGRhdGVcIiA6IGZ1bmN0aW9uKGNtZCwgYXJncywga3dhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5jb25zb2xlX2xvZ19pZl9kZWJ1Zyhrd2FyZ3MpO1xyXG4gICAgICAgIGxldCBlID0ga3dhcmdzLmVkZ2VfdG9fdXBkYXRlO1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5zc2VxLmVkZ2VzW2UudXVpZF0sIGUpO1xyXG4gICAgICAgIC8vIHRoaXMuZGlzcGxheS51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgXCJkaXNwbGF5LnNldF9iYWNrZ3JvdW5kX2NvbG9yXCIgOiBmdW5jdGlvbihjbWQsIGFyZ3MsIGt3YXJncykge1xyXG4gICAgICAgIHRoaXMuZGlzcGxheS5zZXRCYWNrZ3JvdW5kQ29sb3Ioa3dhcmdzLmNvbG9yKTtcclxuICAgIH0sXHJcblxyXG4gICAgXCJpbnRlcmFjdC5hbGVydFwiIDogZnVuY3Rpb24oY21kLCBhcmdzLCBrd2FyZ3MpIHtcclxuICAgICAgICBhbGVydChrd2FyZ3MubXNnKTtcclxuICAgIH0sXHJcbiAgICBcImludGVyYWN0LnByb21wdFwiIDogZnVuY3Rpb24oY21kLCBhcmdzLCBrd2FyZ3MpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gcHJvbXB0KGt3YXJncy5tc2csIGt3YXJncy5kZWZhdWx0KTtcclxuICAgICAgICB0aGlzLnNlbmQoXCJpbnRlcmFjdC5yZXN1bHRcIiwge1wicmVzdWx0XCIgOiByZXN1bHR9KTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydHMuU3BlY3RyYWxTZXF1ZW5jZVNvY2tldExpc3RlbmVyID0gU3BlY3RyYWxTZXF1ZW5jZVNvY2tldExpc3RlbmVyOyIsImxldCB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xyXG5sZXQgQ2hhcnRTaGFwZSA9IHJlcXVpcmUoXCIuL0NoYXJ0U2hhcGUuanNcIikuQ2hhcnRTaGFwZTtcclxuXHJcbmNsYXNzIENoYXJ0Q2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3Ioc3NlcSwga3dhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fc3NlcSA9IHNzZXE7XHJcbiAgICAgICAgdGhpcy5fdmFsaWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3hfb2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl95X29mZnNldCA9IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gdXRpbHMuYXNzaWduX2ZpZWxkcyh0aGlzLCBrd2FyZ3MsIFtcclxuICAgICAgICAvLyAgICAgeyBcInR5cGVcIiA6IFwibWFuZGF0b3J5XCIsIFwiZmllbGRcIiA6IFwieFwiIH0sXHJcbiAgICAgICAgLy8gICAgIHsgXCJ0eXBlXCIgOiBcIm1hbmRhdG9yeVwiLCBcImZpZWxkXCIgOiBcInlcIiB9LFxyXG4gICAgICAgIC8vICAgICB7IFwidHlwZVwiIDogXCJvcHRpb25hbFwiLCBcImZpZWxkXCIgOiBcImlkeFwiIH0sXHJcbiAgICAgICAgLy8gICAgIHsgXCJ0eXBlXCIgOiBcImRlZmF1bHRcIiwgICBcImZpZWxkXCIgOiBcIm5hbWVcIiwgICAgICAgICAgICAgXCJkZWZhdWx0XCIgOiBcIlwiIH0sXHJcbiAgICAgICAgLy8gICAgIHsgXCJ0eXBlXCIgOiBcImRlZmF1bHRcIiwgICBcImZpZWxkXCIgOiBcInRyYW5zaXRpb25fcGFnZXNcIiwgXCJkZWZhdWx0XCIgOiBbXSB9LFxyXG4gICAgICAgIC8vICAgICB7IFwidHlwZVwiIDogXCJtYW5kYXRvcnlcIiwgXCJmaWVsZFwiIDogXCJub2RlX2xpc3RcIiB9LFxyXG4gICAgICAgIC8vICAgICB7IFwidHlwZVwiIDogXCJkZWZhdWx0XCIsICAgXCJmaWVsZFwiIDogXCJ0cmFuc2l0aW9uX3BhZ2VzXCIsIFwiZGVmYXVsdFwiIDogW10gfSxcclxuICAgICAgICAvLyAgICAgeyBcInR5cGVcIiA6IFwiZGVmYXVsdFwiLCAgIFwiZmllbGRcIiA6IFwidmlzaWJsZVwiLCAgICAgICAgICBcImRlZmF1bHRcIiA6IHRydWUgfSxcclxuICAgICAgICAvLyAgICAgeyBcInR5cGVcIiA6IFwib3B0aW9uYWxcIiwgIFwiZmllbGRcIiA6IFwieG9mZnNldFwiIH0sXHJcbiAgICAgICAgLy8gICAgIHsgXCJ0eXBlXCIgOiBcIm9wdGlvbmFsXCIsICBcImZpZWxkXCIgOiBcInlvZmZzZXRcIiB9LFxyXG4gICAgICAgIC8vICAgICB7IFwidHlwZVwiIDogXCJvcHRpb25hbFwiLCAgXCJmaWVsZFwiIDogXCJ0b29sdGlwXCIgfSxcclxuICAgICAgICAvLyAgICAgeyBcInR5cGVcIiA6IFwib3B0aW9uYWxcIiwgIFwiZmllbGRcIiA6IFwidXVpZFwiIH0sXHJcbiAgICAgICAgLy8gXSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVE9ETzogbmV3IHV0aWxzIGZ1bmN0aW9uIHRoYXQgZW5zdXJlcyBubyBcIl9cIiBmaWVsZHMgcHJlc2VudCwgcmFpc2VzIGVycm9yIFwiYmFkIHNlcmlhbGl6ZWQgY2xhc3NcIi5cclxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGt3YXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UG9zaXRpb24oeCwgeSwgc2l6ZSkge1xyXG4gICAgICAgIGlmKGlzTmFOKHgpIHx8IGlzTmFOKHkpIHx8IGlzTmFOKHNpemUpKXtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLCB4LCB5LCBzaXplKTtcclxuICAgICAgICAgICAgdGhyb3cgXCJjbGFzcy5zZXRQb3NpdGlvbiBjYWxsZWQgd2l0aCBiYWQgYXJndW1lbnQuXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NhbnZhc194ID0geDtcclxuICAgICAgICB0aGlzLl9jYW52YXNfeSA9IHk7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgZHJhdyhjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9ub2RlO1xyXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG5cclxuICAgICAgICBpZihub2RlLm9wYWNpdHkpIHtcclxuICAgICAgICAgICAgY29udGV4dC5vcGFjaXR5ID0gbm9kZS5vcGFjaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYobm9kZS5jb2xvcikge1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG5vZGUuY29sb3I7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBub2RlLmNvbG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYobm9kZS5zdHJva2UgJiYgbm9kZS5zdHJva2UgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IG5vZGUuc3Ryb2tlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYobm9kZS5maWxsICYmIG5vZGUuZmlsbCAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG5vZGUuZmlsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKG5vZGUuaGlnaGxpZ2h0KSB7XHJcbiAgICAgICAgICAgIGlmKG5vZGUuaGNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG5vZGUuaGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IG5vZGUuaGNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihub2RlLmhzdHJva2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBub2RlLmhzdHJva2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKG5vZGUuaGZpbGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gbm9kZS5oZmlsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IE1hdGgubWluKDMsIG5vZGUuc2l6ZSAqIG5vZGUuc2NhbGUgLyAyMCk7IC8vIE1hZ2ljIG51bWJlclxyXG4gICAgICAgIHRoaXMuX3BhdGggPSBDaGFydFNoYXBlLmRyYXcobm9kZS5zaGFwZSwgY29udGV4dCwgdGhpcy5fY2FudmFzX3gsIHRoaXMuX2NhbnZhc195LCB0aGlzLl9zaXplICogbm9kZS5zY2FsZSwgbm9kZSk7XHJcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2RyYXdPblBhZ2VRKHBhZ2Upe1xyXG4gICAgICAgIGxldCBpZHggPSB0aGlzLl9nZXRQYWdlSW5kZXgocGFnZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV9saXN0W2lkeF0gIT0gbnVsbCAmJiB0aGlzLnZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgX2luUmFuZ2VRKHhtaW4sIHhtYXgsIHltaW4sIHltYXgpe1xyXG4gICAgICAgIHJldHVybiB4bWluIDw9IHRoaXMueCAmJiB0aGlzLnggPD0geG1heCAmJiB5bWluIDw9IHRoaXMueSAmJiB0aGlzLnkgPD0geW1heDtcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0UGFnZUluZGV4KHBhZ2Upe1xyXG4gICAgICAgIGlmKCBwYWdlID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVfbGlzdC5sZW5ndGggLSAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiggcGFnZSA9PT0gdGhpcy5fbGFzdF9wYWdlICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFzdF9wYWdlX2lkeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHBhZ2VfaWR4ID0gdGhpcy50cmFuc2l0aW9uX3BhZ2VzLmxlbmd0aDtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy50cmFuc2l0aW9uX3BhZ2VzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgaWYodGhpcy50cmFuc2l0aW9uX3BhZ2VzW2ldID49IHBhZ2Upe1xyXG4gICAgICAgICAgICAgICAgcGFnZV9pZHggPSBpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGFzdF9wYWdlID0gcGFnZTtcclxuICAgICAgICB0aGlzLl9sYXN0X3BhZ2VfaWR4ID0gcGFnZV9pZHg7XHJcbiAgICAgICAgcmV0dXJuIHBhZ2VfaWR4O1xyXG4gICAgfVxyXG5cclxuICAgIGdldE5hbWVDb29yZCgpe1xyXG4gICAgICAgIGxldCB0b29sdGlwID0gXCJcIjtcclxuICAgICAgICBpZiAodGhpcy5uYW1lICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXAgPSBgXFxcXChcXFxcbGFyZ2UgJHt0aGlzLm5hbWV9XFxcXCkmbmJzcDsmbWRhc2g7Jm5ic3A7YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9vbHRpcCArPSBgKCR7dGhpcy54fSwgJHt0aGlzLnl9KWA7XHJcbiAgICAgICAgcmV0dXJuIHRvb2x0aXA7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0WE9mZnNldCgpIHtcclxuICAgICAgICBsZXQgeF9vZmZzZXQ7XHJcbiAgICAgICAgbGV0IGNsYXNzZXMgPSB0aGlzLl9zc2VxLmNsYXNzZXNfYnlfZGVncmVlLmdldChbdGhpcy54LCB0aGlzLnldKTtcclxuICAgICAgICBsZXQgbnVtX2NsYXNzZXMgPSBjbGFzc2VzLmxlbmd0aDtcclxuICAgICAgICBsZXQgaWR4ID0gdGhpcy5pZHg7XHJcbiAgICAgICAgbGV0IG91dCA9IChpZHggLSAobnVtX2NsYXNzZXMgLSAxKSAvIDIpICogdGhpcy5fc3NlcS5vZmZzZXRfc2l6ZTtcclxuICAgICAgICBpZiAoaXNOYU4ob3V0KSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBvZmZzZXQgZm9yIGNsYXNzOlwiLCB0aGlzKTtcclxuICAgICAgICAgICAgeF9vZmZzZXQgPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhfb2Zmc2V0ID0gb3V0OyBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB4X251ZGdlID0gdGhpcy54X251ZGdlID8gdGhpcy54X251ZGdlIDogMDtcclxuICAgICAgICByZXR1cm4geF9vZmZzZXQgKyB4X251ZGdlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFlPZmZzZXQoKSB7XHJcbiAgICAgICAgbGV0IHlfb2Zmc2V0ID0gMDtcclxuICAgICAgICBsZXQgeV9udWRnZSA9IHRoaXMueV9udWRnZSA/IHRoaXMueV9udWRnZSA6IDA7XHJcbiAgICAgICAgcmV0dXJuIHlfb2Zmc2V0ICsgeV9udWRnZTtcclxuICAgIH1cclxuXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLnB1YmxpY19maWVsZHModGhpcyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuQ2hhcnRDbGFzcyA9IENoYXJ0Q2xhc3M7IiwibGV0IHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XHJcbmxldCBJTkZJTklUWSA9IHJlcXVpcmUoXCIuLi9pbmZpbml0eS5qc1wiKS5JTkZJTklUWTtcclxuXHJcbmNsYXNzIENoYXJ0RWRnZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBrd2FyZ3MpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIGlmKCFcInNvdXJjZVwiIGluIGt3YXJncyl7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBFZGdlIGlzIG1pc3NpbmcgYXJndW1lbnQgXCJzb3VyY2VcIi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIVwidGFyZ2V0XCIgaW4ga3dhcmdzKXtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEVkZ2UgaXMgbWlzc2luZyBhcmd1bWVudCBcInRhcmdldFwiLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZighXCJ2aXNpYmxlXCIgaW4ga3dhcmdzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywga3dhcmdzKTtcclxuICAgICAgICAvLyB1dGlscy5hc3NpZ25fZmllbGRzKHRoaXMsIGt3YXJncywgW1xyXG4gICAgICAgIC8vICAgICB7IFwidHlwZVwiIDogXCJtYW5kYXRvcnlcIiwgXCJmaWVsZFwiIDogXCJzb3VyY2VcIn0sXHJcbiAgICAgICAgLy8gICAgIHsgXCJ0eXBlXCIgOiBcIm1hbmRhdG9yeVwiLCBcImZpZWxkXCIgOiBcInRhcmdldFwifSxcclxuICAgICAgICAvLyAgICAgeyBcInR5cGVcIiA6IFwiZGVmYXVsdFwiLCBcImZpZWxkXCIgOiBcInZpc2libGVcIiwgXCJkZWZhdWx0XCIgOiB0cnVlfSxcclxuICAgICAgICAvLyAgICAgeyBcInR5cGVcIiA6IFwib3B0aW9uYWxcIiwgXCJmaWVsZFwiIDogXCJjb2xvclwifSxcclxuICAgICAgICAvLyAgICAgeyBcInR5cGVcIiA6IFwib3B0aW9uYWxcIiwgXCJmaWVsZFwiIDogXCJvcGFjaXR5XCJ9LFxyXG4gICAgICAgIC8vICAgICB7IFwidHlwZVwiIDogXCJvcHRpb25hbFwiLCBcImZpZWxkXCIgOiBcImJlbmRcIn0sXHJcbiAgICAgICAgLy8gICAgIHsgXCJ0eXBlXCIgOiBcIm9wdGlvbmFsXCIsIFwiZmllbGRcIiA6IFwiY29udHJvbF9wb2ludHNcIn0sXHJcbiAgICAgICAgLy8gICAgIHsgXCJ0eXBlXCIgOiBcIm9wdGlvbmFsXCIsIFwiZmllbGRcIiA6IFwiYXJyb3dfdHlwZVwifSxcclxuICAgICAgICAvLyBdKVxyXG4gICAgfVxyXG5cclxuICAgIF9kcmF3T25QYWdlUShwYWdlUmFuZ2Upe1xyXG4gICAgICAgIGxldCBtYXhfcGFnZSA9IHRoaXMubWF4X3BhZ2UgfHwgSU5GSU5JVFk7XHJcbiAgICAgICAgbGV0IG1pbl9wYWdlID0gdGhpcy5taW5fcGFnZSB8fCAwO1xyXG4gICAgICAgIHJldHVybiBwYWdlUmFuZ2VbMF0gPD0gbWF4X3BhZ2UgJiYgbWluX3BhZ2UgPD0gcGFnZVJhbmdlWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdXRpbHMucHVibGljX2ZpZWxkcyh0aGlzKTtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgQ2hhcnREaWZmZXJlbnRpYWwgZXh0ZW5kcyBDaGFydEVkZ2Uge1xyXG4gICAgY29uc3RydWN0b3Ioa3dhcmdzKXtcclxuICAgICAgICBzdXBlcihcImRpZmZlcmVudGlhbFwiLCBrd2FyZ3MpO1xyXG4gICAgICAgIHV0aWxzLmFzc2lnbl9rd2FyZ19tYW5kYXRvcnkodGhpcywga3dhcmdzLCBcInBhZ2VcIik7XHJcbiAgICB9XHJcblxyXG4gICAgX2RyYXdPblBhZ2VRKHBhZ2VSYW5nZSl7XHJcbiAgICAgICAgcmV0dXJuIHBhZ2VSYW5nZVswXSA9PT0gMCB8fCAocGFnZVJhbmdlWzBdIDw9IHRoaXMucGFnZSAmJiB0aGlzLnBhZ2UgPD0gcGFnZVJhbmdlWzFdKTtcclxuICAgIH0gICAgXHJcbn1cclxuXHJcbmNsYXNzIENoYXJ0U3RydWN0bGluZSBleHRlbmRzIENoYXJ0RWRnZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihrd2FyZ3Mpe1xyXG4gICAgICAgIHN1cGVyKFwic3RydWN0bGluZVwiLCBrd2FyZ3MpO1xyXG4gICAgICAgIGlmKHRoaXMubWF4X3BhZ2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heF9wYWdlID0gSU5GSU5JVFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMubWluX3BhZ2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1pbl9wYWdlID0gMDtcclxuICAgICAgICB9ICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBfZHJhd09uUGFnZVEocGFnZVJhbmdlKXtcclxuICAgICAgICByZXR1cm4gcGFnZVJhbmdlWzBdIDw9IHRoaXMubWF4X3BhZ2UgJiYgdGhpcy5taW5fcGFnZSA8PSBwYWdlUmFuZ2VbMF07XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIENoYXJ0RXh0ZW5zaW9uIGV4dGVuZHMgQ2hhcnRFZGdlIHtcclxuICAgIGNvbnN0cnVjdG9yKGt3YXJncyl7XHJcbiAgICAgICAgc3VwZXIoXCJleHRlbnNpb25cIiwga3dhcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICBfZHJhd09uUGFnZVEocGFnZVJhbmdlKXtcclxuICAgICAgICByZXR1cm4gcGFnZVJhbmdlWzBdID09PSBJTkZJTklUWTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydHMuQ2hhcnRFZGdlID0gQ2hhcnRFZGdlO1xyXG5leHBvcnRzLkNoYXJ0RGlmZmVyZW50aWFsID0gQ2hhcnREaWZmZXJlbnRpYWw7XHJcbmV4cG9ydHMuQ2hhcnRTdHJ1Y3RsaW5lID0gQ2hhcnRTdHJ1Y3RsaW5lO1xyXG5leHBvcnRzLkNoYXJ0RXh0ZW5zaW9uID0gQ2hhcnRFeHRlbnNpb247IiwibGV0IHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XHJcblxyXG5jbGFzcyBDaGFydE5vZGUge1xyXG4gICAgY29uc3RydWN0b3Ioa3dhcmdzKSB7XHJcbiAgICAgICAgdXRpbHMuYXNzaWduX2ZpZWxkcyh0aGlzLCBrd2FyZ3MsIFtcclxuICAgICAgICAgICAgeyBcInR5cGVcIiA6IFwibWFuZGF0b3J5XCIsIFwiZmllbGRcIiA6IFwic2hhcGVcIn0sXHJcbiAgICAgICAgICAgIHsgXCJ0eXBlXCIgOiBcImRlZmF1bHRcIiwgXCJmaWVsZFwiIDogXCJzY2FsZVwiLCBcImRlZmF1bHRcIiA6IDF9LFxyXG4gICAgICAgICAgICB7IFwidHlwZVwiIDogXCJvcHRpb25hbFwiLCBcImZpZWxkXCIgOiBcImZpbGxcIn0sXHJcbiAgICAgICAgICAgIHsgXCJ0eXBlXCIgOiBcIm9wdGlvbmFsXCIsIFwiZmllbGRcIiA6IFwic3Ryb2tlXCJ9LFxyXG4gICAgICAgICAgICB7IFwidHlwZVwiIDogXCJvcHRpb25hbFwiLCBcImZpZWxkXCIgOiBcImNvbG9yXCJ9LFxyXG4gICAgICAgICAgICB7IFwidHlwZVwiIDogXCJvcHRpb25hbFwiLCBcImZpZWxkXCIgOiBcIm9wYWNpdHlcIn0sICAgICAgICAgICAgXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcblxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB1dGlscy5wdWJsaWNfZmllbGRzKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnRzLkNoYXJ0Tm9kZSA9IENoYXJ0Tm9kZTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNsYXNzIENoYXJ0U2hhcGUge1xyXG4gICAgc3RhdGljIGRyYXcoc2hhcGUsIC4uLnJlc3QpIHtcclxuICAgICAgICByZXR1cm4gU2hhcGVzW3NoYXBlXS5kcmF3KC4uLnJlc3QpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnRzLkNoYXJ0U2hhcGUgPSBDaGFydFNoYXBlO1xyXG5cclxubGV0IFNoYXBlcyA9IHt9O1xyXG5cclxuU2hhcGVzLmNpcmNsZSA9IHtcclxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHgsIHksIHNpemUsIHBhdGgyZD10cnVlKSB7XHJcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjb250ZXh0LmFyYyh4LCB5LCBzaXplICogMC4xLCAwLCAyKk1hdGguUEkpO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcblxyXG4gICAgICAgIGxldCBwYXRoID0gbmV3IFBhdGgyRCgpO1xyXG4gICAgICAgIHBhdGguYXJjKHgsIHksIHNpemUgKiAwLjIsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblNoYXBlcy5jaXJjbGVuID0ge1xyXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgeCwgeSwgc2l6ZSwgbm9kZSkge1xyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5hcmMoeCwgeSwgc2l6ZSAqIDAuMSwgMCwgMipNYXRoLlBJKTtcclxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcclxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG5cclxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XHJcbiAgICAgICAgbGV0IGZvbnRzaXplID0gMC4xNSpzaXplIHwgMDtcclxuICAgICAgICBjb250ZXh0LmZvbnQgPSBgJHtmb250c2l6ZX1weCBBcmlhbGA7XHJcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChub2RlLm9yZGVyLCB4LCB5ICsgc2l6ZSowLjA2KTtcclxuXHJcbiAgICAgICAgbGV0IHBhdGggPSBuZXcgUGF0aDJEKCk7XHJcbiAgICAgICAgcGF0aC5hcmMoeCwgeSwgc2l6ZSAqIDAuMiwgMCwgMiAqIE1hdGguUEkpO1xyXG5cclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxufTtcclxuXHJcblNoYXBlcy5zcXVhcmUgPSB7XHJcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCB4LCB5LCBzaXplKSB7XHJcbiAgICAgICAgbGV0IGh3aWR0aCA9IDAuMSAqIHNpemU7XHJcblxyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5yZWN0KHggLSBod2lkdGgsIHkgLSBod2lkdGgsIDIqaHdpZHRoLCAyKmh3aWR0aCk7XHJcbiAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuXHJcbiAgICAgICAgbGV0IHBhdGggPSBuZXcgUGF0aDJEKCk7XHJcbiAgICAgICAgcGF0aC5yZWN0KHggLSAyKmh3aWR0aCwgeSAtIDIqaHdpZHRoLCA0Kmh3aWR0aCwgNCpod2lkdGgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxufVxyXG5cclxuZm9yKGxldCBrIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFNoYXBlcykpe1xyXG4gICAgU2hhcGVzW2tdLm5hbWUgPSBrO1xyXG4gICAgZXhwb3J0c1trXSA9IFNoYXBlc1trXTtcclxufVxyXG4iLCJsZXQgU3RyaW5naWZ5aW5nTWFwID0gcmVxdWlyZShcIi4uL1N0cmluZ2lmeWluZ01hcC5qc1wiKTtcclxubGV0IENoYXJ0Tm9kZSA9IHJlcXVpcmUoXCIuL0NoYXJ0Tm9kZS5qc1wiKS5DaGFydE5vZGU7XHJcbmxldCBDaGFydENsYXNzID0gcmVxdWlyZShcIi4vQ2hhcnRDbGFzcy5qc1wiKS5DaGFydENsYXNzO1xyXG5sZXQgQ2hhcnRFZGdlSlMgPSByZXF1aXJlKFwiLi9DaGFydEVkZ2UuanNcIik7XHJcbmxldCBDaGFydEVkZ2UgPSBDaGFydEVkZ2VKUy5DaGFydEVkZ2U7XHJcbmxldCBDaGFydERpZmZlcmVudGlhbCA9IENoYXJ0RWRnZUpTLkNoYXJ0RGlmZmVyZW50aWFsO1xyXG5sZXQgQ2hhcnRTdHJ1Y3RsaW5lID0gQ2hhcnRFZGdlSlMuQ2hhcnRTdHJ1Y3RsaW5lO1xyXG5sZXQgQ2hhcnRFeHRlbnNpb24gPSBDaGFydEVkZ2VKUy5DaGFydEV4dGVuc2lvbjtcclxubGV0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xyXG5cclxuZnVuY3Rpb24gY2hlY2tfYXJndW1lbnRfaXNfaW50ZWdlcihuYW1lLCB2YWx1ZSl7XHJcbiAgICBpZighTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcclxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoYEFyZ3VtZW50IFwiJHtuYW1lfVwiIGlzICR7eH0gd2hpY2ggaXMgbm90IGFuIGludGVnZXIuIFwiJHtuYW1lfVwiIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGludGVnZXIuYCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGVudHJ5IHRvIGEgbWFwIGtleXMgPT0+IGxpc3RzLlxyXG4gKiBJZiB0aGUgY3VycmVudCBrZXkgaXNuJ3QgcHJlc2VudCBpbiB0aGUgbWFwLCBhZGQgYW4gZW1wdHkgbGlzdCBmaXJzdC5cclxuICogQHBhcmFtIGRpY3Rpb25hcnkgVGhlIGRpY3Rpb25hcnkgb2YgbGlzdHMgdG8gYWRkIHRoZSBlbnRyeSB0b1xyXG4gKiBAcGFyYW0ga2V5XHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKi9cclxuZnVuY3Rpb24gYWRkX3RvX2RpY3Rpb25hcnlfb2ZfbGlzdHMoZGljdGlvbmFyeSwga2V5LHZhbHVlKXtcclxuICAgIGlmKCFkaWN0aW9uYXJ5LmhhcyhrZXkpKXtcclxuICAgICAgICBkaWN0aW9uYXJ5LnNldChrZXksIFtdKTtcclxuICAgIH1cclxuICAgIGRpY3Rpb25hcnkuZ2V0KGtleSkucHVzaCh2YWx1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbHRlcl9kaWN0aW9uYXJ5X29mX2xpc3RzKGRpY3Rpb25hcnksIGtleSxjYWxsYmFjayl7XHJcbiAgICBpZighZGljdGlvbmFyeS5oYXMoa2V5KSl7XHJcbiAgICAgICAgZGljdGlvbmFyeS5zZXQoa2V5LCBbXSk7XHJcbiAgICB9XHJcbiAgICBkaWN0aW9uYXJ5LnNldChkaWN0aW9uYXJ5LmdldChrZXkpLmZpbHRlcihjYWxsYmFjaykpO1xyXG59XHJcblxyXG5jbGFzcyBTcGVjdHJhbFNlcXVlbmNlQ2hhcnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm9mZnNldF9zaXplID0gODtcclxuICAgICAgICB0aGlzLm1pbl9jbGFzc19zaXplID0gMTtcclxuICAgICAgICB0aGlzLm1heF9jbGFzc19zaXplID0gMztcclxuICAgICAgICB0aGlzLmNsYXNzX3NjYWxlID0gMTA7XHJcbiAgICAgICAgdGhpcy5jbGFzc2VzX2J5X2RlZ3JlZSA9IG5ldyBTdHJpbmdpZnlpbmdNYXAoKTtcclxuICAgICAgICB0aGlzLmNsYXNzZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmVkZ2VzID0gW107XHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLnBhZ2VfbGlzdCA9IFsyXTtcclxuICAgICAgICB0aGlzLm1pbl9wYWdlX2lkeCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMueF9yYW5nZSA9IFswLCAxMF07XHJcbiAgICAgICAgdGhpcy55X3JhbmdlID0gWzAsIDEwXTtcclxuICAgICAgICB0aGlzLmluaXRpYWxfeF9yYW5nZSA9IFswLCAxMF07XHJcbiAgICAgICAgdGhpcy5pbml0aWFsX3lfcmFuZ2UgPSBbMCwgMTBdO1xyXG4gICAgICAgIHRoaXMubmV4dF91dWlkID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZnJvbV9KU09OKGpzb24pIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSBuZXcgU3BlY3RyYWxTZXF1ZW5jZUNoYXJ0KCk7XHJcblxyXG4gICAgICAgIGlmKGpzb24ubm9kZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBSZWZlcmVuY2VFcnJvcihcImpzb24ubm9kZXMgaXMgdW5kZWZpbmVkLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGpzb24uY2xhc3NlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IFJlZmVyZW5jZUVycm9yKFwianNvbi5jbGFzc2VzIGlzIHVuZGVmaW5lZC5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihqc29uLmVkZ2VzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgUmVmZXJlbmNlRXJyb3IoXCJqc29uLmVkZ2VzIGlzIHVuZGVmaW5lZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0byBhc3NpZ24gZmllbGRzIHRvIGNoYXJ0IGZpcnN0IGluIGNhc2UgdGhleSBhcmUgdXNlZCBpbiBwcm9jZXNzIG9mIGFkZF9jbGFzcywgYWRkX2VkZ2UuXHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjaGFydCwganNvbik7XHJcblxyXG4gICAgICAgIGNoYXJ0Lm5vZGVzID0gY2hhcnQubm9kZXMubWFwKG4gPT4gbmV3IENoYXJ0Tm9kZShuKSk7XHJcbiAgICAgICAgbGV0IGpzb25fY2xhc3NlcyA9IGNoYXJ0LmNsYXNzZXM7XHJcbiAgICAgICAgbGV0IGpzb25fZWRnZXMgPSBjaGFydC5lZGdlcztcclxuICAgICAgICBjaGFydC5jbGFzc2VzID0ge307XHJcbiAgICAgICAgY2hhcnQuZWRnZXMgPSB7fTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgZm9yKGxldCBbaWQsIGNdIG9mIE9iamVjdC5lbnRyaWVzKGpzb25fY2xhc3NlcykpeyAvLyBpbiBpdGVyYXRlcyBvdmVyIG9iamVjdCBrZXlzLlxyXG4gICAgICAgICAgICBjaGFydC5jbGFzc2VzW2lkXSA9IGNoYXJ0LmFkZF9jbGFzcyhjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKGxldCBbaWQsIGVdIG9mIE9iamVjdC5lbnRyaWVzKGpzb25fZWRnZXMpKXtcclxuICAgICAgICAgICAgY2hhcnQuZWRnZXNbaWRdID0gY2hhcnQuYWRkX2VkZ2UoZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIHJldHVybiBjaGFydDtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzc19ieV9kZWdyZWVfYW5kX2luZGV4KHgsIHksIGlkeCl7XHJcbiAgICAgICAgY2hlY2tfYXJndW1lbnRfaXNfaW50ZWdlcihcInhcIiwgeCk7XHJcbiAgICAgICAgY2hlY2tfYXJndW1lbnRfaXNfaW50ZWdlcihcInlcIiwgeSk7XHJcbiAgICAgICAgY2hlY2tfYXJndW1lbnRfaXNfaW50ZWdlcihcImlkeFwiLCBpZHgpO1xyXG4gICAgICAgIGlmKCF0aGlzLmNsYXNzZXNfYnlfZGVncmVlLmhhcyhbeCx5XSkpe1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgTm8gY2xhc3NlcyBleGlzdCBpbiBiaWRlZ3JlZSAoJHt4fSwgJHt5fSkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjbGFzc2VzID0gdGhpcy5jbGFzc2VzX2J5X2RlZ3JlZS5nZXQoW3gsIHldKTtcclxuICAgICAgICBpZihpZHggPj0gY2xhc3Nlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEZld2VyIHRoYW4gJHtpZHh9IGNsYXNzZXMgZXhpc3QgaW4gYmlkZWdyZWUgKCR7eH0sICR7eX0pLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xhc3Nlc1tpZHhdO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZF9jbGFzcyhrd2FyZ3MpIHtcclxuICAgICAgICBsZXQgYyA9IG5ldyBDaGFydENsYXNzKHRoaXMsIGt3YXJncyk7XHJcbiAgICAgICAgaWYoXCJ1dWlkXCIgaW4ga3dhcmdzKXtcclxuICAgICAgICAgICAgYy51dWlkID0ga3dhcmdzW1widXVpZFwiXVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGMudXVpZCA9IHRoaXMubmV4dF91dWlkO1xyXG4gICAgICAgICAgICB0aGlzLm5leHRfdXVpZCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGVncmVlID0gW2MueCwgYy55XTtcclxuICAgICAgICB0aGlzLmNsYXNzZXNbYy51dWlkXSA9IGM7XHJcbiAgICAgICAgZmlsdGVyX2RpY3Rpb25hcnlfb2ZfbGlzdHModGhpcy5jbGFzc2VzX2J5X2RlZ3JlZSwgZGVncmVlLCBjID0+IGMuX3ZhbGlkKTtcclxuICAgICAgICBpZihjLmlkeCA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgYy5pZHggPSB0aGlzLmNsYXNzZXNfYnlfZGVncmVlLmdldChkZWdyZWUpLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkX3RvX2RpY3Rpb25hcnlfb2ZfbGlzdHModGhpcy5jbGFzc2VzX2J5X2RlZ3JlZSwgZGVncmVlLCBjKTtcclxuICAgICAgICB0aGlzLmVtaXQoXCJjbGFzcy1hZGRlZFwiLCBjKTtcclxuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkX2VkZ2Uoa3dhcmdzKSB7XHJcbiAgICAgICAgbGV0IGVkZ2VfdHlwZSA9IGt3YXJnc1tcInR5cGVcIl07XHJcbiAgICAgICAgc3dpdGNoKGVkZ2VfdHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIENoYXJ0RGlmZmVyZW50aWFsLm5hbWU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRfZGlmZmVyZW50aWFsKGt3YXJncyk7XHJcbiAgICAgICAgICAgIGNhc2UgQ2hhcnRTdHJ1Y3RsaW5lLm5hbWU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRfc3RydWN0bGluZShrd2FyZ3MpO1xyXG4gICAgICAgICAgICBjYXNlIENoYXJ0RXh0ZW5zaW9uLm5hbWU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRfZXh0ZW5zaW9uKGt3YXJncyk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoYEFyZ3VtZW50IFwidHlwZVwiIGV4cGVjdGVkIHRvIGNvbnRhaW4gb25lIG9mIFwiJHtDaGFydERpZmZlcmVudGlhbC5uYW1lfVwiIFxcXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJHtDaGFydFN0cnVjdGxpbmUubmFtZX1cIiwgb3IgXCIke0NoYXJ0RXh0ZW5zaW9uLm5hbWV9XCIsIG5vdCBcIiR7ZWRnZV90eXBlfVwiLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRfZGlmZmVyZW50aWFsKGt3YXJncykge1xyXG4gICAgICAgIGxldCBlID0gbmV3IENoYXJ0RGlmZmVyZW50aWFsKGt3YXJncyk7XHJcbiAgICAgICAgaWYoXCJ1dWlkXCIgaW4ga3dhcmdzKXtcclxuICAgICAgICAgICAgZS51dWlkID0ga3dhcmdzW1widXVpZFwiXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlLnV1aWQgPSB0aGlzLm5leHRfdXVpZDtcclxuICAgICAgICAgICAgdGhpcy5uZXh0X3V1aWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lZGdlc1tlW1widXVpZFwiXV0gPSBlO1xyXG4gICAgICAgIHRoaXMuZW1pdChcImRpZmZlcmVudGlhbC1hZGRlZFwiLCBlKTtcclxuICAgICAgICB0aGlzLmVtaXQoXCJlZGdlLWFkZGVkXCIsIGUpO1xyXG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiKTtcclxuICAgICAgICByZXR1cm4gZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRfc3RydWN0bGluZShrd2FyZ3MpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBDaGFydFN0cnVjdGxpbmUoa3dhcmdzKTtcclxuICAgICAgICBpZihcInV1aWRcIiBpbiBrd2FyZ3Mpe1xyXG4gICAgICAgICAgICBlLnV1aWQgPSBrd2FyZ3NbXCJ1dWlkXCJdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGUudXVpZCA9IHRoaXMubmV4dF91dWlkO1xyXG4gICAgICAgICAgICB0aGlzLm5leHRfdXVpZCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVkZ2VzW2UudXVpZF0gPSBlO1xyXG4gICAgICAgIHRoaXMuZW1pdChcInN0cnVjdGxpbmUtYWRkZWRcIiwgZSk7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwiZWRnZS1hZGRlZFwiLCBlKTtcclxuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XHJcbiAgICAgICAgcmV0dXJuIGU7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkX2V4dGVuc2lvbihrd2FyZ3MpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBDaGFydEV4dGVuc2lvbihrd2FyZ3MpO1xyXG4gICAgICAgIGlmKFwidXVpZFwiIGluIGt3YXJncyl7XHJcbiAgICAgICAgICAgIGUudXVpZCA9IGt3YXJnc1tcInV1aWRcIl07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZS51dWlkID0gdGhpcy5uZXh0X3V1aWQ7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dF91dWlkKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWRnZXNbZS51dWlkXSA9IGU7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwiZXh0ZW5zaW9uLWFkZGVkXCIsIGUpO1xyXG4gICAgICAgIHRoaXMuZW1pdChcImVkZ2UtYWRkZWRcIiwgZSk7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIpO1xyXG4gICAgICAgIHJldHVybiBlOyAgICBcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG5vZGUgdG8gYmUgZHJhd24gZm9yIHRoZSBjbGFzcyBvbiB0aGUgZ2l2ZW4gcGFnZS4gVXNlZCBwcmltYXJpbHkgYnkgZGlzcGxheS5cclxuICAgICAqIEBwYXJhbSBjXHJcbiAgICAgKiBAcGFyYW0gcGFnZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGdldENsYXNzTm9kZShjLCBwYWdlKSB7XHJcbiAgICAgICAgbGV0IG5vZGVfb3JfaWR4ID0gYy5ub2RlX2xpc3RbYy5fZ2V0UGFnZUluZGV4KHBhZ2UpXTtcclxuICAgICAgICBpZihub2RlX29yX2lkeC5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIG5vZGVfb3JfaWR4ID0gdGhpcy5ub2Rlc1tub2RlX29yX2lkeF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlX29yX2lkeDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRFbGVtZW50c1RvRHJhdyhwYWdlLCB4bWluLCB4bWF4LCB5bWluLCB5bWF4KSB7XHJcbiAgICAgICAgLy8gVXRpbC5jaGVja0FyZ3VtZW50c0RlZmluZWQoU3BlY3RyYWxTZXF1ZW5jZUNoYXJ0LnByb3RvdHlwZS5nZXREcmF3bkVsZW1lbnRzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGxldCBwYWdlUmFuZ2U7XHJcbiAgICAgICAgLy8gVE9ETzogY2xlYW4gdXAgcGFnZVJhbmdlLiBQcm9iYWJseSB3ZSBzaG91bGQgYWx3YXlzIHBhc3MgcGFnZXMgYXMgcGFpcnM/XHJcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShwYWdlKSkge1xyXG4gICAgICAgICAgICBwYWdlUmFuZ2UgPSBwYWdlO1xyXG4gICAgICAgICAgICBwYWdlID0gcGFnZVswXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYWdlUmFuZ2UgPSBbcGFnZSwgcGFnZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkaXNwbGF5X2NsYXNzZXMgPSBPYmplY3QudmFsdWVzKHRoaXMuY2xhc3NlcykuZmlsdGVyKGMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWMgfHwgYy5pbnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGMuX2luUmFuZ2VRKHhtaW4sIHhtYXgsIHltaW4sIHltYXgpICYmIGMuX2RyYXdPblBhZ2VRKHBhZ2UpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBNYXliZSBtb3ZlIHRoaXMgZWxzZXdoZXJlLi4uXHJcbiAgICAgICAgZm9yIChsZXQgZSBvZiBPYmplY3QudmFsdWVzKHRoaXMuZWRnZXMpKSB7XHJcbiAgICAgICAgICAgIGUuX3NvdXJjZSA9IHRoaXMuY2xhc3Nlc1tlLnNvdXJjZV07XHJcbiAgICAgICAgICAgIGUuX3RhcmdldCA9IHRoaXMuY2xhc3Nlc1tlLnRhcmdldF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEaXNwbGF5IGVkZ2VzIHN1Y2ggdGhhdFxyXG4gICAgICAgIC8vIDEpIGUgaXMgYSB2YWxpZCBlZGdlXHJcbiAgICAgICAgLy8gMikgZSBpcyBzdXBwb3NlZCB0byBiZSBkcmF3biBvbiB0aGUgY3VycmVudCBwYWdlUmFuZ2UuXHJcbiAgICAgICAgLy8gMykgZS5zb3VyY2UgYW5kIGUudGFyZ2V0IGFyZSBzdXBwb3NlZCB0byBiZSBkcmF3biBvbiB0aGUgY3VycmVudCBwYWdlUmFuZ2VcclxuICAgICAgICAvLyA0KSBBdCBsZWFzdCBvbmUgb2YgdGhlIHNvdXJjZSBvciB0YXJnZXQgaXMgaW4gYm91bmRzLlxyXG4gICAgICAgIGxldCBkaXNwbGF5X2VkZ2VzID0gT2JqZWN0LnZhbHVlcyh0aGlzLmVkZ2VzKS5maWx0ZXIoZSA9PlxyXG4gICAgICAgICAgICBlICYmICFlLmludmFsaWQgJiYgXHJcbiAgICAgICAgICAgIGUuX2RyYXdPblBhZ2VRKHBhZ2VSYW5nZSlcclxuICAgICAgICAgICAgJiYgZS5fc291cmNlLl9kcmF3T25QYWdlUShwYWdlKSBcclxuICAgICAgICAgICAgJiYgZS5fdGFyZ2V0Ll9kcmF3T25QYWdlUShwYWdlKVxyXG4gICAgICAgICAgICAmJiAoZS5fc291cmNlLl9pblJhbmdlUSh4bWluLCB4bWF4LCB5bWluLCB5bWF4KSB8fCBlLl90YXJnZXQuX2luUmFuZ2VRKHhtaW4sIHhtYXgsIHltaW4sIHltYXgpKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZ28gYmFjayBhbmQgbWFrZSBzdXJlIHRoYXQgZm9yIGV2ZXJ5IGVkZ2Ugd2UgYXJlIHBsYW5uaW5nIHRvICBkcmF3LCB3ZSBkcmF3IGJvdGggaXRzIHNvdXJjZSBhbmRcclxuICAgICAgICAvLyB0YXJnZXQgZXZlbiBpZiBvbmUgb2YgdGhlbSBpcyBvdXQgb2YgYm91bmRzLiBDaGVjayBmb3Igb3V0IG9mIGJvdW5kcyBzb3VyY2VzIC8gdGFyZ2V0cyBhbmQgYWRkIHRoZW0gdG8gdGhlXHJcbiAgICAgICAgLy8gbGlzdCBvZiBlZGdlcyB0byBkcmF3LlxyXG4gICAgICAgIGZvciAobGV0IGUgb2YgZGlzcGxheV9lZGdlcykge1xyXG4gICAgICAgICAgICBpZiAoIWUuX3NvdXJjZS5pbl9yYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheV9jbGFzc2VzLnB1c2goZS5fc291cmNlKTtcclxuICAgICAgICAgICAgICAgIGUuX3NvdXJjZS5faW5fcmFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZS5fdGFyZ2V0LmluX3JhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBlLl90YXJnZXQuX2luX3JhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlfY2xhc3Nlcy5wdXNoKGUuX3RhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcihsZXQgYyBvZiBkaXNwbGF5X2NsYXNzZXMpIHtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmdldENsYXNzTm9kZShjLCBwYWdlKTtcclxuICAgICAgICAgICAgaWYobm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5kZWZpbmVkIG5vZGUgZm9yOlwiLCBjKTtcclxuICAgICAgICAgICAgICAgIHRocm93IFJlZmVyZW5jZUVycm9yKGBVbmRlZmluZWQgbm9kZSBvbiBwYWdlICR7cGFnZX0gZm9yIGNsYXNzOiAke2N9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYy5fbm9kZSA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmb3IgKGxldCBlIG9mIGRpc3BsYXlfZWRnZXMpIHtcclxuICAgICAgICAvLyAgICAgZS5zb3VyY2Vfbm9kZSA9IGUuc291cmNlLm5vZGU7XHJcbiAgICAgICAgLy8gICAgIGUudGFyZ2V0X25vZGUgPSBlLnRhcmdldC5ub2RlO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICByZXR1cm4gW2Rpc3BsYXlfY2xhc3NlcywgZGlzcGxheV9lZGdlc107XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU3BlY3RyYWxTZXF1ZW5jZUNoYXJ0ID0gU3BlY3RyYWxTZXF1ZW5jZUNoYXJ0OyIsImV4cG9ydHMuU2hhcGVzID0gcmVxdWlyZShcIi4vQ2hhcnRTaGFwZS5qc1wiKTtcclxuZXhwb3J0cy5DaGFydE5vZGUgPSByZXF1aXJlKFwiLi9DaGFydE5vZGUuanNcIikuQ2hhcnROb2RlO1xyXG5leHBvcnRzLkNoYXJ0Q2xhc3MgPSByZXF1aXJlKFwiLi9DaGFydENsYXNzLmpzXCIpLkNoYXJ0Q2xhc3M7XHJcbmxldCBDaGFydEVkZ2VqcyA9IHJlcXVpcmUoXCIuL0NoYXJ0RWRnZS5qc1wiKVxyXG5leHBvcnRzLkNoYXJ0RWRnZSA9IENoYXJ0RWRnZWpzLkNoYXJ0RWRnZTtcclxuZXhwb3J0cy5DaGFydERpZmZlcmVudGlhbCA9IENoYXJ0RWRnZWpzLkNoYXJ0RGlmZmVyZW50aWFsO1xyXG5leHBvcnRzLkNoYXJ0U3RydWN0bGluZSA9IENoYXJ0RWRnZWpzLkNoYXJ0U3RydWN0bGluZTtcclxuZXhwb3J0cy5DaGFydEV4dGVuc2lvbiA9IENoYXJ0RWRnZWpzLkNoYXJ0RXh0ZW5zaW9uO1xyXG5leHBvcnRzLlNwZWN0cmFsU2VxdWVuY2VDaGFydCA9IHJlcXVpcmUoXCIuL1NwZWN0cmFsU2VxdWVuY2VDaGFydC5qc1wiKS5TcGVjdHJhbFNlcXVlbmNlQ2hhcnQ7XHJcbiIsImZ1bmN0aW9uIEtleUVycm9yKG1lc3NhZ2UpIHtcclxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICB0aGlzLm5hbWUgPSAnS2V5RXJyb3InO1xyXG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxufVxyXG5cclxuZXhwb3J0cy5hc3NpZ25fZmllbGRzID0gZnVuY3Rpb24gYXNzaWduX2ZpZWxkcyhvYmosIGt3YXJncywgZmllbGRzKSB7XHJcbiAgICBmb3IobGV0IGZpZWxkIG9mIGZpZWxkcykge1xyXG4gICAgICAgIHN3aXRjaChmaWVsZFtcInR5cGVcIl0pIHtcclxuICAgICAgICAgICAgY2FzZSBcIm1hbmRhdG9yeVwiOlxyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5hc3NpZ25fa3dhcmdfbWFuZGF0b3J5KG9iaiwga3dhcmdzLCBmaWVsZFtcImZpZWxkXCJdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwib3B0aW9uYWxcIjpcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuYXNzaWduX2t3YXJnX29wdGlvbmFsKG9iaiwga3dhcmdzLCBmaWVsZFtcImZpZWxkXCJdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5hc3NpZ25fa3dhcmdfZGVmYXVsdChvYmosIGt3YXJncywgZmllbGRbXCJmaWVsZFwiXSwgZmllbGRbXCJkZWZhdWx0XCJdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEtleUVycm9yKGBVbmtub3duIGZpZWxkIHR5cGUgJHtmaWVsZFtcInR5cGVcIl19YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnRzLmFzc2lnbl9rd2FyZ19tYW5kYXRvcnkgPSBmdW5jdGlvbiBhc3NpZ25fa3dhcmdfbWFuZGF0b3J5KG9iaiwga3dhcmdzLCBmaWVsZCkge1xyXG4gICAgaWYoZmllbGQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJmaWVsZCBpcyB1bmRlZmluZWQuXCIpXHJcbiAgICB9XHJcbiAgICBpZihrd2FyZ3MgPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImt3YXJncyBpcyB1bmRlZmluZWQuXCIpO1xyXG4gICAgfVxyXG4gICAgaWYoa3dhcmdzW2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEtleUVycm9yKGBBcmd1bWVudCBrd2FyZ3MgaXMgbWlzc2luZyBtYW5kYXRvcnkgZmllbGQgJHtmaWVsZH0uIGt3YXJncyBpcyA6ICR7SlNPTi5zdHJpbmdpZnkoa3dhcmdzKX1gKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb2JqW2ZpZWxkXSA9IGt3YXJnc1tmaWVsZF07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuYXNzaWduX2t3YXJnX29wdGlvbmFsID0gZnVuY3Rpb24gYXNzaWduX2t3YXJnX29wdGlvbmFsKG9iaiwga3dhcmdzLCBmaWVsZCkge1xyXG4gICAgaWYoZmllbGQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJmaWVsZCBpcyB1bmRlZmluZWQuXCIpXHJcbiAgICB9ICAgIFxyXG4gICAgaWYoa3dhcmdzID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgIHRocm93IG5ldyBLZXlFcnJvcihcImt3YXJncyBpcyB1bmRlZmluZWQhXCIpO1xyXG4gICAgfVxyXG4gICAgaWYoa3dhcmdzW2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBvYmpbZmllbGRdID0ga3dhcmdzW2ZpZWxkXVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0cy5hc3NpZ25fa3dhcmdfZGVmYXVsdCA9IGZ1bmN0aW9uIGFzc2lnbl9rd2FyZ19kZWZhdWx0KG9iaiwga3dhcmdzLCBmaWVsZCwgZGVmYXVsdF92YWx1ZSkge1xyXG4gICAgaWYoZmllbGQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJmaWVsZCBpcyB1bmRlZmluZWQuXCIpXHJcbiAgICB9ICAgIFxyXG4gICAgaWYoa3dhcmdzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgS2V5RXJyb3IoXCJrd2FyZ3MgaXMgdW5kZWZpbmVkIVwiKTtcclxuICAgIH1cclxuICAgIGlmKGt3YXJnc1tmaWVsZF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG9ialtmaWVsZF0gPSBkZWZhdWx0X3ZhbHVlXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9ialtmaWVsZF0gPSBrd2FyZ3NbZmllbGRdXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydHMucHVibGljX2ZpZWxkcyA9IGZ1bmN0aW9uIHB1YmxpY19maWVsZHMob2JqKXtcclxuICAgIHJlc3VsdCA9IHt9O1xyXG4gICAgZm9yKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xyXG4gICAgICAgIGlmKCFrZXkuc3RhcnRzV2l0aChcIl9cIikpe1xyXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn0iXX0=
